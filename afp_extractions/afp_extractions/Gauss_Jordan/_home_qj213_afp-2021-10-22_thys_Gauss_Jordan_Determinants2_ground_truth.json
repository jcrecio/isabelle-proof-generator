{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/Determinants2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma det_interchange_rows:\nshows \"det (interchange_rows A i j) = of_int (if i = j then 1 else -1) * det A\"", "lemma det_mult_row:\nshows \"det (mult_row A a k) = k * det A\"", "lemma det_row_add':\nassumes i_not_j: \"i \\<noteq> j\"\nshows \"det (row_add A i j q) = det A\"", "lemma det_interchange_columns:\nshows \"det (interchange_columns A i j) = of_int (if i = j then 1 else -1) * det A\"", "lemma det_mult_columns:\nshows \"det (mult_column A a k) = k * det A\"", "lemma det_column_add:\nassumes i_not_j: \"i \\<noteq> j\"\nshows \"det (column_add A i j q) = det A\"", "lemma det_row_add_iterate_upt_n:\nfixes A::\"'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\"\nassumes n: \"n<nrows A\"\nshows \"det (row_add_iterate A n i j) = det A\"", "lemma det_Gauss_Jordan_in_ij:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\ndefines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\nshows \"det (Gauss_Jordan_in_ij A i j) = det A' \"", "lemma det_Gauss_Jordan_in_ij_1:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\ndefines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\nassumes i: \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) = i\"\nshows \"det (Gauss_Jordan_in_ij A i j) = 1/(A$i$j) * det A\"", "lemma det_Gauss_Jordan_in_ij_2:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\ndefines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\nassumes i: \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) \\<noteq> i\"\nshows \"det (Gauss_Jordan_in_ij A i j) = - 1/(A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j) * det A\"", "lemma Gauss_Jordan_in_ij_det_P_code[code]:\nshows \"Gauss_Jordan_in_ij_det_P A i j = \n    (let n = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n);\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i (1 / interchange_A $ i $ j) in (if i = n then 1/(A $ i $ j) else - 1/(A $ n $ j), Gauss_Jordan_wrapper i j A' interchange_A))\"", "lemma det_Gauss_Jordan_in_ij_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\nshows \"(fst (Gauss_Jordan_in_ij_det_P A i j)) * det A  = det (snd (Gauss_Jordan_in_ij_det_P A i j))\"", "lemma det_Gauss_Jordan_column_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes det: \"det_P * det B = det A\"\nshows \"(fst (Gauss_Jordan_column_k_det_P (det_P,i,A) k)) * det B = det (snd (snd (Gauss_Jordan_column_k_det_P (det_P,i,A) k)))\"", "lemma det_Gauss_Jordan_upt_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"(fst (Gauss_Jordan_upt_k_det_P A k)) * det A = det (snd (Gauss_Jordan_upt_k_det_P A k))\"", "lemma det_Gauss_Jordan_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"(fst (Gauss_Jordan_det_P A)) * det A = det (snd (Gauss_Jordan_det_P A))\"", "lemma upper_triangular_upt_imp_upper_triangular:\nassumes \"upper_triangular_upt_k A (nrows A)\"\nshows \"upper_triangular A\"", "lemma rref_imp_upper_triagular_upt:\nfixes A::\"'a::{one, zero}^'n::{mod_type}^'n::{mod_type}\"\nassumes \"reduced_row_echelon_form A\"\nshows \"upper_triangular_upt_k A k\"", "lemma rref_imp_upper_triagular:\nassumes \"reduced_row_echelon_form A\"\nshows \"upper_triangular A\"", "lemma det_Gauss_Jordan[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"det (Gauss_Jordan A) = prod (\\<lambda>i. (Gauss_Jordan A)$i$i) (UNIV:: 'n set)\"", "lemma snd_Gauss_Jordan_in_ij_det_P_is_snd_Gauss_Jordan_in_ij_PA:\nshows \"snd (Gauss_Jordan_in_ij_det_P A i j) = snd (Gauss_Jordan_in_ij_PA (P,A) i j)\"", "lemma snd_Gauss_Jordan_column_k_det_P_is_snd_Gauss_Jordan_column_k_PA:\nshows \"snd (Gauss_Jordan_column_k_det_P (n,i,A) k) = snd (Gauss_Jordan_column_k_PA (P,i,A) k)\"", "lemma det_fst_row_add_iterate_PA:\nfixes A::\"'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\"\nassumes n: \"n<nrows A\"\nshows \"det (fst (row_add_iterate_PA (P,A) n i j)) = det P\"", "lemma det_fst_Gauss_Jordan_in_ij_PA_eq_fst_Gauss_Jordan_in_ij_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_in_ij_det_P A i j) * det P = det (fst (Gauss_Jordan_in_ij_PA (P,A) i j))\"", "lemma det_fst_Gauss_Jordan_column_k_PA_eq_fst_Gauss_Jordan_column_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_column_k_det_P (det P,i,A) k) = det (fst (Gauss_Jordan_column_k_PA (P,i,A) k))\"", "lemma fst_snd_Gauss_Jordan_column_k_det_P_eq_fst_snd_Gauss_Jordan_column_k_PA:\nshows \"fst (snd (Gauss_Jordan_column_k_det_P (n,i,A) k)) = fst (snd (Gauss_Jordan_column_k_PA (P,i,A) k))\"", "lemma foldl_Gauss_Jordan_column_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows det_fst_Gauss_Jordan_upt_k_PA_eq_fst_Gauss_Jordan_upt_k_det_P: \"fst (Gauss_Jordan_upt_k_det_P A k) = det (fst (Gauss_Jordan_upt_k_PA A k))\"\nand snd_Gauss_Jordan_upt_k_det_P_is_snd_Gauss_Jordan_upt_k_PA: \"snd (Gauss_Jordan_upt_k_det_P A k) = snd (Gauss_Jordan_upt_k_PA A k)\"\nand fst_snd_foldl_Gauss_det_P_PA: \"fst (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k])) = fst (snd (foldl Gauss_Jordan_column_k_PA (mat 1, 0, A) [0..<Suc k]))\"", "lemma snd_Gauss_Jordan_det_P_is_Gauss_Jordan:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"snd (Gauss_Jordan_det_P A) = (Gauss_Jordan A)\"", "lemma det_snd_Gauss_Jordan_det_P[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"det (snd (Gauss_Jordan_det_P A)) = prod (\\<lambda>i. (snd (Gauss_Jordan_det_P A))$i$i) (UNIV:: 'n set)\"", "lemma det_fst_Gauss_Jordan_PA_eq_fst_Gauss_Jordan_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_det_P A) = det (fst (Gauss_Jordan_PA A))\"", "lemma fst_Gauss_Jordan_det_P_not_0:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_det_P A) \\<noteq> 0\"", "lemma det_code_equation[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"det A = (let A' = Gauss_Jordan_det_P A in prod (\\<lambda>i. (snd (A'))$i$i) (UNIV::'n set)/(fst (A')))\""], "translations": [["", "lemma det_interchange_rows:\nshows \"det (interchange_rows A i j) = of_int (if i = j then 1 else -1) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "have \"(interchange_rows A i j) = (\\<chi> a. A $ (Fun.swap i j id) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_rows A i j = (\\<chi>a. A $ Fun.swap i j id a)", "unfolding interchange_rows_def Fun.swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = i then A $ j $ ja\n        else if ia = j then A $ i $ ja else A $ ia $ ja) =\n    (\\<chi>a. A $ (id(i := id j, j := id i)) a)", "by vector"], ["proof (state)\nthis:\n  interchange_rows A i j = (\\<chi>a. A $ Fun.swap i j id a)\n\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "hence \"det(interchange_rows A i j) = det(\\<chi> a. A$(Fun.swap i j id) a)\""], ["proof (prove)\nusing this:\n  interchange_rows A i j = (\\<chi>a. A $ Fun.swap i j id a)\n\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = det (\\<chi>a. A $ Fun.swap i j id a)", "by simp"], ["proof (state)\nthis:\n  det (interchange_rows A i j) = det (\\<chi>a. A $ Fun.swap i j id a)\n\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "also"], ["proof (state)\nthis:\n  det (interchange_rows A i j) = det (\\<chi>a. A $ Fun.swap i j id a)\n\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "have \"... = of_int (sign (Fun.swap i j id)) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (\\<chi>a. A $ Fun.swap i j id a) =\n    of_int (sign (Fun.swap i j id)) * det A", "by (rule det_permute_rows[of \"Fun.swap i j id\" A], simp add: permutes_swap_id)"], ["proof (state)\nthis:\n  det (\\<chi>a. A $ Fun.swap i j id a) =\n  of_int (sign (Fun.swap i j id)) * det A\n\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "finally"], ["proof (chain)\npicking this:\n  det (interchange_rows A i j) = of_int (sign (Fun.swap i j id)) * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (interchange_rows A i j) = of_int (sign (Fun.swap i j id)) * det A\n\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "unfolding sign_swap_id"], ["proof (prove)\nusing this:\n  det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A\n\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A", "."], ["proof (state)\nthis:\n  det (interchange_rows A i j) = of_int (if i = j then 1 else - 1) * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary det_interchange_different_rows:\nassumes i_not_j: \"i \\<noteq> j\"\nshows \"det (interchange_rows A i j) = - det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = - det A", "unfolding det_interchange_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = - det A", "using i_not_j"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = - det A", "by simp"], ["", "corollary det_interchange_same_rows:\nassumes i_eq_j: \"i = j\"\nshows \"det (interchange_rows A i j) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_rows A i j) = det A", "unfolding det_interchange_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = det A", "using i_eq_j"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = det A", "by simp"], ["", "lemma det_mult_row:\nshows \"det (mult_row A a k) = k * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "have A_rw: \"(\\<chi> i. if i = a then A$a else A$i) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. if i = a then A $ a else A $ i) = A", "by vector"], ["proof (state)\nthis:\n  (\\<chi>i. if i = a then A $ a else A $ i) = A\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "have \"(mult_row A a k) = (\\<chi> i. if i = a then k *s A $ a else A $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_row A a k = (\\<chi>i. if i = a then k *s A $ a else A $ i)", "unfolding mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. if i = a then k * A $ a $ j else A $ i $ j) =\n    (\\<chi>i. if i = a then k *s A $ a else A $ i)", "by vector"], ["proof (state)\nthis:\n  mult_row A a k = (\\<chi>i. if i = a then k *s A $ a else A $ i)\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "hence \"det(mult_row A a k) = det(\\<chi> i. if i = a then k *s A $ a else A $ i)\""], ["proof (prove)\nusing this:\n  mult_row A a k = (\\<chi>i. if i = a then k *s A $ a else A $ i)\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) =\n    det (\\<chi>i. if i = a then k *s A $ a else A $ i)", "by simp"], ["proof (state)\nthis:\n  det (mult_row A a k) = det (\\<chi>i. if i = a then k *s A $ a else A $ i)\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "also"], ["proof (state)\nthis:\n  det (mult_row A a k) = det (\\<chi>i. if i = a then k *s A $ a else A $ i)\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "have \"... =  k * det(\\<chi> i. if i = a then A$a else A$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (\\<chi>i. if i = a then k *s A $ a else A $ i) =\n    k * det (\\<chi>i. if i = a then A $ a else A $ i)", "unfolding det_row_mul"], ["proof (prove)\ngoal (1 subgoal):\n 1. k * det (\\<chi>i. if i = a then A $ a else A $ i) =\n    k * det (\\<chi>i. if i = a then A $ a else A $ i)", ".."], ["proof (state)\nthis:\n  det (\\<chi>i. if i = a then k *s A $ a else A $ i) =\n  k * det (\\<chi>i. if i = a then A $ a else A $ i)\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "also"], ["proof (state)\nthis:\n  det (\\<chi>i. if i = a then k *s A $ a else A $ i) =\n  k * det (\\<chi>i. if i = a then A $ a else A $ i)\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "have \"... = k * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * det (\\<chi>i. if i = a then A $ a else A $ i) = k * det A", "unfolding A_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. k * det A = k * det A", ".."], ["proof (state)\nthis:\n  k * det (\\<chi>i. if i = a then A $ a else A $ i) = k * det A\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "finally"], ["proof (chain)\npicking this:\n  det (mult_row A a k) = k * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (mult_row A a k) = k * det A\n\ngoal (1 subgoal):\n 1. det (mult_row A a k) = k * det A", "."], ["proof (state)\nthis:\n  det (mult_row A a k) = k * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "(*The name det_row_add is already used in the Determinants.thy file of the standard library*)"], ["", "lemma det_row_add':\nassumes i_not_j: \"i \\<noteq> j\"\nshows \"det (row_add A i j q) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add A i j q) = det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (row_add A i j q) = det A", "have \"(row_add A i j q) = (\\<chi> k. if k = i then row i A + q *s row j A else row k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A i j q =\n    (\\<chi>k. if k = i then row i A + q *s row j A else row k A)", "unfolding row_add_def row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = i then A $ i $ ja + q * A $ j $ ja else A $ ia $ ja) =\n    (\\<chi>k.\n        if k = i\n        then vec_lambda (($) (A $ i)) + q *s vec_lambda (($) (A $ j))\n        else vec_lambda (($) (A $ k)))", "by vector"], ["proof (state)\nthis:\n  row_add A i j q =\n  (\\<chi>k. if k = i then row i A + q *s row j A else row k A)\n\ngoal (1 subgoal):\n 1. det (row_add A i j q) = det A", "hence \"det(row_add A i j q) = det(\\<chi> k. if k = i then row i A + q *s row j A else row k A)\""], ["proof (prove)\nusing this:\n  row_add A i j q =\n  (\\<chi>k. if k = i then row i A + q *s row j A else row k A)\n\ngoal (1 subgoal):\n 1. det (row_add A i j q) =\n    det (\\<chi>k. if k = i then row i A + q *s row j A else row k A)", "by simp"], ["proof (state)\nthis:\n  det (row_add A i j q) =\n  det (\\<chi>k. if k = i then row i A + q *s row j A else row k A)\n\ngoal (1 subgoal):\n 1. det (row_add A i j q) = det A", "also"], ["proof (state)\nthis:\n  det (row_add A i j q) =\n  det (\\<chi>k. if k = i then row i A + q *s row j A else row k A)\n\ngoal (1 subgoal):\n 1. det (row_add A i j q) = det A", "have \"... = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (\\<chi>k. if k = i then row i A + q *s row j A else row k A) = det A", "unfolding det_row_operation[OF i_not_j]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A", ".."], ["proof (state)\nthis:\n  det (\\<chi>k. if k = i then row i A + q *s row j A else row k A) = det A\n\ngoal (1 subgoal):\n 1. det (row_add A i j q) = det A", "finally"], ["proof (chain)\npicking this:\n  det (row_add A i j q) = det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (row_add A i j q) = det A\n\ngoal (1 subgoal):\n 1. det (row_add A i j q) = det A", "."], ["proof (state)\nthis:\n  det (row_add A i j q) = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Relationships between determinants and elementary column operations\\<close>"], ["", "lemma det_interchange_columns:\nshows \"det (interchange_columns A i j) = of_int (if i = j then 1 else -1) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "have \"(interchange_columns A i j) = (\\<chi> a b. A $ a $ (Fun.swap i j id) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interchange_columns A i j = (\\<chi>a b. A $ a $ Fun.swap i j id b)", "unfolding interchange_columns_def Fun.swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ja = i then A $ ia $ j\n        else if ja = j then A $ ia $ i else A $ ia $ ja) =\n    (\\<chi>a b. A $ a $ (id(i := id j, j := id i)) b)", "by vector"], ["proof (state)\nthis:\n  interchange_columns A i j = (\\<chi>a b. A $ a $ Fun.swap i j id b)\n\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "hence \"det(interchange_columns A i j) = det(\\<chi> a b. A $ a $ (Fun.swap i j id) b)\""], ["proof (prove)\nusing this:\n  interchange_columns A i j = (\\<chi>a b. A $ a $ Fun.swap i j id b)\n\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    det (\\<chi>a b. A $ a $ Fun.swap i j id b)", "by simp"], ["proof (state)\nthis:\n  det (interchange_columns A i j) =\n  det (\\<chi>a b. A $ a $ Fun.swap i j id b)\n\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "also"], ["proof (state)\nthis:\n  det (interchange_columns A i j) =\n  det (\\<chi>a b. A $ a $ Fun.swap i j id b)\n\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "have \"... = of_int (sign (Fun.swap i j id)) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (\\<chi>a b. A $ a $ Fun.swap i j id b) =\n    of_int (sign (Fun.swap i j id)) * det A", "by (rule det_permute_columns[of \"Fun.swap i j id\" A], simp add: permutes_swap_id)"], ["proof (state)\nthis:\n  det (\\<chi>a b. A $ a $ Fun.swap i j id b) =\n  of_int (sign (Fun.swap i j id)) * det A\n\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "finally"], ["proof (chain)\npicking this:\n  det (interchange_columns A i j) = of_int (sign (Fun.swap i j id)) * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (interchange_columns A i j) = of_int (sign (Fun.swap i j id)) * det A\n\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "unfolding sign_swap_id"], ["proof (prove)\nusing this:\n  det (interchange_columns A i j) =\n  of_int (if i = j then 1 else - 1) * det A\n\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) =\n    of_int (if i = j then 1 else - 1) * det A", "."], ["proof (state)\nthis:\n  det (interchange_columns A i j) =\n  of_int (if i = j then 1 else - 1) * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary det_interchange_different_columns:\nassumes i_not_j: \"i \\<noteq> j\"\nshows \"det (interchange_columns A i j) = - det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) = - det A", "unfolding det_interchange_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = - det A", "using i_not_j"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = - det A", "by simp"], ["", "corollary det_interchange_same_columns:\nassumes i_eq_j: \"i = j\"\nshows \"det (interchange_columns A i j) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (interchange_columns A i j) = det A", "unfolding det_interchange_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = det A", "using i_eq_j"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. of_int (if i = j then 1 else - 1) * det A = det A", "by simp"], ["", "lemma det_mult_columns:\nshows \"det (mult_column A a k) = k * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "have \"mult_column A a k = transpose (mult_row (transpose A) a k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_column A a k =\n    Finite_Cartesian_Product.transpose\n     (mult_row (Finite_Cartesian_Product.transpose A) a k)", "unfolding transpose_def mult_row_def mult_column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. if j = a then A $ i $ j * k else A $ i $ j) =\n    (\\<chi>i j.\n        (\\<chi>i j.\n            if i = a then k * (\\<chi>i j. A $ j $ i) $ a $ j\n            else (\\<chi>i j. A $ j $ i) $ i $ j) $\n        j $\n        i)", "by vector"], ["proof (state)\nthis:\n  mult_column A a k =\n  Finite_Cartesian_Product.transpose\n   (mult_row (Finite_Cartesian_Product.transpose A) a k)\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "hence \"det (mult_column A a k) = det (transpose (mult_row (transpose A) a k))\""], ["proof (prove)\nusing this:\n  mult_column A a k =\n  Finite_Cartesian_Product.transpose\n   (mult_row (Finite_Cartesian_Product.transpose A) a k)\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) =\n    det (Finite_Cartesian_Product.transpose\n          (mult_row (Finite_Cartesian_Product.transpose A) a k))", "by simp"], ["proof (state)\nthis:\n  det (mult_column A a k) =\n  det (Finite_Cartesian_Product.transpose\n        (mult_row (Finite_Cartesian_Product.transpose A) a k))\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "also"], ["proof (state)\nthis:\n  det (mult_column A a k) =\n  det (Finite_Cartesian_Product.transpose\n        (mult_row (Finite_Cartesian_Product.transpose A) a k))\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "have \"... = det (mult_row (transpose A) a k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Finite_Cartesian_Product.transpose\n          (mult_row (Finite_Cartesian_Product.transpose A) a k)) =\n    det (mult_row (Finite_Cartesian_Product.transpose A) a k)", "unfolding det_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row (Finite_Cartesian_Product.transpose A) a k) =\n    det (mult_row (Finite_Cartesian_Product.transpose A) a k)", ".."], ["proof (state)\nthis:\n  det (Finite_Cartesian_Product.transpose\n        (mult_row (Finite_Cartesian_Product.transpose A) a k)) =\n  det (mult_row (Finite_Cartesian_Product.transpose A) a k)\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "also"], ["proof (state)\nthis:\n  det (Finite_Cartesian_Product.transpose\n        (mult_row (Finite_Cartesian_Product.transpose A) a k)) =\n  det (mult_row (Finite_Cartesian_Product.transpose A) a k)\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "have \"... = k * det (transpose A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row (Finite_Cartesian_Product.transpose A) a k) =\n    k * det (Finite_Cartesian_Product.transpose A)", "unfolding det_mult_row"], ["proof (prove)\ngoal (1 subgoal):\n 1. k * det (Finite_Cartesian_Product.transpose A) =\n    k * det (Finite_Cartesian_Product.transpose A)", ".."], ["proof (state)\nthis:\n  det (mult_row (Finite_Cartesian_Product.transpose A) a k) =\n  k * det (Finite_Cartesian_Product.transpose A)\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "also"], ["proof (state)\nthis:\n  det (mult_row (Finite_Cartesian_Product.transpose A) a k) =\n  k * det (Finite_Cartesian_Product.transpose A)\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "have \"... = k * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * det (Finite_Cartesian_Product.transpose A) = k * det A", "unfolding det_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. k * det A = k * det A", ".."], ["proof (state)\nthis:\n  k * det (Finite_Cartesian_Product.transpose A) = k * det A\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "finally"], ["proof (chain)\npicking this:\n  det (mult_column A a k) = k * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (mult_column A a k) = k * det A\n\ngoal (1 subgoal):\n 1. det (mult_column A a k) = k * det A", "."], ["proof (state)\nthis:\n  det (mult_column A a k) = k * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_column_add:\nassumes i_not_j: \"i \\<noteq> j\"\nshows \"det (column_add A i j q) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "have \"(column_add A i j q) = (transpose (row_add (transpose A) i j q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column_add A i j q =\n    Finite_Cartesian_Product.transpose\n     (row_add (Finite_Cartesian_Product.transpose A) i j q)", "unfolding transpose_def column_add_def row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ja = i then A $ ia $ i + A $ ia $ j * q else A $ ia $ ja) =\n    (\\<chi>ia ja.\n        (\\<chi>ia ja.\n            if ia = i\n            then (\\<chi>i j. A $ j $ i) $ i $ ja +\n                 q * (\\<chi>i j. A $ j $ i) $ j $ ja\n            else (\\<chi>i j. A $ j $ i) $ ia $ ja) $\n        ja $\n        ia)", "by vector"], ["proof (state)\nthis:\n  column_add A i j q =\n  Finite_Cartesian_Product.transpose\n   (row_add (Finite_Cartesian_Product.transpose A) i j q)\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "hence \"det (column_add A i j q) = det (transpose (row_add (transpose A) i j q))\""], ["proof (prove)\nusing this:\n  column_add A i j q =\n  Finite_Cartesian_Product.transpose\n   (row_add (Finite_Cartesian_Product.transpose A) i j q)\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) =\n    det (Finite_Cartesian_Product.transpose\n          (row_add (Finite_Cartesian_Product.transpose A) i j q))", "by simp"], ["proof (state)\nthis:\n  det (column_add A i j q) =\n  det (Finite_Cartesian_Product.transpose\n        (row_add (Finite_Cartesian_Product.transpose A) i j q))\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "also"], ["proof (state)\nthis:\n  det (column_add A i j q) =\n  det (Finite_Cartesian_Product.transpose\n        (row_add (Finite_Cartesian_Product.transpose A) i j q))\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "have \"... = det (row_add (transpose A) i j q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Finite_Cartesian_Product.transpose\n          (row_add (Finite_Cartesian_Product.transpose A) i j q)) =\n    det (row_add (Finite_Cartesian_Product.transpose A) i j q)", "unfolding det_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add (Finite_Cartesian_Product.transpose A) i j q) =\n    det (row_add (Finite_Cartesian_Product.transpose A) i j q)", ".."], ["proof (state)\nthis:\n  det (Finite_Cartesian_Product.transpose\n        (row_add (Finite_Cartesian_Product.transpose A) i j q)) =\n  det (row_add (Finite_Cartesian_Product.transpose A) i j q)\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "also"], ["proof (state)\nthis:\n  det (Finite_Cartesian_Product.transpose\n        (row_add (Finite_Cartesian_Product.transpose A) i j q)) =\n  det (row_add (Finite_Cartesian_Product.transpose A) i j q)\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "have \"... = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add (Finite_Cartesian_Product.transpose A) i j q) = det A", "unfolding det_row_add'[OF i_not_j] det_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A = det A", ".."], ["proof (state)\nthis:\n  det (row_add (Finite_Cartesian_Product.transpose A) i j q) = det A\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "finally"], ["proof (chain)\npicking this:\n  det (column_add A i j q) = det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (column_add A i j q) = det A\n\ngoal (1 subgoal):\n 1. det (column_add A i j q) = det A", "."], ["proof (state)\nthis:\n  det (column_add A i j q) = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Proving that the determinant can be computed by means of the Gauss Jordan algorithm\\<close>"], ["", "subsubsection\\<open>Previous properties\\<close>"], ["", "lemma det_row_add_iterate_upt_n:\nfixes A::\"'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\"\nassumes n: \"n<nrows A\"\nshows \"det (row_add_iterate A n i j) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add_iterate A n i j) = det A", "using n"], ["proof (prove)\nusing this:\n  n < nrows A\n\ngoal (1 subgoal):\n 1. det (row_add_iterate A n i j) = det A", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 < nrows A \\<Longrightarrow> det (row_add_iterate A 0 i j) = det A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   det (row_add_iterate A n i j) = det A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (row_add_iterate A (Suc n) i j) = det A", "case 0"], ["proof (state)\nthis:\n  0 < nrows A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 < nrows A \\<Longrightarrow> det (row_add_iterate A 0 i j) = det A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   det (row_add_iterate A n i j) = det A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (row_add_iterate A (Suc n) i j) = det A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add_iterate A 0 i j) = det A", "unfolding row_add_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (if i = (0::'n) then A\n         else row_add A (0::'n) i (- A $ (0::'n) $ j)) =\n    det A", "using det_row_add'[of 0 i A]"], ["proof (prove)\nusing this:\n  (0::'n) \\<noteq> i \\<Longrightarrow> det (row_add A (0::'n) i ?q) = det A\n\ngoal (1 subgoal):\n 1. det (if i = (0::'n) then A\n         else row_add A (0::'n) i (- A $ (0::'n) $ j)) =\n    det A", "by auto"], ["proof (state)\nthis:\n  det (row_add_iterate A 0 i j) = det A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   det (row_add_iterate A n i j) = det A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (row_add_iterate A (Suc n) i j) = det A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   det (row_add_iterate A n i j) = det A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (row_add_iterate A (Suc n) i j) = det A", "case (Suc n)"], ["proof (state)\nthis:\n  n < nrows ?A \\<Longrightarrow> det (row_add_iterate ?A n i j) = det ?A\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   det (row_add_iterate A n i j) = det A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (row_add_iterate A (Suc n) i j) = det A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add_iterate A (Suc n) i j) = det A", "unfolding row_add_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n         else row_add_iterate\n               (row_add A (mod_type_class.from_nat (Suc n)) i\n                 (- A $ mod_type_class.from_nat (Suc n) $ j))\n               n i j) =\n    det A", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    det (row_add_iterate A n i j) = det A\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det A", "show \"det (row_add_iterate A n i j) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add_iterate A n i j) = det A", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  n < nrows ?A \\<Longrightarrow> det (row_add_iterate ?A n i j) = det ?A\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. det (row_add_iterate A n i j) = det A", "by simp"], ["proof (state)\nthis:\n  det (row_add_iterate A n i j) = det A\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det A", "assume Suc_n_not_i: \"Suc n \\<noteq> to_nat i\""], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det A", "have \"det (row_add_iterate (row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)) n i j) \n= det (row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j))", "proof (rule Suc.hyps, unfold nrows_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. n < CARD('n)", "show \" n < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < CARD('n)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. n < CARD('n)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc n < CARD('n)\n\ngoal (1 subgoal):\n 1. n < CARD('n)", "by auto"], ["proof (state)\nthis:\n  n < CARD('n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (row_add_iterate\n        (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j))\n        n i j) =\n  det (row_add A (mod_type_class.from_nat (Suc n)) i\n        (- A $ mod_type_class.from_nat (Suc n) $ j))\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det A", "also"], ["proof (state)\nthis:\n  det (row_add_iterate\n        (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j))\n        n i j) =\n  det (row_add A (mod_type_class.from_nat (Suc n)) i\n        (- A $ mod_type_class.from_nat (Suc n) $ j))\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det A", "have \"... = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j)) =\n    det A", "proof (rule det_row_add',rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "assume \"from_nat (Suc n) = i\""], ["proof (state)\nthis:\n  mod_type_class.from_nat (Suc n) = i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "hence \"to_nat (from_nat (Suc n)::'n) = to_nat i\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (Suc n) = i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc n)) =\n    mod_type_class.to_nat i", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc n)) =\n  mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "hence \"(Suc n) = to_nat i\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc n)) =\n  mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n = mod_type_class.to_nat i", "unfolding to_nat_from_nat_id[OF Suc.prems[unfolded nrows_def]]"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n = mod_type_class.to_nat i", "."], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. False", "using Suc_n_not_i"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (row_add A (mod_type_class.from_nat (Suc n)) i\n        (- A $ mod_type_class.from_nat (Suc n) $ j)) =\n  det A\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det A", "finally"], ["proof (chain)\npicking this:\n  det (row_add_iterate\n        (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j))\n        n i j) =\n  det A", "show \"det (row_add_iterate (row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)) n i j) = det A\""], ["proof (prove)\nusing this:\n  det (row_add_iterate\n        (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j))\n        n i j) =\n  det A\n\ngoal (1 subgoal):\n 1. det (row_add_iterate\n          (row_add A (mod_type_class.from_nat (Suc n)) i\n            (- A $ mod_type_class.from_nat (Suc n) $ j))\n          n i j) =\n    det A", "."], ["proof (state)\nthis:\n  det (row_add_iterate\n        (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j))\n        n i j) =\n  det A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (row_add_iterate A (Suc n) i j) = det A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary det_row_add_iterate:\nfixes A::\"'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\"\nshows \"det (row_add_iterate A (nrows A - 1) i j) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add_iterate A (nrows A - 1) i j) = det A", "by (metis det_row_add_iterate_upt_n diff_less neq0_conv nrows_not_0 zero_less_one)"], ["", "lemma det_Gauss_Jordan_in_ij:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\ndefines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\nshows \"det (Gauss_Jordan_in_ij A i j) = det A' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "have nrows_eq: \"nrows A' = nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A' = nrows A", "unfolding nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) = CARD('n)", "by simp"], ["proof (state)\nthis:\n  nrows A' = nrows A\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "have \"row_add_iterate A' (nrows A - 1) i j  =  Gauss_Jordan_in_ij A i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' (nrows A - 1) i j = Gauss_Jordan_in_ij A i j", "using row_add_iterate_eq_Gauss_Jordan_in_ij"], ["proof (prove)\nusing this:\n  row_add_iterate\n   (mult_row\n     (interchange_rows ?A ?i\n       (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n))\n     ?i ((1::?'a) /\n         interchange_rows ?A ?i\n          (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n) $\n         ?i $\n         ?j))\n   (nrows ?A - 1) ?i ?j =\n  Gauss_Jordan_in_ij ?A ?i ?j\n\ngoal (1 subgoal):\n 1. row_add_iterate A' (nrows A - 1) i j = Gauss_Jordan_in_ij A i j", "unfolding A'"], ["proof (prove)\nusing this:\n  row_add_iterate\n   (mult_row\n     (interchange_rows ?A ?i\n       (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n))\n     ?i ((1::?'a) /\n         interchange_rows ?A ?i\n          (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n) $\n         ?i $\n         ?j))\n   (nrows ?A - 1) ?i ?j =\n  Gauss_Jordan_in_ij ?A ?i ?j\n\ngoal (1 subgoal):\n 1. row_add_iterate\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          i $\n          j))\n     (nrows A - 1) i j =\n    Gauss_Jordan_in_ij A i j", "."], ["proof (state)\nthis:\n  row_add_iterate A' (nrows A - 1) i j = Gauss_Jordan_in_ij A i j\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "hence \"det (Gauss_Jordan_in_ij A i j) = det (row_add_iterate A' (nrows A - 1) i j)\""], ["proof (prove)\nusing this:\n  row_add_iterate A' (nrows A - 1) i j = Gauss_Jordan_in_ij A i j\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    det (row_add_iterate A' (nrows A - 1) i j)", "by simp"], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) =\n  det (row_add_iterate A' (nrows A - 1) i j)\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "also"], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) =\n  det (row_add_iterate A' (nrows A - 1) i j)\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "have \"... = det A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add_iterate A' (nrows A - 1) i j) = det A'", "by (rule det_row_add_iterate[of A', unfolded nrows_eq])"], ["proof (state)\nthis:\n  det (row_add_iterate A' (nrows A - 1) i j) = det A'\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "finally"], ["proof (chain)\npicking this:\n  det (Gauss_Jordan_in_ij A i j) = det A'", "show ?thesis"], ["proof (prove)\nusing this:\n  det (Gauss_Jordan_in_ij A i j) = det A'\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "."], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) = det A'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_Gauss_Jordan_in_ij_1:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\ndefines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\nassumes i: \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) = i\"\nshows \"det (Gauss_Jordan_in_ij A i j) = 1/(A$i$j) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A", "have \"det (Gauss_Jordan_in_ij A i j) = det A' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "using det_Gauss_Jordan_in_ij"], ["proof (prove)\nusing this:\n  det (Gauss_Jordan_in_ij ?A ?i ?j) =\n  det (mult_row\n        (interchange_rows ?A ?i\n          (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n))\n        ?i ((1::?'a) /\n            interchange_rows ?A ?i\n             (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n) $\n            ?i $\n            ?j))\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "unfolding A'"], ["proof (prove)\nusing this:\n  det (Gauss_Jordan_in_ij ?A ?i ?j) =\n  det (mult_row\n        (interchange_rows ?A ?i\n          (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n))\n        ?i ((1::?'a) /\n            interchange_rows ?A ?i\n             (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n) $\n            ?i $\n            ?j))\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    det (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             i $\n             j))", "by auto"], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) = det A'\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A", "also"], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) = det A'\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A", "have \"... = 1/(A$i$j) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A' = (1::'a) / A $ i $ j * det A", "unfolding A' det_mult_row"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) /\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j *\n    det (interchange_rows A i\n          (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) =\n    (1::'a) / A $ i $ j * det A", "unfolding i det_interchange_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / interchange_rows A i i $ i $ j *\n    (of_int (if i = i then 1 else - 1) * det A) =\n    (1::'a) / A $ i $ j * det A", "by auto"], ["proof (state)\nthis:\n  det A' = (1::'a) / A $ i $ j * det A\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A", "finally"], ["proof (chain)\npicking this:\n  det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A", "."], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_Gauss_Jordan_in_ij_2:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\ndefines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\nassumes i: \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) \\<noteq> i\"\nshows \"det (Gauss_Jordan_in_ij A i j) = - 1/(A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "have \"det (Gauss_Jordan_in_ij A i j) = det A' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "using det_Gauss_Jordan_in_ij"], ["proof (prove)\nusing this:\n  det (Gauss_Jordan_in_ij ?A ?i ?j) =\n  det (mult_row\n        (interchange_rows ?A ?i\n          (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n))\n        ?i ((1::?'a) /\n            interchange_rows ?A ?i\n             (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n) $\n            ?i $\n            ?j))\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) = det A'", "unfolding A'"], ["proof (prove)\nusing this:\n  det (Gauss_Jordan_in_ij ?A ?i ?j) =\n  det (mult_row\n        (interchange_rows ?A ?i\n          (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n))\n        ?i ((1::?'a) /\n            interchange_rows ?A ?i\n             (LEAST n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n) $\n            ?i $\n            ?j))\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    det (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             i $\n             j))", "by auto"], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) = det A'\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "also"], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) = det A'\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "have \"... = - 1/(A$ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $j) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A' =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "unfolding A' det_mult_row"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) /\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j *\n    det (interchange_rows A i\n          (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "unfolding det_interchange_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) /\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j *\n    (of_int\n      (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) then 1\n       else - 1) *\n     det A) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "using i"], ["proof (prove)\nusing this:\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<noteq> i\n\ngoal (1 subgoal):\n 1. (1::'a) /\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j *\n    (of_int\n      (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) then 1\n       else - 1) *\n     det A) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "by auto"], ["proof (state)\nthis:\n  det A' =\n  - (1::'a) /\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n  det A\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "finally"], ["proof (chain)\npicking this:\n  det (Gauss_Jordan_in_ij A i j) =\n  - (1::'a) /\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n  det A", "show ?thesis"], ["proof (prove)\nusing this:\n  det (Gauss_Jordan_in_ij A i j) =\n  - (1::'a) /\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n  det A\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan_in_ij A i j) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det A", "."], ["proof (state)\nthis:\n  det (Gauss_Jordan_in_ij A i j) =\n  - (1::'a) /\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n  det A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Definitions\\<close>"], ["", "text\\<open>The following definitions allow the computation of the determinant of a matrix using the Gauss-Jordan algorithm. In the first component the determinant of each transformation\nis accumulated and the second component contains the matrix transformed into a reduced row echelon form matrix\\<close>"], ["", "definition Gauss_Jordan_in_ij_det_P :: \"'a::{semiring_1, inverse, one, uminus}^'m^'n::{finite, ord}=> 'n=>'m=>('a \\<times> ('a^'m^'n::{finite, ord}))\"\n  where \"Gauss_Jordan_in_ij_det_P A i j = (let n = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) in (if i = n then 1/(A $ i $ j) else - 1/(A $ n $ j), Gauss_Jordan_in_ij A i j))\""], ["", "definition Gauss_Jordan_column_k_det_P where \"Gauss_Jordan_column_k_det_P A' k =\n(let det_P= fst A'; i = fst (snd A'); A = snd (snd A'); from_nat_i = from_nat i; from_nat_k = from_nat k\n in if (\\<forall>m\\<ge>from_nat_i. A $ m $ from_nat_k = 0) \\<or> i = nrows A then (det_P, i, A)\n    else let gauss = Gauss_Jordan_in_ij_det_P A (from_nat_i) (from_nat_k) in (fst gauss * det_P, i + 1, snd gauss))\""], ["", "definition Gauss_Jordan_upt_k_det_P \n  where \"Gauss_Jordan_upt_k_det_P A k = (let foldl = foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k] in (fst foldl, snd (snd foldl)))\""], ["", "definition Gauss_Jordan_det_P \n  where \"Gauss_Jordan_det_P A = Gauss_Jordan_upt_k_det_P A (ncols A - 1)\""], ["", "subsubsection\\<open>Proofs\\<close>"], ["", "text\\<open>This is an equivalent definition created to achieve a more efficient computation.\\<close>"], ["", "lemma Gauss_Jordan_in_ij_det_P_code[code]:\nshows \"Gauss_Jordan_in_ij_det_P A i j = \n    (let n = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n);\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i (1 / interchange_A $ i $ j) in (if i = n then 1/(A $ i $ j) else - 1/(A $ n $ j), Gauss_Jordan_wrapper i j A' interchange_A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij_det_P A i j =\n    (let n = LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)\n     in (if i = n then (1::'a) / A $ i $ j else - (1::'a) / A $ n $ j,\n         Gauss_Jordan_wrapper i j A' interchange_A))", "unfolding Gauss_Jordan_in_ij_det_P_def Gauss_Jordan_in_ij_def Gauss_Jordan_wrapper_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j,\n     \\<chi>s.\n        if s = i\n        then mult_row\n              (interchange_rows A i\n                (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n              i ((1::'a) /\n                 interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 i $\n                 j) $\n             s\n        else row_add\n              (mult_row\n                (interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                i ((1::'a) /\n                   interchange_rows A i\n                    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                   i $\n                   j))\n              s i\n              (- interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 s $\n                 j) $\n             s) =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j,\n     \\<chi>s.\n        if s = i\n        then mult_row\n              (interchange_rows A i\n                (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n              i ((1::'a) /\n                 interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 i $\n                 j) $\n             s\n        else row_add\n              (mult_row\n                (interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                i ((1::'a) /\n                   interchange_rows A i\n                    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                   i $\n                   j))\n              s i\n              (- interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 s $\n                 j) $\n             s)", "by auto"], ["", "lemma det_Gauss_Jordan_in_ij_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\" and i j::\"'n\"\nshows \"(fst (Gauss_Jordan_in_ij_det_P A i j)) * det A  = det (snd (Gauss_Jordan_in_ij_det_P A i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det A =\n    det (snd (Gauss_Jordan_in_ij_det_P A i j))", "unfolding Gauss_Jordan_in_ij_det_P_def Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det A =\n    det (Gauss_Jordan_in_ij A i j)", "using det_Gauss_Jordan_in_ij_1[of A j i]"], ["proof (prove)\nusing this:\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) =\n  i \\<Longrightarrow>\n  det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A\n\ngoal (1 subgoal):\n 1. (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det A =\n    det (Gauss_Jordan_in_ij A i j)", "using det_Gauss_Jordan_in_ij_2[of A j i]"], ["proof (prove)\nusing this:\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) =\n  i \\<Longrightarrow>\n  det (Gauss_Jordan_in_ij A i j) = (1::'a) / A $ i $ j * det A\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<noteq>\n  i \\<Longrightarrow>\n  det (Gauss_Jordan_in_ij A i j) =\n  - (1::'a) /\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n  det A\n\ngoal (1 subgoal):\n 1. (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det A =\n    det (Gauss_Jordan_in_ij A i j)", "by auto"], ["", "lemma det_Gauss_Jordan_column_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nassumes det: \"det_P * det B = det A\"\nshows \"(fst (Gauss_Jordan_column_k_det_P (det_P,i,A) k)) * det B = det (snd (snd (Gauss_Jordan_column_k_det_P (det_P,i,A) k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_det_P (det_P, i, A) k) * det B =\n    det (snd (snd (Gauss_Jordan_column_k_det_P (det_P, i, A) k)))", "proof (unfold Gauss_Jordan_column_k_det_P_def Let_def, auto simp add: assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_in_ij_det_P A\n                               (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k)) *\n                         det_P *\n                         det B =\n                         det (snd (Gauss_Jordan_in_ij_det_P A\n                                    (mod_type_class.from_nat i)\n                                    (mod_type_class.from_nat k)))", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_in_ij_det_P A\n                               (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k)) *\n                         det_P *\n                         det B =\n                         det (snd (Gauss_Jordan_in_ij_det_P A\n                                    (mod_type_class.from_nat i)\n                                    (mod_type_class.from_nat k)))", "assume i_not_nrows: \"i \\<noteq> nrows A\"\nand i_less_m: \"from_nat i \\<le> m\"\nand Amk_not_0: \"A $ m $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> nrows A\n  mod_type_class.from_nat i \\<le> m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_in_ij_det_P A\n                               (mod_type_class.from_nat i)\n                               (mod_type_class.from_nat k)) *\n                         det_P *\n                         det B =\n                         det (snd (Gauss_Jordan_in_ij_det_P A\n                                    (mod_type_class.from_nat i)\n                                    (mod_type_class.from_nat k)))", "show  \"fst (Gauss_Jordan_in_ij_det_P A (from_nat i) (from_nat k)) * det_P * det B =\n        det (snd (Gauss_Jordan_in_ij_det_P A (from_nat i) (from_nat k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n          (mod_type_class.from_nat k)) *\n    det_P *\n    det B =\n    det (snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n               (mod_type_class.from_nat k)))", "unfolding mult.assoc det"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n          (mod_type_class.from_nat k)) *\n    det A =\n    det (snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n               (mod_type_class.from_nat k)))", "unfolding det_Gauss_Jordan_in_ij_det_P"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n               (mod_type_class.from_nat k))) =\n    det (snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n               (mod_type_class.from_nat k)))", ".."], ["proof (state)\nthis:\n  fst (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k)) *\n  det_P *\n  det B =\n  det (snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n             (mod_type_class.from_nat k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_Gauss_Jordan_upt_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"(fst (Gauss_Jordan_upt_k_det_P A k)) * det A = det (snd (Gauss_Jordan_upt_k_det_P A k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n    det (snd (Gauss_Jordan_upt_k_det_P A k))", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (Gauss_Jordan_upt_k_det_P A 0) * det A =\n    det (snd (Gauss_Jordan_upt_k_det_P A 0))\n 2. \\<And>k.\n       fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A k)) \\<Longrightarrow>\n       fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. fst (Gauss_Jordan_upt_k_det_P A 0) * det A =\n    det (snd (Gauss_Jordan_upt_k_det_P A 0))\n 2. \\<And>k.\n       fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A k)) \\<Longrightarrow>\n       fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_upt_k_det_P A 0) * det A =\n    det (snd (Gauss_Jordan_upt_k_det_P A 0))", "unfolding Gauss_Jordan_upt_k_det_P_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc 0]),\n         snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                    [0..<Suc 0]))) *\n    det A =\n    det (snd (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                    [0..<Suc 0]),\n              snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                         [0..<Suc 0]))))", "unfolding fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc 0]) *\n    det A =\n    det (snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                    [0..<Suc 0])))", "by (simp add:det_Gauss_Jordan_column_k_det_P)"], ["proof (state)\nthis:\n  fst (Gauss_Jordan_upt_k_det_P A 0) * det A =\n  det (snd (Gauss_Jordan_upt_k_det_P A 0))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A k)) \\<Longrightarrow>\n       fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A k)) \\<Longrightarrow>\n       fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "case (Suc k)"], ["proof (state)\nthis:\n  fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n  det (snd (Gauss_Jordan_upt_k_det_P A k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A k)) \\<Longrightarrow>\n       fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "have suc_rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A k)) \\<Longrightarrow>\n       fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "have fold_expand: \"(foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k]) \n= (fst (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k]), fst (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k])),\n  snd (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k] =\n    (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k]),\n     fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                [0..<Suc k])),\n     snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                [0..<Suc k])))", "by simp"], ["proof (state)\nthis:\n  foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k] =\n  (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k]),\n   fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])),\n   snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       fst (Gauss_Jordan_upt_k_det_P A k) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A k)) \\<Longrightarrow>\n       fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n       det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n    det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))", "unfolding Gauss_Jordan_upt_k_det_P_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc (Suc k)]),\n         snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                    [0..<Suc (Suc k)]))) *\n    det A =\n    det (snd (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                    [0..<Suc (Suc k)]),\n              snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                         [0..<Suc (Suc k)]))))", "unfolding suc_rw foldl_append List.foldl.simps fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_det_P\n          (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])\n          (Suc k)) *\n    det A =\n    det (snd (snd (Gauss_Jordan_column_k_det_P\n                    (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                      [0..<Suc k])\n                    (Suc k))))", "by(subst (1 2) fold_expand, rule det_Gauss_Jordan_column_k_det_P, rule Suc.hyps[unfolded Gauss_Jordan_upt_k_det_P_def Let_def fst_conv snd_conv])"], ["proof (state)\nthis:\n  fst (Gauss_Jordan_upt_k_det_P A (Suc k)) * det A =\n  det (snd (Gauss_Jordan_upt_k_det_P A (Suc k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_Gauss_Jordan_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"(fst (Gauss_Jordan_det_P A)) * det A = det (snd (Gauss_Jordan_det_P A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_det_P A) * det A = det (snd (Gauss_Jordan_det_P A))", "using det_Gauss_Jordan_upt_k_det_P"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_upt_k_det_P ?A ?k) * det ?A =\n  det (snd (Gauss_Jordan_upt_k_det_P ?A ?k))\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_det_P A) * det A = det (snd (Gauss_Jordan_det_P A))", "unfolding Gauss_Jordan_det_P_def"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_upt_k_det_P ?A ?k) * det ?A =\n  det (snd (Gauss_Jordan_upt_k_det_P ?A ?k))\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_upt_k_det_P A (ncols A - 1)) * det A =\n    det (snd (Gauss_Jordan_upt_k_det_P A (ncols A - 1)))", "by simp"], ["", "definition upper_triangular_upt_k where \"upper_triangular_upt_k A k = (\\<forall>i j. j<i \\<and> to_nat j < k \\<longrightarrow> A $ i $ j = 0)\""], ["", "definition upper_triangular where \"upper_triangular A = (\\<forall>i j. j<i \\<longrightarrow> A $ i $ j = 0)\""], ["", "lemma upper_triangular_upt_imp_upper_triangular:\nassumes \"upper_triangular_upt_k A (nrows A)\"\nshows \"upper_triangular A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular A", "using assms"], ["proof (prove)\nusing this:\n  upper_triangular_upt_k A (nrows A)\n\ngoal (1 subgoal):\n 1. upper_triangular A", "unfolding upper_triangular_upt_k_def upper_triangular_def nrows_def"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     j < i \\<and> mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n     A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i j. j < i \\<longrightarrow> A $ i $ j = (0::'a)", "using to_nat_less_card[where ?'a='b]"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     j < i \\<and> mod_type_class.to_nat j < CARD('b) \\<longrightarrow>\n     A $ i $ j = (0::'a)\n  mod_type_class.to_nat ?j < CARD('b)\n\ngoal (1 subgoal):\n 1. \\<forall>i j. j < i \\<longrightarrow> A $ i $ j = (0::'a)", "by blast"], ["", "lemma rref_imp_upper_triagular_upt:\nfixes A::\"'a::{one, zero}^'n::{mod_type}^'n::{mod_type}\"\nassumes \"reduced_row_echelon_form A\"\nshows \"upper_triangular_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A k", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. upper_triangular_upt_k A 0\n 2. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. upper_triangular_upt_k A 0\n 2. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A 0", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       j < i \\<and> mod_type_class.to_nat j < 0 \\<longrightarrow>\n       A $ i $ j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  upper_triangular_upt_k A 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  upper_triangular_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       upper_triangular_upt_k A k \\<Longrightarrow>\n       upper_triangular_upt_k A (Suc k)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular_upt_k A (Suc k)", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       j < i \\<and> mod_type_class.to_nat j < Suc k \\<longrightarrow>\n       A $ i $ j = (0::'a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "fix i j::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "assume j_less_i: \"j < i\" and j_less_suc_k: \"to_nat j < Suc k\""], ["proof (state)\nthis:\n  j < i\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>j < i; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "show \"A $ i $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "proof (cases \"to_nat j < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)\n 2. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using Suc.hyps"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  upper_triangular_upt_k A k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  \\<forall>i j.\n     j < i \\<and> mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using j_less_i True"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < k\n  \\<forall>i j.\n     j < i \\<and> mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ i $ j = (0::'a)\n  j < i\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "hence j_eq_k: \"to_nat j = k\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "using j_less_suc_k"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat j < k\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j = k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat j = k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have rref_suc: \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "by (metis assms rref_implies_rref_upt)"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A (Suc k)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "proof (cases \"A $ i $ from_nat k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ i $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)\n 2. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "case True"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k = (0::'a)\n\ngoal (2 subgoals):\n 1. A $ i $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)\n 2. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "have \"from_nat k = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k = j", "by (metis from_nat_to_nat_id j_eq_k)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k = j\n\ngoal (2 subgoals):\n 1. A $ i $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)\n 2. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat k = j\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using True"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat k = j\n  A $ i $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "case False"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "have zero_i_k: \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)", "by (metis (hide_lams, mono_tags) Suc.hyps leD le_less_linear less_imp_le j_eq_k j_less_i le_trans to_nat_mono' upper_triangular_upt_k_def)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "have not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i (Suc k) A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < Suc k \\<longrightarrow>\n               A $ i $ j = (0::'a))", "using False"], ["proof (prove)\nusing this:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < Suc k \\<longrightarrow>\n               A $ i $ j = (0::'a))", "by (metis j_eq_k lessI to_nat_from_nat)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "have Least_eq: \"(LEAST n. A $ i $ n \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"A $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)", "using False"], ["proof (prove)\nusing this:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"\\<And>y. A $ i $ y \\<noteq> 0 \\<Longrightarrow> from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ i $ y \\<noteq> (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "by (metis (full_types) is_zero_row_upt_k_def not_le_imp_less to_nat_le zero_i_k)"], ["proof (state)\nthis:\n  A $ i $ ?y \\<noteq> (0::'a) \\<Longrightarrow>\n  mod_type_class.from_nat k \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) = mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "have i_not_k: \"i \\<noteq> from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> mod_type_class.from_nat k", "by (metis less_irrefl from_nat_to_nat_id j_eq_k j_less_i)"], ["proof (state)\nthis:\n  i \\<noteq> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<Longrightarrow>\n    A $ i $ j = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using rref_upt_condition4_explicit[OF rref_suc not_zero_i_suc_k i_not_k]"], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat k $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "unfolding Least_eq"], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat k $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using rref_upt_condition1_explicit[OF rref_suc]"], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat k $ mod_type_class.from_nat k = (0::'a)\n  \\<lbrakk>is_zero_row_upt_k ?i (Suc k) A; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?j (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using Suc.hyps"], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat k $ mod_type_class.from_nat k = (0::'a)\n  \\<lbrakk>is_zero_row_upt_k ?i (Suc k) A; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?j (Suc k) A\n  upper_triangular_upt_k A k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "unfolding upper_triangular_upt_k_def"], ["proof (prove)\nusing this:\n  A $ mod_type_class.from_nat k $ mod_type_class.from_nat k = (0::'a)\n  \\<lbrakk>is_zero_row_upt_k ?i (Suc k) A; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?j (Suc k) A\n  \\<forall>i j.\n     j < i \\<and> mod_type_class.to_nat j < k \\<longrightarrow>\n     A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by (metis (mono_tags) leD not_le_imp_less is_zero_row_upt_k_def is_zero_row_upt_k_suc j_eq_k j_less_i not_zero_i_suc_k to_nat_from_nat to_nat_mono')"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  upper_triangular_upt_k A (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rref_imp_upper_triagular:\nassumes \"reduced_row_echelon_form A\"\nshows \"upper_triangular A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_triangular A", "by (metis assms rref_imp_upper_triagular_upt upper_triangular_upt_imp_upper_triangular)"], ["", "lemma det_Gauss_Jordan[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"det (Gauss_Jordan A) = prod (\\<lambda>i. (Gauss_Jordan A)$i$i) (UNIV:: 'n set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (Gauss_Jordan A) = (\\<Prod>i\\<in>UNIV. Gauss_Jordan A $ i $ i)", "using det_upperdiagonal rref_imp_upper_triagular[OF rref_Gauss_Jordan[of A]]"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      j < i \\<Longrightarrow> ?A $ i $ j = (0::?'a)) \\<Longrightarrow>\n  det ?A = (\\<Prod>i\\<in>UNIV. ?A $ i $ i)\n  upper_triangular (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan A) = (\\<Prod>i\\<in>UNIV. Gauss_Jordan A $ i $ i)", "unfolding upper_triangular_def"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      j < i \\<Longrightarrow> ?A $ i $ j = (0::?'a)) \\<Longrightarrow>\n  det ?A = (\\<Prod>i\\<in>UNIV. ?A $ i $ i)\n  \\<forall>i j. j < i \\<longrightarrow> Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. det (Gauss_Jordan A) = (\\<Prod>i\\<in>UNIV. Gauss_Jordan A $ i $ i)", "by blast"], ["", "lemma snd_Gauss_Jordan_in_ij_det_P_is_snd_Gauss_Jordan_in_ij_PA:\nshows \"snd (Gauss_Jordan_in_ij_det_P A i j) = snd (Gauss_Jordan_in_ij_PA (P,A) i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_in_ij_det_P A i j) =\n    snd (Gauss_Jordan_in_ij_PA (P, A) i j)", "unfolding Gauss_Jordan_in_ij_det_P_def Gauss_Jordan_in_ij_PA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (let n = LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n\n         in (if i = n then (1::'a) / A $ i $ j else - (1::'a) / A $ n $ j,\n             Gauss_Jordan_in_ij A i j)) =\n    snd (let Pa = fst (P, A); A = snd (P, A);\n             n = LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n;\n             interchange_A = interchange_rows A i n;\n             interchange_P = interchange_rows Pa i n;\n             P' = mult_row interchange_P i ((1::'a) / interchange_A $ i $ j)\n         in (\\<chi>s.\n                if s = i then P' $ s\n                else row_add P' s i (- interchange_A $ s $ j) $ s,\n             Gauss_Jordan_in_ij A i j))", "unfolding  Gauss_Jordan_in_ij_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>s.\n        if s = i\n        then mult_row\n              (interchange_rows A i\n                (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n              i ((1::'a) /\n                 interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 i $\n                 j) $\n             s\n        else row_add\n              (mult_row\n                (interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                i ((1::'a) /\n                   interchange_rows A i\n                    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                   i $\n                   j))\n              s i\n              (- interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 s $\n                 j) $\n             s) =\n    (\\<chi>s.\n        if s = i\n        then mult_row\n              (interchange_rows A i\n                (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n              i ((1::'a) /\n                 interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 i $\n                 j) $\n             s\n        else row_add\n              (mult_row\n                (interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                i ((1::'a) /\n                   interchange_rows A i\n                    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                   i $\n                   j))\n              s i\n              (- interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                 s $\n                 j) $\n             s)", ".."], ["", "lemma snd_Gauss_Jordan_column_k_det_P_is_snd_Gauss_Jordan_column_k_PA:\nshows \"snd (Gauss_Jordan_column_k_det_P (n,i,A) k) = snd (Gauss_Jordan_column_k_PA (P,i,A) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_column_k_det_P (n, i, A) k) =\n    snd (Gauss_Jordan_column_k_PA (P, i, A) k)", "unfolding Gauss_Jordan_column_k_det_P_def Gauss_Jordan_column_k_PA_def Let_def snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat (fst (i, A)).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            fst (i, A) = nrows A\n         then (fst (n, i, A), fst (i, A), A)\n         else (fst (Gauss_Jordan_in_ij_det_P A\n                     (mod_type_class.from_nat (fst (i, A)))\n                     (mod_type_class.from_nat k)) *\n               fst (n, i, A),\n               fst (i, A) + 1,\n               snd (Gauss_Jordan_in_ij_det_P A\n                     (mod_type_class.from_nat (fst (i, A)))\n                     (mod_type_class.from_nat k)))) =\n    snd (if (\\<forall>m\\<ge>mod_type_class.from_nat (fst (i, A)).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            fst (i, A) = nrows A\n         then (fst (P, i, A), fst (i, A), A)\n         else (fst (Gauss_Jordan_in_ij_PA (fst (P, i, A), A)\n                     (mod_type_class.from_nat (fst (i, A)))\n                     (mod_type_class.from_nat k)),\n               fst (i, A) + 1,\n               snd (Gauss_Jordan_in_ij_PA (fst (P, i, A), A)\n                     (mod_type_class.from_nat (fst (i, A)))\n                     (mod_type_class.from_nat k))))", "unfolding fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (n, i, A)\n         else (fst (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)) *\n               n,\n               i + 1,\n               snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)))) =\n    snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (P, i, A)\n         else (fst (Gauss_Jordan_in_ij_PA (P, A) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)),\n               i + 1,\n               snd (Gauss_Jordan_in_ij_PA (P, A) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k))))", "using snd_Gauss_Jordan_in_ij_det_P_is_snd_Gauss_Jordan_in_ij_PA"], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_in_ij_det_P ?A ?i ?j) =\n  snd (Gauss_Jordan_in_ij_PA (?P, ?A) ?i ?j)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (n, i, A)\n         else (fst (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)) *\n               n,\n               i + 1,\n               snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)))) =\n    snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (P, i, A)\n         else (fst (Gauss_Jordan_in_ij_PA (P, A) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)),\n               i + 1,\n               snd (Gauss_Jordan_in_ij_PA (P, A) (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k))))", "by auto"], ["", "lemma det_fst_row_add_iterate_PA:\nfixes A::\"'a::{comm_ring_1}^'n::{mod_type}^'n::{mod_type}\"\nassumes n: \"n<nrows A\"\nshows \"det (fst (row_add_iterate_PA (P,A) n i j)) = det P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) n i j)) = det P", "using n"], ["proof (prove)\nusing this:\n  n < nrows A\n\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) n i j)) = det P", "proof (induct n arbitrary: P A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P A.\n       0 < nrows A \\<Longrightarrow>\n       det (fst (row_add_iterate_PA (P, A) 0 i j)) = det P\n 2. \\<And>n P A.\n       \\<lbrakk>\\<And>P A.\n                   n < nrows A \\<Longrightarrow>\n                   det (fst (row_add_iterate_PA (P, A) n i j)) = det P;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n                         det P", "case 0"], ["proof (state)\nthis:\n  0 < nrows A\n\ngoal (2 subgoals):\n 1. \\<And>P A.\n       0 < nrows A \\<Longrightarrow>\n       det (fst (row_add_iterate_PA (P, A) 0 i j)) = det P\n 2. \\<And>n P A.\n       \\<lbrakk>\\<And>P A.\n                   n < nrows A \\<Longrightarrow>\n                   det (fst (row_add_iterate_PA (P, A) n i j)) = det P;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n                         det P", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) 0 i j)) = det P", "unfolding row_add_iterate_PA.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (if i = (0::'n) then (P, A)\n              else (row_add P (0::'n) i (- A $ (0::'n) $ j),\n                    row_add A (0::'n) i (- A $ (0::'n) $ j)))) =\n    det P", "using det_row_add'[of 0 i P]"], ["proof (prove)\nusing this:\n  (0::'n) \\<noteq> i \\<Longrightarrow> det (row_add P (0::'n) i ?q) = det P\n\ngoal (1 subgoal):\n 1. det (fst (if i = (0::'n) then (P, A)\n              else (row_add P (0::'n) i (- A $ (0::'n) $ j),\n                    row_add A (0::'n) i (- A $ (0::'n) $ j)))) =\n    det P", "by simp"], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P, A) 0 i j)) = det P\n\ngoal (1 subgoal):\n 1. \\<And>n P A.\n       \\<lbrakk>\\<And>P A.\n                   n < nrows A \\<Longrightarrow>\n                   det (fst (row_add_iterate_PA (P, A) n i j)) = det P;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n                         det P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n P A.\n       \\<lbrakk>\\<And>P A.\n                   n < nrows A \\<Longrightarrow>\n                   det (fst (row_add_iterate_PA (P, A) n i j)) = det P;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n                         det P", "case (Suc n)"], ["proof (state)\nthis:\n  n < nrows ?A \\<Longrightarrow>\n  det (fst (row_add_iterate_PA (?P, ?A) n i j)) = det ?P\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>n P A.\n       \\<lbrakk>\\<And>P A.\n                   n < nrows A \\<Longrightarrow>\n                   det (fst (row_add_iterate_PA (P, A) n i j)) = det P;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n                         det P", "have n: \"n<nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows A", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. n < nrows A", "by simp"], ["proof (state)\nthis:\n  n < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>n P A.\n       \\<lbrakk>\\<And>P A.\n                   n < nrows A \\<Longrightarrow>\n                   det (fst (row_add_iterate_PA (P, A) n i j)) = det P;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n                         det P", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "unfolding row_add_iterate_PA.simps if_P[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) n i j)) = det P", "using Suc.hyps[OF n]"], ["proof (prove)\nusing this:\n  det (fst (row_add_iterate_PA (?P, A) n i j)) = det ?P\n\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) n i j)) = det P", "."], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "define P' where \"P' = row_add P (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)\""], ["proof (state)\nthis:\n  P' =\n  row_add P (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "define A' where \"A' = row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)\""], ["proof (state)\nthis:\n  A' =\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "have n2: \"n< nrows A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows A'", "using n"], ["proof (prove)\nusing this:\n  n < nrows A\n\ngoal (1 subgoal):\n 1. n < nrows A'", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  n < CARD('n)\n\ngoal (1 subgoal):\n 1. n < CARD('n)", "."], ["proof (state)\nthis:\n  n < nrows A'\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "have \"det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det (fst (row_add_iterate_PA (P', A') n i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n    det (fst (row_add_iterate_PA (P', A') n i j))", "unfolding row_add_iterate_PA.simps if_not_P[OF False] P'_def A'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA\n               (row_add P (mod_type_class.from_nat (Suc n)) i\n                 (- A $ mod_type_class.from_nat (Suc n) $ j),\n                row_add A (mod_type_class.from_nat (Suc n)) i\n                 (- A $ mod_type_class.from_nat (Suc n) $ j))\n               n i j)) =\n    det (fst (row_add_iterate_PA\n               (row_add P (mod_type_class.from_nat (Suc n)) i\n                 (- A $ mod_type_class.from_nat (Suc n) $ j),\n                row_add A (mod_type_class.from_nat (Suc n)) i\n                 (- A $ mod_type_class.from_nat (Suc n) $ j))\n               n i j))", ".."], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n  det (fst (row_add_iterate_PA (P', A') n i j))\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "also"], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) =\n  det (fst (row_add_iterate_PA (P', A') n i j))\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "have \"... = det P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P', A') n i j)) = det P'", "using Suc.hyps[OF n2]"], ["proof (prove)\nusing this:\n  det (fst (row_add_iterate_PA (?P, A') n i j)) = det ?P\n\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P', A') n i j)) = det P'", "."], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P', A') n i j)) = det P'\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "also"], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P', A') n i j)) = det P'\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "have \"... = det P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det P' = det P", "unfolding P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (row_add P (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j)) =\n    det P", "proof (rule det_row_add', rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "assume \"from_nat (Suc n) = i\""], ["proof (state)\nthis:\n  mod_type_class.from_nat (Suc n) = i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "hence \"to_nat (from_nat (Suc n)::'n) = to_nat i\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (Suc n) = i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat (Suc n)) =\n    mod_type_class.to_nat i", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc n)) =\n  mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "hence \"(Suc n) = to_nat i\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat (Suc n)) =\n  mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n = mod_type_class.to_nat i", "unfolding to_nat_from_nat_id[OF Suc.prems[unfolded nrows_def]]"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n = mod_type_class.to_nat i", "."], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) = i \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  Suc n = mod_type_class.to_nat i\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det P' = det P\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "finally"], ["proof (chain)\npicking this:\n  det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "show ?thesis"], ["proof (prove)\nusing this:\n  det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P\n\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P", "."], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P, A) (Suc n) i j)) = det P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_fst_Gauss_Jordan_in_ij_PA_eq_fst_Gauss_Jordan_in_ij_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_in_ij_det_P A i j) * det P = det (fst (Gauss_Jordan_in_ij_PA (P,A) i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "define P' where \"P' = mult_row (interchange_rows P i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ i $ j)\""], ["proof (state)\nthis:\n  P' =\n  mult_row\n   (interchange_rows P i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n   i ((1::'a) /\n      interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n      i $\n      j)\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "define A' where \"A' = mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ i $ j)\""], ["proof (state)\nthis:\n  A' =\n  mult_row\n   (interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n   i ((1::'a) /\n      interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n      i $\n      j)\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "have \"det (fst (Gauss_Jordan_in_ij_PA (P,A) i j)) = det (fst (row_add_iterate_PA (P',A') (nrows A - 1) i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (Gauss_Jordan_in_ij_PA (P, A) i j)) =\n    det (fst (row_add_iterate_PA (P', A') (nrows A - 1) i j))", "unfolding fst_row_add_iterate_PA_eq_fst_Gauss_Jordan_in_ij_PA[symmetric] A'_def P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA\n               (mult_row\n                 (interchange_rows P i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j),\n                mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j))\n               (nrows A - 1) i j)) =\n    det (fst (row_add_iterate_PA\n               (mult_row\n                 (interchange_rows P i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j),\n                mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j))\n               (nrows A - 1) i j))", ".."], ["proof (state)\nthis:\n  det (fst (Gauss_Jordan_in_ij_PA (P, A) i j)) =\n  det (fst (row_add_iterate_PA (P', A') (nrows A - 1) i j))\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "also"], ["proof (state)\nthis:\n  det (fst (Gauss_Jordan_in_ij_PA (P, A) i j)) =\n  det (fst (row_add_iterate_PA (P', A') (nrows A - 1) i j))\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "have \"...= det P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (row_add_iterate_PA (P', A') (nrows A - 1) i j)) = det P'", "by (rule det_fst_row_add_iterate_PA, simp add: nrows_def)"], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P', A') (nrows A - 1) i j)) = det P'\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "also"], ["proof (state)\nthis:\n  det (fst (row_add_iterate_PA (P', A') (nrows A - 1) i j)) = det P'\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "have \"... = (if i = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) then 1 / A $ i $ j else - 1 / A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j) * det P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "proof (cases \"i = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i =\n    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<Longrightarrow>\n    det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P\n 2. i \\<noteq>\n    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<Longrightarrow>\n    det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "case True"], ["proof (state)\nthis:\n  i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (2 subgoals):\n 1. i =\n    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<Longrightarrow>\n    det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P\n 2. i \\<noteq>\n    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<Longrightarrow>\n    det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "unfolding if_P[OF True] P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row\n          (interchange_rows P i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             i $\n             j)) =\n    (1::'a) / A $ i $ j * det P", "unfolding True[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row (interchange_rows P i i) i\n          ((1::'a) / interchange_rows A i i $ i $ j)) =\n    (1::'a) / A $ i $ j * det P", "unfolding interchange_same_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row P i ((1::'a) / A $ i $ j)) = (1::'a) / A $ i $ j * det P", "unfolding det_mult_row"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / A $ i $ j * det P = (1::'a) / A $ i $ j * det P", ".."], ["proof (state)\nthis:\n  det P' =\n  (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n   then (1::'a) / A $ i $ j\n   else - (1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n  det P\n\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<Longrightarrow>\n    det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<Longrightarrow>\n    det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "case False"], ["proof (state)\nthis:\n  i \\<noteq> (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) \\<Longrightarrow>\n    det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det P' =\n    (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P", "unfolding if_not_P[OF False] P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mult_row\n          (interchange_rows P i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             i $\n             j)) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det P", "unfolding det_mult_row"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) /\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j *\n    det (interchange_rows P i\n          (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det P", "unfolding det_interchange_different_rows[OF False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) /\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j *\n    - det P =\n    - (1::'a) /\n    A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j *\n    det P", "by simp"], ["proof (state)\nthis:\n  det P' =\n  (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n   then (1::'a) / A $ i $ j\n   else - (1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n  det P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det P' =\n  (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n   then (1::'a) / A $ i $ j\n   else - (1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n  det P\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "also"], ["proof (state)\nthis:\n  det P' =\n  (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n   then (1::'a) / A $ i $ j\n   else - (1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n  det P\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "have \"... = fst (Gauss_Jordan_in_ij_det_P A i j) * det P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P =\n    fst (Gauss_Jordan_in_ij_det_P A i j) * det P", "unfolding Gauss_Jordan_in_ij_det_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n     then (1::'a) / A $ i $ j\n     else - (1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n    det P =\n    fst (let n = LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n\n         in (if i = n then (1::'a) / A $ i $ j else - (1::'a) / A $ n $ j,\n             Gauss_Jordan_in_ij A i j)) *\n    det P", "by simp"], ["proof (state)\nthis:\n  (if i = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n   then (1::'a) / A $ i $ j\n   else - (1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) *\n  det P =\n  fst (Gauss_Jordan_in_ij_det_P A i j) * det P\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", "finally"], ["proof (chain)\npicking this:\n  det (fst (Gauss_Jordan_in_ij_PA (P, A) i j)) =\n  fst (Gauss_Jordan_in_ij_det_P A i j) * det P", "show ?thesis"], ["proof (prove)\nusing this:\n  det (fst (Gauss_Jordan_in_ij_PA (P, A) i j)) =\n  fst (Gauss_Jordan_in_ij_det_P A i j) * det P\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n    det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))", ".."], ["proof (state)\nthis:\n  fst (Gauss_Jordan_in_ij_det_P A i j) * det P =\n  det (fst (Gauss_Jordan_in_ij_PA (P, A) i j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_fst_Gauss_Jordan_column_k_PA_eq_fst_Gauss_Jordan_column_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_column_k_det_P (det P,i,A) k) = det (fst (Gauss_Jordan_column_k_PA (P,i,A) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_det_P (det P, i, A) k) =\n    det (fst (Gauss_Jordan_column_k_PA (P, i, A) k))", "unfolding Gauss_Jordan_column_k_det_P_def Gauss_Jordan_column_k_PA_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (det P, i, A)\n         else (fst (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)) *\n               det P,\n               i + 1,\n               snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)))) =\n    det (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                     A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                 i = nrows A\n              then (P, i, A)\n              else (fst (Gauss_Jordan_in_ij_PA (P, A)\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k)),\n                    i + 1,\n                    snd (Gauss_Jordan_in_ij_PA (P, A)\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k)))))", "using det_fst_Gauss_Jordan_in_ij_PA_eq_fst_Gauss_Jordan_in_ij_det_P"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_in_ij_det_P ?A ?i ?j) * det ?P =\n  det (fst (Gauss_Jordan_in_ij_PA (?P, ?A) ?i ?j))\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (det P, i, A)\n         else (fst (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)) *\n               det P,\n               i + 1,\n               snd (Gauss_Jordan_in_ij_det_P A (mod_type_class.from_nat i)\n                     (mod_type_class.from_nat k)))) =\n    det (fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                     A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                 i = nrows A\n              then (P, i, A)\n              else (fst (Gauss_Jordan_in_ij_PA (P, A)\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k)),\n                    i + 1,\n                    snd (Gauss_Jordan_in_ij_PA (P, A)\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k)))))", "by auto"], ["", "lemma fst_snd_Gauss_Jordan_column_k_det_P_eq_fst_snd_Gauss_Jordan_column_k_PA:\nshows \"fst (snd (Gauss_Jordan_column_k_det_P (n,i,A) k)) = fst (snd (Gauss_Jordan_column_k_PA (P,i,A) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P (n, i, A) k)) =\n    fst (snd (Gauss_Jordan_column_k_PA (P, i, A) k))", "unfolding Gauss_Jordan_column_k_det_P_def Gauss_Jordan_column_k_PA_def Let_def snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                     A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                 i = nrows A\n              then (n, i, A)\n              else (fst (Gauss_Jordan_in_ij_det_P A\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k)) *\n                    n,\n                    i + 1,\n                    snd (Gauss_Jordan_in_ij_det_P A\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k))))) =\n    fst (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                     A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n                 i = nrows A\n              then (P, i, A)\n              else (fst (Gauss_Jordan_in_ij_PA (P, A)\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k)),\n                    i + 1,\n                    snd (Gauss_Jordan_in_ij_PA (P, A)\n                          (mod_type_class.from_nat i)\n                          (mod_type_class.from_nat k)))))", "by auto"], ["", "text\\<open>The way of proving the following lemma is very similar to the demonstration of @{thm \"rref_and_index_Gauss_Jordan_upt_k\"}.\\<close>"], ["", "lemma foldl_Gauss_Jordan_column_k_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows det_fst_Gauss_Jordan_upt_k_PA_eq_fst_Gauss_Jordan_upt_k_det_P: \"fst (Gauss_Jordan_upt_k_det_P A k) = det (fst (Gauss_Jordan_upt_k_PA A k))\"\nand snd_Gauss_Jordan_upt_k_det_P_is_snd_Gauss_Jordan_upt_k_PA: \"snd (Gauss_Jordan_upt_k_det_P A k) = snd (Gauss_Jordan_upt_k_PA A k)\"\nand fst_snd_foldl_Gauss_det_P_PA: \"fst (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k])) = fst (snd (foldl Gauss_Jordan_column_k_PA (mat 1, 0, A) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_upt_k_det_P A k) =\n    det (fst (Gauss_Jordan_upt_k_PA A k)) &&&\n    snd (Gauss_Jordan_upt_k_det_P A k) = snd (Gauss_Jordan_upt_k_PA A k) &&&\n    fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "proof (induct k)"], ["proof (state)\ngoal (6 subgoals):\n 1. fst (Gauss_Jordan_upt_k_det_P A 0) =\n    det (fst (Gauss_Jordan_upt_k_PA A 0))\n 2. snd (Gauss_Jordan_upt_k_det_P A 0) = snd (Gauss_Jordan_upt_k_PA A 0)\n 3. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))\n 4. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 5. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 6. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. fst (Gauss_Jordan_upt_k_det_P A 0) =\n    det (fst (Gauss_Jordan_upt_k_PA A 0))\n 2. snd (Gauss_Jordan_upt_k_det_P A 0) = snd (Gauss_Jordan_upt_k_PA A 0)\n 3. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))\n 4. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 5. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 6. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "show \"fst (Gauss_Jordan_upt_k_det_P A 0) = det (fst (Gauss_Jordan_upt_k_PA A 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_upt_k_det_P A 0) =\n    det (fst (Gauss_Jordan_upt_k_PA A 0))", "unfolding Gauss_Jordan_upt_k_det_P_def Gauss_Jordan_upt_k_PA_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc 0]),\n         snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                    [0..<Suc 0]))) =\n    det (fst (fst (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                    [0..<Suc 0]),\n              snd (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                         [0..<Suc 0]))))", "by (simp, metis det_fst_Gauss_Jordan_column_k_PA_eq_fst_Gauss_Jordan_column_k_det_P det_I)"], ["proof (state)\nthis:\n  fst (Gauss_Jordan_upt_k_det_P A 0) = det (fst (Gauss_Jordan_upt_k_PA A 0))\n\ngoal (5 subgoals):\n 1. snd (Gauss_Jordan_upt_k_det_P A 0) = snd (Gauss_Jordan_upt_k_PA A 0)\n 2. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 4. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 5. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "show \"snd (Gauss_Jordan_upt_k_det_P A 0) = snd (Gauss_Jordan_upt_k_PA A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_upt_k_det_P A 0) = snd (Gauss_Jordan_upt_k_PA A 0)", "unfolding Gauss_Jordan_upt_k_det_P_def Gauss_Jordan_upt_k_PA_def Let_def snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    snd (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (Gauss_Jordan_column_k_det_P (1::'a, 0, A) 0)) =\n    snd (snd (Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) 0))", "using snd_Gauss_Jordan_column_k_det_P_is_snd_Gauss_Jordan_column_k_PA"], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_column_k_det_P (?n, ?i, ?A) ?k) =\n  snd (Gauss_Jordan_column_k_PA (?P, ?i, ?A) ?k)\n\ngoal (1 subgoal):\n 1. snd (snd (Gauss_Jordan_column_k_det_P (1::'a, 0, A) 0)) =\n    snd (snd (Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) 0))", "by metis"], ["proof (state)\nthis:\n  snd (Gauss_Jordan_upt_k_det_P A 0) = snd (Gauss_Jordan_upt_k_PA A 0)\n\ngoal (4 subgoals):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 4. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "show \"fst (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc 0])) = fst (snd (foldl Gauss_Jordan_column_k_PA (mat 1, 0, A) [0..<Suc 0]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))", "unfolding Gauss_Jordan_column_k_det_P_def Gauss_Jordan_column_k_PA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc 0])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc 0]))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P (1::'a, 0, A) 0)) =\n    fst (snd (Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) 0))", "using fst_snd_Gauss_Jordan_column_k_det_P_eq_fst_snd_Gauss_Jordan_column_k_PA"], ["proof (prove)\nusing this:\n  fst (snd (Gauss_Jordan_column_k_det_P (?n, ?i, ?A) ?k)) =\n  fst (snd (Gauss_Jordan_column_k_PA (?P, ?i, ?A) ?k))\n\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P (1::'a, 0, A) 0)) =\n    fst (snd (Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) 0))", "by metis"], ["proof (state)\nthis:\n  fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc 0])) =\n  fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) [0..<Suc 0]))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "fix k"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "assume hyp1: \"fst (Gauss_Jordan_upt_k_det_P A k) = det (fst (Gauss_Jordan_upt_k_PA A k))\"\nand hyp2: \"snd (Gauss_Jordan_upt_k_det_P A k) = snd (Gauss_Jordan_upt_k_PA A k)\"\nand hyp3: \"fst (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k])) = fst (snd (foldl Gauss_Jordan_column_k_PA (mat 1, 0, A) [0..<Suc k]))\""], ["proof (state)\nthis:\n  fst (Gauss_Jordan_upt_k_det_P A k) = det (fst (Gauss_Jordan_upt_k_PA A k))\n  snd (Gauss_Jordan_upt_k_det_P A k) = snd (Gauss_Jordan_upt_k_PA A k)\n  fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])) =\n  fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) [0..<Suc k]))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "have list_rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "have det_mat_nn: \"det (mat 1::'a^'n::{mod_type}^'n::{mod_type}) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mat (1::'a)) = (1::'a)", "using det_I"], ["proof (prove)\nusing this:\n  det (mat (1::?'a)) = (1::?'a)\n\ngoal (1 subgoal):\n 1. det (mat (1::'a)) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  det (mat (1::'a)) = (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "define f where \"f = foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k]\""], ["proof (state)\nthis:\n  f = foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k]\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "define g where \"g = foldl Gauss_Jordan_column_k_PA (mat 1, 0, A) [0..<Suc k]\""], ["proof (state)\nthis:\n  g = foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) [0..<Suc k]\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "have f_rw: \"f = (fst f, fst (snd f), snd(snd f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = (fst f, fst (snd f), snd (snd f))", "by simp"], ["proof (state)\nthis:\n  f = (fst f, fst (snd f), snd (snd f))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "have g_rw: \"g = (fst g, fst (snd g), snd(snd g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = (fst g, fst (snd g), snd (snd g))", "by simp"], ["proof (state)\nthis:\n  g = (fst g, fst (snd g), snd (snd g))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "have fst_snd: \"fst (snd f) = fst (snd g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd f) = fst (snd g)", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "using hyp3"], ["proof (prove)\nusing this:\n  fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])) =\n  fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "unfolding Gauss_Jordan_upt_k_det_P_def Gauss_Jordan_upt_k_PA_def Let_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])) =\n  fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "."], ["proof (state)\nthis:\n  fst (snd f) = fst (snd g)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "have snd_snd: \"snd (snd f) = snd (snd g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd f) = snd (snd g)", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    snd (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "using hyp2"], ["proof (prove)\nusing this:\n  snd (Gauss_Jordan_upt_k_det_P A k) = snd (Gauss_Jordan_upt_k_PA A k)\n\ngoal (1 subgoal):\n 1. snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    snd (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "unfolding Gauss_Jordan_upt_k_det_P_def Gauss_Jordan_upt_k_PA_def Let_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])) =\n  snd (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    snd (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "."], ["proof (state)\nthis:\n  snd (snd f) = snd (snd g)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "have fst_det: \"fst f = det (fst g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst f = det (fst g)", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k]) =\n    det (fst (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "using hyp1"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_upt_k_det_P A k) = det (fst (Gauss_Jordan_upt_k_PA A k))\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k]) =\n    det (fst (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "unfolding Gauss_Jordan_upt_k_det_P_def Gauss_Jordan_upt_k_PA_def Let_def fst_conv"], ["proof (prove)\nusing this:\n  fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k]) =\n  det (fst (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k]) =\n    det (fst (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k]))", "by simp"], ["proof (state)\nthis:\n  fst f = det (fst g)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "show \"fst (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc k])) = fst (snd (foldl Gauss_Jordan_column_k_PA (mat 1, 0, A) [0..<Suc k])) \\<Longrightarrow>\n        fst (Gauss_Jordan_upt_k_det_P A (Suc k)) = det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k])) \\<Longrightarrow>\n    fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n    det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))", "unfolding Gauss_Jordan_upt_k_det_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k])) \\<Longrightarrow>\n    fst (let foldl =\n               foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                [0..<Suc (Suc k)]\n         in (fst foldl, snd (snd foldl))) =\n    det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))", "unfolding Gauss_Jordan_upt_k_PA_def Let_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k])) \\<Longrightarrow>\n    fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n          [0..<Suc (Suc k)]) =\n    det (fst (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc (Suc k)]))", "unfolding list_rw foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k])) \\<Longrightarrow>\n    fst (foldl Gauss_Jordan_column_k_det_P\n          (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])\n          [Suc k]) =\n    det (fst (foldl Gauss_Jordan_column_k_PA\n               (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                 [0..<Suc k])\n               [Suc k]))", "unfolding List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc k])) \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k_det_P\n          (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])\n          (Suc k)) =\n    det (fst (Gauss_Jordan_column_k_PA\n               (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                 [0..<Suc k])\n               (Suc k)))", "unfolding f_def[symmetric] g_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd f) = fst (snd g) \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k_det_P f (Suc k)) =\n    det (fst (Gauss_Jordan_column_k_PA g (Suc k)))", "apply (subst f_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd f) = fst (snd g) \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k_det_P (fst f, fst (snd f), snd (snd f))\n          (Suc k)) =\n    det (fst (Gauss_Jordan_column_k_PA g (Suc k)))", "apply (subst g_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd f) = fst (snd g) \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k_det_P (fst f, fst (snd f), snd (snd f))\n          (Suc k)) =\n    det (fst (Gauss_Jordan_column_k_PA (fst g, fst (snd g), snd (snd g))\n               (Suc k)))", "unfolding fst_snd snd_snd fst_det"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd g) = fst (snd g) \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k_det_P (det (fst g), fst (snd g), snd (snd g))\n          (Suc k)) =\n    det (fst (Gauss_Jordan_column_k_PA (fst g, fst (snd g), snd (snd g))\n               (Suc k)))", "by (rule det_fst_Gauss_Jordan_column_k_PA_eq_fst_Gauss_Jordan_column_k_det_P)"], ["proof (state)\nthis:\n  fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])) =\n  fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n             [0..<Suc k])) \\<Longrightarrow>\n  fst (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n  det (fst (Gauss_Jordan_upt_k_PA A (Suc k)))\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n                         snd (Gauss_Jordan_upt_k_PA A (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "show \"snd (Gauss_Jordan_upt_k_det_P A (Suc k)) = snd (Gauss_Jordan_upt_k_PA A (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n    snd (Gauss_Jordan_upt_k_PA A (Suc k))", "unfolding Gauss_Jordan_upt_k_det_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (let foldl =\n               foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                [0..<Suc (Suc k)]\n         in (fst foldl, snd (snd foldl))) =\n    snd (Gauss_Jordan_upt_k_PA A (Suc k))", "unfolding Gauss_Jordan_upt_k_PA_def Let_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc (Suc k)]),\n         snd (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                    [0..<Suc (Suc k)]))) =\n    snd (fst (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc (Suc k)]),\n         snd (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                    [0..<Suc (Suc k)])))", "unfolding list_rw foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (foldl Gauss_Jordan_column_k_det_P\n               (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])\n               [Suc k]),\n         snd (snd (foldl Gauss_Jordan_column_k_det_P\n                    (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                      [0..<Suc k])\n                    [Suc k]))) =\n    snd (fst (foldl Gauss_Jordan_column_k_PA\n               (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                 [0..<Suc k])\n               [Suc k]),\n         snd (snd (foldl Gauss_Jordan_column_k_PA\n                    (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                      [0..<Suc k])\n                    [Suc k])))", "unfolding List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (Gauss_Jordan_column_k_det_P\n               (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])\n               (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_det_P\n                    (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                      [0..<Suc k])\n                    (Suc k)))) =\n    snd (fst (Gauss_Jordan_column_k_PA\n               (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                 [0..<Suc k])\n               (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_PA\n                    (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                      [0..<Suc k])\n                    (Suc k))))", "unfolding f_def[symmetric] g_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (Gauss_Jordan_column_k_det_P f (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_det_P f (Suc k)))) =\n    snd (fst (Gauss_Jordan_column_k_PA g (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_PA g (Suc k))))", "apply (subst f_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (Gauss_Jordan_column_k_det_P (fst f, fst (snd f), snd (snd f))\n               (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_det_P f (Suc k)))) =\n    snd (fst (Gauss_Jordan_column_k_PA g (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_PA g (Suc k))))", "apply (subst g_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (Gauss_Jordan_column_k_det_P (fst f, fst (snd f), snd (snd f))\n               (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_det_P f (Suc k)))) =\n    snd (fst (Gauss_Jordan_column_k_PA (fst g, fst (snd g), snd (snd g))\n               (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_PA g (Suc k))))", "unfolding fst_snd snd_snd fst_det"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (Gauss_Jordan_column_k_det_P\n               (det (fst g), fst (snd g), snd (snd g)) (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_det_P f (Suc k)))) =\n    snd (fst (Gauss_Jordan_column_k_PA (fst g, fst (snd g), snd (snd g))\n               (Suc k)),\n         snd (snd (Gauss_Jordan_column_k_PA g (Suc k))))", "by (metis fst_snd prod.collapse snd_Gauss_Jordan_column_k_det_P_is_snd_Gauss_Jordan_column_k_PA snd_eqD snd_snd)"], ["proof (state)\nthis:\n  snd (Gauss_Jordan_upt_k_det_P A (Suc k)) =\n  snd (Gauss_Jordan_upt_k_PA A (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>fst (Gauss_Jordan_upt_k_det_P A k) =\n                det (fst (Gauss_Jordan_upt_k_PA A k));\n        snd (Gauss_Jordan_upt_k_det_P A k) =\n        snd (Gauss_Jordan_upt_k_PA A k);\n        fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n                   [0..<Suc k])) =\n        fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                   [0..<Suc k]))\\<rbrakk>\n       \\<Longrightarrow> fst (snd (foldl Gauss_Jordan_column_k_det_P\n                                    (1::'a, 0, A) [0..<Suc (Suc k)])) =\n                         fst (snd (foldl Gauss_Jordan_column_k_PA\n                                    (mat (1::'a), 0, A) [0..<Suc (Suc k)]))", "show \"fst (snd (foldl Gauss_Jordan_column_k_det_P (1, 0, A) [0..<Suc (Suc k)])) = fst (snd (foldl Gauss_Jordan_column_k_PA (mat 1, 0, A) [0..<Suc (Suc k)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc (Suc k)])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc (Suc k)]))", "unfolding Gauss_Jordan_upt_k_det_P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc (Suc k)])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc (Suc k)]))", "unfolding Gauss_Jordan_upt_k_PA_def Let_def fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n               [0..<Suc (Suc k)])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n               [0..<Suc (Suc k)]))", "unfolding list_rw foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (foldl Gauss_Jordan_column_k_det_P\n               (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])\n               [Suc k])) =\n    fst (snd (foldl Gauss_Jordan_column_k_PA\n               (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                 [0..<Suc k])\n               [Suc k]))", "unfolding List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P\n               (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A) [0..<Suc k])\n               (Suc k))) =\n    fst (snd (Gauss_Jordan_column_k_PA\n               (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n                 [0..<Suc k])\n               (Suc k)))", "unfolding f_def[symmetric] g_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P f (Suc k))) =\n    fst (snd (Gauss_Jordan_column_k_PA g (Suc k)))", "apply (subst f_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P (fst f, fst (snd f), snd (snd f))\n               (Suc k))) =\n    fst (snd (Gauss_Jordan_column_k_PA g (Suc k)))", "apply (subst g_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P (fst f, fst (snd f), snd (snd f))\n               (Suc k))) =\n    fst (snd (Gauss_Jordan_column_k_PA (fst g, fst (snd g), snd (snd g))\n               (Suc k)))", "unfolding fst_snd snd_snd fst_det"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (snd (Gauss_Jordan_column_k_det_P\n               (det (fst g), fst (snd g), snd (snd g)) (Suc k))) =\n    fst (snd (Gauss_Jordan_column_k_PA (fst g, fst (snd g), snd (snd g))\n               (Suc k)))", "by (rule fst_snd_Gauss_Jordan_column_k_det_P_eq_fst_snd_Gauss_Jordan_column_k_PA)"], ["proof (state)\nthis:\n  fst (snd (foldl Gauss_Jordan_column_k_det_P (1::'a, 0, A)\n             [0..<Suc (Suc k)])) =\n  fst (snd (foldl Gauss_Jordan_column_k_PA (mat (1::'a), 0, A)\n             [0..<Suc (Suc k)]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_Gauss_Jordan_det_P_is_Gauss_Jordan:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"snd (Gauss_Jordan_det_P A) = (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_det_P A) = Gauss_Jordan A", "unfolding Gauss_Jordan_det_P_def Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Gauss_Jordan_upt_k_det_P A (ncols A - 1)) =\n    Gauss_Jordan_upt_k A (ncols A - 1)", "unfolding snd_Gauss_Jordan_upt_k_det_P_is_snd_Gauss_Jordan_upt_k_PA \nsnd_Gauss_Jordan_upt_k_PA"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_upt_k A (ncols A - 1) = Gauss_Jordan_upt_k A (ncols A - 1)", ".."], ["", "lemma det_snd_Gauss_Jordan_det_P[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"det (snd (Gauss_Jordan_det_P A)) = prod (\\<lambda>i. (snd (Gauss_Jordan_det_P A))$i$i) (UNIV:: 'n set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (snd (Gauss_Jordan_det_P A)) =\n    (\\<Prod>i\\<in>UNIV. snd (Gauss_Jordan_det_P A) $ i $ i)", "unfolding snd_Gauss_Jordan_det_P_is_Gauss_Jordan det_Gauss_Jordan"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. Gauss_Jordan A $ i $ i) =\n    (\\<Prod>i\\<in>UNIV. Gauss_Jordan A $ i $ i)", ".."], ["", "lemma det_fst_Gauss_Jordan_PA_eq_fst_Gauss_Jordan_det_P:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_det_P A) = det (fst (Gauss_Jordan_PA A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_det_P A) = det (fst (Gauss_Jordan_PA A))", "by (unfold Gauss_Jordan_det_P_def Gauss_Jordan_PA_def, rule det_fst_Gauss_Jordan_upt_k_PA_eq_fst_Gauss_Jordan_upt_k_det_P)"], ["", "lemma fst_Gauss_Jordan_det_P_not_0:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"fst (Gauss_Jordan_det_P A) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_det_P A) \\<noteq> (0::'a)", "unfolding det_fst_Gauss_Jordan_PA_eq_fst_Gauss_Jordan_det_P"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (fst (Gauss_Jordan_PA A)) \\<noteq> (0::'a)", "by (metis (mono_tags) det_I det_mul invertible_fst_Gauss_Jordan_PA matrix_inv_right mult_zero_left zero_neq_one)"], ["", "lemma det_code_equation[code_unfold]:\nfixes A::\"'a::{field}^'n::{mod_type}^'n::{mod_type}\"\nshows \"det A = (let A' = Gauss_Jordan_det_P A in prod (\\<lambda>i. (snd (A'))$i$i) (UNIV::'n set)/(fst (A')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (let A' = Gauss_Jordan_det_P A\n     in (\\<Prod>i\\<in>UNIV. snd A' $ i $ i) / fst A')", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det A =\n    (\\<Prod>i\\<in>UNIV. snd (Gauss_Jordan_det_P A) $ i $ i) /\n    fst (Gauss_Jordan_det_P A)", "using det_Gauss_Jordan_det_P[of A]"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_det_P A) * det A = det (snd (Gauss_Jordan_det_P A))\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Prod>i\\<in>UNIV. snd (Gauss_Jordan_det_P A) $ i $ i) /\n    fst (Gauss_Jordan_det_P A)", "unfolding det_snd_Gauss_Jordan_det_P"], ["proof (prove)\nusing this:\n  fst (Gauss_Jordan_det_P A) * det A =\n  (\\<Prod>i\\<in>UNIV. snd (Gauss_Jordan_det_P A) $ i $ i)\n\ngoal (1 subgoal):\n 1. det A =\n    (\\<Prod>i\\<in>UNIV. snd (Gauss_Jordan_det_P A) $ i $ i) /\n    fst (Gauss_Jordan_det_P A)", "by (simp add: fst_Gauss_Jordan_det_P_not_0 nonzero_eq_divide_eq ac_simps)"], ["", "end"]]}