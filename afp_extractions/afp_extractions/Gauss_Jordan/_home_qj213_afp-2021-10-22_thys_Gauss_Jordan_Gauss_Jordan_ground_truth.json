{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/Gauss_Jordan.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma Gauss_Jordan_in_ij_unfold:\n  assumes \"\\<exists>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\"\n  obtains n :: \"'n::{finite, wellorder}\" and interchange_A and A'\n  where\n    \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) = n\"\n    and \"A $ n $ j \\<noteq> 0\"\n    and \"i \\<le> n\"\n    and \"interchange_A = interchange_rows A i n\"\n    and \"A' = mult_row interchange_A i (1 / interchange_A $ i $ j)\"\n    and \"Gauss_Jordan_in_ij A i j = vec_lambda (\\<lambda>s. if s = i then A' $ s \n      else (row_add A' s i (- (interchange_A $ s $ j))) $ s)\"", "lemma greatest_plus_one_eq_0:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 = 0\"", "lemma from_nat_to_nat_greatest:\n  fixes A::\"'a::{zero}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"from_nat (Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A))) = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\"", "lemma greatest_less_zero_row:\n  fixes A::\"'a::{one, zero}^'n::{mod_type}^'m::{finite,one,plus,linorder}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i: \"is_zero_row_upt_k i k A\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\"", "lemma rref_suc_if_zero_below_greatest:\n  fixes A::\"'a::{one, zero}^'n::{mod_type}^'m::{finite,one,plus,linorder}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\" (*This premisse is necessary to assure the existence of the Greatest*)\n  and all_zero_below_greatest: \"\\<forall>a. a>(GREATEST m. \\<not> is_zero_row_upt_k m k A) \\<longrightarrow> is_zero_row_upt_k a (Suc k) A\"\n  shows \"reduced_row_echelon_form_upt_k A (Suc k)\"", "lemma rref_suc_if_all_rows_not_zero:\n  fixes A::\"'a::{one, zero}^'n::{mod_type}^'m::{finite,one,plus,linorder}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and all_not_zero: \"\\<forall>n. \\<not> is_zero_row_upt_k n k A\"\n  shows \"reduced_row_echelon_form_upt_k A (Suc k)\"", "lemma greatest_ge_nonzero_row:\n  fixes A::\"'a::{zero}^'n::{mod_type}^'m::{finite,linorder}\"\n  assumes \"\\<not> is_zero_row_upt_k i k A\"\n  shows \"i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\"", "lemma greatest_ge_nonzero_row':\n  fixes A::\"'a::{zero, one}^'n::{mod_type}^'m::{finite, linorder, one, plus}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and i: \"i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"\\<not> is_zero_row_upt_k i k A\"", "lemma Gauss_Jordan_in_ij_1:\n  fixes A::\"'a::{field}^'m^'n::{finite, ord, wellorder}\"\n  assumes ex: \"\\<exists>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\"\n  shows \"(Gauss_Jordan_in_ij A i j) $ i $ j = 1\"", "lemma Gauss_Jordan_in_ij_0:\n  fixes A::\"'a::{field}^'m^'n::{finite, ord, wellorder}\"\n  assumes ex: \"\\<exists>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\" and a: \"a \\<noteq> i\"\n  shows \"(Gauss_Jordan_in_ij A i j) $ a $ j = 0\"", "lemma Gauss_Jordan_in_ij_preserves_previous_elements:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_a: \"\\<not> is_zero_row_upt_k a k A\"\n  and exists_m: \"\\<exists>m. A $ m $ (from_nat k) \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> m\"\n  and Greatest_plus_1: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\"\n  and j_le_k: \"to_nat j < k\"\n  shows \"Gauss_Jordan_in_ij A ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) (from_nat k) $ i $ j = A $ i $ j\"", "lemma Gauss_Jordan_in_ij_preserves_previous_elements':\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes all_zero: \"\\<forall>n. is_zero_row_upt_k n k A\"\n  and j_le_k: \"to_nat j < k\"\n  and A_nk_not_zero: \"A $ n $ (from_nat k) \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ j = A $ i $ j\"", "lemma is_zero_after_Gauss:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes zero_a: \"is_zero_row_upt_k a k A\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and r: \"reduced_row_echelon_form_upt_k A k\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k a k (Gauss_Jordan_in_ij A ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) (from_nat k))\"", "lemma all_zero_imp_Gauss_Jordan_column_not_zero_in_row_0:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes all_zero: \"\\<forall>n. is_zero_row_upt_k n k A\"\n  and not_zero_i: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and Amk_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"i=0\"", "lemma condition_1_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes zero_column_k: \"\\<forall>m\\<ge>from_nat 0. A $ m $ from_nat k = 0\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  shows \"is_zero_row_upt_k j (Suc k) A\"", "lemma condition_1_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes j_not_zero: \"j \\<noteq> 0\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\" \n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k j (Suc k) (Gauss_Jordan_in_ij A (from_nat 0) (from_nat k))\"", "lemma condition_1_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B \\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_less_j: \"i<j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\"\n  shows \"is_zero_row_upt_k j (Suc k) A\"", "lemma condition_1_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B \\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\" \n  and i_less_j: \"i<j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"is_zero_row_upt_k j (Suc k) A\"", "lemma condition_1_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B \\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\" \n  and i_less_j: \"i<j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k j (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k))\"", "lemma condition_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\" and i_less_j: \"i < j\"\n  shows \"is_zero_row_upt_k j (Suc k) B\"", "lemma condition_2_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and all_zero_k: \"\\<forall>m. A $ m $ from_nat k = 0\"\n  shows \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\"", "lemma condition_2_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ (LEAST ka. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ ka \\<noteq> 0) = 1\"", "lemma condition_2_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  shows \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\"", "lemma condition_2_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\"", "lemma condition_2_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_noteq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $\n  (LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) = 1\"", "lemma condition_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  shows \"B $ i $ (LEAST k. B $ i $ k \\<noteq> 0) = 1\"", "lemma condition_3_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and all_zero_k: \"\\<forall>m. A $ m $ from_nat k = 0\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\"", "lemma condition_3_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_notzero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"(LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ n \\<noteq> 0) < (LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ (i + 1) $ n \\<noteq> 0)\"", "lemma condition_3_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\"", "lemma condition_3_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\" and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\"", "lemma condition_3_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"(LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0)\n  < (LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i + 1) $ n \\<noteq> 0)\"", "lemma condition_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  shows \"(LEAST n. B $ i $ n \\<noteq> 0) < (LEAST n. B $ (i + 1) $ n \\<noteq> 0)\"", "lemma condition_4_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and all_zero_k: \"\\<forall>m. A $ m $ from_nat k = 0\"\n  shows \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\"", "lemma condition_4_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A 0 (from_nat k) $ j $ (LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ n \\<noteq> 0) = 0\"", "lemma condition_4_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and not_zero_m: \" \\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\" \n  shows \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\"", "lemma condition_4_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\"", "lemma condition_4_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ j $ \n  (LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0) = 0\"", "lemma condition_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  shows \"B $ j $ (LEAST n. B $ i $ n \\<noteq> 0) = 0\"", "lemma reduced_row_echelon_form_upt_k_Gauss_Jordan_column_k:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  shows \"reduced_row_echelon_form_upt_k B (Suc k)\"", "lemma foldl_Gauss_condition_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and \"\\<forall>m\\<ge>0. A $ m $ from_nat k = 0\"\n  shows \"is_zero_row_upt_k m (Suc k) A\"", "lemma foldl_Gauss_condition_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\"", "lemma foldl_Gauss_condition_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"           \n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  and \"\\<not> is_zero_row_upt_k ma (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\"\n  shows \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))) = 0\"", "lemma foldl_Gauss_condition_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes rref_A: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_a:\"\\<not> is_zero_row_upt_k a k A\"\n  and all_zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  shows \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\"", "lemma foldl_Gauss_condition_6:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"nrows A = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))\"", "lemma foldl_Gauss_condition_8:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and not_zero_m: \" \\<not> is_zero_row_upt_k m k A\" \n  and A_ma_k: \" A $ ma $ from_nat k \\<noteq> 0\" \n  and ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k))\"", "lemma foldl_Gauss_condition_9:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and rref_A: \"reduced_row_echelon_form_upt_k A k\"\n  assumes not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and suc_greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  to_nat(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k)))\"", "lemma rref_and_index_Gauss_Jordan_upt_k:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes  \"k < ncols A\"\n  shows rref_Gauss_Jordan_upt_k: \"reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k)\"\n  and snd_Gauss_Jordan_upt_k: \n  \"foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m. is_zero_row_upt_k m (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) then 0\n  else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) + 1,\n  snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\"", "lemma independent_not_zero_rows_rref:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"vec.independent {row i A |i. row i A \\<noteq> 0}\"", "lemma invertible_row_add_iterate:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes n: \"n<nrows A\"\n  shows \"\\<exists>P. invertible P \\<and> row_add_iterate A n i j = P**A\"", "lemma row_add_iterate_preserves_greater_than_n:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes n: \"n<nrows A\"\n  and a: \"to_nat a > n\"\n  shows \"(row_add_iterate A n i j) $ a $ b = A $ a $ b\"", "lemma row_add_iterate_preserves_pivot_row:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes n: \"n<nrows A\"\n  and a: \"to_nat i \\<le> n\"\n  shows \"(row_add_iterate A n i j) $ i $ b = A $ i $ b\"", "lemma row_add_iterate_eq_row_add:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes a_not_i: \"a \\<noteq> i\"\n  and n: \"n<nrows A\"\n  and \"to_nat a \\<le> n\"\n  shows \"(row_add_iterate A n i j) $ a $ b = (row_add A a i (- A $ a $ j)) $ a $ b\"", "lemma row_add_iterate_eq_Gauss_Jordan_in_ij:\n  fixes A::\"'a::{field}^'n^'m::{mod_type}\" and i::\"'m\" and j::\"'n\"\n  defines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\n  shows \"row_add_iterate A' (nrows A - 1) i j = Gauss_Jordan_in_ij A i j\"", "lemma invertible_Gauss_Jordan_column_k:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\" and k::nat\n  shows \"\\<exists>P. invertible P \\<and> (snd (Gauss_Jordan_column_k (i,A) k)) = P**A\"", "lemma invertible_Gauss_Jordan_up_to_k:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"\\<exists>P. invertible P \\<and> (Gauss_Jordan_upt_k A k) = P**A\"", "lemma inj_index_independent_rows:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and x: \"row x A \\<in> {row i A |i. row i A \\<noteq> 0}\"\n  and eq: \"A $ x = A $ y\"\n  shows \"x = y\"", "lemma invertible_Gauss_Jordan:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"\\<exists>P. invertible P \\<and> (Gauss_Jordan A) = P**A\"", "lemma Gauss_Jordan:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"\\<exists>P. invertible P \\<and> (Gauss_Jordan A) = P**A \\<and> reduced_row_echelon_form (Gauss_Jordan A)\"", "lemma rref_rank:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"rank A = card {row i A |i. row i A \\<noteq> 0}\"", "lemma column_leading_coefficient_component_eq:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and v: \"v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\" \n  and vx: \"v $ x \\<noteq> 0\"\n  and vy: \"v $ y \\<noteq> 0\"\n  shows \"x = y\"", "lemma column_leading_coefficient_component_1:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and v: \"v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\" \n  and vx: \"v $ x \\<noteq> 0\"\n  shows \"v $ x = 1\"", "lemma column_leading_coefficient_component_0:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and v: \"v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\" \n  and vx: \"v $ x \\<noteq> 0\"\n  and x_not_y: \"x \\<noteq> y\"\n  shows \"v $ y = 0\"", "lemma rref_col_rank:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{mod_type}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"col_rank A = card {column (LEAST n. A $ i $ n \\<noteq> 0) A | i. row i A \\<noteq> 0}\"", "lemma rref_row_rank:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"row_rank A = card {column (LEAST n. A $ i $ n \\<noteq> 0) A | i. row i A \\<noteq> 0}\"", "lemma row_rank_eq_col_rank_rref:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{mod_type}\"\nassumes r: \"reduced_row_echelon_form A\"\nshows \"row_rank A = col_rank A\"", "lemma row_rank_eq_col_rank:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"row_rank A = col_rank A\"", "theorem rank_col_rank:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = col_rank A\"", "theorem rank_eq_dim_image:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = vec.dim (range (\\<lambda>x. A *v x))\"", "theorem rank_eq_dim_col_space:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = vec.dim (col_space A)\"", "lemma rank_transpose: \n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows  \"rank (transpose A) = rank A\"", "lemma rank_le_nrows:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A \\<le> nrows A\"", "lemma rank_le_ncols:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A \\<le> ncols A\"", "lemma rank_Gauss_Jordan:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = rank (Gauss_Jordan A)\"", "lemma A_0_imp_Gauss_Jordan_0:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"A=0\"\n  shows \"Gauss_Jordan A = 0\"", "lemma rank_0: \"rank 0 = 0\"", "lemma rank_greater_zero:\n  assumes \"A \\<noteq> 0\"\n  shows \"rank A > 0\"", "lemma Gauss_Jordan_not_0:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes \"A \\<noteq> 0\"\nshows \"Gauss_Jordan A \\<noteq> 0\"", "lemma rank_eq_suc_to_nat_greatest:\nassumes A_not_0: \"A \\<noteq> 0\"\nshows \"rank A = to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) + 1\"", "lemma rank_less_row_i_imp_i_is_zero:\nassumes rank_less_i: \"to_nat i \\<ge> rank A\"\nshows \"Gauss_Jordan A $ i = 0\"", "lemma rank_Gauss_Jordan_eq:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = (let A'=(Gauss_Jordan A) in card {row i A' |i. row i A' \\<noteq> 0})\"", "lemma [code abstract]: \nshows \"vec_nth (Gauss_Jordan_in_ij A i j) = (let n = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n); \n  interchange_A = (interchange_rows A i n); \n  A' = mult_row interchange_A i (1/interchange_A$i$j) in \n  (% s. if s=i then A' $ s else (row_add A' s i (-(interchange_A$s$j))) $ s))\"", "lemma rank_Gauss_Jordan_code[code]:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = (if A = 0 then 0 else (let A'=(Gauss_Jordan A) in to_nat (GREATEST a. row a A' \\<noteq> 0) + 1))\"", "lemma dim_null_space[code_unfold]:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (null_space A) = (vec.dimension TYPE('a) TYPE('cols)) - rank (A)\"", "lemma rank_eq_dim_col_space'[code_unfold]:\n fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n shows \"vec.dim (col_space A) = rank A\"", "lemma dim_left_null_space[code_unfold]:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (left_null_space A) = (vec.dimension TYPE('a) TYPE('rows)) - rank (A)\"", "lemmas rank_col_rank[symmetric, code_unfold]", "lemmas rank_def[symmetric, code_unfold]", "lemmas row_rank_def[symmetric, code_unfold]", "lemmas col_rank_def[symmetric, code_unfold]", "lemmas DIM_cart[code_unfold]", "lemmas DIM_real[code_unfold]"], "translations": [["", "lemma Gauss_Jordan_in_ij_unfold:\n  assumes \"\\<exists>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\"\n  obtains n :: \"'n::{finite, wellorder}\" and interchange_A and A'\n  where\n    \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) = n\"\n    and \"A $ n $ j \\<noteq> 0\"\n    and \"i \\<le> n\"\n    and \"interchange_A = interchange_rows A i n\"\n    and \"A' = mult_row interchange_A i (1 / interchange_A $ i $ j)\"\n    and \"Gauss_Jordan_in_ij A i j = vec_lambda (\\<lambda>s. if s = i then A' $ s \n      else (row_add A' s i (- (interchange_A $ s $ j))) $ s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n", "obtain m where Anj: \"A $ m $ j \\<noteq> 0 \\<and> i \\<le> m\""], ["proof (prove)\nusing this:\n  \\<exists>n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        A $ m $ j \\<noteq> (0::'a) \\<and> i \\<le> m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  A $ m $ j \\<noteq> (0::'a) \\<and> i \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  A $ m $ j \\<noteq> (0::'a) \\<and> i \\<le> m\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define n where \"n = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)\""], ["proof (state)\nthis:\n  n = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  n = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)", "have P1: \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) = n\""], ["proof (prove)\nusing this:\n  n = (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  A $ m $ j \\<noteq> (0::'a) \\<and> i \\<le> m\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n", "have P2: \"A $ n $ j \\<noteq> 0\" and P3: \"i \\<le> n\""], ["proof (prove)\nusing this:\n  A $ m $ j \\<noteq> (0::'a) \\<and> i \\<le> m\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n\n\ngoal (1 subgoal):\n 1. A $ n $ j \\<noteq> (0::'a) &&& i \\<le> n", "using LeastI [of \"\\<lambda>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\" m]"], ["proof (prove)\nusing this:\n  A $ m $ j \\<noteq> (0::'a) \\<and> i \\<le> m\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n\n  A $ m $ j \\<noteq> (0::'a) \\<and> i \\<le> m \\<Longrightarrow>\n  A $ (LEAST x. A $ x $ j \\<noteq> (0::'a) \\<and> i \\<le> x) $ j \\<noteq>\n  (0::'a) \\<and>\n  i \\<le> (LEAST x. A $ x $ j \\<noteq> (0::'a) \\<and> i \\<le> x)\n\ngoal (1 subgoal):\n 1. A $ n $ j \\<noteq> (0::'a) &&& i \\<le> n", "by simp_all"], ["proof (state)\nthis:\n  A $ n $ j \\<noteq> (0::'a)\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define interchange_A where \"interchange_A = interchange_rows A i n\""], ["proof (state)\nthis:\n  interchange_A = interchange_rows A i n\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  interchange_A = interchange_rows A i n", "have P4: \"interchange_A = interchange_rows A i n\""], ["proof (prove)\nusing this:\n  interchange_A = interchange_rows A i n\n\ngoal (1 subgoal):\n 1. interchange_A = interchange_rows A i n", "by simp"], ["proof (state)\nthis:\n  interchange_A = interchange_rows A i n\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define A' where \"A' = mult_row interchange_A i (1 / interchange_A $ i $ j)\""], ["proof (state)\nthis:\n  A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)", "have P5: \"A' = mult_row interchange_A i (1 / interchange_A $ i $ j)\""], ["proof (prove)\nusing this:\n  A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)\n\ngoal (1 subgoal):\n 1. A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)", "by simp"], ["proof (state)\nthis:\n  A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have P6: \"Gauss_Jordan_in_ij A i j = vec_lambda (\\<lambda>s. if s = i then A' $ s \n    else (row_add A' s i (- (interchange_A $ s $ j))) $ s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A i j =\n    (\\<chi>s.\n        if s = i then A' $ s\n        else row_add A' s i (- interchange_A $ s $ j) $ s)", "by (simp only: Gauss_Jordan_in_ij_def P1 P4 [symmetric] P5 [symmetric] Let_def)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A i j =\n  (\\<chi>s.\n      if s = i then A' $ s\n      else row_add A' s i (- interchange_A $ s $ j) $ s)\n\ngoal (1 subgoal):\n 1. (\\<And>n interchange_A A'.\n        \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n         A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n         Gauss_Jordan_in_ij A i j =\n         (\\<chi>s.\n             if s = i then A' $ s\n             else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from P1 P2 P3 P4 P5 P6 that"], ["proof (chain)\npicking this:\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n\n  A $ n $ j \\<noteq> (0::'a)\n  i \\<le> n\n  interchange_A = interchange_rows A i n\n  A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)\n  Gauss_Jordan_in_ij A i j =\n  (\\<chi>s.\n      if s = i then A' $ s\n      else row_add A' s i (- interchange_A $ s $ j) $ s)\n  \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = ?n;\n   A $ ?n $ j \\<noteq> (0::'a); i \\<le> ?n;\n   ?interchange_A = interchange_rows A i ?n;\n   ?A' = mult_row ?interchange_A i ((1::'a) / ?interchange_A $ i $ j);\n   Gauss_Jordan_in_ij A i j =\n   (\\<chi>s.\n       if s = i then ?A' $ s\n       else row_add ?A' s i (- ?interchange_A $ s $ j) $ s)\\<rbrakk>\n  \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n\n  A $ n $ j \\<noteq> (0::'a)\n  i \\<le> n\n  interchange_A = interchange_rows A i n\n  A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j)\n  Gauss_Jordan_in_ij A i j =\n  (\\<chi>s.\n      if s = i then A' $ s\n      else row_add A' s i (- interchange_A $ s $ j) $ s)\n  \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = ?n;\n   A $ ?n $ j \\<noteq> (0::'a); i \\<le> ?n;\n   ?interchange_A = interchange_rows A i ?n;\n   ?A' = mult_row ?interchange_A i ((1::'a) / ?interchange_A $ i $ j);\n   Gauss_Jordan_in_ij A i j =\n   (\\<chi>s.\n       if s = i then ?A' $ s\n       else row_add ?A' s i (- ?interchange_A $ s $ j) $ s)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The following definition makes the step of Gauss-Jordan in a column. This function receives two input parameters: the column k\nwhere the step of Gauss-Jordan must be applied and a pair (which consists of the row where the pivot should be placed in the column k and the original matrix).\\<close>"], ["", "definition Gauss_Jordan_column_k :: \"(nat \\<times> ('a::{zero,inverse,uminus,semiring_1}^'m::{mod_type}^'n::{mod_type})) \n=> nat => (nat \\<times> ('a^'m::{mod_type}^'n::{mod_type}))\"\nwhere \"Gauss_Jordan_column_k A' k = (let i=fst A'; A=(snd A'); from_nat_i=(from_nat i::'n); from_nat_k=(from_nat k::'m) in \n        if (\\<forall>m\\<ge>(from_nat_i). A $ m $(from_nat_k)=0) \\<or> (i = nrows A) then (i,A) else (i+1, (Gauss_Jordan_in_ij A (from_nat_i) (from_nat_k))))\""], ["", "text\\<open>The following definition applies the Gauss-Jordan step from the first column up to the k one (included).\\<close>"], ["", "definition Gauss_Jordan_upt_k :: \"'a::{inverse,uminus,semiring_1}^'columns::{mod_type}^'rows::{mod_type} => nat \n=> 'a^'columns::{mod_type}^'rows::{mod_type}\"\n where \"Gauss_Jordan_upt_k A k = snd (foldl Gauss_Jordan_column_k (0,A) [0..<Suc k])\""], ["", "text\\<open>Gauss-Jordan is to apply the @{term \"Gauss_Jordan_column_k\"} in all columns.\\<close>"], ["", "definition Gauss_Jordan :: \"'a::{inverse,uminus,semiring_1}^'columns::{mod_type}^'rows::{mod_type}  \n=> 'a^'columns::{mod_type}^'rows::{mod_type}\"\n where \"Gauss_Jordan A = Gauss_Jordan_upt_k A ((ncols A) - 1)\""], ["", "subsection\\<open>Properties about rref and the greatest nonzero row.\\<close>"], ["", "lemma greatest_plus_one_eq_0:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "have \"to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) + 1 = card (UNIV::'rows set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) + 1 =\n    CARD('rows)", "using assms"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) + 1 =\n    CARD('rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) + 1 =\n    CARD('rows)", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) + 1 =\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "thus \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) + 1 =\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "using to_nat_plus_one_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST R. \\<not> is_zero_row_upt_k R k A) + 1 =\n  CARD('rows)\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "by fastforce"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_nat_to_nat_greatest:\n  fixes A::\"'a::{zero}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"from_nat (Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A))) = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (Suc (mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A))) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "unfolding Suc_eq_plus1"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n      1) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "unfolding to_nat_1[where ?'a='rows, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n      mod_type_class.to_nat (1::'rows)) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "unfolding add_to_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat\n     (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n      mod_type_class.to_nat (1::'rows)) =\n    mod_type_class.from_nat\n     (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n      mod_type_class.to_nat (1::'rows))", ".."], ["", "lemma greatest_less_zero_row:\n  fixes A::\"'a::{one, zero}^'n::{mod_type}^'m::{finite,one,plus,linorder}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i: \"is_zero_row_upt_k i k A\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "assume not_less_i: \"\\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\""], ["proof (state)\nthis:\n  \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\n\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "have i_less_greatest: \"i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by (metis (mono_tags, lifting) GreatestI neqE not_all_zero not_less_i zero_i)"], ["proof (state)\nthis:\n  i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "have \"is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A", "using r zero_i i_less_greatest"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n  is_zero_row_upt_k i k A\n  i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A", "unfolding reduced_row_echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      is_zero_row_upt_k i k A \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n      A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)) \\<and>\n  (\\<forall>i.\n      i < i + (1::'m) \\<and>\n      \\<not> is_zero_row_upt_k i k A \\<and>\n      \\<not> is_zero_row_upt_k (i + (1::'m)) k A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n      (\\<forall>j.\n          i \\<noteq> j \\<longrightarrow>\n          A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)))\n  is_zero_row_upt_k i k A\n  i < (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A", "by blast"], ["proof (state)\nthis:\n  is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\n\ngoal (1 subgoal):\n 1. \\<not> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n           < i \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\n\ngoal (1 subgoal):\n 1. False", "using GreatestI_ex not_all_zero"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (GREATEST m. \\<not> is_zero_row_upt_k m k A) k A\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (Greatest ?P)\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rref_suc_if_zero_below_greatest:\n  fixes A::\"'a::{one, zero}^'n::{mod_type}^'m::{finite,one,plus,linorder}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\" (*This premisse is necessary to assure the existence of the Greatest*)\n  and all_zero_below_greatest: \"\\<forall>a. a>(GREATEST m. \\<not> is_zero_row_upt_k m k A) \\<longrightarrow> is_zero_row_upt_k a (Suc k) A\"\n  shows \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "proof (rule reduced_row_echelon_form_upt_k_intro, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "fix i j"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "assume zero_i_suc: \"is_zero_row_upt_k i (Suc k) A\" and i_le_j: \"i < j\""], ["proof (state)\nthis:\n  is_zero_row_upt_k i (Suc k) A\n  i < j\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "have zero_i: \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "using zero_i_suc"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < Suc k \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "have \"i>(GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i", "by (rule greatest_less_zero_row[OF r zero_i not_all_zero])"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "hence \"j>(GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) < j", "using i_le_j"], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\n  i < j\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) < j", "by simp"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < j\n\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) A; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "thus \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "using all_zero_below_greatest"], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < j\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "by fast"], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k) A\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 3. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 3. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 3. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "assume not_zero_i: \"\\<not> is_zero_row_upt_k i (Suc k) A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) A \\<Longrightarrow>\n       A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 3. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "show \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using  greatest_less_zero_row[OF r _ not_all_zero] not_zero_i r all_zero_below_greatest"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k ?i k A \\<Longrightarrow>\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  reduced_row_echelon_form_upt_k A k\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "unfolding reduced_row_echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k ?i k A \\<Longrightarrow>\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  (\\<forall>i.\n      is_zero_row_upt_k i k A \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n      A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)) \\<and>\n  (\\<forall>i.\n      i < i + (1::'m) \\<and>\n      \\<not> is_zero_row_upt_k i k A \\<and>\n      \\<not> is_zero_row_upt_k (i + (1::'m)) k A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n      (\\<forall>j.\n          i \\<noteq> j \\<longrightarrow>\n          A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)))\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "by fast"], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "assume i: \"i < i + 1\" and not_zero_i: \"\\<not> is_zero_row_upt_k i (Suc k) A\" and not_zero_suc_i: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) A\""], ["proof (state)\nthis:\n  i < i + (1::'m)\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "have not_zero_i_k: \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "using all_zero_below_greatest greatest_less_zero_row[OF r _ not_all_zero] not_zero_i"], ["proof (prove)\nusing this:\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n  is_zero_row_upt_k ?i k A \\<Longrightarrow>\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "have not_zero_suc_i: \"\\<not> is_zero_row_upt_k (i+1) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'m)) k A", "using all_zero_below_greatest greatest_less_zero_row[OF r _ not_all_zero] not_zero_suc_i"], ["proof (prove)\nusing this:\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n  is_zero_row_upt_k ?i k A \\<Longrightarrow>\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'m)) k A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (i + (1::'m)) k A\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "have aux:\"(\\<forall>i j. i + 1 = j \\<and> i < j \\<and> \\<not> is_zero_row_upt_k i k A \\<and> \\<not> is_zero_row_upt_k j k A \\<longrightarrow> (LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ j $ n \\<noteq> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i + (1::'m) = j \\<and>\n       i < j \\<and>\n       \\<not> is_zero_row_upt_k i k A \\<and>\n       \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "using r"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i + (1::'m) = j \\<and>\n       i < j \\<and>\n       \\<not> is_zero_row_upt_k i k A \\<and>\n       \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "unfolding reduced_row_echelon_form_upt_k_def"], ["proof (prove)\nusing this:\n  (\\<forall>i.\n      is_zero_row_upt_k i k A \\<longrightarrow>\n      \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n      A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)) \\<and>\n  (\\<forall>i.\n      i < i + (1::'m) \\<and>\n      \\<not> is_zero_row_upt_k i k A \\<and>\n      \\<not> is_zero_row_upt_k (i + (1::'m)) k A \\<longrightarrow>\n      (LEAST n. A $ i $ n \\<noteq> (0::'a))\n      < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))) \\<and>\n  (\\<forall>i.\n      \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n      (\\<forall>j.\n          i \\<noteq> j \\<longrightarrow>\n          A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i + (1::'m) = j \\<and>\n       i < j \\<and>\n       \\<not> is_zero_row_upt_k i k A \\<and>\n       \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a))\n       < (LEAST n. A $ j $ n \\<noteq> (0::'a))", "by fast"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i + (1::'m) = j \\<and>\n     i < j \\<and>\n     \\<not> is_zero_row_upt_k i k A \\<and>\n     \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'m); \\<not> is_zero_row_upt_k i (Suc k) A;\n        \\<not> is_zero_row_upt_k (i + (1::'m)) (Suc k) A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "show \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))", "using aux not_zero_i_k not_zero_suc_i i"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i + (1::'m) = j \\<and>\n     i < j \\<and>\n     \\<not> is_zero_row_upt_k i k A \\<and>\n     \\<not> is_zero_row_upt_k j k A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ j $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row_upt_k i k A\n  \\<not> is_zero_row_upt_k (i + (1::'m)) k A\n  i < i + (1::'m)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ (i + (1::'m)) $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "assume \"\\<not> is_zero_row_upt_k i (Suc k) A\" and \"i \\<noteq> j\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) A; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "thus \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using all_zero_below_greatest greatest_less_zero_row not_all_zero r rref_upt_condition4"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  i \\<noteq> j\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n  \\<lbrakk>reduced_row_echelon_form_upt_k ?A ?k; is_zero_row_upt_k ?i ?k ?A;\n   \\<not> (\\<forall>a. is_zero_row_upt_k a ?k ?A)\\<rbrakk>\n  \\<Longrightarrow> (GREATEST m. \\<not> is_zero_row_upt_k m ?k ?A) < ?i\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n  reduced_row_echelon_form_upt_k A k\n  reduced_row_echelon_form_upt_k ?A ?k \\<Longrightarrow>\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i ?k ?A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         ?A $ j $ (LEAST n. ?A $ i $ n \\<noteq> (0::?'a)) = (0::?'a))\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rref_suc_if_all_rows_not_zero:\n  fixes A::\"'a::{one, zero}^'n::{mod_type}^'m::{finite,one,plus,linorder}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and all_not_zero: \"\\<forall>n. \\<not> is_zero_row_upt_k n k A\"\n  shows \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "proof (rule rref_suc_if_zero_below_greatest)"], ["proof (state)\ngoal (3 subgoals):\n 1. reduced_row_echelon_form_upt_k A k\n 2. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n 3. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "show \"reduced_row_echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "using r"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (2 subgoals):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n 2. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "show \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)", "using all_not_zero"], ["proof (prove)\nusing this:\n  \\<forall>n. \\<not> is_zero_row_upt_k n k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n\ngoal (1 subgoal):\n 1. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "show \"\\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A. is_zero_row_upt_k a (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "using all_not_zero not_greater_Greatest"], ["proof (prove)\nusing this:\n  \\<forall>n. \\<not> is_zero_row_upt_k n k A\n  (GREATEST x. ?P x) < ?k \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "by blast"], ["proof (state)\nthis:\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greatest_ge_nonzero_row:\n  fixes A::\"'a::{zero}^'n::{mod_type}^'m::{finite,linorder}\"\n  assumes \"\\<not> is_zero_row_upt_k i k A\"\n  shows \"i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "using Greatest_ge[of \"(\\<lambda>m. \\<not> is_zero_row_upt_k m k A)\", OF assms]"], ["proof (prove)\nusing this:\n  i \\<le> (GREATEST x. \\<not> is_zero_row_upt_k x k A)\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "."], ["", "lemma greatest_ge_nonzero_row':\n  fixes A::\"'a::{zero, one}^'n::{mod_type}^'m::{finite, linorder, one, plus}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and i: \"i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\"\n  and not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\"\n  shows \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "using greatest_less_zero_row[OF r] i not_all_zero"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k ?i k A;\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "by fastforce"], ["", "corollary row_greater_greatest_is_zero:\n  fixes A::\"'a::{zero}^'n::{mod_type}^'m::{finite,linorder}\"\n  assumes \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\"\n  shows \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "using greatest_ge_nonzero_row assms"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i ?k ?A \\<Longrightarrow>\n  ?i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m ?k ?A)\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < i\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by fastforce"], ["", "subsection\\<open>The proof of its correctness\\<close>"], ["", "text\\<open>Properties of @{term \"Gauss_Jordan_in_ij\"}\\<close>"], ["", "lemma Gauss_Jordan_in_ij_1:\n  fixes A::\"'a::{field}^'m^'n::{finite, ord, wellorder}\"\n  assumes ex: \"\\<exists>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\"\n  shows \"(Gauss_Jordan_in_ij A i j) $ i $ j = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A i j $ i $ j = (1::'a)", "proof (unfold Gauss_Jordan_in_ij_def Let_def mult_row_def interchange_rows_def, vector)"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j \\<noteq>\n    (0::'a)", "obtain n where Anj: \"A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex"], ["proof (prove)\nusing this:\n  \\<exists>n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j \\<noteq>\n    (0::'a)", "show \"A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j \\<noteq>\n    (0::'a)", "using LeastI[of \"\\<lambda>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\" n, OF Anj]"], ["proof (prove)\nusing this:\n  A $ (LEAST x. A $ x $ j \\<noteq> (0::'a) \\<and> i \\<le> x) $ j \\<noteq>\n  (0::'a) \\<and>\n  i \\<le> (LEAST x. A $ x $ j \\<noteq> (0::'a) \\<and> i \\<le> x)\n\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gauss_Jordan_in_ij_0:\n  fixes A::\"'a::{field}^'m^'n::{finite, ord, wellorder}\"\n  assumes ex: \"\\<exists>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\" and a: \"a \\<noteq> i\"\n  shows \"(Gauss_Jordan_in_ij A i j) $ a $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A i j $ a $ j = (0::'a)", "using ex"], ["proof (prove)\nusing this:\n  \\<exists>n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A i j $ a $ j = (0::'a)", "apply (rule Gauss_Jordan_in_ij_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n interchange_A A'.\n       \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n        A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n        interchange_A = interchange_rows A i n;\n        A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n        Gauss_Jordan_in_ij A i j =\n        (\\<chi>s.\n            if s = i then A' $ s\n            else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A i j $ a $ j = (0::'a)", "using a"], ["proof (prove)\nusing this:\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>n interchange_A A'.\n       \\<lbrakk>(LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) = n;\n        A $ n $ j \\<noteq> (0::'a); i \\<le> n;\n        interchange_A = interchange_rows A i n;\n        A' = mult_row interchange_A i ((1::'a) / interchange_A $ i $ j);\n        Gauss_Jordan_in_ij A i j =\n        (\\<chi>s.\n            if s = i then A' $ s\n            else row_add A' s i (- interchange_A $ s $ j) $ s)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A i j $ a $ j = (0::'a)", "by (simp add: mult_row_def interchange_rows_def row_add_def)"], ["", "corollary Gauss_Jordan_in_ij_0':\n  fixes A::\"'a::{field}^'m^'n::{finite, ord, wellorder}\"\n  assumes ex: \"\\<exists>n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n\"\n  shows \"\\<forall>a. a \\<noteq> i \\<longrightarrow> (Gauss_Jordan_in_ij A i j) $ a $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a \\<noteq> i \\<longrightarrow>\n       Gauss_Jordan_in_ij A i j $ a $ j = (0::'a)", "using assms Gauss_Jordan_in_ij_0"], ["proof (prove)\nusing this:\n  \\<exists>n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n\n  \\<lbrakk>\\<exists>n. ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n;\n   ?a \\<noteq> ?i\\<rbrakk>\n  \\<Longrightarrow> Gauss_Jordan_in_ij ?A ?i ?j $ ?a $ ?j = (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a \\<noteq> i \\<longrightarrow>\n       Gauss_Jordan_in_ij A i j $ a $ j = (0::'a)", "by blast"], ["", "lemma Gauss_Jordan_in_ij_preserves_previous_elements:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes r: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_a: \"\\<not> is_zero_row_upt_k a k A\"\n  and exists_m: \"\\<exists>m. A $ m $ (from_nat k) \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> m\"\n  and Greatest_plus_1: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\"\n  and j_le_k: \"to_nat j < k\"\n  shows \"Gauss_Jordan_in_ij A ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) (from_nat k) $ i $ j = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    j =\n    A $ i $ j", "proof (unfold Gauss_Jordan_in_ij_def Let_def interchange_rows_def mult_row_def row_add_def, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) =\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j /\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 2. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) \\<noteq>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j -\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j\n 3. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 4. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i \\<noteq> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j =\n                      (0::'a)", "define last_nonzero_row where \"last_nonzero_row = (GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (state)\nthis:\n  last_nonzero_row = (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) =\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j /\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 2. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) \\<noteq>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j -\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j\n 3. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 4. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i \\<noteq> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j =\n                      (0::'a)", "have \"last_nonzero_row < (last_nonzero_row + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_nonzero_row < last_nonzero_row + (1::'rows)", "by (rule  Suc_le'[of last_nonzero_row], auto simp add: last_nonzero_row_def Greatest_plus_1)"], ["proof (state)\nthis:\n  last_nonzero_row < last_nonzero_row + (1::'rows)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) =\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j /\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 2. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) \\<noteq>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j -\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j\n 3. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 4. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i \\<noteq> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j =\n                      (0::'a)", "hence zero_row: \"is_zero_row_upt_k (last_nonzero_row + 1) k A\""], ["proof (prove)\nusing this:\n  last_nonzero_row < last_nonzero_row + (1::'rows)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (last_nonzero_row + (1::'rows)) k A", "using not_le greatest_ge_nonzero_row last_nonzero_row_def"], ["proof (prove)\nusing this:\n  last_nonzero_row < last_nonzero_row + (1::'rows)\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n  \\<not> is_zero_row_upt_k ?i ?k ?A \\<Longrightarrow>\n  ?i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m ?k ?A)\n  last_nonzero_row = (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (last_nonzero_row + (1::'rows)) k A", "by fastforce"], ["proof (state)\nthis:\n  is_zero_row_upt_k (last_nonzero_row + (1::'rows)) k A\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) =\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j /\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 2. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) \\<noteq>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j -\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j\n 3. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 4. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i \\<noteq> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j =\n                      (0::'a)", "hence A_greatest_0: \"A $ (last_nonzero_row + 1) $ j = 0\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (last_nonzero_row + (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. A $ (last_nonzero_row + (1::'rows)) $ j = (0::'a)", "unfolding is_zero_row_upt_k_def last_nonzero_row_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $\n     ((GREATEST m.\n          \\<not> (\\<forall>j.\n                     mod_type_class.to_nat j < k \\<longrightarrow>\n                     A $ m $ j = (0::'a))) +\n      (1::'rows)) $\n     j =\n     (0::'a)\n\ngoal (1 subgoal):\n 1. A $\n    ((GREATEST m.\n         \\<not> (\\<forall>j.\n                    mod_type_class.to_nat j < k \\<longrightarrow>\n                    A $ m $ j = (0::'a))) +\n     (1::'rows)) $\n    j =\n    (0::'a)", "using j_le_k"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     A $\n     ((GREATEST m.\n          \\<not> (\\<forall>j.\n                     mod_type_class.to_nat j < k \\<longrightarrow>\n                     A $ m $ j = (0::'a))) +\n      (1::'rows)) $\n     j =\n     (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $\n    ((GREATEST m.\n         \\<not> (\\<forall>j.\n                    mod_type_class.to_nat j < k \\<longrightarrow>\n                    A $ m $ j = (0::'a))) +\n     (1::'rows)) $\n    j =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  A $ (last_nonzero_row + (1::'rows)) $ j = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) =\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j /\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 2. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) \\<noteq>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j -\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j\n 3. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 4. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i \\<noteq> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j =\n                      (0::'a)", "then"], ["proof (chain)\npicking this:\n  A $ (last_nonzero_row + (1::'rows)) $ j = (0::'a)", "show \"A $ (last_nonzero_row + 1) $ j / A $ (last_nonzero_row + 1) $ from_nat k = A $ (last_nonzero_row + 1) $ j\""], ["proof (prove)\nusing this:\n  A $ (last_nonzero_row + (1::'rows)) $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ (last_nonzero_row + (1::'rows)) $ j /\n    A $ (last_nonzero_row + (1::'rows)) $ mod_type_class.from_nat k =\n    A $ (last_nonzero_row + (1::'rows)) $ j", "by simp"], ["proof (state)\nthis:\n  A $ (last_nonzero_row + (1::'rows)) $ j /\n  A $ (last_nonzero_row + (1::'rows)) $ mod_type_class.from_nat k =\n  A $ (last_nonzero_row + (1::'rows)) $ j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) \\<noteq>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j -\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j\n 2. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j\n 3. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i \\<noteq> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j =\n                      (0::'a)", "show zero: \"A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n) $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j =\n    (0::'a)", "define least_n where \"least_n = (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n)\""], ["proof (state)\nthis:\n  least_n =\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n)\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j =\n    (0::'a)", "have \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n", "by (metis exists_m)"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j =\n    (0::'a)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n", "obtain n where n1: \"A $ n $ from_nat k \\<noteq> 0\"  and n2: \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a);\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j =\n    (0::'a)", "have \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> least_n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> least_n", "by (metis (lifting, full_types) LeastI_ex least_n_def n1 n2)"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> least_n\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j =\n    (0::'a)", "hence \"is_zero_row_upt_k least_n k A\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> least_n\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k least_n k A", "using last_nonzero_row_def less_le rref_upt_condition1[OF r] zero_row"], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> least_n\n  last_nonzero_row = (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n  (?x < ?y) = (?x \\<le> ?y \\<and> ?x \\<noteq> ?y)\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  is_zero_row_upt_k (last_nonzero_row + (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k least_n k A", "by metis"], ["proof (state)\nthis:\n  is_zero_row_upt_k least_n k A\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j =\n    (0::'a)", "thus \"A $ least_n $ j = 0\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k least_n k A\n\ngoal (1 subgoal):\n 1. A $ least_n $ j = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ least_n $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ least_n $ j = (0::'a)", "using j_le_k"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ least_n $ j = (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ least_n $ j = (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ least_n $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n  j =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n         \\<le> n) \\<noteq>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j -\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j\n 2. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j", "show \"A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) $ j -\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) $ from_nat k *\n    A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n) $ j /\n    A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n) $ from_nat k =\n    A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j -\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $\n    mod_type_class.from_nat k *\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j", "unfolding last_nonzero_row_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (last_nonzero_row + (1::'rows)) $ j -\n    A $ (last_nonzero_row + (1::'rows)) $ mod_type_class.from_nat k *\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        last_nonzero_row + (1::'rows) \\<le> n) $\n    j /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        last_nonzero_row + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        last_nonzero_row + (1::'rows) \\<le> n) $\n    j", "unfolding A_greatest_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) -\n    A $ (last_nonzero_row + (1::'rows)) $ mod_type_class.from_nat k *\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        last_nonzero_row + (1::'rows) \\<le> n) $\n    j /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        last_nonzero_row + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        last_nonzero_row + (1::'rows) \\<le> n) $\n    j", "unfolding last_nonzero_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) -\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $\n    mod_type_class.from_nat k *\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j", "unfolding zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) -\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $\n    mod_type_class.from_nat k *\n    (0::'a) /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j -\n  A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $\n  mod_type_class.from_nat k *\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n  j /\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n  mod_type_class.from_nat k =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n  j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n             (1::'rows) \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n                 \\<le> n);\n     i = (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                          (1::'rows)\n                          \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                       (1::'rows)) $\n                      j", "show \"A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n) $ j /\n    A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<le> n) $ from_nat k =\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    j /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j", "unfolding zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j", "using A_greatest_0"], ["proof (prove)\nusing this:\n  A $ (last_nonzero_row + (1::'rows)) $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j", "unfolding last_nonzero_row_def"], ["proof (prove)\nusing this:\n  A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j", "by simp"], ["proof (state)\nthis:\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n  j /\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> n) $\n  mod_type_class.from_nat k =\n  A $ ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)) $ j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gauss_Jordan_in_ij_preserves_previous_elements':\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes all_zero: \"\\<forall>n. is_zero_row_upt_k n k A\"\n  and j_le_k: \"to_nat j < k\"\n  and A_nk_not_zero: \"A $ n $ (from_nat k) \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ j = A $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $ j =\n    A $ i $ j", "proof (unfold Gauss_Jordan_in_ij_def Let_def mult_row_def interchange_rows_def row_add_def, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i = (0::'rows);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) =\n     (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $ (0::'rows) $ j /\n                      A $ (0::'rows) $ mod_type_class.from_nat k =\n                      A $ (0::'rows) $ j\n 2. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) \\<noteq>\n     (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $ (0::'rows) $ j -\n                      A $ (0::'rows) $ mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j\n 3. \\<lbrakk>(LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n) \\<noteq>\n             (0::'rows);\n     i = (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $ (0::'rows) $ j\n 4. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n);\n     i \\<noteq> (0::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j =\n                      (0::'a)", "have A_0_j: \"A $ 0 $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (0::'rows) $ j = (0::'a)", "using all_zero is_zero_row_upt_k_def j_le_k"], ["proof (prove)\nusing this:\n  \\<forall>n. is_zero_row_upt_k n k A\n  is_zero_row_upt_k ?i ?k ?A =\n  (\\<forall>j.\n      mod_type_class.to_nat j < ?k \\<longrightarrow> ?A $ ?i $ j = (0::?'a))\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ (0::'rows) $ j = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ (0::'rows) $ j = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = (0::'rows);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) =\n     (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $ (0::'rows) $ j /\n                      A $ (0::'rows) $ mod_type_class.from_nat k =\n                      A $ (0::'rows) $ j\n 2. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) \\<noteq>\n     (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $ (0::'rows) $ j -\n                      A $ (0::'rows) $ mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j\n 3. \\<lbrakk>(LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n) \\<noteq>\n             (0::'rows);\n     i = (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $ (0::'rows) $ j\n 4. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n);\n     i \\<noteq> (0::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j =\n                      (0::'a)", "then"], ["proof (chain)\npicking this:\n  A $ (0::'rows) $ j = (0::'a)", "show \"A $ 0 $ j / A $ 0 $ from_nat k = A $ 0 $ j\""], ["proof (prove)\nusing this:\n  A $ (0::'rows) $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ (0::'rows) $ j / A $ (0::'rows) $ mod_type_class.from_nat k =\n    A $ (0::'rows) $ j", "by simp"], ["proof (state)\nthis:\n  A $ (0::'rows) $ j / A $ (0::'rows) $ mod_type_class.from_nat k =\n  A $ (0::'rows) $ j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) \\<noteq>\n     (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $ (0::'rows) $ j -\n                      A $ (0::'rows) $ mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j\n 2. \\<lbrakk>(LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n) \\<noteq>\n             (0::'rows);\n     i = (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $ (0::'rows) $ j\n 3. \\<lbrakk>i \\<noteq>\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n);\n     i \\<noteq> (0::'rows);\n     A $ i $ mod_type_class.from_nat k \\<noteq> (0::'a);\n     A $\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) $\n     mod_type_class.from_nat k \\<noteq>\n     (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j =\n                      (0::'a)", "show A_least_j: \"A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n) $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    j =\n    (0::'a)", "using all_zero is_zero_row_upt_k_def j_le_k"], ["proof (prove)\nusing this:\n  \\<forall>n. is_zero_row_upt_k n k A\n  is_zero_row_upt_k ?i ?k ?A =\n  (\\<forall>j.\n      mod_type_class.to_nat j < ?k \\<longrightarrow> ?A $ ?i $ j = (0::?'a))\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    j =\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (0::'rows) \\<le> n) $\n  j =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i =\n             (LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n);\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         (0::'rows) \\<le> n) \\<noteq>\n     (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $ (0::'rows) $ j -\n                      A $ (0::'rows) $ mod_type_class.from_nat k *\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j\n 2. \\<lbrakk>(LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n) \\<noteq>\n             (0::'rows);\n     i = (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $ (0::'rows) $ j", "show \"A $ 0 $ j -\n    A $ 0 $ from_nat k * A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n) $ j /\n    A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n) $ from_nat k =\n    A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (0::'rows) $ j -\n    A $ (0::'rows) $ mod_type_class.from_nat k *\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    j /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    j", "unfolding A_0_j A_least_j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) -\n    A $ (0::'rows) $ mod_type_class.from_nat k * (0::'a) /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ (0::'rows) $ j -\n  A $ (0::'rows) $ mod_type_class.from_nat k *\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (0::'rows) \\<le> n) $\n  j /\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (0::'rows) \\<le> n) $\n  mod_type_class.from_nat k =\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (0::'rows) \\<le> n) $\n  j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(LEAST n.\n                 A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n                 (0::'rows) \\<le> n) \\<noteq>\n             (0::'rows);\n     i = (0::'rows)\\<rbrakk>\n    \\<Longrightarrow> A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      j /\n                      A $\n                      (LEAST n.\n                          A $ n $ mod_type_class.from_nat k \\<noteq>\n                          (0::'a) \\<and>\n                          (0::'rows) \\<le> n) $\n                      mod_type_class.from_nat k =\n                      A $ (0::'rows) $ j", "show \"A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n) $ j / A $ (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n) $ from_nat k = A $ 0 $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    j /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    A $ (0::'rows) $ j", "unfolding A_least_j A_0_j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) /\n    A $\n    (LEAST n.\n        A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n        (0::'rows) \\<le> n) $\n    mod_type_class.from_nat k =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (0::'rows) \\<le> n) $\n  j /\n  A $\n  (LEAST n.\n      A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n      (0::'rows) \\<le> n) $\n  mod_type_class.from_nat k =\n  A $ (0::'rows) $ j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_zero_after_Gauss:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes zero_a: \"is_zero_row_upt_k a k A\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and r: \"reduced_row_echelon_form_upt_k A k\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k a k (Gauss_Jordan_in_ij A ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k\n     (Gauss_Jordan_in_ij A\n       ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n       (mod_type_class.from_nat k))", "proof (subst is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n        (mod_type_class.from_nat k) $\n       a $\n       j =\n       (0::'a)", "fix j::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n        (mod_type_class.from_nat k) $\n       a $\n       j =\n       (0::'a)", "assume j_less_k: \"to_nat j < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n        (mod_type_class.from_nat k) $\n       a $\n       j =\n       (0::'a)", "have not_zero_g: \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) \\<noteq> (0::'m)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) =\n    (0::'m) \\<Longrightarrow>\n    False", "assume \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1 = 0\""], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) = (0::'m)\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) =\n    (0::'m) \\<Longrightarrow>\n    False", "hence \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) = -1\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) = (0::'m)\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) = - (1::'m)", "using a_eq_minus_1"], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) = (0::'m)\n  \\<forall>a. a + (1::?'a) = (0::?'a) \\<longrightarrow> a = - (1::?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) = - (1::'m)", "by blast"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) = - (1::'m)\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) =\n    (0::'m) \\<Longrightarrow>\n    False", "hence \"a\\<le>(GREATEST m. \\<not> is_zero_row_upt_k m k A)\""], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) = - (1::'m)\n\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "using Greatest_is_minus_1"], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) = - (1::'m)\n  \\<forall>a. a \\<le> - (1::?'a)\n\ngoal (1 subgoal):\n 1. a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)", "by auto"], ["proof (state)\nthis:\n  a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) =\n    (0::'m) \\<Longrightarrow>\n    False", "hence \"\\<not> is_zero_row_upt_k a k A\""], ["proof (prove)\nusing this:\n  a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "using greatest_less_zero_row[OF r] not_zero_m"], ["proof (prove)\nusing this:\n  a \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A)\n  \\<lbrakk>is_zero_row_upt_k ?i k A;\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k a k A", "by fastforce"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) =\n    (0::'m) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. False", "using zero_a"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k a k A\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m) \\<noteq> (0::'m)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n        (mod_type_class.from_nat k) $\n       a $\n       j =\n       (0::'a)", "have \"Gauss_Jordan_in_ij A ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) (from_nat k) $ a $ j = A $ a $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n     (mod_type_class.from_nat k) $\n    a $\n    j =\n    A $ a $ j", "by (rule Gauss_Jordan_in_ij_preserves_previous_elements[OF r not_zero_m _ not_zero_g j_less_k], auto intro!: A_ma_k_not_zero greatest_less_ma)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n   (mod_type_class.from_nat k) $\n  a $\n  j =\n  A $ a $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n        (mod_type_class.from_nat k) $\n       a $\n       j =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n   (mod_type_class.from_nat k) $\n  a $\n  j =\n  A $ a $ j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n        (mod_type_class.from_nat k) $\n       a $\n       j =\n       (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "using zero_a j_less_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a k A\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ a $ j = (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. A $ a $ j = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ a $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n        (mod_type_class.from_nat k) $\n       a $\n       j =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n   (mod_type_class.from_nat k) $\n  a $\n  j =\n  (0::'a)", "show \"Gauss_Jordan_in_ij A ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + 1) (from_nat k) $ a $ j = 0\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n   (mod_type_class.from_nat k) $\n  a $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n     (mod_type_class.from_nat k) $\n    a $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'m))\n   (mod_type_class.from_nat k) $\n  a $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_zero_imp_Gauss_Jordan_column_not_zero_in_row_0:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes all_zero: \"\\<forall>n. is_zero_row_upt_k n k A\"\n  and not_zero_i: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and Amk_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"i=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (0::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "assume i_not_0: \"i \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "have ia2: \"ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = 0", "using ia all_zero"], ["proof (prove)\nusing this:\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  \\<forall>n. is_zero_row_upt_k n k A\n\ngoal (1 subgoal):\n 1. ia = 0", "by simp"], ["proof (state)\nthis:\n  ia = 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "have B_eq_Gauss: \"B = Gauss_Jordan_in_ij A 0 (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "using all_zero Amk_zero least_mod_type"], ["proof (prove)\nusing this:\n  \\<forall>n. is_zero_row_upt_k n k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "unfolding from_nat_0 nrows_def"], ["proof (prove)\nusing this:\n  \\<forall>n. is_zero_row_upt_k n k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>0::'rows.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = CARD('rows)\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (0::'rows)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "by auto"], ["proof (state)\nthis:\n  B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "have \"...$ i $ (from_nat k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule Gauss_Jordan_in_ij_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (0::'rows) \\<le> n\n 2. i \\<noteq> (0::'rows)", "show \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> 0 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (0::'rows) \\<le> n", "using Amk_zero least_mod_type"], ["proof (prove)\nusing this:\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (0::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (0::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows)", "show \"i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows)", "using i_not_0"], ["proof (prove)\nusing this:\n  i \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows)", "."], ["proof (state)\nthis:\n  i \\<noteq> (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  B $ i $ mod_type_class.from_nat k = (0::'a)", "have \"B $ i $ from_nat k = 0\""], ["proof (prove)\nusing this:\n  B $ i $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. B $ i $ mod_type_class.from_nat k = (0::'a)", "."], ["proof (state)\nthis:\n  B $ i $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "hence \"is_zero_row_upt_k i (Suc k) B\""], ["proof (prove)\nusing this:\n  B $ i $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k) B", "unfolding B_eq_Gauss"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k)\n     (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "using Gauss_Jordan_in_ij_preserves_previous_elements'[OF all_zero _ Amk_zero]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  mod_type_class.from_nat k =\n  (0::'a)\n  mod_type_class.to_nat ?j < k \\<Longrightarrow>\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $ ?j =\n  A $ ?i $ ?j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k)\n     (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "by (metis all_zero is_zero_row_upt_k_def less_SucE to_nat_from_nat)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'rows) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. False", "using not_zero_i"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Here we start to prove that \n      the output of @{term \"Gauss Jordan A\"} is a matrix in reduced row echelon form.\\<close>"], ["", "lemma condition_1_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes zero_column_k: \"\\<forall>m\\<ge>from_nat 0. A $ m $ from_nat k = 0\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  shows \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ja.\n       mod_type_class.to_nat ja < Suc k \\<longrightarrow>\n       A $ j $ ja = (0::'a)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "fix ja::'columns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "assume ja_less_suc_k: \"to_nat ja < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "show \"A $ j $ ja = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "proof (cases \"to_nat ja < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow> A $ j $ ja = (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow> A $ j $ ja = (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using all_zero"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n  \\<forall>m j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ m $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "hence ja_eq_k: \"k = to_nat ja \""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "using ja_less_suc_k"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "by simp"], ["proof (state)\nthis:\n  k = mod_type_class.to_nat ja\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using zero_column_k"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>mod_type_class.from_nat 0.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "unfolding ja_eq_k from_nat_to_nat_id from_nat_0"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>0::'rows. A $ m $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using least_mod_type"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>0::'rows. A $ m $ ja = (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_1_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes j_not_zero: \"j \\<noteq> 0\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\" \n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k j (Suc k) (Gauss_Jordan_in_ij A (from_nat 0) (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n       (mod_type_class.from_nat k))", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "fix ja::'columns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "assume ja_less_suc_k: \"to_nat ja < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "show \"Gauss_Jordan_in_ij A (from_nat 0) (from_nat k) $ j $ ja = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "proof (cases \"to_nat ja < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "have \"Gauss_Jordan_in_ij A (from_nat 0) (from_nat k) $ j $ ja = A $ j $ ja\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    A $ j $ ja", "unfolding from_nat_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $ ja =\n    A $ j $ ja", "using Gauss_Jordan_in_ij_preserves_previous_elements'[OF all_zero True Amk_not_zero]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $ ja =\n  A $ ?i $ ja\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $ ja =\n    A $ j $ ja", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  A $ j $ ja\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  A $ j $ ja\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using all_zero True"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>m j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ m $ j = (0::'a)\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "hence k_eq_ja: \"k = to_nat ja\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "using ja_less_suc_k"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "by simp"], ["proof (state)\nthis:\n  k = mod_type_class.to_nat ja\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "show \"Gauss_Jordan_in_ij A (from_nat 0) (from_nat k) $ j $ ja = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "unfolding k_eq_ja from_nat_to_nat_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat 0) ja $ j $ ja = (0::'a)", "proof (rule Gauss_Jordan_in_ij_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ ja \\<noteq> (0::'a) \\<and> mod_type_class.from_nat 0 \\<le> n\n 2. j \\<noteq> mod_type_class.from_nat 0", "show \"\\<exists>n. A $ n $ ja \\<noteq> 0 \\<and> from_nat 0 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ ja \\<noteq> (0::'a) \\<and> mod_type_class.from_nat 0 \\<le> n", "using least_mod_type Amk_not_zero"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ ja \\<noteq> (0::'a) \\<and> mod_type_class.from_nat 0 \\<le> n", "unfolding k_eq_ja from_nat_to_nat_id from_nat_0"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> ?n\n  A $ m $ ja \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n. A $ n $ ja \\<noteq> (0::'a) \\<and> (0::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ ja \\<noteq> (0::'a) \\<and> mod_type_class.from_nat 0 \\<le> n\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat 0", "show \"j \\<noteq> from_nat 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat 0", "using j_not_zero"], ["proof (prove)\nusing this:\n  j \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat 0", "unfolding from_nat_0"], ["proof (prove)\nusing this:\n  j \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'rows)", "."], ["proof (state)\nthis:\n  j \\<noteq> mod_type_class.from_nat 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_1_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B \\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_less_j: \"i<j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\"\n  shows \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "proof (unfold is_zero_row_upt_k_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "fix ja::'columns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "assume ja_less_suc_k: \"to_nat ja < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>mod_type_class.from_nat\n                     (Suc (mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A))).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     (mod_type_class.from_nat\n       (Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A))))\n     (mod_type_class.from_nat k) =\n    A", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "using zero_below_greatest"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "by blast"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "have zero_ikA: \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "using zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "unfolding B_eq_A is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < Suc k \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "hence zero_jkA: \"is_zero_row_upt_k j k A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "using rref_upt_condition1[OF rref] i_less_j"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  i < j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "by blast"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       A $ j $ ja = (0::'a)", "show \"A $ j $ ja = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "proof (cases \"to_nat ja < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow> A $ j $ ja = (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow> A $ j $ ja = (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using zero_jkA"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n  is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n  \\<forall>ja.\n     mod_type_class.to_nat ja < k \\<longrightarrow> A $ j $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "hence k_eq_ja:\"k = to_nat ja\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "using ja_less_suc_k"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "by auto"], ["proof (state)\nthis:\n  k = mod_type_class.to_nat ja\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> j", "proof (rule le_Suc, rule GreatestI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k ?a2 k A\n 2. \\<And>x. \\<not> is_zero_row_upt_k x k A \\<Longrightarrow> x < j", "show \"\\<not> is_zero_row_upt_k m k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "."], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> is_zero_row_upt_k x k A \\<Longrightarrow> x < j", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> is_zero_row_upt_k x k A \\<Longrightarrow> x < j", "assume not_zero_xkA: \"\\<not> is_zero_row_upt_k x k A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k x k A\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> is_zero_row_upt_k x k A \\<Longrightarrow> x < j", "show \"x < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < j", "using rref_upt_condition1[OF rref] not_zero_xkA zero_jkA neq_iff"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  \\<not> is_zero_row_upt_k x k A\n  is_zero_row_upt_k j k A\n  (?x \\<noteq> ?y) = (?x < ?y \\<or> ?y < ?x)\n\ngoal (1 subgoal):\n 1. x < j", "by blast"], ["proof (state)\nthis:\n  x < j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    A $ j $ ja = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> j\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using zero_below_greatest"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> j\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "unfolding k_eq_ja from_nat_to_nat_id is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  (GREATEST n.\n      \\<not> (\\<forall>j.\n                 mod_type_class.to_nat j\n                 < mod_type_class.to_nat ja \\<longrightarrow>\n                 A $ n $ j = (0::'a))) +\n  (1::'rows)\n  \\<le> j\n  \\<forall>m\\<ge>(GREATEST n.\n                     \\<not> (\\<forall>j.\n                                mod_type_class.to_nat j\n                                < mod_type_class.to_nat ja \\<longrightarrow>\n                                A $ n $ j = (0::'a))) +\n                 (1::'rows).\n     A $ m $ ja = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_1_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B \\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\" \n  and i_less_j: \"i<j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "using greatest_eq_card nrows_def"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n  nrows ?A = CARD(?'rows)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "by force"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "have rref_Suc: \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "proof (rule rref_suc_if_zero_below_greatest[OF rref])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n 2. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "show \"\\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A. is_zero_row_upt_k a (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "using greatest_eq_card not_less_eq to_nat_less_card to_nat_mono nrows_def"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n  (\\<not> ?m < ?n) = (?n < Suc ?m)\n  mod_type_class.to_nat ?j < CARD(?'a)\n  ?a < ?b \\<Longrightarrow>\n  mod_type_class.to_nat ?a < mod_type_class.to_nat ?b\n  nrows ?A = CARD(?'rows)\n\ngoal (1 subgoal):\n 1. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "by metis"], ["proof (state)\nthis:\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)", "show \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)", "by fast"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A (Suc k)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "using zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "using rref_upt_condition1[OF rref_Suc] i_less_j"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) A\n  \\<forall>i.\n     is_zero_row_upt_k i (Suc k) A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j (Suc k) A)\n  i < j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "by fast"], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_1_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B \\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\" \n  and i_less_j: \"i<j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"is_zero_row_upt_k j (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k))", "proof (subst (1) is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "fix ja::'columns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "assume ja_less_suc_k: \"to_nat ja < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "have B_eq_Gauss_ij: \"B = Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "unfolding B Gauss_Jordan_column_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (let i = fst (ia, A); A = snd (ia, A);\n             from_nat_i = mod_type_class.from_nat i;\n             from_nat_k = mod_type_class.from_nat k\n         in if (\\<forall>m\\<ge>from_nat_i.\n                   A $ m $ from_nat_k = (0::'a)) \\<or>\n               i = nrows A\n            then (i, A)\n            else (i + 1, Gauss_Jordan_in_ij A from_nat_i from_nat_k)) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "unfolding ia2 Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "using greatest_not_card greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "by (auto simp add: from_nat_to_nat_greatest nrows_def)"], ["proof (state)\nthis:\n  B =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "have zero_ikA: \"is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "fix a::'columns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "assume a_less_k: \"to_nat a < k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat a < k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have \"A $ i $ a = Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ a =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    a", "proof (rule Gauss_Jordan_in_ij_preserves_previous_elements[symmetric])"], ["proof (state)\ngoal (5 subgoals):\n 1. reduced_row_echelon_form_upt_k A k\n 2. \\<not> is_zero_row_upt_k ?a k A\n 3. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 4. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 5. mod_type_class.to_nat a < k", "show \"reduced_row_echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "using rref"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (4 subgoals):\n 1. \\<not> is_zero_row_upt_k ?a k A\n 2. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 3. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 4. mod_type_class.to_nat a < k", "show \"\\<not> is_zero_row_upt_k m k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "."], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (3 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 2. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 3. mod_type_class.to_nat a < k", "show \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (2 subgoals):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 2. mod_type_class.to_nat a < k", "show \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "using suc_not_zero greatest_not_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < k", "show \"to_nat a < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < k", "using a_less_k"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a < k", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat a < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ a =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  a\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "also"], ["proof (state)\nthis:\n  A $ i $ a =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  a\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    a =\n    (0::'a)", "unfolding B_eq_Gauss_ij[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ i $ a = (0::'a)", "using zero_i_suc_k a_less_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) B\n  mod_type_class.to_nat a < k\n\ngoal (1 subgoal):\n 1. B $ i $ a = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < Suc k \\<longrightarrow> B $ i $ j = (0::'a)\n  mod_type_class.to_nat a < k\n\ngoal (1 subgoal):\n 1. B $ i $ a = (0::'a)", "by simp"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  a =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < k \\<Longrightarrow> A $ i $ j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  A $ i $ a = (0::'a)", "show \"A $ i $ a = 0\""], ["proof (prove)\nusing this:\n  A $ i $ a = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ a = (0::'a)", "."], ["proof (state)\nthis:\n  A $ i $ a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "hence zero_jkA: \"is_zero_row_upt_k j k A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "using rref_upt_condition1[OF rref] i_less_j"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  i < j\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j k A", "by blast"], ["proof (state)\nthis:\n  is_zero_row_upt_k j k A\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       mod_type_class.to_nat ja < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       j $\n       ja =\n       (0::'a)", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ j $ ja = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "proof (cases \"to_nat ja < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "have \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ j $ ja = A $ j $ ja\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    A $ j $ ja", "proof (rule Gauss_Jordan_in_ij_preserves_previous_elements)"], ["proof (state)\ngoal (5 subgoals):\n 1. reduced_row_echelon_form_upt_k A k\n 2. \\<not> is_zero_row_upt_k ?a k A\n 3. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 4. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 5. mod_type_class.to_nat ja < k", "show \"reduced_row_echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "using rref"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (4 subgoals):\n 1. \\<not> is_zero_row_upt_k ?a k A\n 2. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 3. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 4. mod_type_class.to_nat ja < k", "show \"\\<not> is_zero_row_upt_k m k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "."], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (3 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 2. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 3. mod_type_class.to_nat ja < k", "show \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (2 subgoals):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 2. mod_type_class.to_nat ja < k", "show \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "using suc_not_zero greatest_not_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ja < k", "show \"to_nat ja < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ja < k", "using True"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ja < k", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat ja < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  A $ j $ ja\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  A $ j $ ja\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "using zero_jkA True"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k j k A\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>ja.\n     mod_type_class.to_nat ja < k \\<longrightarrow> A $ j $ ja = (0::'a)\n  mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. A $ j $ ja = (0::'a)", "by fast"], ["proof (state)\nthis:\n  A $ j $ ja = (0::'a)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)\n 2. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "hence k_eq_ja: \"k = to_nat ja\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "using ja_less_suc_k"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat ja < k\n  mod_type_class.to_nat ja < Suc k\n\ngoal (1 subgoal):\n 1. k = mod_type_class.to_nat ja", "by simp"], ["proof (state)\nthis:\n  k = mod_type_class.to_nat ja\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat ja < k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    ja =\n    (0::'a)", "proof (unfold k_eq_ja from_nat_to_nat_id, rule Gauss_Jordan_in_ij_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ ja \\<noteq> (0::'a) \\<and>\n       (GREATEST n.\n           \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n       (1::'rows)\n       \\<le> n\n 2. j \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n    (1::'rows)", "show \"\\<exists>n. A $ n $ ja \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n (to_nat ja) A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ ja \\<noteq> (0::'a) \\<and>\n       (GREATEST n.\n           \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n       (1::'rows)\n       \\<le> n", "using A_ma_k_not_zero greatest_less_ma k_eq_ja to_nat_from_nat"], ["proof (prove)\nusing this:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  k = mod_type_class.to_nat ja\n  mod_type_class.to_nat ?j = ?k \\<Longrightarrow>\n  mod_type_class.from_nat ?k = ?j\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ ja \\<noteq> (0::'a) \\<and>\n       (GREATEST n.\n           \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n       (1::'rows)\n       \\<le> n", "by auto"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ ja \\<noteq> (0::'a) \\<and>\n     (GREATEST n. \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n     (1::'rows)\n     \\<le> n\n\ngoal (1 subgoal):\n 1. j \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n    (1::'rows)", "show \"j \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n (to_nat ja) A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n    (1::'rows)", "proof (unfold k_eq_ja[symmetric], rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j \\<noteq>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           (1::'rows) \\<Longrightarrow>\n    False", "assume \"\\<not> j \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  \\<not> j \\<noteq>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> j \\<noteq>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           (1::'rows) \\<Longrightarrow>\n    False", "hence j_eq: \"j = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\nusing this:\n  \\<not> j \\<noteq>\n         (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. j = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "by fast"], ["proof (state)\nthis:\n  j = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> j \\<noteq>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           (1::'rows) \\<Longrightarrow>\n    False", "hence \"i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\nusing this:\n  j = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "using i_less_j"], ["proof (prove)\nusing this:\n  j = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  i < j\n\ngoal (1 subgoal):\n 1. i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "by force"], ["proof (state)\nthis:\n  i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> j \\<noteq>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           (1::'rows) \\<Longrightarrow>\n    False", "hence i_le_greatest: \"i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\nusing this:\n  i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "using le_Suc not_less"], ["proof (prove)\nusing this:\n  i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  ?a < ?b \\<Longrightarrow> ?a + (1::?'a) \\<le> ?b\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "by auto"], ["proof (state)\nthis:\n  i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. \\<not> j \\<noteq>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           (1::'rows) \\<Longrightarrow>\n    False", "hence \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\nusing this:\n  i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "using greatest_ge_nonzero_row'[OF rref] not_zero_m"], ["proof (prove)\nusing this:\n  i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  \\<lbrakk>?i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A);\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_zero_row_upt_k ?i k A\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "by fast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> j \\<noteq>\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           (1::'rows) \\<Longrightarrow>\n    False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. False", "using zero_ikA"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j \\<noteq>\n  (GREATEST n. \\<not> is_zero_row_upt_k n (mod_type_class.to_nat ja) A) +\n  (1::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  ja =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and zero_i_suc_k: \"is_zero_row_upt_k i (Suc k) B\" and i_less_j: \"i < j\"\n  shows \"is_zero_row_upt_k j (Suc k) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) B", "proof (unfold B Gauss_Jordan_column_k_def ia Let_def fst_conv snd_conv, auto, unfold from_nat_to_nat_greatest)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>mod_type_class.from_nat 0.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n        mod_type_class.from_nat 0 \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                            (mod_type_class.from_nat k))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "assume zero_k: \"\\<forall>m\\<ge>from_nat 0. A $ m $ from_nat k = 0\"  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\""], ["proof (state)\nthis:\n  \\<forall>m\\<ge>mod_type_class.from_nat 0.\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>mod_type_class.from_nat 0.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n        mod_type_class.from_nat 0 \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                            (mod_type_class.from_nat k))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "show \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "using condition_1_part_1[OF zero_k all_zero]"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k ?j (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "."], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k) A\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n        mod_type_class.from_nat 0 \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                            (mod_type_class.from_nat k))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n        mod_type_class.from_nat 0 \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                            (mod_type_class.from_nat k))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "fix m"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n        mod_type_class.from_nat 0 \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                            (mod_type_class.from_nat k))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "assume all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\" and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n        mod_type_class.from_nat 0 \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                            (mod_type_class.from_nat k))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "have j_not_0: \"j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'rows)", "using i_less_j least_mod_type not_le"], ["proof (prove)\nusing this:\n  i < j\n  (0::?'a) \\<le> ?n\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. j \\<noteq> (0::'rows)", "by blast"], ["proof (state)\nthis:\n  j \\<noteq> (0::'rows)\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n        mod_type_class.from_nat 0 \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                            (mod_type_class.from_nat k))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "show \"is_zero_row_upt_k j (Suc k) (Gauss_Jordan_in_ij A (from_nat 0) (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n       (mod_type_class.from_nat k))", "using condition_1_part_2[OF j_not_0 all_zero Amk_not_zero]"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k j (Suc k)\n   (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n       (mod_type_class.from_nat k))", "."], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k)\n   (Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n     (mod_type_class.from_nat k))\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "assume not_zero_mkA: \"\\<not> is_zero_row_upt_k m k A\"\n    and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "show \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "using condition_1_part_3[OF rref i_less_j not_zero_mkA zero_below_greatest] zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k)) \\<Longrightarrow>\n  is_zero_row_upt_k j (Suc k) A\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "unfolding B ia"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k)) \\<Longrightarrow>\n  is_zero_row_upt_k j (Suc k) A\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "."], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k) A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =  nrows A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) A\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "show \"is_zero_row_upt_k j (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "using condition_1_part_4[OF rref _ i_less_j not_zero_m greatest_eq_card] zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k)) \\<Longrightarrow>\n  is_zero_row_upt_k j (Suc k) A\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "unfolding B ia nrows_def"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k)) \\<Longrightarrow>\n  is_zero_row_upt_k j (Suc k) A\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k) A", "."], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "fix m ma"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\nand greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n    and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k)\n                          (Gauss_Jordan_in_ij A\n                            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                             (1::'rows))\n                            (mod_type_class.from_nat k))", "show \"is_zero_row_upt_k j (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k))", "using condition_1_part_5[OF rref _ i_less_j not_zero_m greatest_not_card greatest_less_ma A_ma_k_not_zero]"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k)) \\<Longrightarrow>\n  is_zero_row_upt_k j (Suc k)\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k))", "using zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k)) \\<Longrightarrow>\n  is_zero_row_upt_k j (Suc k)\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k))", "unfolding B ia"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k)) \\<Longrightarrow>\n  is_zero_row_upt_k j (Suc k)\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n  is_zero_row_upt_k i (Suc k)\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                1,\n           A)\n          k))\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k j (Suc k)\n     (Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k))", "."], ["proof (state)\nthis:\n  is_zero_row_upt_k j (Suc k)\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_2_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and all_zero_k: \"\\<forall>m. A $ m $ from_nat k = 0\"\n  shows \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have ia2: \"ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = 0", "using ia all_zero"], ["proof (prove)\nusing this:\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. ia = 0", "by simp"], ["proof (state)\nthis:\n  ia = 0\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    A", "using all_zero_k"], ["proof (prove)\nusing this:\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    A", "by fastforce"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using all_zero_k condition_1_part_1[OF _ all_zero] not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n  \\<forall>m\\<ge>mod_type_class.from_nat 0.\n     A $ m $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n  is_zero_row_upt_k ?j (Suc k) A\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n  \\<forall>m\\<ge>mod_type_class.from_nat 0.\n     A $ m $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n  is_zero_row_upt_k ?j (Suc k) A\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "by presburger"], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_2_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ (LEAST ka. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ ka \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have ia2: \"ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = 0", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    0", "using all_zero"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    0", "by simp"], ["proof (state)\nthis:\n  ia = 0\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have B_eq: \"B = Gauss_Jordan_in_ij A 0 (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "unfolding B Gauss_Jordan_column_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (let i = fst (ia, A); A = snd (ia, A);\n             from_nat_i = mod_type_class.from_nat i;\n             from_nat_k = mod_type_class.from_nat k\n         in if (\\<forall>m\\<ge>from_nat_i.\n                   A $ m $ from_nat_k = (0::'a)) \\<or>\n               i = nrows A\n            then (i, A)\n            else (i + 1, Gauss_Jordan_in_ij A from_nat_i from_nat_k)) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "unfolding ia2 Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "using Amk_not_zero least_mod_type"], ["proof (prove)\nusing this:\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "unfolding from_nat_0 nrows_def"], ["proof (prove)\nusing this:\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>0::'rows.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = CARD('rows)\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (0::'rows)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "by auto"], ["proof (state)\nthis:\n  B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have i_eq_0: \"i=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (0::'rows)", "using Amk_not_zero B_eq all_zero condition_1_part_2 from_nat_0 not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)\n  \\<forall>m. is_zero_row_upt_k m k A\n  \\<lbrakk>?j \\<noteq> (0::?'rows); \\<forall>m. is_zero_row_upt_k m ?k ?A;\n   ?A $ ?m $ mod_type_class.from_nat ?k \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?j (Suc ?k)\n                     (Gauss_Jordan_in_ij ?A (mod_type_class.from_nat 0)\n                       (mod_type_class.from_nat ?k))\n  mod_type_class.from_nat 0 = (0::?'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. i = (0::'rows)", "by metis"], ["proof (state)\nthis:\n  i = (0::'rows)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have Least_eq: \"(LEAST ka. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ ka \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "have \"Gauss_Jordan_in_ij A 0 (from_nat k) $ 0 $ from_nat k = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k =\n    (1::'a)", "using Gauss_Jordan_in_ij_1 Amk_not_zero least_mod_type"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n \\<Longrightarrow>\n  Gauss_Jordan_in_ij ?A ?i ?j $ ?i $ ?j = (1::?'a)\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k =\n    (1::'a)", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "thus \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding i_eq_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "assume not_zero_gauss: \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "assume \"\\<not> from_nat k \\<le> y\""], ["proof (state)\nthis:\n  \\<not> mod_type_class.from_nat k \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "hence y: \"y < from_nat k\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.from_nat k \\<le> y\n\ngoal (1 subgoal):\n 1. y < mod_type_class.from_nat k", "by force"], ["proof (state)\nthis:\n  y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "have \"Gauss_Jordan_in_ij A 0 (from_nat k) $ 0 $ y = A $ 0 $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    y =\n    A $ (0::'rows) $ y", "by (rule Gauss_Jordan_in_ij_preserves_previous_elements'[OF all_zero to_nat_le[OF y] Amk_not_zero])"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  y =\n  A $ (0::'rows) $ y\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  y =\n  A $ (0::'rows) $ y\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (0::'rows) $ y = (0::'a)", "using all_zero to_nat_le[OF y]"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. A $ (0::'rows) $ y = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>m j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ m $ j = (0::'a)\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. A $ (0::'rows) $ y = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ (0::'rows) $ y = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  y =\n  (0::'a)", "show \"False\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  y =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using not_zero_gauss"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  y =\n  (0::'a)\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "unfolding i_eq_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  y =\n  (0::'a)\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat k \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      ka \\<noteq>\n      (0::'a)) =\n  mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "unfolding Least_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    mod_type_class.from_nat k =\n    (1::'a)", "unfolding i_eq_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k =\n    (1::'a)", "by (rule Gauss_Jordan_in_ij_1, auto intro!: Amk_not_zero least_mod_type)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_2_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  shows \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>mod_type_class.from_nat\n                     (Suc (mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A))).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     (mod_type_class.from_nat\n       (Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A))))\n     (mod_type_class.from_nat k) =\n    A", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "using zero_below_greatest"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "by blast"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "proof (cases \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 < CARD('rows)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n    < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n  < CARD('rows)\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n    < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "have \"i<(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               (1::'rows) \\<Longrightarrow>\n    False", "assume \"\\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               (1::'rows) \\<Longrightarrow>\n    False", "hence i: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> i\""], ["proof (prove)\nusing this:\n  \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> i", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               (1::'rows) \\<Longrightarrow>\n    False", "hence \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) < i\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> i\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < i", "using le_Suc' True"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> i\n  \\<lbrakk>?a + (1::?'a) \\<le> ?b;\n   mod_type_class.to_nat ?a + 1 < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a < ?b\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n  < CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < i", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < i\n\ngoal (1 subgoal):\n 1. \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               (1::'rows) \\<Longrightarrow>\n    False", "hence zero_i: \"is_zero_row_upt_k i k A\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < i\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "using not_greater_Greatest"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < i\n  (GREATEST x. ?P x) < ?k \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A", "by blast"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               (1::'rows) \\<Longrightarrow>\n    False", "hence \"is_zero_row_upt_k i (Suc k) A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k) A", "proof (unfold is_zero_row_upt_k_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j.\n                   mod_type_class.to_nat j < k \\<longrightarrow>\n                   A $ i $ j = (0::'a);\n        is_zero_row_upt_k i k A; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "fix j::'columns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j.\n                   mod_type_class.to_nat j < k \\<longrightarrow>\n                   A $ i $ j = (0::'a);\n        is_zero_row_upt_k i k A; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "assume \"to_nat j < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>j.\n                   mod_type_class.to_nat j < k \\<longrightarrow>\n                   A $ i $ j = (0::'a);\n        is_zero_row_upt_k i k A; mod_type_class.to_nat j < Suc k\\<rbrakk>\n       \\<Longrightarrow> A $ i $ j = (0::'a)", "thus \"A $ i $ j = 0\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using zero_i"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < Suc k\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < Suc k\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "using zero_below_greatest i"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j < Suc k\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> i\n\ngoal (1 subgoal):\n 1. A $ i $ j = (0::'a)", "by (metis from_nat_to_nat_id le_neq_implies_less not_le not_less_eq_eq)"], ["proof (state)\nthis:\n  A $ i $ j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<not> i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               (1::'rows) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. False", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) A\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. False", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) A\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "hence \"i\\<le>(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\nusing this:\n  i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "using not_le le_Suc"], ["proof (prove)\nusing this:\n  i < (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n  ?a < ?b \\<Longrightarrow> ?a + (1::?'a) \\<le> ?b\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "by metis"], ["proof (state)\nthis:\n  i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "using greatest_ge_nonzero_row'[OF rref] not_zero_m"], ["proof (prove)\nusing this:\n  i \\<le> (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  \\<lbrakk>?i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A);\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_zero_row_upt_k ?i k A\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "by fast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n    < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using rref_upt_condition2[OF rref]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "by blast"], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1\n         < CARD('rows)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have greatest_plus_one_eq_0: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "using to_nat_plus_one_less_card False"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n  \\<not> mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n         1\n         < CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "by blast"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "proof (rule not_is_zero_row_upt_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k i (Suc k) A\n 2. \\<forall>i. A $ i $ mod_type_class.from_nat k = (0::'a)", "show \"\\<not> is_zero_row_upt_k i (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i (Suc k) A", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i (Suc k) A", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i (Suc k) A", "."], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<forall>i. A $ i $ mod_type_class.from_nat k = (0::'a)", "show \"\\<forall>i. A $ i $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. A $ i $ mod_type_class.from_nat k = (0::'a)", "using zero_below_greatest"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. A $ i $ mod_type_class.from_nat k = (0::'a)", "unfolding greatest_plus_one_eq_0"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>i. A $ i $ mod_type_class.from_nat k = (0::'a)", "using least_mod_type"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<forall>i. A $ i $ mod_type_class.from_nat k = (0::'a)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i. A $ i $ mod_type_class.from_nat k = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.to_nat\n            (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n           1\n           < CARD('rows) \\<Longrightarrow>\n    A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using rref_upt_condition2[OF rref]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "by blast"], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_2_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "have \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow> False", "assume zero_i: \"is_zero_row_upt_k i k A\""], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow> False", "hence zero_minus_1: \"is_zero_row_upt_k (-1) k A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (- (1::'rows)) k A", "using rref_upt_condition1[OF rref]"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (- (1::'rows)) k A", "using Greatest_is_minus_1 neq_le_trans"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  \\<forall>a. a \\<le> - (1::?'a)\n  \\<lbrakk>?a \\<noteq> ?b; ?a \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (- (1::'rows)) k A", "by metis"], ["proof (state)\nthis:\n  is_zero_row_upt_k (- (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow> False", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "using greatest_plus_one_eq_0[OF greatest_eq_card]"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "."], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow> False", "hence greatest_eq_minus_1: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = -1\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "using a_eq_minus_1"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n  \\<forall>a. a + (1::?'a) = (0::?'a) \\<longrightarrow> a = - (1::?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "by fast"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow> False", "have \"\\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) k\n            A", "by (rule greatest_ge_nonzero_row'[OF rref _ ], auto intro!: not_zero_m)"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) k A\n\ngoal (1 subgoal):\n 1. False", "using zero_minus_1"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) k A\n  is_zero_row_upt_k (- (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. False", "unfolding greatest_eq_minus_1"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k (- (1::'rows)) k A\n  is_zero_row_upt_k (- (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using rref_upt_condition2[OF rref]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "by blast"], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_2_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_noteq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $\n  (LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have B_eq_Gauss: \"B=Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<ge>mod_type_class.from_nat\n                      (Suc (mod_type_class.to_nat\n                             (GREATEST n. \\<not> is_zero_row_upt_k n k A))).\n         A $ m $ mod_type_class.from_nat k = (0::'a)) \\<longrightarrow>\n     A =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k)) \\<and>\n    (Suc (mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n     nrows A \\<longrightarrow>\n     A =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k)) \\<and>\n    ((\\<exists>m\\<ge>mod_type_class.from_nat\n                      (Suc (mod_type_class.to_nat\n                             (GREATEST n. \\<not> is_zero_row_upt_k n k A))).\n         A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n     Suc (mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n     nrows A \\<longrightarrow>\n     Gauss_Jordan_in_ij A\n      (mod_type_class.from_nat\n        (Suc (mod_type_class.to_nat\n               (GREATEST n. \\<not> is_zero_row_upt_k n k A))))\n      (mod_type_class.from_nat k) =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k))", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     (1::'rows).\n         A $ m $ mod_type_class.from_nat k = (0::'a)) \\<longrightarrow>\n     A =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k)) \\<and>\n    (Suc (mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n     nrows A \\<longrightarrow>\n     A =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k)) \\<and>\n    ((\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     (1::'rows).\n         A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n     Suc (mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n     nrows A \\<longrightarrow>\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k) =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k))", "using greatest_noteq_card A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. ((\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     (1::'rows).\n         A $ m $ mod_type_class.from_nat k = (0::'a)) \\<longrightarrow>\n     A =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k)) \\<and>\n    (Suc (mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n     nrows A \\<longrightarrow>\n     A =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k)) \\<and>\n    ((\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                     (1::'rows).\n         A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n     Suc (mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n     nrows A \\<longrightarrow>\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k) =\n     Gauss_Jordan_in_ij A\n      ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n      (mod_type_class.from_nat k))", "by blast"], ["proof (state)\nthis:\n  B =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have greatest_plus_one_not_zero: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "using suc_not_zero greatest_noteq_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "by auto"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "proof (cases \"is_zero_row_upt_k i k A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "case True"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "hence not_zero_iB: \"is_zero_row_upt_k i k B\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k B", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow> B $ i $ j = (0::'a)", "unfolding B_eq_Gauss"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       j =\n       (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ greatest_plus_one_not_zero]"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)\n  \\<lbrakk>\\<exists>m.\n              A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n              \\<le> m;\n   mod_type_class.to_nat ?j < k\\<rbrakk>\n  \\<Longrightarrow> Gauss_Jordan_in_ij A\n                     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                      (1::'rows))\n                     (mod_type_class.from_nat k) $\n                    ?i $\n                    ?j =\n                    A $ ?i $ ?j\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       j =\n       (0::'a)", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ i $ j = (0::'a)\n  \\<lbrakk>\\<exists>m.\n              A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n              \\<le> m;\n   mod_type_class.to_nat ?j < k\\<rbrakk>\n  \\<Longrightarrow> Gauss_Jordan_in_ij A\n                     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                      (1::'rows))\n                     (mod_type_class.from_nat k) $\n                    ?i $\n                    ?j =\n                    A $ ?i $ ?j\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < k \\<longrightarrow>\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       j =\n       (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k B\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "hence Gauss_Jordan_i_not_0: \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (from_nat k) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k B\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding B_eq_Gauss"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (Gauss_Jordan_in_ij A\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     Gauss_Jordan_in_ij A\n      ((GREATEST n.\n           \\<not> (\\<forall>j.\n                      mod_type_class.to_nat j < k \\<longrightarrow>\n                      A $ n $ j = (0::'a))) +\n       (1::'rows))\n      (mod_type_class.from_nat k) $\n     i $\n     j =\n     (0::'a)\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < Suc k \\<longrightarrow>\n             Gauss_Jordan_in_ij A\n              ((GREATEST n.\n                   \\<not> (\\<forall>j.\n                              mod_type_class.to_nat j < k \\<longrightarrow>\n                              A $ n $ j = (0::'a))) +\n               (1::'rows))\n              (mod_type_class.from_nat k) $\n             i $\n             j =\n             (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n.\n          \\<not> (\\<forall>j.\n                     mod_type_class.to_nat j < k \\<longrightarrow>\n                     A $ n $ j = (0::'a))) +\n      (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using from_nat_to_nat_id less_Suc_eq"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow>\n     Gauss_Jordan_in_ij A\n      ((GREATEST n.\n           \\<not> (\\<forall>j.\n                      mod_type_class.to_nat j < k \\<longrightarrow>\n                      A $ n $ j = (0::'a))) +\n       (1::'rows))\n      (mod_type_class.from_nat k) $\n     i $\n     j =\n     (0::'a)\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < Suc k \\<longrightarrow>\n             Gauss_Jordan_in_ij A\n              ((GREATEST n.\n                   \\<not> (\\<forall>j.\n                              mod_type_class.to_nat j < k \\<longrightarrow>\n                              A $ n $ j = (0::'a))) +\n               (1::'rows))\n              (mod_type_class.from_nat k) $\n             i $\n             j =\n             (0::'a))\n  mod_type_class.from_nat (mod_type_class.to_nat ?x) = ?x\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n.\n          \\<not> (\\<forall>j.\n                     mod_type_class.to_nat j < k \\<longrightarrow>\n                     A $ n $ j = (0::'a))) +\n      (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis (lifting, no_types))"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have \"i = ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "assume i_not_greatest: \"i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "have \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (from_nat k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule Gauss_Jordan_in_ij_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 2. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "using i_not_greatest"], ["proof (prove)\nusing this:\n  i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "."], ["proof (state)\nthis:\n  i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using Gauss_Jordan_i_not_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (0::'a)\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "hence Gauss_Jordan_i_1: \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (from_nat k) = 1\""], ["proof (prove)\nusing this:\n  i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k =\n    (1::'a)", "using Gauss_Jordan_in_ij_1"], ["proof (prove)\nusing this:\n  i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  \\<exists>n.\n     ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n \\<Longrightarrow>\n  Gauss_Jordan_in_ij ?A ?i ?j $ ?i $ ?j = (1::?'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k =\n    (1::'a)", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  \\<exists>n.\n     ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n \\<Longrightarrow>\n  Gauss_Jordan_in_ij ?A ?i ?j $ ?i $ ?j = (1::?'a)\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k =\n    (1::'a)", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have Least_eq_k: \"(LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using Gauss_Jordan_i_not_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show  \"\\<And>y. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ y \\<noteq> 0 \\<Longrightarrow> from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "using B_eq_Gauss is_zero_row_upt_k_def not_less not_zero_iB to_nat_le"], ["proof (prove)\nusing this:\n  B =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k)\n  is_zero_row_upt_k ?i ?k ?A =\n  (\\<forall>j.\n      mod_type_class.to_nat j < ?k \\<longrightarrow> ?A $ ?i $ j = (0::?'a))\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n  is_zero_row_upt_k i k B\n  ?y < mod_type_class.from_nat ?k \\<Longrightarrow>\n  mod_type_class.to_nat ?y < ?k\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "by fast"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  ?y \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  mod_type_class.from_nat k \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "using Gauss_Jordan_i_1"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "unfolding Least_eq_k"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k =\n    (1::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "obtain j where Aij_not_0: \"A $ i $ j \\<noteq> 0\" and j_le_k: \"to_nat j < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>A $ i $ j \\<noteq> (0::'a);\n         mod_type_class.to_nat j < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>A $ i $ j \\<noteq> (0::'a);\n         mod_type_class.to_nat j < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>A $ i $ j \\<noteq> (0::'a);\n         mod_type_class.to_nat j < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $ i $ j \\<noteq> (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have least_le_k: \"to_nat (LEAST ka. A $ i $ ka \\<noteq> 0) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k", "by (metis (lifting, mono_tags) Aij_not_0 j_le_k less_trans linorder_cases not_less_Least to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have least_le_j: \"(LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a))\n    \\<le> j", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ greatest_plus_one_not_zero j_le_k]"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  j =\n  A $ ?i $ j\n\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a))\n    \\<le> j", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  j =\n  A $ ?i $ j\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a))\n    \\<le> j", "using Aij_not_0 False not_le_imp_less not_less_Least"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  j =\n  A $ ?i $ j\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ i $ j \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k i k A\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n  ?k < (LEAST x. ?P x) \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a))\n    \\<le> j", "by (metis (mono_tags))"], ["proof (state)\nthis:\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a))\n  \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have Least_eq: \"(LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) \n      = (LEAST ka. A $ i $ ka \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (LEAST ka. A $ i $ ka \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref False _ greatest_plus_one_not_zero] least_le_k False rref_upt_condition2[OF rref]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>m.\n              A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n              \\<le> m;\n   mod_type_class.to_nat ?j < k\\<rbrakk>\n  \\<Longrightarrow> Gauss_Jordan_in_ij A\n                     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                      (1::'rows))\n                     (mod_type_class.from_nat k) $\n                    ?i $\n                    ?j =\n                    A $ ?i $ ?j\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n  \\<not> is_zero_row_upt_k i k A\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using  A_ma_k_not_zero B_eq_Gauss greatest_less_ma zero_neq_one"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>m.\n              A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n              \\<le> m;\n   mod_type_class.to_nat ?j < k\\<rbrakk>\n  \\<Longrightarrow> Gauss_Jordan_in_ij A\n                     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                      (1::'rows))\n                     (mod_type_class.from_nat k) $\n                    ?i $\n                    ?j =\n                    A $ ?i $ ?j\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n  \\<not> is_zero_row_upt_k i k A\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  B =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  (0::?'a) \\<noteq> (1::?'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "assume Gauss_Jordan_y:\"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST ka. A $ i $ ka \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "proof (cases \"to_nat y < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "using least_le_k less_trans not_le_imp_less to_nat_from_nat to_nat_le"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat y < k\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n  mod_type_class.to_nat ?j = ?k \\<Longrightarrow>\n  mod_type_class.from_nat ?k = ?j\n  ?y < mod_type_class.from_nat ?k \\<Longrightarrow>\n  mod_type_class.to_nat ?y < ?k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by metis"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "have \"A $ i $ y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_y"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ greatest_plus_one_not_zero True]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "using Least_le"], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by fastforce"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "have \"A $ i $ (LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "using False"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. A $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "using rref_upt_condition2[OF rref]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "unfolding Least_eq"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) = (1::'a)", "by blast"], ["proof (state)\nthis:\n  A $ i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "unfolding Least_eq"], ["proof (prove)\nusing this:\n  A $ i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n    (1::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref False _ greatest_plus_one_not_zero]"], ["proof (prove)\nusing this:\n  A $ i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) = (1::'a)\n  \\<lbrakk>\\<exists>m.\n              A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n              \\<le> m;\n   mod_type_class.to_nat ?j < k\\<rbrakk>\n  \\<Longrightarrow> Gauss_Jordan_in_ij A\n                     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                      (1::'rows))\n                     (mod_type_class.from_nat k) $\n                    ?i $\n                    ?j =\n                    A $ ?i $ ?j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n    (1::'a)", "using least_le_k A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  A $ i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) = (1::'a)\n  \\<lbrakk>\\<exists>m.\n              A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n              \\<le> m;\n   mod_type_class.to_nat ?j < k\\<rbrakk>\n  \\<Longrightarrow> Gauss_Jordan_in_ij A\n                     ((GREATEST m. \\<not> is_zero_row_upt_k m k A) +\n                      (1::'rows))\n                     (mod_type_class.from_nat k) $\n                    ?i $\n                    ?j =\n                    A $ ?i $ ?j\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n    (1::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  shows \"B $ i $ (LEAST k. B $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ i $ (LEAST k. B $ i $ k \\<noteq> (0::'a)) = (1::'a)", "proof (unfold B Gauss_Jordan_column_k_def ia Let_def fst_conv snd_conv, auto, unfold from_nat_to_nat_greatest from_nat_0)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>0::'rows.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                      (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "assume all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\" and all_zero_k: \"\\<forall>m\\<ge>0. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>0::'rows.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                      (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "show \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using condition_2_part_1[OF _ all_zero] not_zero_i_suc_k all_zero_k least_mod_type"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> A $ ?i $ (LEAST k. A $ ?i $ k \\<noteq> (0::'a)) =\n                    (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> A $ ?i $ (LEAST k. A $ ?i $ k \\<noteq> (0::'a)) =\n                    (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "by blast"], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "fix m"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "assume all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n    and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "show \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ (LEAST ka. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ ka \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "using condition_2_part_2[OF _ all_zero Amk_not_zero] not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "show \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using condition_2_part_3[OF rref _ not_zero_m zero_below_greatest] not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ ?i $ (LEAST k. A $ ?i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ ?i $ (LEAST k. A $ ?i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "."], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) =\n                         (1::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "show \"A $ i $ (LEAST k. A $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using condition_2_part_4[OF rref not_zero_m greatest_eq_card]"], ["proof (prove)\nusing this:\n  A $ ?i $ (LEAST k. A $ ?i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)", "."], ["proof (state)\nthis:\n  A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "fix m ma"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_noteq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n    and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n    and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         i $\n                         (LEAST ka.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             ka \\<noteq>\n                             (0::'a)) =\n                         (1::'a)", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i \n    $ (LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "using condition_2_part_5[OF rref _ not_zero_m greatest_noteq_card greatest_less_ma A_ma_k_not_zero] not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      ?i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      ?i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (1::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_3_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and all_zero_k: \"\\<forall>m. A $ m $ from_nat k = 0\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have ia2: \"ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = 0", "using ia all_zero"], ["proof (prove)\nusing this:\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. ia = 0", "by simp"], ["proof (state)\nthis:\n  ia = 0\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    A", "using all_zero_k"], ["proof (prove)\nusing this:\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    A", "by fastforce"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have \"is_zero_row_upt_k i (Suc k) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k) B", "using all_zero all_zero_k"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i (Suc k) B", "unfolding B_eq_A is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>m j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ m $ j = (0::'a)\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < Suc k \\<longrightarrow> A $ i $ j = (0::'a)", "by (metis less_SucE to_nat_from_nat)"], ["proof (state)\nthis:\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "by contradiction"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_3_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_notzero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"(LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ n \\<noteq> 0) < (LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have ia2: \"ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = 0", "using ia all_zero"], ["proof (prove)\nusing this:\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. ia = 0", "by simp"], ["proof (state)\nthis:\n  ia = 0\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have B_eq_Gauss: \"B = Gauss_Jordan_in_ij A 0 (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "using all_zero Amk_notzero least_mod_type"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "unfolding from_nat_0"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>0::'rows.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (0::'rows)\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)", "by auto"], ["proof (state)\nthis:\n  B = Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have \"i=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (0::'rows)", "using all_zero_imp_Gauss_Jordan_column_not_zero_in_row_0[OF all_zero _ Amk_notzero] not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  ?i = (0::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. i = (0::'rows)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  ?i = (0::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. i = (0::'rows)", "."], ["proof (state)\nthis:\n  i = (0::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "moreover"], ["proof (state)\nthis:\n  i = (0::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have \"i+1=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + (1::'rows) = (0::'rows)", "using all_zero_imp_Gauss_Jordan_column_not_zero_in_row_0[OF all_zero _ Amk_notzero] not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  ?i = (0::'rows)\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. i + (1::'rows) = (0::'rows)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  ?i = (0::'rows)\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. i + (1::'rows) = (0::'rows)", "."], ["proof (state)\nthis:\n  i + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  i = (0::'rows)\n  i + (1::'rows) = (0::'rows)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = (0::'rows)\n  i + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "using i_le"], ["proof (prove)\nusing this:\n  i = (0::'rows)\n  i + (1::'rows) = (0::'rows)\n  i < i + (1::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "by auto"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        n \\<noteq>\n        (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_3_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>mod_type_class.from_nat\n                     (Suc (mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A))).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     (mod_type_class.from_nat\n       (Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A))))\n     (mod_type_class.from_nat k) =\n    A", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "using zero_below_greatest"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "by blast"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have rref_suc: \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "proof (rule rref_suc_if_zero_below_greatest)"], ["proof (state)\ngoal (3 subgoals):\n 1. reduced_row_echelon_form_upt_k A k\n 2. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n 3. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "show \"reduced_row_echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "using rref"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (2 subgoals):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n 2. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "show \"\\<not> (\\<forall>a. is_zero_row_upt_k a k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row_upt_k a k A)", "by fast"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\n\ngoal (1 subgoal):\n 1. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "show \"\\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A. is_zero_row_upt_k a (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n       is_zero_row_upt_k a (Suc k) A", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a \\<Longrightarrow>\n       is_zero_row_upt_k a (Suc k) A", "fix a::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a \\<Longrightarrow>\n       is_zero_row_upt_k a (Suc k) A", "assume greatest_less_a:  \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) < a\""], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a \\<Longrightarrow>\n       is_zero_row_upt_k a (Suc k) A", "show \"is_zero_row_upt_k a (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a (Suc k) A", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k a k A\n 2. A $ a $ mod_type_class.from_nat k = (0::'a)", "show \"is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "using greatest_less_a row_greater_greatest_is_zero"], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a\n  (GREATEST m. \\<not> is_zero_row_upt_k m ?k ?A) < ?i \\<Longrightarrow>\n  is_zero_row_upt_k ?i ?k ?A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "by fast"], ["proof (state)\nthis:\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "show \"A $ a $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "using  le_Suc[OF greatest_less_a] zero_below_greatest"], ["proof (prove)\nusing this:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> a\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "by fast"], ["proof (state)\nthis:\n  A $ a $ mod_type_class.from_nat k = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a>GREATEST m. \\<not> is_zero_row_upt_k m k A.\n     is_zero_row_upt_k a (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A (Suc k)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using rref_upt_condition3[OF rref_suc] i_le not_zero_i_suc_k not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i < i + (1::'rows) \\<and>\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<and>\n     \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  i < i + (1::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i < i + (1::'rows) \\<and>\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<and>\n     \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  i < i + (1::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_3_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\" and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "using greatest_eq_card"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "by simp"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have greatest_eq_minus_1: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "using a_eq_minus_1 greatest_eq_card to_nat_plus_one_less_card"], ["proof (prove)\nusing this:\n  \\<forall>a. a + (1::?'a) = (0::?'a) \\<longrightarrow> a = - (1::?'a)\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  \\<forall>a. a + (1::?'a) = (0::?'a) \\<longrightarrow> a = - (1::?'a)\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  CARD('rows)\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "by fastforce"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "have rref_suc: \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "proof (rule rref_suc_if_all_rows_not_zero)"], ["proof (state)\ngoal (2 subgoals):\n 1. reduced_row_echelon_form_upt_k A k\n 2. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "show \"reduced_row_echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "using rref"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "show \"\\<forall>n. \\<not> is_zero_row_upt_k n k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "using Greatest_is_minus_1 greatest_eq_minus_1 greatest_ge_nonzero_row'[OF rref _] not_zero_m"], ["proof (prove)\nusing this:\n  \\<forall>a. a \\<le> - (1::?'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n  \\<lbrakk>?i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A);\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_zero_row_upt_k ?i k A\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "by metis"], ["proof (state)\nthis:\n  \\<forall>n. \\<not> is_zero_row_upt_k n k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A (Suc k)\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using rref_upt_condition3[OF rref_suc] i_le not_zero_i_suc_k not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i < i + (1::'rows) \\<and>\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<and>\n     \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  i < i + (1::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i < i + (1::'rows) \\<and>\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<and>\n     \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  i < i + (1::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_3_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"(LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0)\n  < (LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have B_eq_Gauss: \"B = Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "unfolding B Gauss_Jordan_column_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (let i = fst (ia, A); A = snd (ia, A);\n             from_nat_i = mod_type_class.from_nat i;\n             from_nat_k = mod_type_class.from_nat k\n         in if (\\<forall>m\\<ge>from_nat_i.\n                   A $ m $ from_nat_k = (0::'a)) \\<or>\n               i = nrows A\n            then (i, A)\n            else (i + 1, Gauss_Jordan_in_ij A from_nat_i from_nat_k)) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "unfolding ia2 Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "using greatest_not_card greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "by (auto simp add: from_nat_to_nat_greatest)"], ["proof (state)\nthis:\n  B =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have suc_greatest_not_zero: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "using Suc_eq_plus1 suc_not_zero greatest_not_card"], ["proof (prove)\nusing this:\n  Suc ?n = ?n + 1\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc ?n = ?n + 1\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "by auto"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "proof (cases \"is_zero_row_upt_k (i + 1) k A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "case True"], ["proof (state)\nthis:\n  is_zero_row_upt_k (i + (1::'rows)) k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have zero_i_plus_one_k_B: \"is_zero_row_upt_k (i+1) k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k (i + (1::'rows)) k B", "by (unfold B_eq_Gauss, rule is_zero_after_Gauss[OF True not_zero_m rref greatest_less_ma A_ma_k_not_zero])"], ["proof (state)\nthis:\n  is_zero_row_upt_k (i + (1::'rows)) k B\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "hence Gauss_Jordan_i_not_0: \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i+1) $ (from_nat k) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (i + (1::'rows)) k B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (i + (1::'rows)) k B\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding B_eq_Gauss"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (i + (1::'rows)) k\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n          (Gauss_Jordan_in_ij A\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using is_zero_row_upt_k_suc"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k (i + (1::'rows)) k\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n          (Gauss_Jordan_in_ij A\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k))\n  \\<lbrakk>is_zero_row_upt_k ?i ?k ?A;\n   ?A $ ?i $ mod_type_class.from_nat ?k = (0::?'b)\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?i (Suc ?k) ?A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have i_plus_one_eq: \"i + 1 = ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + (1::'rows) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i + (1::'rows) \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "assume i_not_greatest: \"i + 1 \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  i + (1::'rows) \\<noteq>\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i + (1::'rows) \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "have \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i + 1) $ (from_nat k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule Gauss_Jordan_in_ij_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 2. i + (1::'rows) \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "using greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. i + (1::'rows) \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"i + 1 \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + (1::'rows) \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "using i_not_greatest"], ["proof (prove)\nusing this:\n  i + (1::'rows) \\<noteq>\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i + (1::'rows) \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "."], ["proof (state)\nthis:\n  i + (1::'rows) \\<noteq>\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i + (1::'rows) \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using Gauss_Jordan_i_not_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  mod_type_class.from_nat k =\n  (0::'a)\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i + (1::'rows) = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "hence i_eq_greatest: \"i=(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\nusing this:\n  i + (1::'rows) = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i = (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "using add_right_cancel"], ["proof (prove)\nusing this:\n  i + (1::'rows) = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  (?b + ?a = ?c + ?a) = (?b = ?c)\n\ngoal (1 subgoal):\n 1. i = (GREATEST n. \\<not> is_zero_row_upt_k n k A)", "by simp"], ["proof (state)\nthis:\n  i = (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have Least_eq_k: \"(LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i+1) $ ka \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        ka \\<noteq>\n        (0::'a)) =\n    mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i+1) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by (metis Gauss_Jordan_i_not_0)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "assume \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i+1) $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "thus \"from_nat k \\<le> y\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "using zero_i_plus_one_k_B"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n  is_zero_row_upt_k (i + (1::'rows)) k B\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "unfolding i_eq_greatest B_eq_Gauss"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n  is_zero_row_upt_k\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "by (metis is_zero_row_upt_k_def not_less to_nat_le)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      (i + (1::'rows)) $\n      ka \\<noteq>\n      (0::'a)) =\n  mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have not_zero_i_A: \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "using greatest_less_zero_row[OF rref] not_zero_m"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k ?i k A;\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "unfolding i_eq_greatest"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_zero_row_upt_k ?i k A;\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> (GREATEST m. \\<not> is_zero_row_upt_k m k A) < ?i\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (GREATEST n. \\<not> is_zero_row_upt_k n k A) k\n            A", "by fast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "from this"], ["proof (chain)\npicking this:\n  \\<not> is_zero_row_upt_k i k A", "obtain j where Aij_not_0: \"A $ i $ j \\<noteq> 0\" and j_le_k: \"to_nat j < k\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>A $ i $ j \\<noteq> (0::'a);\n         mod_type_class.to_nat j < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>A $ i $ j \\<noteq> (0::'a);\n         mod_type_class.to_nat j < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ i $ j \\<noteq> (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have least_le_k: \"to_nat (LEAST ka. A $ i $ ka \\<noteq> 0) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k", "by (metis (lifting, mono_tags) Aij_not_0 j_le_k less_trans linorder_cases not_less_Least to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have Least_eq: \" (LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0) = \n      (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (LEAST ka. A $ i $ ka \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_i_A _ suc_greatest_not_zero least_le_k] greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using rref_upt_condition2[OF rref] not_zero_i_A"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "assume Gauss_Jordan_y:\"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST ka. A $ i $ ka \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "proof (cases \"to_nat y < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by (metis not_le least_le_k less_trans to_nat_mono)"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "have \"A $ i $ y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_y"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ suc_greatest_not_zero True]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "using Least_le"], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by fastforce"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "also"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have \"... < from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k", "by (metis is_zero_row_upt_k_def is_zero_row_upt_k_suc le_less_linear le_less_trans least_le_k not_zero_suc_i_suc_k to_nat_mono' zero_i_plus_one_k_B)"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) < mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))\n 2. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "finally"], ["proof (chain)\npicking this:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a))\n  < mod_type_class.from_nat k", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a))\n  < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "unfolding Least_eq_k"], ["proof (prove)\nusing this:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a))\n  < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < mod_type_class.from_nat k", "."], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        n \\<noteq>\n        (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have not_zero_i_A: \"\\<not> is_zero_row_upt_k i k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "using rref_upt_condition1[OF rref] False i_le"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     is_zero_row_upt_k i k A \\<longrightarrow>\n     \\<not> (\\<exists>j>i. \\<not> is_zero_row_upt_k j k A)\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) k A\n  i < i + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "from this"], ["proof (chain)\npicking this:\n  \\<not> is_zero_row_upt_k i k A", "obtain j where Aij_not_0: \"A $ i $ j \\<noteq> 0\" and j_le_k: \"to_nat j < k\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>A $ i $ j \\<noteq> (0::'a);\n         mod_type_class.to_nat j < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>A $ i $ j \\<noteq> (0::'a);\n         mod_type_class.to_nat j < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ i $ j \\<noteq> (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have least_le_k: \"to_nat (LEAST ka. A $ i $ ka \\<noteq> 0) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k", "by (metis (lifting, mono_tags) Aij_not_0 j_le_k less_trans linorder_cases not_less_Least to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have Least_i_eq: \"(LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0)\n      = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ i $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (LEAST ka. A $ i $ ka \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_i_A _ suc_greatest_not_zero least_le_k] greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using rref_upt_condition2[OF rref] not_zero_i_A"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "assume Gauss_Jordan_y:\"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ i $ n \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST ka. A $ i $ ka \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "proof (cases \"to_nat y < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by (metis not_le not_less_iff_gr_or_eq le_less_trans least_le_k to_nat_mono)"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "have \"A $ i $ y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_y"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ suc_greatest_not_zero True]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "using Least_le"], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by fastforce"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "from False"], ["proof (chain)\npicking this:\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) k A", "obtain s where Ais_not_0: \"A $ (i+1) $ s \\<noteq> 0\" and s_le_k: \"to_nat s < k\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>A $ (i + (1::'rows)) $ s \\<noteq> (0::'a);\n         mod_type_class.to_nat s < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ (i + (1::'rows)) $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>A $ (i + (1::'rows)) $ s \\<noteq> (0::'a);\n         mod_type_class.to_nat s < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A $ (i + (1::'rows)) $ s \\<noteq> (0::'a)\n  mod_type_class.to_nat s < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have least_le_k: \"to_nat (LEAST ka. A $ (i+1) $ ka \\<noteq> 0) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a))\n    < k", "by (metis (lifting, mono_tags) Ais_not_0 s_le_k neq_iff less_trans not_less_Least to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a))\n  < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "have Least_i_plus_one_eq: \"(LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i+1) $ n \\<noteq> 0)\n      = (LEAST n. A $ (i+1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        n \\<noteq>\n        (0::'a)) =\n    (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a)) \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i+1) $ (LEAST ka. A $ (i+1) $ ka \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_i_A _ suc_greatest_not_zero least_le_k] greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using rref_upt_condition2[OF rref] False"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) k A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    (i + (1::'rows)) $\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a)) \\<le> y", "assume Gauss_Jordan_y:\"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i+1) $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       (i + (1::'rows)) $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST ka. A $ (i+1) $ ka \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "proof (cases \"to_nat y < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "by (metis (mono_tags) le_less_linear least_le_k less_trans to_nat_mono)"], ["proof (state)\nthis:\n  (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "have \"A $ (i+1) $ y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (i + (1::'rows)) $ y \\<noteq> (0::'a)", "using Gauss_Jordan_y"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ (i + (1::'rows)) $ y \\<noteq> (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ suc_greatest_not_zero True]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n\ngoal (1 subgoal):\n 1. A $ (i + (1::'rows)) $ y \\<noteq> (0::'a)", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  (i + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. A $ (i + (1::'rows)) $ y \\<noteq> (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ (i + (1::'rows)) $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ (i + (1::'rows)) $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "using Least_le"], ["proof (prove)\nusing this:\n  A $ (i + (1::'rows)) $ y \\<noteq> (0::'a)\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y", "by fastforce"], ["proof (state)\nthis:\n  (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka. A $ (i + (1::'rows)) $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      (i + (1::'rows)) $\n      n \\<noteq>\n      (0::'a)) =\n  (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<Longrightarrow>\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "unfolding Least_i_plus_one_eq Least_i_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using rref_upt_condition3[OF rref] i_le False not_zero_i_A"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     i < i + (1::'rows) \\<and>\n     \\<not> is_zero_row_upt_k i k A \\<and>\n     \\<not> is_zero_row_upt_k (i + (1::'rows)) k A \\<longrightarrow>\n     (LEAST n. A $ i $ n \\<noteq> (0::'a))\n     < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  i < i + (1::'rows)\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) k A\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        n \\<noteq>\n        (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        n \\<noteq>\n        (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and i_le: \"i < i + 1\"\n  and not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and not_zero_suc_i_suc_k: \"\\<not> is_zero_row_upt_k (i + 1) (Suc k) B\"\n  shows \"(LEAST n. B $ i $ n \\<noteq> 0) < (LEAST n. B $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. B $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. B $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "proof (unfold B Gauss_Jordan_column_k_def ia Let_def fst_conv snd_conv, auto, unfold from_nat_to_nat_greatest from_nat_0)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>0::'rows.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                      < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A (0::'rows)\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "assume all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n    and all_zero_k: \"\\<forall>m\\<ge>0. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>0::'rows.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                      < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A (0::'rows)\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using condition_3_part_1[OF _ all_zero]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ ?i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (?i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using all_zero_k least_mod_type not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ ?i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (?i + (1::'rows)) $ n \\<noteq> (0::'a))\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n  (0::?'a) \\<le> ?n\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ ?i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (?i + (1::'rows)) $ n \\<noteq> (0::'a))\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n  (0::?'a) \\<le> ?n\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "by fast"], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A (0::'rows)\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A (0::'rows)\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "fix m"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A (0::'rows)\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "assume all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n    and Amk_notzero: \"A $ m $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A (0::'rows)\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ n \\<noteq> 0) < (LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "using condition_3_part_2[OF i_le _ _ all_zero Amk_notzero]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Gauss_Jordan_in_ij A (0::'rows)\n                         (mod_type_class.from_nat k) $\n                        i $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          Gauss_Jordan_in_ij A (0::'rows)\n                           (mod_type_class.from_nat k) $\n                          (i + (1::'rows)) $\n                          n \\<noteq>\n                          (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "using not_zero_i_suc_k not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Gauss_Jordan_in_ij A (0::'rows)\n                         (mod_type_class.from_nat k) $\n                        i $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          Gauss_Jordan_in_ij A (0::'rows)\n                           (mod_type_class.from_nat k) $\n                          (i + (1::'rows)) $\n                          n \\<noteq>\n                          (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Gauss_Jordan_in_ij A (0::'rows)\n                         (mod_type_class.from_nat k) $\n                        i $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          Gauss_Jordan_in_ij A (0::'rows)\n                           (mod_type_class.from_nat k) $\n                          (i + (1::'rows)) $\n                          n \\<noteq>\n                          (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "."], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        n \\<noteq>\n        (0::'a))\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using condition_3_part_3[OF rref i_le _ _ not_zero_m zero_below_greatest]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using not_zero_i_suc_k not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "."], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. A $ i $ n \\<noteq> 0) < (LEAST n. A $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using condition_3_part_4[OF rref i_le _ _ not_zero_m greatest_eq_card]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using not_zero_i_suc_k not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. (LEAST n. A $ i $ n \\<noteq> (0::'a))\n    < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "."], ["proof (state)\nthis:\n  (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  < (LEAST n. A $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "fix m ma"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n    and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n    and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a))\n                         < (LEAST n.\n                               Gauss_Jordan_in_ij A\n                                ((GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                 (1::'rows))\n                                (mod_type_class.from_nat k) $\n                               (i + (1::'rows)) $\n                               n \\<noteq>\n                               (0::'a))", "show \"(LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0) \n    < (LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "using condition_3_part_5[OF rref i_le _ _ not_zero_m greatest_not_card greatest_less_ma A_ma_k_not_zero]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Gauss_Jordan_in_ij A\n                         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          (1::'rows))\n                         (mod_type_class.from_nat k) $\n                        i $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          Gauss_Jordan_in_ij A\n                           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                            (1::'rows))\n                           (mod_type_class.from_nat k) $\n                          (i + (1::'rows)) $\n                          n \\<noteq>\n                          (0::'a))\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "using not_zero_i_suc_k not_zero_suc_i_suc_k"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Gauss_Jordan_in_ij A\n                         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          (1::'rows))\n                         (mod_type_class.from_nat k) $\n                        i $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          Gauss_Jordan_in_ij A\n                           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                            (1::'rows))\n                           (mod_type_class.from_nat k) $\n                          (i + (1::'rows)) $\n                          n \\<noteq>\n                          (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                        1,\n                   A)\n                  k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        Gauss_Jordan_in_ij A\n                         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                          (1::'rows))\n                         (mod_type_class.from_nat k) $\n                        i $\n                        n \\<noteq>\n                        (0::'a))\n                    < (LEAST n.\n                          Gauss_Jordan_in_ij A\n                           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                            (1::'rows))\n                           (mod_type_class.from_nat k) $\n                          (i + (1::'rows)) $\n                          n \\<noteq>\n                          (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n  \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a))\n    < (LEAST n.\n          Gauss_Jordan_in_ij A\n           ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n           (mod_type_class.from_nat k) $\n          (i + (1::'rows)) $\n          n \\<noteq>\n          (0::'a))", "."], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a))\n  < (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        (i + (1::'rows)) $\n        n \\<noteq>\n        (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_4_part_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and all_zero_k: \"\\<forall>m. A $ m $ from_nat k = 0\"\n  shows \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have ia2: \"ia = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia = 0", "using ia all_zero"], ["proof (prove)\nusing this:\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  \\<forall>m. is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. ia = 0", "by simp"], ["proof (state)\nthis:\n  ia = 0\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    A", "using all_zero_k"], ["proof (prove)\nusing this:\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat 0.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            0 = nrows A\n         then (0, A)\n         else (0 + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat 0)\n                (mod_type_class.from_nat k))) =\n    A", "by fastforce"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using B_eq_A all_zero all_zero_k is_zero_row_upt_k_suc not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  B = A\n  \\<forall>m. is_zero_row_upt_k m k A\n  \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\n  \\<lbrakk>is_zero_row_upt_k ?i ?k ?A;\n   ?A $ ?i $ mod_type_class.from_nat ?k = (0::?'b)\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?i (Suc ?k) ?A\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_4_part_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes not_zero_i_suc_k: \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A 0 (from_nat k) $ j $ (LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have i_eq_0: \"i=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (0::'rows)", "using all_zero_imp_Gauss_Jordan_column_not_zero_in_row_0[OF all_zero _ Amk_not_zero] not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  ?i = (0::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. i = (0::'rows)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k ?i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  ?i = (0::'rows)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. i = (0::'rows)", "."], ["proof (state)\nthis:\n  i = (0::'rows)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have least_eq_k: \"(LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ n \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding i_eq_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using Amk_not_zero Gauss_Jordan_in_ij_1 least_mod_type zero_neq_one"], ["proof (prove)\nusing this:\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  \\<exists>n.\n     ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n \\<Longrightarrow>\n  Gauss_Jordan_in_ij ?A ?i ?j $ ?i $ ?j = (1::?'a)\n  (0::?'a) \\<le> ?n\n  (0::?'a) \\<noteq> (1::?'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "assume Gauss_Jordan_y_not_0: \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"from_nat k \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "assume \"\\<not> from_nat k \\<le> y\""], ["proof (state)\nthis:\n  \\<not> mod_type_class.from_nat k \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "hence \"y < (from_nat k)\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.from_nat k \\<le> y\n\ngoal (1 subgoal):\n 1. y < mod_type_class.from_nat k", "by simp"], ["proof (state)\nthis:\n  y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "hence to_nat_y_less_k: \"to_nat y < k\""], ["proof (prove)\nusing this:\n  y < mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k", "using to_nat_le"], ["proof (prove)\nusing this:\n  y < mod_type_class.from_nat k\n  ?y < mod_type_class.from_nat ?k \\<Longrightarrow>\n  mod_type_class.to_nat ?y < ?k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "have \"Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $ y =\n    (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements'[OF all_zero to_nat_y_less_k Amk_not_zero] all_zero to_nat_y_less_k"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $ y =\n  A $ ?i $ y\n  \\<forall>m. is_zero_row_upt_k m k A\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $ y =\n    (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $ y =\n  A $ ?i $ y\n  \\<forall>m j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ m $ j = (0::'a)\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $ y =\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $ y =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat k \\<le> y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $ y =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using Gauss_Jordan_y_not_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $ y =\n  (0::'a)\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat k \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a)) =\n  mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "unfolding least_eq_k"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    mod_type_class.from_nat k =\n    (0::'a)", "apply (rule Gauss_Jordan_in_ij_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (0::'rows) \\<le> n\n 2. j \\<noteq> (0::'rows)", "using i_eq_0 i_not_j Amk_not_zero least_mod_type"], ["proof (prove)\nusing this:\n  i = (0::'rows)\n  i \\<noteq> j\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (0::?'a) \\<le> ?n\n\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (0::'rows) \\<le> n\n 2. j \\<noteq> (0::'rows)", "by blast+"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_4_part_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and not_zero_m: \" \\<not> is_zero_row_upt_k m k A\"\n  and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\" \n  shows \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>mod_type_class.from_nat\n                     (Suc (mod_type_class.to_nat\n                            (GREATEST n. \\<not> is_zero_row_upt_k n k A))).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     (mod_type_class.from_nat\n       (Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A))))\n     (mod_type_class.from_nat k) =\n    A", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "using zero_below_greatest"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows).\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)) \\<and>\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n    nrows A \\<longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) =\n    A", "by blast"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have rref_suc: \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "proof (rule rref_suc_if_zero_below_greatest[OF rref], auto intro!: not_zero_m)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a \\<Longrightarrow>\n       is_zero_row_upt_k a (Suc k) A", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a \\<Longrightarrow>\n       is_zero_row_upt_k a (Suc k) A", "assume greatest_less_a: \"(GREATEST m. \\<not> is_zero_row_upt_k m k A) < a\""], ["proof (state)\nthis:\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (GREATEST m. \\<not> is_zero_row_upt_k m k A) < a \\<Longrightarrow>\n       is_zero_row_upt_k a (Suc k) A", "show \"is_zero_row_upt_k a (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a (Suc k) A", "proof (rule is_zero_row_upt_k_suc)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k a k A\n 2. A $ a $ mod_type_class.from_nat k = (0::'a)", "show \"is_zero_row_upt_k a k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "using row_greater_greatest_is_zero[OF greatest_less_a]"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k a k A", "."], ["proof (state)\nthis:\n  is_zero_row_upt_k a k A\n\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "show \"A $ a $ from_nat k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "using zero_below_greatest  le_Suc[OF greatest_less_a]"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n  (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows) \\<le> a\n\ngoal (1 subgoal):\n 1. A $ a $ mod_type_class.from_nat k = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ a $ mod_type_class.from_nat k = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k a (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A (Suc k)\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using rref_upt_condition4[OF rref_suc] not_zero_i_suc_k i_not_j"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "unfolding B_eq_A"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_4_part_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have B_eq_A: \"B=A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A", "unfolding B Gauss_Jordan_column_k_def Let_def fst_conv snd_conv ia2"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "unfolding from_nat_to_nat_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "using greatest_eq_card"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    A", "by simp"], ["proof (state)\nthis:\n  B = A\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have greatest_eq_minus_1: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "using a_eq_minus_1 greatest_eq_card to_nat_plus_one_less_card"], ["proof (prove)\nusing this:\n  \\<forall>a. a + (1::?'a) = (0::?'a) \\<longrightarrow> a = - (1::?'a)\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  \\<forall>a. a + (1::?'a) = (0::?'a) \\<longrightarrow> a = - (1::?'a)\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  CARD('rows)\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "by fastforce"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "have rref_suc: \"reduced_row_echelon_form_upt_k A (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A (Suc k)", "proof (rule rref_suc_if_all_rows_not_zero)"], ["proof (state)\ngoal (2 subgoals):\n 1. reduced_row_echelon_form_upt_k A k\n 2. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "show \"reduced_row_echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "using rref"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "show \"\\<forall>n. \\<not> is_zero_row_upt_k n k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "using Greatest_is_minus_1 greatest_eq_minus_1 greatest_ge_nonzero_row'[OF rref _] not_zero_m"], ["proof (prove)\nusing this:\n  \\<forall>a. a \\<le> - (1::?'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n  \\<lbrakk>?i \\<le> (GREATEST m. \\<not> is_zero_row_upt_k m k A);\n   \\<not> (\\<forall>a. is_zero_row_upt_k a k A)\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_zero_row_upt_k ?i k A\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<forall>n. \\<not> is_zero_row_upt_k n k A", "by metis"], ["proof (state)\nthis:\n  \\<forall>n. \\<not> is_zero_row_upt_k n k A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A (Suc k)\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using rref_upt_condition4[OF rref_suc]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using not_zero_i_suc_k i_not_j"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "unfolding B_eq_A i_not_j"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i (Suc k) A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n  \\<not> is_zero_row_upt_k i (Suc k) A\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_4_part_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  and not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ j $ \n  (LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have ia2: \"ia=to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "unfolding ia"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. (if \\<forall>m. is_zero_row_upt_k m k A then 0\n     else mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n          1) =\n    mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1", "by presburger"], ["proof (state)\nthis:\n  ia =\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have B_eq_Gauss: \"B = Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "unfolding B Gauss_Jordan_column_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (let i = fst (ia, A); A = snd (ia, A);\n             from_nat_i = mod_type_class.from_nat i;\n             from_nat_k = mod_type_class.from_nat k\n         in if (\\<forall>m\\<ge>from_nat_i.\n                   A $ m $ from_nat_k = (0::'a)) \\<or>\n               i = nrows A\n            then (i, A)\n            else (i + 1, Gauss_Jordan_in_ij A from_nat_i from_nat_k)) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "unfolding ia2 Let_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "using greatest_not_card greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                              1).\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            mod_type_class.to_nat\n             (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n            1 =\n            nrows A\n         then (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1,\n               A)\n         else (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n               1 +\n               1,\n               Gauss_Jordan_in_ij A\n                (mod_type_class.from_nat\n                  (mod_type_class.to_nat\n                    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                   1))\n                (mod_type_class.from_nat k))) =\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k)", "by (auto simp add: from_nat_to_nat_greatest)"], ["proof (state)\nthis:\n  B =\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have suc_greatest_not_zero: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "using Suc_eq_plus1 suc_not_zero greatest_not_card"], ["proof (prove)\nusing this:\n  Suc ?n = ?n + 1\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc ?n = ?n + 1\n  mod_type_class.to_nat ?a + 1 \\<noteq> CARD(?'a) \\<Longrightarrow>\n  ?a + (1::?'a) \\<noteq> (0::?'a)\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  CARD('rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "by auto"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "proof (cases \"is_zero_row_upt_k i k A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k A\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have zero_i_k_B: \"is_zero_row_upt_k i k B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k B", "unfolding B_eq_Gauss"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k i k\n     (Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k))", "by (rule is_zero_after_Gauss[OF True not_zero_m rref greatest_less_ma A_ma_k_not_zero])"], ["proof (state)\nthis:\n  is_zero_row_upt_k i k B\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "hence Gauss_Jordan_i_not_0: \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ (i) $ (from_nat k) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k B\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "unfolding B_eq_Gauss"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (Gauss_Jordan_in_ij A\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using is_zero_row_upt_k_suc"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k i k\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (Gauss_Jordan_in_ij A\n            ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n            (mod_type_class.from_nat k))\n  \\<lbrakk>is_zero_row_upt_k ?i ?k ?A;\n   ?A $ ?i $ mod_type_class.from_nat ?k = (0::?'b)\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?i (Suc ?k) ?A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have i_eq_greatest: \"i = ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "assume i_not_greatest: \"i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "have \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (from_nat k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k =\n    (0::'a)", "proof (rule Gauss_Jordan_in_ij_0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 2. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "using greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "show \"i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "using i_not_greatest"], ["proof (prove)\nusing this:\n  i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)", "."], ["proof (state)\nthis:\n  i \\<noteq> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq>\n    (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n    (1::'rows) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using Gauss_Jordan_i_not_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (0::'a)\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have Gauss_Jordan_i_1: \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (from_nat k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k =\n    (1::'a)", "unfolding i_eq_greatest"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k =\n    (1::'a)", "using Gauss_Jordan_in_ij_1 greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n \\<Longrightarrow>\n  Gauss_Jordan_in_ij ?A ?i ?j $ ?i $ ?j = (1::?'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n    mod_type_class.from_nat k =\n    (1::'a)", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have Least_eq_k: \"(LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) = from_nat k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    mod_type_class.from_nat k", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "using Gauss_Jordan_i_not_0"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    mod_type_class.from_nat k \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "assume \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       mod_type_class.from_nat k \\<le> y", "thus \"from_nat k \\<le> y\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "using zero_i_k_B"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  is_zero_row_upt_k i k B\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "unfolding i_eq_greatest B_eq_Gauss"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) $\n  y \\<noteq>\n  (0::'a)\n  is_zero_row_upt_k\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)) k\n   (Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat k \\<le> y", "by (metis is_zero_row_upt_k_def not_less to_nat_le)"], ["proof (state)\nthis:\n  mod_type_class.from_nat k \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)\n 2. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "using A_ma_k_not_zero Gauss_Jordan_in_ij_0' Least_eq_k greatest_less_ma i_eq_greatest i_not_j"], ["proof (prove)\nusing this:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  \\<exists>n.\n     ?A $ n $ ?j \\<noteq> (0::?'a) \\<and> ?i \\<le> n \\<Longrightarrow>\n  \\<forall>a.\n     a \\<noteq> ?i \\<longrightarrow>\n     Gauss_Jordan_in_ij ?A ?i ?j $ a $ ?j = (0::?'a)\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  mod_type_class.from_nat k\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  i = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "by force"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "obtain n where Ain_not_0: \"A $ i $ n \\<noteq> 0\" and j_le_k: \"to_nat n < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>A $ i $ n \\<noteq> (0::'a);\n         mod_type_class.to_nat n < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>A $ i $ n \\<noteq> (0::'a);\n         mod_type_class.to_nat n < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j.\n             mod_type_class.to_nat j < k \\<longrightarrow>\n             A $ i $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>A $ i $ n \\<noteq> (0::'a);\n         mod_type_class.to_nat n < k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A $ i $ n \\<noteq> (0::'a)\n  mod_type_class.to_nat n < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have least_le_k: \"to_nat (LEAST ka. A $ i $ ka \\<noteq> 0) < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k", "by (metis (lifting, mono_tags) Ain_not_0 neq_iff j_le_k less_trans not_less_Least to_nat_mono)"], ["proof (state)\nthis:\n  mod_type_class.to_nat (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) < k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have Least_eq: \"(LEAST ka. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ ka \\<noteq> 0) \n      = (LEAST ka. A $ i $ ka \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        ka \\<noteq>\n        (0::'a)) =\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)\n 2. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ (LEAST ka. A $ i $ ka \\<noteq> 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref False _ suc_greatest_not_zero least_le_k]"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using greatest_less_ma A_ma_k_not_zero"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "using rref_upt_condition2[OF rref] False"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row_upt_k i k A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    i $\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n    (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "assume Gauss_Jordan_y:\"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ y \\<noteq> 0\""], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Gauss_Jordan_in_ij A\n        ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n        (mod_type_class.from_nat k) $\n       i $\n       y \\<noteq>\n       (0::'a) \\<Longrightarrow>\n       (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "show \"(LEAST ka. A $ i $ ka \\<noteq> 0) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "proof (cases \"to_nat y < k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> mod_type_class.to_nat y < k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n 2. \\<not> mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by (metis (mono_tags) False least_le_k less_trans not_le_imp_less to_nat_from_nat to_nat_le)"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat y < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "have \"A $ i $ y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_y"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ suc_greatest_not_zero True]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  i $\n  y \\<noteq>\n  (0::'a)\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  y =\n  A $ ?i $ y\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. A $ i $ y \\<noteq> (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat y < k \\<Longrightarrow>\n    (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  A $ i $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y", "by (rule Least_le)"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST ka.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      ka \\<noteq>\n      (0::'a)) =\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "have Gauss_Jordan_eq_A: \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ j $ (LEAST n. A $ i $ n \\<noteq> 0) =\n      A $ j $ (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "using Gauss_Jordan_in_ij_preserves_previous_elements[OF rref not_zero_m _ suc_greatest_not_zero least_le_k]"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "using A_ma_k_not_zero greatest_less_ma"], ["proof (prove)\nusing this:\n  \\<exists>m.\n     A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows)\n     \\<le> m \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST m. \\<not> is_zero_row_upt_k m k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  ?i $\n  (LEAST ka. A $ i $ ka \\<noteq> (0::'a)) =\n  A $ ?i $ (LEAST ka. A $ i $ ka \\<noteq> (0::'a))\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k i k A \\<Longrightarrow>\n    Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "unfolding Least_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    (0::'a)", "using rref_upt_condition4[OF rref]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    (0::'a)", "using False Gauss_Jordan_eq_A i_not_j"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row_upt_k i k A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n  \\<not> is_zero_row_upt_k i k A\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a))\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n    (0::'a)", "by presburger"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma condition_4:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_i_suc_k:  \"\\<not> is_zero_row_upt_k i (Suc k) B\"\n  and i_not_j: \"i \\<noteq> j\"\n  shows \"B $ j $ (LEAST n. B $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B $ j $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) = (0::'a)", "proof (unfold B Gauss_Jordan_column_k_def ia Let_def fst_conv snd_conv, auto, unfold from_nat_to_nat_greatest from_nat_0)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>0::'rows.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                      (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "assume all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n    and all_zero_k: \"\\<forall>m\\<ge>0. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A;\n     \\<forall>m\\<ge>0::'rows.\n        A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                      (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "show \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using condition_4_part_1[OF _ all_zero]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> A $ ?j $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) =\n                    (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using all_zero_k not_zero_i_suc_k least_mod_type"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> A $ ?j $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) =\n                    (0::'a)\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k)\n                   (snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n k A) +\n                                1,\n                           A)\n                          k));\n   \\<forall>m. A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> A $ ?j $ (LEAST n. A $ ?i $ n \\<noteq> (0::'a)) =\n                    (0::'a)\n  \\<forall>m\\<ge>0::'rows. A $ m $ mod_type_class.from_nat k = (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "fix m"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "assume all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n    and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m k A\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m k A; (0::'rows) \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A (0::'rows)\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A (0::'rows)\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "show \"Gauss_Jordan_in_ij A 0 (from_nat k) $ j $ (LEAST n. Gauss_Jordan_in_ij A 0 (from_nat k) $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "using condition_4_part_2[OF _ i_not_j all_zero Amk_not_zero]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "using  not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       (1::'rows).\n           A $ m $ mod_type_class.from_nat k = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "show \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using condition_4_part_3[OF rref _ i_not_j not_zero_m zero_below_greatest]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "."], ["proof (state)\nthis:\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n        nrows A\\<rbrakk>\n       \\<Longrightarrow> A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "show \"A $ j $ (LEAST n. A $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using  condition_4_part_4[OF rref _ i_not_j not_zero_m greatest_eq_card]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "."], ["proof (state)\nthis:\n  A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "fix m ma"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n    and greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n    and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n    and A_ma_k_not_zero: \"A $ ma $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m k A;\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n        nrows A;\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma;\n        A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> Gauss_Jordan_in_ij A\n                          ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                           (1::'rows))\n                          (mod_type_class.from_nat k) $\n                         j $\n                         (LEAST n.\n                             Gauss_Jordan_in_ij A\n                              ((GREATEST n.\n                                   \\<not> is_zero_row_upt_k n k A) +\n                               (1::'rows))\n                              (mod_type_class.from_nat k) $\n                             i $\n                             n \\<noteq>\n                             (0::'a)) =\n                         (0::'a)", "show \"Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ j $ \n    (LEAST n. Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k) $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "using  condition_4_part_5[OF rref _ i_not_j not_zero_m greatest_not_card greatest_less_ma A_ma_k_not_zero]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "using not_zero_i_suc_k"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k) B\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "unfolding B ia"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k)) \\<Longrightarrow>\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n  \\<not> is_zero_row_upt_k i (Suc k)\n          (snd (Gauss_Jordan_column_k\n                 (if \\<forall>m. is_zero_row_upt_k m k A then 0\n                  else mod_type_class.to_nat\n                        (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                       1,\n                  A)\n                 k))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    j $\n    (LEAST n.\n        Gauss_Jordan_in_ij A\n         ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n         (mod_type_class.from_nat k) $\n        i $\n        n \\<noteq>\n        (0::'a)) =\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A\n   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n   (mod_type_class.from_nat k) $\n  j $\n  (LEAST n.\n      Gauss_Jordan_in_ij A\n       ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n       (mod_type_class.from_nat k) $\n      i $\n      n \\<noteq>\n      (0::'a)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reduced_row_echelon_form_upt_k_Gauss_Jordan_column_k:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  defines ia:\"ia\\<equiv>(if \\<forall>m. is_zero_row_upt_k m k A then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1)\"\n  defines B:\"B\\<equiv>(snd (Gauss_Jordan_column_k (ia,A) k))\"\n  assumes rref: \"reduced_row_echelon_form_upt_k A k\"\n  shows \"reduced_row_echelon_form_upt_k B (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k B (Suc k)", "proof (rule reduced_row_echelon_form_upt_k_intro, auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) B\n 2. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) B \\<Longrightarrow>\n       B $ i $ (LEAST k. B $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 3. \\<And>i.\n       \\<lbrakk>i < i + (1::'rows); \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               B $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 4. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) B; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> B $ j $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "show \"\\<And>i j. is_zero_row_upt_k i (Suc k) B \\<Longrightarrow> i < j \\<Longrightarrow> is_zero_row_upt_k j (Suc k) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) B", "using condition_1 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>reduced_row_echelon_form_upt_k ?A ?k;\n   is_zero_row_upt_k ?i (Suc ?k)\n    (snd (Gauss_Jordan_column_k\n           (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n            else mod_type_class.to_nat\n                  (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) +\n                 1,\n            ?A)\n           ?k));\n   ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?j (Suc ?k)\n                     (snd (Gauss_Jordan_column_k\n                            (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n ?k ?A) +\n                                  1,\n                             ?A)\n                            ?k))\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  B \\<equiv> snd (Gauss_Jordan_column_k (ia, A) k)\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>is_zero_row_upt_k i (Suc k) B; i < j\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k j (Suc k) B", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>is_zero_row_upt_k ?i (Suc k) B; ?i < ?j\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?j (Suc k) B\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) B \\<Longrightarrow>\n       B $ i $ (LEAST k. B $ i $ k \\<noteq> (0::'a)) = (1::'a)\n 2. \\<And>i.\n       \\<lbrakk>i < i + (1::'rows); \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               B $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 3. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) B; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> B $ j $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "show \"\\<And>i. \\<not> is_zero_row_upt_k i (Suc k) B \\<Longrightarrow> B $ i $ (LEAST k. B $ i $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) B \\<Longrightarrow>\n       B $ i $ (LEAST k. B $ i $ k \\<noteq> (0::'a)) = (1::'a)", "using condition_2 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>reduced_row_echelon_form_upt_k ?A ?k;\n   \\<not> is_zero_row_upt_k ?i (Suc ?k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) +\n                        1,\n                   ?A)\n                  ?k))\\<rbrakk>\n  \\<Longrightarrow> snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n ?k ?A) +\n                                1,\n                           ?A)\n                          ?k) $\n                    ?i $\n                    (LEAST k.\n                        snd (Gauss_Jordan_column_k\n                              (if \\<forall>m. is_zero_row_upt_k m ?k ?A\n                               then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n ?k ?A) +\n                                    1,\n                               ?A)\n                              ?k) $\n                        ?i $\n                        k \\<noteq>\n                        (0::?'a)) =\n                    (1::?'a)\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  B \\<equiv> snd (Gauss_Jordan_column_k (ia, A) k)\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_row_upt_k i (Suc k) B \\<Longrightarrow>\n       B $ i $ (LEAST k. B $ i $ k \\<noteq> (0::'a)) = (1::'a)", "by blast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k ?i (Suc k) B \\<Longrightarrow>\n  B $ ?i $ (LEAST k. B $ ?i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'rows); \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               B $ (i + (1::'rows)) $ n \\<noteq> (0::'a))\n 2. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) B; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> B $ j $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "show \"\\<And>i. i < i + 1 \\<Longrightarrow> \\<not> is_zero_row_upt_k i (Suc k) B \\<Longrightarrow> \\<not> is_zero_row_upt_k (i + 1) (Suc k) B \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> 0) < (LEAST n. B $ (i + 1) $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'rows); \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               B $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "using condition_3 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>reduced_row_echelon_form_upt_k ?A ?k; ?i < ?i + (1::?'rows);\n   \\<not> is_zero_row_upt_k ?i (Suc ?k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) +\n                        1,\n                   ?A)\n                  ?k));\n   \\<not> is_zero_row_upt_k (?i + (1::?'rows)) (Suc ?k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) +\n                        1,\n                   ?A)\n                  ?k))\\<rbrakk>\n  \\<Longrightarrow> (LEAST n.\n                        snd (Gauss_Jordan_column_k\n                              (if \\<forall>m. is_zero_row_upt_k m ?k ?A\n                               then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n ?k ?A) +\n                                    1,\n                               ?A)\n                              ?k) $\n                        ?i $\n                        n \\<noteq>\n                        (0::?'a))\n                    < (LEAST n.\n                          snd (Gauss_Jordan_column_k\n                                (if \\<forall>m. is_zero_row_upt_k m ?k ?A\n                                 then 0\n                                 else mod_type_class.to_nat\n (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) +\n1,\n                                 ?A)\n                                ?k) $\n                          (?i + (1::?'rows)) $\n                          n \\<noteq>\n                          (0::?'a))\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  B \\<equiv> snd (Gauss_Jordan_column_k (ia, A) k)\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < i + (1::'rows); \\<not> is_zero_row_upt_k i (Suc k) B;\n        \\<not> is_zero_row_upt_k (i + (1::'rows)) (Suc k) B\\<rbrakk>\n       \\<Longrightarrow> (LEAST n. B $ i $ n \\<noteq> (0::'a))\n                         < (LEAST n.\n                               B $ (i + (1::'rows)) $ n \\<noteq> (0::'a))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?i + (1::'rows); \\<not> is_zero_row_upt_k ?i (Suc k) B;\n   \\<not> is_zero_row_upt_k (?i + (1::'rows)) (Suc k) B\\<rbrakk>\n  \\<Longrightarrow> (LEAST n. B $ ?i $ n \\<noteq> (0::'a))\n                    < (LEAST n. B $ (?i + (1::'rows)) $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) B; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> B $ j $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "show \"\\<And>i j. \\<not> is_zero_row_upt_k i (Suc k) B \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> B $ j $ (LEAST n. B $ i $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) B; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> B $ j $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "using condition_4 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>reduced_row_echelon_form_upt_k ?A ?k;\n   \\<not> is_zero_row_upt_k ?i (Suc ?k)\n           (snd (Gauss_Jordan_column_k\n                  (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n                   else mod_type_class.to_nat\n                         (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) +\n                        1,\n                   ?A)\n                  ?k));\n   ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> snd (Gauss_Jordan_column_k\n                          (if \\<forall>m. is_zero_row_upt_k m ?k ?A then 0\n                           else mod_type_class.to_nat\n                                 (GREATEST n.\n                                     \\<not> is_zero_row_upt_k n ?k ?A) +\n                                1,\n                           ?A)\n                          ?k) $\n                    ?j $\n                    (LEAST n.\n                        snd (Gauss_Jordan_column_k\n                              (if \\<forall>m. is_zero_row_upt_k m ?k ?A\n                               then 0\n                               else mod_type_class.to_nat\n                                     (GREATEST n.\n   \\<not> is_zero_row_upt_k n ?k ?A) +\n                                    1,\n                               ?A)\n                              ?k) $\n                        ?i $\n                        n \\<noteq>\n                        (0::?'a)) =\n                    (0::?'a)\n  ia \\<equiv>\n  if \\<forall>m. is_zero_row_upt_k m k A then 0\n  else mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n       1\n  B \\<equiv> snd (Gauss_Jordan_column_k (ia, A) k)\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<not> is_zero_row_upt_k i (Suc k) B; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> B $ j $ (LEAST n. B $ i $ n \\<noteq> (0::'a)) =\n                         (0::'a)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?i (Suc k) B; ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> B $ ?j $ (LEAST n. B $ ?i $ n \\<noteq> (0::'a)) =\n                    (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_Gauss_condition_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and \"\\<forall>m\\<ge>0. A $ m $ from_nat k = 0\"\n  shows \"is_zero_row_upt_k m (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k m (Suc k) A", "by (rule is_zero_row_upt_k_suc, auto simp add: assms least_mod_type)"], ["", "lemma foldl_Gauss_condition_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"\n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "have to_nat_from_nat_k_suc: \"to_nat (from_nat k::'columns) < (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "using to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat k) = k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "have A0k_eq_1: \"(Gauss_Jordan_in_ij A 0 (from_nat k)) $ 0 $ (from_nat k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k =\n    (1::'a)", "by (rule Gauss_Jordan_in_ij_1, auto intro!: Amk_not_zero least_mod_type)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "have \"\\<not> is_zero_row_upt_k 0 (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < Suc k \\<longrightarrow>\n               Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n               (0::'rows) $\n               j =\n               (0::'a))", "using A0k_eq_1 to_nat_from_nat_k_suc"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  mod_type_class.from_nat k =\n  (1::'a)\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < Suc k \\<longrightarrow>\n               Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n               (0::'rows) $\n               j =\n               (0::'a))", "by force"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n          (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n          (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "by blast"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc k)\n             (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_Gauss_condition_3:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and all_zero: \"\\<forall>m. is_zero_row_upt_k m k A\"           \n  and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\"\n  and \"\\<not> is_zero_row_upt_k ma (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\"\n  shows \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A (0::'rows)\n                   (mod_type_class.from_nat k))) =\n    0", "proof (unfold to_nat_eq_0, rule Greatest_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows)\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "have to_nat_from_nat_k_suc: \"to_nat (from_nat k::'columns) < Suc (k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "using to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat k) = k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows)\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "have A0k_eq_1: \"(Gauss_Jordan_in_ij A 0 (from_nat k)) $ 0 $ (from_nat k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n    (0::'rows) $\n    mod_type_class.from_nat k =\n    (1::'a)", "by (rule Gauss_Jordan_in_ij_1, auto intro!: Amk_not_zero least_mod_type)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows)\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "show \"\\<not> is_zero_row_upt_k 0 (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n            (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < Suc k \\<longrightarrow>\n               Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n               (0::'rows) $\n               j =\n               (0::'a))", "using A0k_eq_1 to_nat_from_nat_k_suc"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ (0::'rows) $\n  mod_type_class.from_nat k =\n  (1::'a)\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < Suc k \\<longrightarrow>\n               Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $\n               (0::'rows) $\n               j =\n               (0::'a))", "by force"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (0::'rows) (Suc k)\n          (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows)\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows)\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "assume not_zero_y: \"\\<not> is_zero_row_upt_k y (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows)\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "have y_eq_0: \"y=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = (0::'rows)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'rows) \\<Longrightarrow> False", "assume y_not_0: \"y \\<noteq> 0\""], ["proof (state)\nthis:\n  y \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'rows) \\<Longrightarrow> False", "have \"is_zero_row_upt_k y (Suc k) (Gauss_Jordan_in_ij A 0 (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y (Suc k)\n     (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < Suc k \\<longrightarrow>\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n       (0::'a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n       (0::'a)", "fix j::\"'columns\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n       (0::'a)", "assume j: \"to_nat j < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n       (0::'a)", "show \"Gauss_Jordan_in_ij A 0 (from_nat k) $ y $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "proof (cases \"to_nat j = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j = k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)\n 2. mod_type_class.to_nat j \\<noteq> k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat j = k\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat j = k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)\n 2. mod_type_class.to_nat j \\<noteq> k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "unfolding to_nat_from_nat[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) j $ y $ j = (0::'a)", "by (rule Gauss_Jordan_in_ij_0[OF _ y_not_0], unfold to_nat_from_nat[OF True, symmetric], auto intro!:  y_not_0 least_mod_type Amk_not_zero)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j \\<noteq> k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j \\<noteq> k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat j \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j \\<noteq> k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "hence j_less_k: \"to_nat j < k\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat j \\<noteq> k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < k", "by (metis j less_SucE)"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j \\<noteq> k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "using Gauss_Jordan_in_ij_preserves_previous_elements'[OF all_zero j_less_k Amk_not_zero]"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $ j =\n  A $ ?i $ j\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "using all_zero j_less_k"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $ j =\n  A $ ?i $ j\n  \\<forall>m. is_zero_row_upt_k m k A\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ ?i $ j =\n  A $ ?i $ j\n  \\<forall>m j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ m $ j = (0::'a)\n  mod_type_class.to_nat j < k\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n    (0::'a)", "by presburger"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k) $ y $ j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y (Suc k)\n   (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'rows) \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. False", "using not_zero_y"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (Gauss_Jordan_in_ij A (0::'rows) (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y = (0::'rows)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A (0::'rows)\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> (0::'rows)", "thus \"y\\<le>0\""], ["proof (prove)\nusing this:\n  y = (0::'rows)\n\ngoal (1 subgoal):\n 1. y \\<le> (0::'rows)", "using least_mod_type"], ["proof (prove)\nusing this:\n  y = (0::'rows)\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. y \\<le> (0::'rows)", "by simp"], ["proof (state)\nthis:\n  y \\<le> (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_Gauss_condition_5:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes rref_A: \"reduced_row_echelon_form_upt_k A k\"\n  and not_zero_a:\"\\<not> is_zero_row_upt_k a k A\"\n  and all_zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1. A $ m $ from_nat k = 0\"\n  shows \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "have \"\\<And>n. (is_zero_row_upt_k n (Suc k) A) = (is_zero_row_upt_k n k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. is_zero_row_upt_k n (Suc k) A = is_zero_row_upt_k n k A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       is_zero_row_upt_k n (Suc k) A \\<Longrightarrow>\n       is_zero_row_upt_k n k A\n 2. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       is_zero_row_upt_k n (Suc k) A \\<Longrightarrow>\n       is_zero_row_upt_k n k A\n 2. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "assume \"is_zero_row_upt_k n (Suc k) A\""], ["proof (state)\nthis:\n  is_zero_row_upt_k n (Suc k) A\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       is_zero_row_upt_k n (Suc k) A \\<Longrightarrow>\n       is_zero_row_upt_k n k A\n 2. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "thus \"is_zero_row_upt_k n k A\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k n (Suc k) A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k n k A", "using is_zero_row_upt_k_le"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k n (Suc k) A\n  is_zero_row_upt_k ?i (Suc ?k) ?A \\<Longrightarrow>\n  is_zero_row_upt_k ?i ?k ?A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k n k A", "by fast"], ["proof (state)\nthis:\n  is_zero_row_upt_k n k A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "assume zero_n_k: \"is_zero_row_upt_k n k A\""], ["proof (state)\nthis:\n  is_zero_row_upt_k n k A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "have \"n>(GREATEST n. \\<not> is_zero_row_upt_k n k A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < n", "by (rule greatest_less_zero_row[OF rref_A zero_n_k], auto intro!: not_zero_a)"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "hence n_ge_gratest: \"n \\<ge> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < n\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "using le_Suc"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < n\n  ?a < ?b \\<Longrightarrow> ?a + (1::?'a) \\<le> ?b\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "hence A_nk_zero: \"A $ n $ (from_nat k) = 0\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (1 subgoal):\n 1. A $ n $ mod_type_class.from_nat k = (0::'a)", "using all_zero_below_greatest"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows).\n     A $ m $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ n $ mod_type_class.from_nat k = (0::'a)", "by fast"], ["proof (state)\nthis:\n  A $ n $ mod_type_class.from_nat k = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_zero_row_upt_k n k A \\<Longrightarrow>\n       is_zero_row_upt_k n (Suc k) A", "show \"is_zero_row_upt_k n (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k n (Suc k) A", "by (rule is_zero_row_upt_k_suc[OF zero_n_k A_nk_zero])"], ["proof (state)\nthis:\n  is_zero_row_upt_k n (Suc k) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k ?n (Suc k) A = is_zero_row_upt_k ?n k A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "thus \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k ?n (Suc k) A = is_zero_row_upt_k ?n k A\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)", "by simp"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) =\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_Gauss_condition_6:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and eq_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) = nrows A\"\n  shows \"nrows A = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "using greatest_plus_one_eq_0[OF eq_card]"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)", "."], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "hence greatest_k_eq_minus_1: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) = -1\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "using a_eq_minus_1"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) = (0::'rows)\n  \\<forall>a. a + (1::?'a) = (0::?'a) \\<longrightarrow> a = - (1::?'a)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)", "by blast"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A) = - (1::'rows)", "proof (rule Greatest_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k (- (1::'rows)) (Suc k) A\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> - (1::'rows)", "show \"\\<not> is_zero_row_upt_k (- 1) (Suc k) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (- (1::'rows)) (Suc k) A", "using GreatestI_ex greatest_k_eq_minus_1 is_zero_row_upt_k_le not_zero_m"], ["proof (prove)\nusing this:\n  \\<exists>x. ?P x \\<Longrightarrow> ?P (Greatest ?P)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n  is_zero_row_upt_k ?i (Suc ?k) ?A \\<Longrightarrow>\n  is_zero_row_upt_k ?i ?k ?A\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k (- (1::'rows)) (Suc k) A", "by force"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k (- (1::'rows)) (Suc k) A\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> - (1::'rows)", "show \"\\<And>y. \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow> y \\<le> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> - (1::'rows)", "using Greatest_is_minus_1"], ["proof (prove)\nusing this:\n  \\<forall>a. a \\<le> - (1::?'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k) A \\<Longrightarrow>\n       y \\<le> - (1::'rows)", "by fast"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k ?y (Suc k) A \\<Longrightarrow>\n  ?y \\<le> - (1::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "thus \"nrows A = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "using eq_card greatest_k_eq_minus_1"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A) = - (1::'rows)\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  nrows A\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) = - (1::'rows)\n\ngoal (1 subgoal):\n 1. nrows A =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))", "by fastforce"], ["proof (state)\nthis:\n  nrows A =\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_Gauss_condition_8:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and not_zero_m: \" \\<not> is_zero_row_upt_k m k A\" \n  and A_ma_k: \" A $ ma $ from_nat k \\<noteq> 0\" \n  and ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  shows \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k))", "define Greatest_plus_one where \"Greatest_plus_one = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  Greatest_plus_one =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k))", "have to_nat_from_nat_k_suc: \"to_nat (from_nat k::'columns) < (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "using to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat k) = k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k))", "have Gauss_eq_1: \"(Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k)) $ Greatest_plus_one $ (from_nat k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n    Greatest_plus_one $\n    mod_type_class.from_nat k =\n    (1::'a)", "by (unfold Greatest_plus_one_def, rule Gauss_Jordan_in_ij_1, auto intro!: A_ma_k ma)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n  Greatest_plus_one $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k))", "show \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc k) (Gauss_Jordan_in_ij A (Greatest_plus_one) (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc k)\n               (Gauss_Jordan_in_ij A Greatest_plus_one\n                 (mod_type_class.from_nat k))", "by (rule exI[of _ \"Greatest_plus_one\"], unfold is_zero_row_upt_k_def, auto, rule exI[of _ \"from_nat k\"], simp add: Gauss_eq_1 to_nat_from_nat_k_suc)"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc k)\n             (Gauss_Jordan_in_ij A Greatest_plus_one\n               (mod_type_class.from_nat k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foldl_Gauss_condition_9:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes k: \"k < ncols A\"\n  and rref_A: \"reduced_row_echelon_form_upt_k A k\"\n  assumes not_zero_m: \"\\<not> is_zero_row_upt_k m k A\"\n  and suc_greatest_not_card: \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq> nrows A\"\n  and greatest_less_ma: \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> ma\"\n  and A_ma_k: \"A $ ma $ from_nat k \\<noteq> 0\"\n  shows \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  to_nat(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k)))", "define Greatest_plus_one where \"Greatest_plus_one = (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\""], ["proof (state)\nthis:\n  Greatest_plus_one =\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k)))", "have to_nat_from_nat_k_suc: \"to_nat (from_nat k::'columns) < (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "using to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (mod_type_class.from_nat k) = k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k)))", "have greatest_plus_one_not_zero: \"Greatest_plus_one \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<noteq> (0::'rows)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<noteq> (0::'rows)", "have \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) < nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n    < nrows A", "using to_nat_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n    < nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n    < CARD('rows)", "by blast"], ["proof (state)\nthis:\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < nrows A\n\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<noteq> (0::'rows)", "hence \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 < nrows A\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < nrows A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n    < nrows A", "using suc_greatest_not_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)\n  < nrows A\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n k A)) \\<noteq>\n  nrows A\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n    < nrows A", "by linarith"], ["proof (state)\nthis:\n  mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1\n  < nrows A\n\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<noteq> (0::'rows)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<noteq> (0::'rows)", "unfolding Greatest_plus_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "by (rule suc_not_zero[OF suc_greatest_not_card[unfolded Suc_eq_plus1 nrows_def]])"], ["proof (state)\nthis:\n  Greatest_plus_one \\<noteq> (0::'rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Greatest_plus_one \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k)))", "have greatest_eq: \"Greatest_plus_one = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Greatest_plus_one =\n    (GREATEST n.\n        \\<not> is_zero_row_upt_k n (Suc k)\n                (Gauss_Jordan_in_ij A Greatest_plus_one\n                  (mod_type_class.from_nat k)))", "proof (rule Greatest_equality[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k Greatest_plus_one (Suc k)\n            (Gauss_Jordan_in_ij A Greatest_plus_one\n              (mod_type_class.from_nat k))\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A Greatest_plus_one\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> Greatest_plus_one", "have \"(Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k)) $ (Greatest_plus_one) $ (from_nat k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n    Greatest_plus_one $\n    mod_type_class.from_nat k =\n    (1::'a)", "by (unfold Greatest_plus_one_def, rule Gauss_Jordan_in_ij_1, auto intro!: greatest_less_ma A_ma_k)"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n  Greatest_plus_one $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. \\<not> is_zero_row_upt_k Greatest_plus_one (Suc k)\n            (Gauss_Jordan_in_ij A Greatest_plus_one\n              (mod_type_class.from_nat k))\n 2. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A Greatest_plus_one\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> Greatest_plus_one", "thus \"\\<not> is_zero_row_upt_k Greatest_plus_one (Suc k) (Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k))\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n  Greatest_plus_one $\n  mod_type_class.from_nat k =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k Greatest_plus_one (Suc k)\n            (Gauss_Jordan_in_ij A Greatest_plus_one\n              (mod_type_class.from_nat k))", "using to_nat_from_nat_k_suc"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n  Greatest_plus_one $\n  mod_type_class.from_nat k =\n  (1::'a)\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k Greatest_plus_one (Suc k)\n            (Gauss_Jordan_in_ij A Greatest_plus_one\n              (mod_type_class.from_nat k))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n  Greatest_plus_one $\n  mod_type_class.from_nat k =\n  (1::'a)\n  mod_type_class.to_nat (mod_type_class.from_nat k) < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < Suc k \\<longrightarrow>\n               Gauss_Jordan_in_ij A Greatest_plus_one\n                (mod_type_class.from_nat k) $\n               Greatest_plus_one $\n               j =\n               (0::'a))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k Greatest_plus_one (Suc k)\n          (Gauss_Jordan_in_ij A Greatest_plus_one\n            (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A Greatest_plus_one\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> Greatest_plus_one", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A Greatest_plus_one\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> Greatest_plus_one", "assume not_zero_y: \"\\<not> is_zero_row_upt_k y (Suc k) (Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k))\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (Gauss_Jordan_in_ij A Greatest_plus_one\n            (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> is_zero_row_upt_k y (Suc k)\n               (Gauss_Jordan_in_ij A Greatest_plus_one\n                 (mod_type_class.from_nat k)) \\<Longrightarrow>\n       y \\<le> Greatest_plus_one", "show \"y \\<le> Greatest_plus_one\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> Greatest_plus_one", "proof (cases \"y<Greatest_plus_one\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one\n 2. \\<not> y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one", "case True"], ["proof (state)\nthis:\n  y < Greatest_plus_one\n\ngoal (2 subgoals):\n 1. y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one\n 2. \\<not> y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one", "thus ?thesis"], ["proof (prove)\nusing this:\n  y < Greatest_plus_one\n\ngoal (1 subgoal):\n 1. y \\<le> Greatest_plus_one", "by simp"], ["proof (state)\nthis:\n  y \\<le> Greatest_plus_one\n\ngoal (1 subgoal):\n 1. \\<not> y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one", "case False"], ["proof (state)\nthis:\n  \\<not> y < Greatest_plus_one\n\ngoal (1 subgoal):\n 1. \\<not> y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one", "hence y_ge_greatest: \"y\\<ge>Greatest_plus_one\""], ["proof (prove)\nusing this:\n  \\<not> y < Greatest_plus_one\n\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<le> y", "by simp"], ["proof (state)\nthis:\n  Greatest_plus_one \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one", "have \"y=Greatest_plus_one\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = Greatest_plus_one", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> Greatest_plus_one \\<Longrightarrow> False", "assume y_not_greatest: \"y \\<noteq> Greatest_plus_one\""], ["proof (state)\nthis:\n  y \\<noteq> Greatest_plus_one\n\ngoal (1 subgoal):\n 1. y \\<noteq> Greatest_plus_one \\<Longrightarrow> False", "have \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "using greatest_plus_one_not_zero"], ["proof (prove)\nusing this:\n  Greatest_plus_one \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "using Suc_le' less_le_trans y_ge_greatest"], ["proof (prove)\nusing this:\n  Greatest_plus_one \\<noteq> (0::'rows)\n  ?a + (1::?'a) \\<noteq> (0::?'a) \\<Longrightarrow> ?a < ?a + (1::?'a)\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  Greatest_plus_one \\<le> y\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "unfolding Greatest_plus_one_def"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n  ?a + (1::?'a) \\<noteq> (0::?'a) \\<Longrightarrow> ?a < ?a + (1::?'a)\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> y\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y", "by auto"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n\ngoal (1 subgoal):\n 1. y \\<noteq> Greatest_plus_one \\<Longrightarrow> False", "hence zero_row_y_upt_k: \"is_zero_row_upt_k y k A\""], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k A", "using not_greater_Greatest[of \"\\<lambda>n. \\<not> is_zero_row_upt_k n k A\" y]"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n  (GREATEST x. \\<not> is_zero_row_upt_k x k A) < y \\<Longrightarrow>\n  \\<not> \\<not> is_zero_row_upt_k y k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k A", "unfolding Greatest_plus_one_def"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) < y\n  (GREATEST x. \\<not> is_zero_row_upt_k x k A) < y \\<Longrightarrow>\n  \\<not> \\<not> is_zero_row_upt_k y k A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y k A", "by fast"], ["proof (state)\nthis:\n  is_zero_row_upt_k y k A\n\ngoal (1 subgoal):\n 1. y \\<noteq> Greatest_plus_one \\<Longrightarrow> False", "have \"is_zero_row_upt_k y (Suc k) (Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row_upt_k y (Suc k)\n     (Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       mod_type_class.to_nat j < Suc k \\<longrightarrow>\n       Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n       y $\n       j =\n       (0::'a)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n       y $\n       j =\n       (0::'a)", "fix j::'columns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n       y $\n       j =\n       (0::'a)", "assume j: \"to_nat j < Suc k\""], ["proof (state)\nthis:\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       mod_type_class.to_nat j < Suc k \\<Longrightarrow>\n       Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $\n       y $\n       j =\n       (0::'a)", "show \"Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k) $ y $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "proof (cases \"j=from_nat k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)\n 2. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  j = mod_type_class.from_nat k\n\ngoal (2 subgoals):\n 1. j = mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)\n 2. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "proof (unfold True, rule Gauss_Jordan_in_ij_0[OF _ y_not_greatest], rule exI[of _ ma], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n 2. Greatest_plus_one \\<le> ma", "show \"A $ ma $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)", "using A_ma_k"], ["proof (prove)\nusing this:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<le> ma", "show \"Greatest_plus_one \\<le> ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<le> ma", "using greatest_less_ma"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. Greatest_plus_one \\<le> ma", "unfolding Greatest_plus_one_def"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma", "."], ["proof (state)\nthis:\n  Greatest_plus_one \\<le> ma\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  j \\<noteq> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "hence j_le_suc_k: \"to_nat j < Suc k\""], ["proof (prove)\nusing this:\n  j \\<noteq> mod_type_class.from_nat k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < Suc k", "using j"], ["proof (prove)\nusing this:\n  j \\<noteq> mod_type_class.from_nat k\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < Suc k", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < Suc k\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "have \"Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k) $ y $ j = A $ y $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    A $ y $ j", "unfolding Greatest_plus_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n     (mod_type_class.from_nat k) $\n    y $\n    j =\n    A $ y $ j", "proof (rule Gauss_Jordan_in_ij_preserves_previous_elements)"], ["proof (state)\ngoal (5 subgoals):\n 1. reduced_row_echelon_form_upt_k A k\n 2. \\<not> is_zero_row_upt_k ?a k A\n 3. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 4. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 5. mod_type_class.to_nat j < k", "show \"reduced_row_echelon_form_upt_k A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "using rref_A"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A k", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A k\n\ngoal (4 subgoals):\n 1. \\<not> is_zero_row_upt_k ?a k A\n 2. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 3. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 4. mod_type_class.to_nat j < k", "show \"\\<not> is_zero_row_upt_k m k A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "using not_zero_m"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k m k A", "."], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m k A\n\ngoal (3 subgoals):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n 2. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 3. mod_type_class.to_nat j < k", "show \"\\<exists>n. A $ n $ from_nat k \\<noteq> 0 \\<and> (GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "using A_ma_k greatest_less_ma"], ["proof (prove)\nusing this:\n  A $ ma $ mod_type_class.from_nat k \\<noteq> (0::'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> ma\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<le> n\n\ngoal (2 subgoals):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)\n 2. mod_type_class.to_nat j < k", "show \"(GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "using greatest_plus_one_not_zero"], ["proof (prove)\nusing this:\n  Greatest_plus_one \\<noteq> (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "unfolding Greatest_plus_one_def"], ["proof (prove)\nusing this:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n    (0::'rows)", "."], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < k", "show \"to_nat j < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < k", "using False from_nat_to_nat_id j_le_suc_k less_antisym"], ["proof (prove)\nusing this:\n  j \\<noteq> mod_type_class.from_nat k\n  mod_type_class.from_nat (mod_type_class.to_nat ?x) = ?x\n  mod_type_class.to_nat j < Suc k\n  \\<lbrakk>\\<not> ?n < ?m; ?n < Suc ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat j < k", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat j < k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n  j =\n  A $ y $ j\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n  j =\n  A $ y $ j\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ y $ j = (0::'a)", "using zero_row_y_upt_k"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y k A\n\ngoal (1 subgoal):\n 1. A $ y $ j = (0::'a)", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ y $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ y $ j = (0::'a)", "using  False le_imp_less_or_eq from_nat_to_nat_id j_le_suc_k less_Suc_eq_le"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     mod_type_class.to_nat j < k \\<longrightarrow> A $ y $ j = (0::'a)\n  j \\<noteq> mod_type_class.from_nat k\n  ?x \\<le> ?y \\<Longrightarrow> ?x < ?y \\<or> ?x = ?y\n  mod_type_class.from_nat (mod_type_class.to_nat ?x) = ?x\n  mod_type_class.to_nat j < Suc k\n  (?m < Suc ?n) = (?m \\<le> ?n)\n\ngoal (1 subgoal):\n 1. A $ y $ j = (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ y $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. j \\<noteq> mod_type_class.from_nat k \\<Longrightarrow>\n    Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n  j =\n  (0::'a)", "show \"Gauss_Jordan_in_ij A Greatest_plus_one (from_nat k) $ y $ j = 0\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n  j =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n    j =\n    (0::'a)", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k) $ y $\n  j =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_zero_row_upt_k y (Suc k)\n   (Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. y \\<noteq> Greatest_plus_one \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. False", "using not_zero_y"], ["proof (prove)\nusing this:\n  is_zero_row_upt_k y (Suc k)\n   (Gauss_Jordan_in_ij A Greatest_plus_one (mod_type_class.from_nat k))\n  \\<not> is_zero_row_upt_k y (Suc k)\n          (Gauss_Jordan_in_ij A Greatest_plus_one\n            (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y = Greatest_plus_one\n\ngoal (1 subgoal):\n 1. \\<not> y < Greatest_plus_one \\<Longrightarrow> y \\<le> Greatest_plus_one", "thus \"y \\<le> Greatest_plus_one\""], ["proof (prove)\nusing this:\n  y = Greatest_plus_one\n\ngoal (1 subgoal):\n 1. y \\<le> Greatest_plus_one", "using y_ge_greatest"], ["proof (prove)\nusing this:\n  y = Greatest_plus_one\n  Greatest_plus_one \\<le> y\n\ngoal (1 subgoal):\n 1. y \\<le> Greatest_plus_one", "by blast"], ["proof (state)\nthis:\n  y \\<le> Greatest_plus_one\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> Greatest_plus_one\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Greatest_plus_one =\n  (GREATEST n.\n      \\<not> is_zero_row_upt_k n (Suc k)\n              (Gauss_Jordan_in_ij A Greatest_plus_one\n                (mod_type_class.from_nat k)))\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k)))", "show \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_in_ij A ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + 1) (from_nat k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (Gauss_Jordan_in_ij A\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n                    (1::'rows))\n                   (mod_type_class.from_nat k)))", "unfolding greatest_eq[unfolded Greatest_plus_one_def, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))", "unfolding add_to_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        mod_type_class.to_nat (1::'rows)))", "unfolding to_nat_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1))", "using to_nat_from_nat_id to_nat_plus_one_less_card"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1))", "using greatest_plus_one_not_zero[unfolded Greatest_plus_one_def]"], ["proof (prove)\nusing this:\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n  \\<forall>a.\n     a + (1::?'a) \\<noteq> (0::?'a) \\<longrightarrow>\n     mod_type_class.to_nat a + 1 < CARD(?'a)\n  (GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows) \\<noteq>\n  (0::'rows)\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n    mod_type_class.to_nat\n     (mod_type_class.from_nat\n       (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A) +\n        1))", "by force"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat (GREATEST n. \\<not> is_zero_row_upt_k n k A)) =\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc k)\n               (Gauss_Jordan_in_ij A\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n k A) + (1::'rows))\n                 (mod_type_class.from_nat k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The following lemma is one of most important ones in the verification of the Gauss-Jordan algorithm.\nThe aim is to prove two statements about @{thm \"Gauss_Jordan_upt_k_def\"} (one about the result is on rref and another about the index).\nThe reason of doing that way is because both statements need them mutually to be proved.\nAs the proof is made using induction, two base cases and two induction steps appear.\n\\<close>"], ["", "lemma rref_and_index_Gauss_Jordan_upt_k:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\" and k::nat\n  assumes  \"k < ncols A\"\n  shows rref_Gauss_Jordan_upt_k: \"reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k)\"\n  and snd_Gauss_Jordan_upt_k: \n  \"foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m. is_zero_row_upt_k m (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) then 0\n  else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) + 1,\n  snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k) &&&\n    foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "using assms"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k) &&&\n    foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "proof (induct k)\n    \\<comment> \\<open>Two base cases, one for each show\\<close>\n    \\<comment> \\<open>The first one\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A 0) (Suc 0)\n 2. 0 < ncols A \\<Longrightarrow>\n    foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc 0]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "show \"reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A 0) (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A 0) (Suc 0)", "unfolding Gauss_Jordan_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])) (Suc 0)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (snd (Gauss_Jordan_column_k (0, A) 0))\n     (Suc 0)", "using reduced_row_echelon_form_upt_k_Gauss_Jordan_column_k[OF rref_upt_0, of A]"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m 0 A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n 0 A) +\n                1,\n           A)\n          0))\n   (Suc 0)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (snd (Gauss_Jordan_column_k (0, A) 0))\n     (Suc 0)", "using is_zero_row_utp_0'[of A]"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k\n   (snd (Gauss_Jordan_column_k\n          (if \\<forall>m. is_zero_row_upt_k m 0 A then 0\n           else mod_type_class.to_nat\n                 (GREATEST n. \\<not> is_zero_row_upt_k n 0 A) +\n                1,\n           A)\n          0))\n   (Suc 0)\n  \\<forall>m. is_zero_row_upt_k m 0 A\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (snd (Gauss_Jordan_column_k (0, A) 0))\n     (Suc 0)", "by simp\n      \\<comment> \\<open>The second base case\\<close>"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A 0) (Suc 0)\n\ngoal (3 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc 0]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "have rw_upt: \"[0..<Suc 0] = [0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc 0] = [0]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc 0] = [0]\n\ngoal (3 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc 0]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "show \"foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0] =\n    (if \\<forall>m. is_zero_row_upt_k m (Suc 0) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])) then 0\n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc 0) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))) + 1,\n    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc 0]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))", "unfolding rw_upt"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k (0, A) [0] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (snd (foldl Gauss_Jordan_column_k (0, A) [0]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0]))", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_column_k (0, A) 0 =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (snd (Gauss_Jordan_column_k (0, A) 0))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (snd (Gauss_Jordan_column_k (0, A) 0))) +\n          1,\n     snd (Gauss_Jordan_column_k (0, A) 0))", "unfolding Gauss_Jordan_column_k_def Let_def from_nat_0 fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<forall>m\\<ge>0::'rows. A $ m $ (0::'columns) = (0::'a)) \\<or>\n        0 = nrows A\n     then (0, A)\n     else (0 + 1, Gauss_Jordan_in_ij A (0::'rows) (0::'columns))) =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc 0)\n            (snd (if (\\<forall>m\\<ge>0::'rows.\n                         A $ m $ (0::'columns) = (0::'a)) \\<or>\n                     0 = nrows A\n                  then (0, A)\n                  else (0 + 1,\n                        Gauss_Jordan_in_ij A (0::'rows) (0::'columns))))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc 0)\n                       (snd (if (\\<forall>m\\<ge>0::'rows.\n                                    A $ m $ (0::'columns) = (0::'a)) \\<or>\n                                0 = nrows A\n                             then (0, A)\n                             else (0 + 1,\n                                   Gauss_Jordan_in_ij A (0::'rows)\n                                    (0::'columns))))) +\n          1,\n     snd (if (\\<forall>m\\<ge>0::'rows.\n                 A $ m $ (0::'columns) = (0::'a)) \\<or>\n             0 = nrows A\n          then (0, A)\n          else (0 + 1, Gauss_Jordan_in_ij A (0::'rows) (0::'columns))))", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<forall>m\\<ge>0::'rows. A $ m $ (0::'columns) = (0::'a)) \\<or>\n        0 = nrows A\n     then (0, A)\n     else (0 + 1, Gauss_Jordan_in_ij A (0::'rows) (0::'columns))) =\n    (if \\<forall>m j.\n           mod_type_class.to_nat j < Suc 0 \\<longrightarrow>\n           snd (if (\\<forall>m\\<ge>0::'rows.\n                       A $ m $ (0::'columns) = (0::'a)) \\<or>\n                   0 = nrows A\n                then (0, A)\n                else (0 + 1,\n                      Gauss_Jordan_in_ij A (0::'rows) (0::'columns))) $\n           m $\n           j =\n           (0::'a)\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> (\\<forall>j.\n                          mod_type_class.to_nat j < Suc 0 \\<longrightarrow>\n                          snd (if (\\<forall>m\\<ge>0::'rows.\nA $ m $ (0::'columns) = (0::'a)) \\<or>\n                                  0 = nrows A\n                               then (0, A)\n                               else (0 + 1,\n                                     Gauss_Jordan_in_ij A (0::'rows)\n(0::'columns))) $\n                          n $\n                          j =\n                          (0::'a))) +\n          1,\n     snd (if (\\<forall>m\\<ge>0::'rows.\n                 A $ m $ (0::'columns) = (0::'a)) \\<or>\n             0 = nrows A\n          then (0, A)\n          else (0 + 1, Gauss_Jordan_in_ij A (0::'rows) (0::'columns))))", "apply (auto simp add: least_mod_type to_nat_eq_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'columns) \\<noteq> (0::'a);\n        \\<forall>m.\n           Gauss_Jordan_in_ij A (0::'rows) (0::'columns) $ m $\n           (0::'columns) =\n           (0::'a)\\<rbrakk>\n       \\<Longrightarrow> A $ ma $ (0::'columns) = (0::'a)\n 2. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'columns) \\<noteq> (0::'a);\n        Gauss_Jordan_in_ij A (0::'rows) (0::'columns) $ ma $\n        (0::'columns) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             Gauss_Jordan_in_ij A (0::'rows) (0::'columns) $\n                             n $\n                             (0::'columns) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "apply (metis Gauss_Jordan_in_ij_1 least_mod_type zero_neq_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m ma.\n       \\<lbrakk>A $ m $ (0::'columns) \\<noteq> (0::'a);\n        Gauss_Jordan_in_ij A (0::'rows) (0::'columns) $ ma $\n        (0::'columns) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             Gauss_Jordan_in_ij A (0::'rows) (0::'columns) $\n                             n $\n                             (0::'columns) \\<noteq>\n                             (0::'a)) =\n                         (0::'rows)", "by (metis (lifting, mono_tags) Gauss_Jordan_in_ij_0 GreatestI_ex least_mod_type)"], ["proof (state)\nthis:\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0] =\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc 0)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc 0)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc 0]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]))\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "next\n    \\<comment> \\<open>Now we begin with the proof of the induction step of the first show. We will make use the induction hypothesis of the second show\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "assume \"(k < ncols A \\<Longrightarrow> reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k))\"\n    and \"(k < ncols A \\<Longrightarrow>\n    foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m. is_zero_row_upt_k m (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) then 0\n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) + 1,\n    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\"\n    and k: \"Suc k < ncols A\""], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k)\n  k < ncols A \\<Longrightarrow>\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n  Suc k < ncols A\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "hence hyp_rref: \"reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k)\"\n    and hyp_foldl: \"foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m. is_zero_row_upt_k m (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) then 0\n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) + 1,\n    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\""], ["proof (prove)\nusing this:\n  k < ncols A \\<Longrightarrow>\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k)\n  k < ncols A \\<Longrightarrow>\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k) &&&\n    foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "by simp+"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k)\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "have rw: \"[0..<Suc (Suc k)]= [0..<(Suc k)] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by auto"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "have rw2: \"(foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) = \n    (if \\<forall>m. is_zero_row_upt_k m (Suc k) (Gauss_Jordan_upt_k A k) then 0 else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_upt_k A k)) + 1,\n    Gauss_Jordan_upt_k A k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m. is_zero_row_upt_k m (Suc k) (Gauss_Jordan_upt_k A k)\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (Gauss_Jordan_upt_k A k)) +\n          1,\n     Gauss_Jordan_upt_k A k)", "unfolding Gauss_Jordan_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "using hyp_foldl"], ["proof (prove)\nusing this:\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc k)\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc k)\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "by fast"], ["proof (state)\nthis:\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m. is_zero_row_upt_k m (Suc k) (Gauss_Jordan_upt_k A k)\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k) (Gauss_Jordan_upt_k A k)) +\n        1,\n   Gauss_Jordan_upt_k A k)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> reduced_row_echelon_form_upt_k\n                          (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "show \"reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A (Suc k)) (Suc (Suc k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A (Suc k))\n     (Suc (Suc k))", "unfolding Gauss_Jordan_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n     (Suc (Suc k))", "unfolding rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (snd (foldl Gauss_Jordan_column_k (0, A) ([0..<Suc k] @ [Suc k])))\n     (Suc (Suc k))", "unfolding foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (snd (foldl Gauss_Jordan_column_k\n            (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) [Suc k]))\n     (Suc (Suc k))", "unfolding foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (snd (Gauss_Jordan_column_k\n            (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k)))\n     (Suc (Suc k))", "unfolding rw2"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (snd (Gauss_Jordan_column_k\n            (if \\<forall>m.\n                   is_zero_row_upt_k m (Suc k) (Gauss_Jordan_upt_k A k)\n             then 0\n             else mod_type_class.to_nat\n                   (GREATEST n.\n                       \\<not> is_zero_row_upt_k n (Suc k)\n                               (Gauss_Jordan_upt_k A k)) +\n                  1,\n             Gauss_Jordan_upt_k A k)\n            (Suc k)))\n     (Suc (Suc k))", "by (rule reduced_row_echelon_form_upt_k_Gauss_Jordan_column_k[OF hyp_rref])\n      \\<comment> \\<open>Making use of the same hypotheses of above proof, we begin with the proof of the induction step of the second show.\\<close>"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A (Suc k))\n   (Suc (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "have fst_foldl: \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) =\n    fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) then 0\n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) + 1,\n    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "using hyp_foldl"], ["proof (prove)\nusing this:\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "by simp"], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) =\n  fst (if \\<forall>m.\n             is_zero_row_upt_k m (Suc k)\n              (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n       then 0\n       else mod_type_class.to_nat\n             (GREATEST n.\n                 \\<not> is_zero_row_upt_k n (Suc k)\n                         (snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc k]))) +\n            1,\n       snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k)\n                 (Suc k);\n        k < ncols A \\<Longrightarrow>\n        foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n        (if \\<forall>m.\n               is_zero_row_upt_k m (Suc k)\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]));\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> foldl Gauss_Jordan_column_k (0, A)\n                          [0..<Suc (Suc k)] =\n                         (if \\<forall>m.\n                                is_zero_row_upt_k m (Suc (Suc k))\n                                 (snd (foldl Gauss_Jordan_column_k (0, A)\n  [0..<Suc (Suc k)]))\n                          then 0\n                          else mod_type_class.to_nat\n                                (GREATEST n.\n                                    \\<not> is_zero_row_upt_k n (Suc (Suc k))\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) +\n                               1,\n                          snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))", "show \"foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)] =\n    (if \\<forall>m. is_zero_row_upt_k m (Suc (Suc k)) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)])) then 0\n    else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) + 1,\n    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)] =\n    (if \\<forall>m.\n           is_zero_row_upt_k m (Suc (Suc k))\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n     then 0\n     else mod_type_class.to_nat\n           (GREATEST n.\n               \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                       (snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc (Suc k)]))) +\n          1,\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "proof (rule prod_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n 2. snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    snd (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "show \"snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n      snd (if \\<forall>m. is_zero_row_upt_k m (Suc (Suc k)) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)])) then 0\n      else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) + 1,\n      snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    snd (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "unfolding Gauss_Jordan_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    snd (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "by force"], ["proof (state)\nthis:\n  snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n  snd (if \\<forall>m.\n             is_zero_row_upt_k m (Suc (Suc k))\n              (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n       then 0\n       else mod_type_class.to_nat\n             (GREATEST n.\n                 \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                         (snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))) +\n            1,\n       snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "define A' where \"A' = snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\""], ["proof (state)\nthis:\n  A' = snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "have ncols_eq: \"ncols A = ncols A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ncols A = ncols A'", "unfolding A'_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('columns) = CARD('columns)", ".."], ["proof (state)\nthis:\n  ncols A = ncols A'\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "have rref_A': \"reduced_row_echelon_form_upt_k A' (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A' (Suc k)", "using hyp_rref"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A k) (Suc k)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k A' (Suc k)", "unfolding A'_def Gauss_Jordan_upt_k_def"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k\n   (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) (Suc k)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) (Suc k)", "."], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k A' (Suc k)\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "show \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n      fst (if \\<forall>m. is_zero_row_upt_k m (Suc (Suc k)) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)])) then 0\n      else to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))) + 1,\n      snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc (Suc k)]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))", "apply (simp only: rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) ([0..<Suc k] @ [Suc k])) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k (0, A)\n                       ([0..<Suc k] @ [Suc k])))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  ([0..<Suc k] @ [Suc k])))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k (0, A) ([0..<Suc k] @ [Suc k])))", "apply (simp only: foldl_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k\n          (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) [Suc k]) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (foldl Gauss_Jordan_column_k\n                       (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n                       [Suc k]))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (foldl Gauss_Jordan_column_k\n                                  (foldl Gauss_Jordan_column_k (0, A)\n                                    [0..<Suc k])\n                                  [Suc k]))) +\n              1,\n         snd (foldl Gauss_Jordan_column_k\n               (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) [Suc k]))", "apply (simp only: foldl.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k\n          (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k)) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (Gauss_Jordan_column_k\n                       (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n                       (Suc k)))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (Gauss_Jordan_column_k\n                                  (foldl Gauss_Jordan_column_k (0, A)\n                                    [0..<Suc k])\n                                  (Suc k)))) +\n              1,\n         snd (Gauss_Jordan_column_k\n               (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k)))", "apply (simp only: Gauss_Jordan_column_k_def Let_def fst_foldl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (fst (if \\<forall>m.\n   is_zero_row_upt_k m (Suc k)\n    (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                                   then 0\n                                   else mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc k)\n               (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n  1,\n                                   snd (foldl Gauss_Jordan_column_k (0, A)\n   [0..<Suc k]))).\n                snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) $ m $\n                mod_type_class.from_nat (Suc k) =\n                (0::'a)) \\<or>\n            fst (if \\<forall>m.\n                       is_zero_row_upt_k m (Suc k)\n                        (snd (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc k]))\n                 then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n.\n                           \\<not> is_zero_row_upt_k n (Suc k)\n                                   (snd (foldl Gauss_Jordan_column_k (0, A)\n    [0..<Suc k]))) +\n                      1,\n                 snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n            nrows (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         then (fst (if \\<forall>m.\n                          is_zero_row_upt_k m (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))\n                    then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k)\n(snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                         1,\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])),\n               snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n         else (fst (if \\<forall>m.\n                          is_zero_row_upt_k m (Suc k)\n                           (snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))\n                    then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k)\n(snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                         1,\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) +\n               1,\n               Gauss_Jordan_in_ij\n                (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                (mod_type_class.from_nat\n                  (fst (if \\<forall>m.\n                              is_zero_row_upt_k m (Suc k)\n                               (snd (foldl Gauss_Jordan_column_k (0, A)\n[0..<Suc k]))\n                        then 0\n                        else mod_type_class.to_nat\n                              (GREATEST n.\n                                  \\<not> is_zero_row_upt_k n (Suc k)\n    (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                             1,\n                        snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))))\n                (mod_type_class.from_nat (Suc k)))) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n    (fst (if \\<forall>m.\n                is_zero_row_upt_k m (Suc k)\n                 (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n          then 0\n          else mod_type_class.to_nat\n                (GREATEST n.\n                    \\<not> is_zero_row_upt_k n (Suc k)\n                            (snd (foldl Gauss_Jordan_column_k (0, A)\n                                   [0..<Suc k]))) +\n               1,\n          snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))).\n                             snd (foldl Gauss_Jordan_column_k (0, A)\n                                   [0..<Suc k]) $\n                             m $\n                             mod_type_class.from_nat (Suc k) =\n                             (0::'a)) \\<or>\n                         fst (if \\<forall>m.\n                                    is_zero_row_upt_k m (Suc k)\n                                     (snd\n (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                              then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                                   1,\n                              snd (foldl Gauss_Jordan_column_k (0, A)\n                                    [0..<Suc k])) =\n                         nrows\n                          (snd (foldl Gauss_Jordan_column_k (0, A)\n                                 [0..<Suc k]))\n                      then (fst (if \\<forall>m.\n is_zero_row_upt_k m (Suc k)\n  (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                                 then 0\n                                 else mod_type_class.to_nat\n (GREATEST n.\n     \\<not> is_zero_row_upt_k n (Suc k)\n             (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n1,\n                                 snd (foldl Gauss_Jordan_column_k (0, A)\n [0..<Suc k])),\n                            snd (foldl Gauss_Jordan_column_k (0, A)\n                                  [0..<Suc k]))\n                      else (fst (if \\<forall>m.\n is_zero_row_upt_k m (Suc k)\n  (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                                 then 0\n                                 else mod_type_class.to_nat\n (GREATEST n.\n     \\<not> is_zero_row_upt_k n (Suc k)\n             (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n1,\n                                 snd (foldl Gauss_Jordan_column_k (0, A)\n [0..<Suc k])) +\n                            1,\n                            Gauss_Jordan_in_ij\n                             (snd (foldl Gauss_Jordan_column_k (0, A)\n                                    [0..<Suc k]))\n                             (mod_type_class.from_nat\n                               (fst (if \\<forall>m.\n     is_zero_row_upt_k m (Suc k)\n      (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                                     then 0\n                                     else mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc k)\n                 (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n    1,\n                                     snd\n(foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))))\n                             (mod_type_class.from_nat (Suc k)))))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n               (fst (if \\<forall>m.\n                           is_zero_row_upt_k m (Suc k)\n                            (snd (foldl Gauss_Jordan_column_k (0, A)\n                                   [0..<Suc k]))\n                     then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k)\n (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                          1,\n                     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))).\n  snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) $ m $\n  mod_type_class.from_nat (Suc k) =\n  (0::'a)) \\<or>\n                                    fst (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n                                    nrows\n                                     (snd\n (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                                 then (fst\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])),\n snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                                 else (fst\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k)\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc k)\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) +\n 1,\n Gauss_Jordan_in_ij (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n  (mod_type_class.from_nat\n    (fst (if \\<forall>m.\n                is_zero_row_upt_k m (Suc k)\n                 (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n          then 0\n          else mod_type_class.to_nat\n                (GREATEST n.\n                    \\<not> is_zero_row_upt_k n (Suc k)\n                            (snd (foldl Gauss_Jordan_column_k (0, A)\n                                   [0..<Suc k]))) +\n               1,\n          snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))))\n  (mod_type_class.from_nat (Suc k)))))) +\n              1,\n         snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                                  (fst (if \\<forall>m.\n        is_zero_row_upt_k m (Suc k)\n         (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n  then 0\n  else mod_type_class.to_nat\n        (GREATEST n.\n            \\<not> is_zero_row_upt_k n (Suc k)\n                    (snd (foldl Gauss_Jordan_column_k (0, A)\n                           [0..<Suc k]))) +\n       1,\n  snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))).\n                     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) $\n                     m $\n                     mod_type_class.from_nat (Suc k) =\n                     (0::'a)) \\<or>\n                 fst (if \\<forall>m.\n                            is_zero_row_upt_k m (Suc k)\n                             (snd (foldl Gauss_Jordan_column_k (0, A)\n                                    [0..<Suc k]))\n                      then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n.\n                                \\<not> is_zero_row_upt_k n (Suc k)\n  (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                           1,\n                      snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc k])) =\n                 nrows\n                  (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n              then (fst (if \\<forall>m.\n                               is_zero_row_upt_k m (Suc k)\n                                (snd (foldl Gauss_Jordan_column_k (0, A)\n [0..<Suc k]))\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k)\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                              1,\n                         snd (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc k])),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n              else (fst (if \\<forall>m.\n                               is_zero_row_upt_k m (Suc k)\n                                (snd (foldl Gauss_Jordan_column_k (0, A)\n [0..<Suc k]))\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k)\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                              1,\n                         snd (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc k])) +\n                    1,\n                    Gauss_Jordan_in_ij\n                     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                     (mod_type_class.from_nat\n                       (fst (if \\<forall>m.\n                                   is_zero_row_upt_k m (Suc k)\n                                    (snd\n(foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n                             then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n (Suc k)\n         (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))) +\n                                  1,\n                             snd (foldl Gauss_Jordan_column_k (0, A)\n                                   [0..<Suc k]))))\n                     (mod_type_class.from_nat (Suc k)))))", "apply (simp only: A'_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (fst (if \\<forall>m.\n   is_zero_row_upt_k m (Suc k) A'\n                                   then 0\n                                   else mod_type_class.to_nat\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n  1,\n                                   A')).\n                A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)) \\<or>\n            fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                 else mod_type_class.to_nat\n                       (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                      1,\n                 A') =\n            nrows A'\n         then (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         1,\n                    A'),\n               A')\n         else (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                    else mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A') +\n                         1,\n                    A') +\n               1,\n               Gauss_Jordan_in_ij A'\n                (mod_type_class.from_nat\n                  (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                        else mod_type_class.to_nat\n                              (GREATEST n.\n                                  \\<not> is_zero_row_upt_k n (Suc k) A') +\n                             1,\n                        A')))\n                (mod_type_class.from_nat (Suc k)))) =\n    fst (if \\<forall>m.\n               is_zero_row_upt_k m (Suc (Suc k))\n                (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n    (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n          else mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n               1,\n          A')).\n                             A' $ m $ mod_type_class.from_nat (Suc k) =\n                             (0::'a)) \\<or>\n                         fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                              then 0\n                              else mod_type_class.to_nat\n                                    (GREATEST n.\n  \\<not> is_zero_row_upt_k n (Suc k) A') +\n                                   1,\n                              A') =\n                         nrows A'\n                      then (fst (if \\<forall>m.\n is_zero_row_upt_k m (Suc k) A'\n                                 then 0\n                                 else mod_type_class.to_nat\n (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n1,\n                                 A'),\n                            A')\n                      else (fst (if \\<forall>m.\n is_zero_row_upt_k m (Suc k) A'\n                                 then 0\n                                 else mod_type_class.to_nat\n (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n1,\n                                 A') +\n                            1,\n                            Gauss_Jordan_in_ij A'\n                             (mod_type_class.from_nat\n                               (fst (if \\<forall>m.\n     is_zero_row_upt_k m (Suc k) A'\n                                     then 0\n                                     else mod_type_class.to_nat\n     (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n    1,\n                                     A')))\n                             (mod_type_class.from_nat (Suc k)))))\n         then 0\n         else mod_type_class.to_nat\n               (GREATEST n.\n                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                           (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n               (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                     else mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A') +\n                          1,\n                     A')).\n  A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)) \\<or>\n                                    fst (if \\<forall>m.\n         is_zero_row_upt_k m (Suc k) A'\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n        1,\n   A') =\n                                    nrows A'\n                                 then (fst\n  (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n   else mod_type_class.to_nat\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n        1,\n   A'),\n A')\n                                 else (fst\n  (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n   else mod_type_class.to_nat\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n        1,\n   A') +\n 1,\n Gauss_Jordan_in_ij A'\n  (mod_type_class.from_nat\n    (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n          else mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n               1,\n          A')))\n  (mod_type_class.from_nat (Suc k)))))) +\n              1,\n         snd (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                                  (fst (if \\<forall>m.\n        is_zero_row_upt_k m (Suc k) A'\n  then 0\n  else mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n       1,\n  A')).\n                     A' $ m $ mod_type_class.from_nat (Suc k) =\n                     (0::'a)) \\<or>\n                 fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A' then 0\n                      else mod_type_class.to_nat\n                            (GREATEST n.\n                                \\<not> is_zero_row_upt_k n (Suc k) A') +\n                           1,\n                      A') =\n                 nrows A'\n              then (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A') +\n                              1,\n                         A'),\n                    A')\n              else (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                         then 0\n                         else mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A') +\n                              1,\n                         A') +\n                    1,\n                    Gauss_Jordan_in_ij A'\n                     (mod_type_class.from_nat\n                       (fst (if \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n                             then 0\n                             else mod_type_class.to_nat\n                                   (GREATEST n.\n \\<not> is_zero_row_upt_k n (Suc k) A') +\n                                  1,\n                             A')))\n                     (mod_type_class.from_nat (Suc k)))))", "apply auto"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>mod_type_class.from_nat 0.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        mod_type_class.from_nat 0 \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n(mod_type_class.from_nat 0) (mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        mod_type_class.from_nat 0 \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (mod_type_class.from_nat 0)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (mod_type_class.from_nat 0)\n  (mod_type_class.from_nat (Suc k)))) =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>mod_type_class.from_nat\n                        (Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A'))).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>mod_type_class.from_nat\n                        (Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A'))).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        mod_type_class.from_nat\n         (Suc (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')))\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n(mod_type_class.from_nat\n  (Suc (mod_type_class.to_nat\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A'))))\n(mod_type_class.from_nat (Suc k)))\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        mod_type_class.from_nat\n         (Suc (mod_type_class.to_nat\n                (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')))\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  (mod_type_class.from_nat\n                    (Suc (mod_type_class.to_nat\n                           (GREATEST n.\n                               \\<not> is_zero_row_upt_k n (Suc k) A'))))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  (mod_type_class.from_nat\n    (Suc (mod_type_class.to_nat\n           (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A'))))\n  (mod_type_class.from_nat (Suc k))))", "apply (simp_all only: from_nat_0 from_nat_to_nat_greatest)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "proof -"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume \"\\<forall>m. is_zero_row_upt_k m (Suc k) A'\" and \"\\<forall>m\\<ge>0. A' $ m $ from_nat (Suc k) = 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  \\<forall>m\\<ge>0::'rows.\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (9 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>0::'rows.\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 6. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 8. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 9. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "thus \"is_zero_row_upt_k m (Suc (Suc k)) A'\""], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  \\<forall>m\\<ge>0::'rows.\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k m (Suc (Suc k)) A'", "using foldl_Gauss_condition_1"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  \\<forall>m\\<ge>0::'rows.\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n  \\<lbrakk>\\<forall>m. is_zero_row_upt_k m ?k ?A;\n   \\<forall>m\\<ge>0::?'rows.\n      ?A $ m $ mod_type_class.from_nat ?k = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> is_zero_row_upt_k ?m (Suc ?k) ?A\n\ngoal (1 subgoal):\n 1. is_zero_row_upt_k m (Suc (Suc k)) A'", "by blast"], ["proof (state)\nthis:\n  is_zero_row_upt_k m (Suc (Suc k)) A'\n\ngoal (8 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume \"\\<forall>m. is_zero_row_upt_k m (Suc k) A'\"\n        and \"A' $ m $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (8 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A' (0::'rows)\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 5. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 7. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 8. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "thus \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) (Gauss_Jordan_in_ij A' 0 (from_nat (Suc k)))\""], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (Gauss_Jordan_in_ij A' (0::'rows)\n                 (mod_type_class.from_nat (Suc k)))", "using foldl_Gauss_condition_2 k ncols_eq"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<lbrakk>?k < ncols ?A; \\<forall>m. is_zero_row_upt_k m ?k ?A;\n   ?A $ ?m $ mod_type_class.from_nat ?k \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       \\<not> is_zero_row_upt_k m (Suc ?k)\n                               (Gauss_Jordan_in_ij ?A (0::?'rows)\n                                 (mod_type_class.from_nat ?k))\n  Suc k < ncols A\n  ncols A = ncols A'\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (Gauss_Jordan_in_ij A' (0::'rows)\n                 (mod_type_class.from_nat (Suc k)))", "by simp"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc (Suc k))\n             (Gauss_Jordan_in_ij A' (0::'rows)\n               (mod_type_class.from_nat (Suc k)))\n\ngoal (7 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m ma"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume \"\\<forall>m. is_zero_row_upt_k m (Suc k) A'\"\n        and \"A' $ m $ from_nat (Suc k) \\<noteq> 0\"\n        and \"\\<not> is_zero_row_upt_k ma (Suc (Suc k)) (Gauss_Jordan_in_ij A' 0 (from_nat (Suc k)))\""], ["proof (state)\nthis:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n          (Gauss_Jordan_in_ij A' (0::'rows)\n            (mod_type_class.from_nat (Suc k)))\n\ngoal (7 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<forall>m. is_zero_row_upt_k m (Suc k) A';\n        (0::'rows) \\<le> m;\n        A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n                (Gauss_Jordan_in_ij A' (0::'rows)\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A' (0::'rows) (mod_type_class.from_nat (Suc k)))) =\n                         0\n 2. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 4. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 6. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 7. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "thus \"to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) (Gauss_Jordan_in_ij A' 0 (from_nat (Suc k)))) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n          (Gauss_Jordan_in_ij A' (0::'rows)\n            (mod_type_class.from_nat (Suc k)))\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (Gauss_Jordan_in_ij A' (0::'rows)\n                   (mod_type_class.from_nat (Suc k)))) =\n    0", "using foldl_Gauss_condition_3  k ncols_eq"], ["proof (prove)\nusing this:\n  \\<forall>m. is_zero_row_upt_k m (Suc k) A'\n  A' $ m $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k ma (Suc (Suc k))\n          (Gauss_Jordan_in_ij A' (0::'rows)\n            (mod_type_class.from_nat (Suc k)))\n  \\<lbrakk>?k < ncols ?A; \\<forall>m. is_zero_row_upt_k m ?k ?A;\n   ?A $ ?m $ mod_type_class.from_nat ?k \\<noteq> (0::?'a);\n   \\<not> is_zero_row_upt_k ?ma (Suc ?k)\n           (Gauss_Jordan_in_ij ?A (0::?'rows)\n             (mod_type_class.from_nat ?k))\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.to_nat\n                     (GREATEST n.\n                         \\<not> is_zero_row_upt_k n (Suc ?k)\n                                 (Gauss_Jordan_in_ij ?A (0::?'rows)\n                                   (mod_type_class.from_nat ?k))) =\n                    0\n  Suc k < ncols A\n  ncols A = ncols A'\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (Gauss_Jordan_in_ij A' (0::'rows)\n                   (mod_type_class.from_nat (Suc k)))) =\n    0", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc (Suc k))\n               (Gauss_Jordan_in_ij A' (0::'rows)\n                 (mod_type_class.from_nat (Suc k)))) =\n  0\n\ngoal (6 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume \"\\<not> is_zero_row_upt_k m (Suc k) A' \""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n\ngoal (6 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 3. \\<And>m.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n 4. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 5. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 6. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "thus \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\" and \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n\ngoal (1 subgoal):\n 1. \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A' &&&\n    \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'", "using is_zero_row_upt_k_le"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  is_zero_row_upt_k ?i (Suc ?k) ?A \\<Longrightarrow>\n  is_zero_row_upt_k ?i ?k ?A\n\ngoal (1 subgoal):\n 1. \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A' &&&\n    \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'", "by blast+"], ["proof (state)\nthis:\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n  \\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) A'\n\ngoal (4 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume not_zero_m: \"\\<not> is_zero_row_upt_k m (Suc k) A'\"\n        and zero_below_greatest: \"\\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + 1. A' $ m $ from_nat (Suc k) = 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                 (1::'rows).\n     A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a)\n\ngoal (4 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        \\<forall>m\\<ge>(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                       (1::'rows).\n           A' $ m $ mod_type_class.from_nat (Suc k) = (0::'a);\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc k) A') =\n                         (GREATEST n.\n                             \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 3. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 4. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "show \"(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') = (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') =\n    (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')", "by (rule foldl_Gauss_condition_5[OF rref_A' not_zero_m zero_below_greatest])"], ["proof (state)\nthis:\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') =\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A')\n\ngoal (3 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume \"\\<not> is_zero_row_upt_k m (Suc k) A'\" and \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) = nrows A'\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n\ngoal (3 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        nrows A';\n        \\<not> is_zero_row_upt_k ma (Suc (Suc k)) A'\\<rbrakk>\n       \\<Longrightarrow> nrows A' =\n                         Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc (Suc k))\n     A'))\n 2. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 3. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "thus \"nrows A' = Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n\ngoal (1 subgoal):\n 1. nrows A' =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))", "using foldl_Gauss_condition_6"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  nrows A'\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?m ?k ?A;\n   Suc (mod_type_class.to_nat\n         (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A)) =\n   nrows ?A\\<rbrakk>\n  \\<Longrightarrow> nrows ?A =\n                    Suc (mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc ?k) ?A))\n\ngoal (1 subgoal):\n 1. nrows A' =\n    Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))", "by blast"], ["proof (state)\nthis:\n  nrows A' =\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) A'))\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m ma"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume \"\\<not> is_zero_row_upt_k m (Suc k) A'\"\n        and \"(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + 1 \\<le> ma\"\n        and \"A' $ ma $ from_nat (Suc k) \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>m ma.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            \\<not> is_zero_row_upt_k m (Suc (Suc k))\n                                    (Gauss_Jordan_in_ij A'\n((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n(mod_type_class.from_nat (Suc k)))\n 2. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "thus \"\\<exists>m. \\<not> is_zero_row_upt_k m (Suc (Suc k)) (Gauss_Jordan_in_ij A' ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + 1) (from_nat (Suc k)))\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (Gauss_Jordan_in_ij A'\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)))", "using foldl_Gauss_condition_8"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<lbrakk>?k < ncols ?A; \\<not> is_zero_row_upt_k ?m ?k ?A;\n   ?A $ ?ma $ mod_type_class.from_nat ?k \\<noteq> (0::?'a);\n   (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) + (1::?'rows)\n   \\<le> ?ma\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       \\<not> is_zero_row_upt_k m (Suc ?k)\n                               (Gauss_Jordan_in_ij ?A\n                                 ((GREATEST n.\n\\<not> is_zero_row_upt_k n ?k ?A) +\n                                  (1::?'rows))\n                                 (mod_type_class.from_nat ?k))\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (Gauss_Jordan_in_ij A'\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)))", "using k ncols_eq"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<lbrakk>?k < ncols ?A; \\<not> is_zero_row_upt_k ?m ?k ?A;\n   ?A $ ?ma $ mod_type_class.from_nat ?k \\<noteq> (0::?'a);\n   (GREATEST n. \\<not> is_zero_row_upt_k n ?k ?A) + (1::?'rows)\n   \\<le> ?ma\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m.\n                       \\<not> is_zero_row_upt_k m (Suc ?k)\n                               (Gauss_Jordan_in_ij ?A\n                                 ((GREATEST n.\n\\<not> is_zero_row_upt_k n ?k ?A) +\n                                  (1::?'rows))\n                                 (mod_type_class.from_nat ?k))\n  Suc k < ncols A\n  ncols A = ncols A'\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<not> is_zero_row_upt_k m (Suc (Suc k))\n               (Gauss_Jordan_in_ij A'\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k)))", "by simp"], ["proof (state)\nthis:\n  \\<exists>m.\n     \\<not> is_zero_row_upt_k m (Suc (Suc k))\n             (Gauss_Jordan_in_ij A'\n               ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                (1::'rows))\n               (mod_type_class.from_nat (Suc k)))\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "fix m ma mb"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "assume \"\\<not> is_zero_row_upt_k m (Suc k) A'\" and\n        \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq> nrows A'\"\n        and \"(GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + 1 \\<le> ma\"\n        and \"A' $ ma $ from_nat (Suc k) \\<noteq> 0\"\n        and \"\\<not> is_zero_row_upt_k mb (Suc (Suc k)) (Gauss_Jordan_in_ij A' ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + 1) (from_nat (Suc k)))\""], ["proof (state)\nthis:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  nrows A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n          (Gauss_Jordan_in_ij A'\n            ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows))\n            (mod_type_class.from_nat (Suc k)))\n\ngoal (1 subgoal):\n 1. \\<And>m ma mb.\n       \\<lbrakk>\\<not> is_zero_row_upt_k m (Suc k) A';\n        Suc (mod_type_class.to_nat\n              (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n        nrows A';\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n        \\<le> ma;\n        A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a);\n        \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n                (Gauss_Jordan_in_ij A'\n                  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                   (1::'rows))\n                  (mod_type_class.from_nat (Suc k)))\\<rbrakk>\n       \\<Longrightarrow> Suc (mod_type_class.to_nat\n                               (GREATEST n.\n                                   \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                         mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc (Suc k))\n(Gauss_Jordan_in_ij A'\n  ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows))\n  (mod_type_class.from_nat (Suc k))))", "thus \"Suc (to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n        to_nat (GREATEST n. \\<not> is_zero_row_upt_k n (Suc (Suc k)) (Gauss_Jordan_in_ij A' ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + 1) (from_nat (Suc k))))\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  nrows A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n          (Gauss_Jordan_in_ij A'\n            ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows))\n            (mod_type_class.from_nat (Suc k)))\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (Gauss_Jordan_in_ij A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k))))", "using foldl_Gauss_condition_9[OF k[unfolded ncols_eq] rref_A']"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  nrows A'\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n          (Gauss_Jordan_in_ij A'\n            ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows))\n            (mod_type_class.from_nat (Suc k)))\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?m (Suc k) A';\n   Suc (mod_type_class.to_nat\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n   nrows A';\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n   \\<le> ?ma;\n   A' $ ?ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> Suc (mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                    mod_type_class.to_nat\n                     (GREATEST n.\n                         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                                 (Gauss_Jordan_in_ij A'\n                                   ((GREATEST n.\n  \\<not> is_zero_row_upt_k n (Suc k) A') +\n                                    (1::'rows))\n                                   (mod_type_class.from_nat (Suc k))))\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (Gauss_Jordan_in_ij A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k))))", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row_upt_k m (Suc k) A'\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n  CARD('rows)\n  (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows) \\<le> ma\n  A' $ ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\n  \\<not> is_zero_row_upt_k mb (Suc (Suc k))\n          (Gauss_Jordan_in_ij A'\n            ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n             (1::'rows))\n            (mod_type_class.from_nat (Suc k)))\n  \\<lbrakk>\\<not> is_zero_row_upt_k ?m (Suc k) A';\n   Suc (mod_type_class.to_nat\n         (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) \\<noteq>\n   CARD('rows);\n   (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') + (1::'rows)\n   \\<le> ?ma;\n   A' $ ?ma $ mod_type_class.from_nat (Suc k) \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> Suc (mod_type_class.to_nat\n                          (GREATEST n.\n                              \\<not> is_zero_row_upt_k n (Suc k) A')) =\n                    mod_type_class.to_nat\n                     (GREATEST n.\n                         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                                 (Gauss_Jordan_in_ij A'\n                                   ((GREATEST n.\n  \\<not> is_zero_row_upt_k n (Suc k) A') +\n                                    (1::'rows))\n                                   (mod_type_class.from_nat (Suc k))))\n\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n    mod_type_class.to_nat\n     (GREATEST n.\n         \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                 (Gauss_Jordan_in_ij A'\n                   ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                    (1::'rows))\n                   (mod_type_class.from_nat (Suc k))))", "by blast"], ["proof (state)\nthis:\n  Suc (mod_type_class.to_nat\n        (GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A')) =\n  mod_type_class.to_nat\n   (GREATEST n.\n       \\<not> is_zero_row_upt_k n (Suc (Suc k))\n               (Gauss_Jordan_in_ij A'\n                 ((GREATEST n. \\<not> is_zero_row_upt_k n (Suc k) A') +\n                  (1::'rows))\n                 (mod_type_class.from_nat (Suc k))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) =\n  fst (if \\<forall>m.\n             is_zero_row_upt_k m (Suc (Suc k))\n              (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n       then 0\n       else mod_type_class.to_nat\n             (GREATEST n.\n                 \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                         (snd (foldl Gauss_Jordan_column_k (0, A)\n                                [0..<Suc (Suc k)]))) +\n            1,\n       snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)] =\n  (if \\<forall>m.\n         is_zero_row_upt_k m (Suc (Suc k))\n          (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n   then 0\n   else mod_type_class.to_nat\n         (GREATEST n.\n             \\<not> is_zero_row_upt_k n (Suc (Suc k))\n                     (snd (foldl Gauss_Jordan_column_k (0, A)\n                            [0..<Suc (Suc k)]))) +\n        1,\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary rref_Gauss_Jordan:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"reduced_row_echelon_form (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form (Gauss_Jordan A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form (Gauss_Jordan A)", "have \"CARD('columns) - 1 < CARD('columns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('columns) - 1 < CARD('columns)", "by fastforce"], ["proof (state)\nthis:\n  CARD('columns) - 1 < CARD('columns)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form (Gauss_Jordan A)", "thus \"reduced_row_echelon_form (Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  CARD('columns) - 1 < CARD('columns)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form (Gauss_Jordan A)", "unfolding reduced_row_echelon_form_def"], ["proof (prove)\nusing this:\n  CARD('columns) - 1 < CARD('columns)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))", "unfolding Gauss_Jordan_def"], ["proof (prove)\nusing this:\n  CARD('columns) - 1 < CARD('columns)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A (ncols A - 1))\n     (ncols (Gauss_Jordan_upt_k A (ncols A - 1)))", "using rref_Gauss_Jordan_upt_k"], ["proof (prove)\nusing this:\n  CARD('columns) - 1 < CARD('columns)\n  ?k < ncols ?A \\<Longrightarrow>\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k ?A ?k) (Suc ?k)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k A (ncols A - 1))\n     (ncols (Gauss_Jordan_upt_k A (ncols A - 1)))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  CARD('columns) - 1 < CARD('columns)\n  ?k < CARD(?'columns) \\<Longrightarrow>\n  reduced_row_echelon_form_upt_k (Gauss_Jordan_upt_k ?A ?k) (Suc ?k)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k\n     (Gauss_Jordan_upt_k A (CARD('columns) - 1)) CARD('columns)", "by (metis (mono_tags) diff_Suc_1 lessE)"], ["proof (state)\nthis:\n  reduced_row_echelon_form (Gauss_Jordan A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma independent_not_zero_rows_rref:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"vec.independent {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent {row i A |i. row i A \\<noteq> 0}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "define R where \"R = {row i A |i. row i A \\<noteq> 0}\""], ["proof (state)\nthis:\n  R = {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "assume dep: \"vec.dependent R\""], ["proof (state)\nthis:\n  vec.dependent R\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  vec.dependent R", "obtain a where a_in_R: \"a\\<in>R\" and a_in_span: \"a \\<in> vec.span (R - {a})\""], ["proof (prove)\nusing this:\n  vec.dependent R\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> R; a \\<in> vec.span (R - {a})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vec.dependent_def"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>R. a \\<in> vec.span (R - {a})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> R; a \\<in> vec.span (R - {a})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  a \\<in> R\n  a \\<in> vec.span (R - {a})\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "from a_in_R"], ["proof (chain)\npicking this:\n  a \\<in> R", "obtain i where a_eq_row_i_A: \"a=row i A\""], ["proof (prove)\nusing this:\n  a \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>i. a = row i A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding R_def"], ["proof (prove)\nusing this:\n  a \\<in> {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>i. a = row i A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  a = row i A\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "hence a_eq_Ai: \"a = A $ i\""], ["proof (prove)\nusing this:\n  a = row i A\n\ngoal (1 subgoal):\n 1. a = A $ i", "unfolding row_def"], ["proof (prove)\nusing this:\n  a = vec_lambda (($) (A $ i))\n\ngoal (1 subgoal):\n 1. a = A $ i", "unfolding vec_nth_inverse"], ["proof (prove)\nusing this:\n  a = A $ i\n\ngoal (1 subgoal):\n 1. a = A $ i", "."], ["proof (state)\nthis:\n  a = A $ i\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have row_i_A_not_zero: \"\\<not> is_zero_row i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A", "using a_in_R"], ["proof (prove)\nusing this:\n  a \\<in> R\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A", "unfolding R_def is_zero_row_def is_zero_row_upt_ncols row_def vec_nth_inverse"], ["proof (prove)\nusing this:\n  a \\<in> {A $ i |i. A $ i \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j. A $ i $ j = (0::'a))", "unfolding vec_lambda_unique zero_vec_def mem_Collect_eq"], ["proof (prove)\nusing this:\n  \\<exists>i. a = A $ i \\<and> A $ i \\<noteq> (\\<chi>i. (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<chi>j. (0::'a)) \\<noteq> A $ i", "using a_eq_Ai"], ["proof (prove)\nusing this:\n  \\<exists>i. a = A $ i \\<and> A $ i \\<noteq> (\\<chi>i. (0::'a))\n  a = A $ i\n\ngoal (1 subgoal):\n 1. (\\<chi>j. (0::'a)) \\<noteq> A $ i", "by force"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "define least_n where \"least_n = (LEAST n. A $ i $ n \\<noteq> 0)\""], ["proof (state)\nthis:\n  least_n = (LEAST n. A $ i $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have span_rw: \"vec.span (R - {a}) = range (\\<lambda>u. \\<Sum>v\\<in>R - {a}. u v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span (R - {a}) = range (\\<lambda>u. \\<Sum>v\\<in>R - {a}. u v *s v)", "proof (rule vec.span_finite)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (R - {a})", "show \"finite (R - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R - {a})", "using finite_rows[of A]"], ["proof (prove)\nusing this:\n  finite (rows A)\n\ngoal (1 subgoal):\n 1. finite (R - {a})", "unfolding rows_def R_def"], ["proof (prove)\nusing this:\n  finite {row i A |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. finite ({row i A |i. row i A \\<noteq> 0} - {a})", "by simp"], ["proof (state)\nthis:\n  finite (R - {a})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec.span (R - {a}) = range (\\<lambda>u. \\<Sum>v\\<in>R - {a}. u v *s v)\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  vec.span (R - {a}) = range (\\<lambda>u. \\<Sum>v\\<in>R - {a}. u v *s v)", "obtain f where f: \"(\\<Sum>v\\<in>(R - {a}). f v *s v) = a\""], ["proof (prove)\nusing this:\n  vec.span (R - {a}) = range (\\<lambda>u. \\<Sum>v\\<in>R - {a}. u v *s v)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<Sum>v\\<in>R - {a}. f v *s v) = a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using a_in_span"], ["proof (prove)\nusing this:\n  vec.span (R - {a}) = range (\\<lambda>u. \\<Sum>v\\<in>R - {a}. u v *s v)\n  a \\<in> vec.span (R - {a})\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<Sum>v\\<in>R - {a}. f v *s v) = a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) imageE)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. f v *s v) = a\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have \"1 = a $ least_n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) = a $ least_n", "using rref_condition2[OF rref_A] row_i_A_not_zero"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (1::'a) = a $ least_n", "unfolding least_n_def a_eq_Ai"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (1::'a) = A $ i $ (LEAST n. A $ i $ n \\<noteq> (0::'a))", "by presburger"], ["proof (state)\nthis:\n  (1::'a) = a $ least_n\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (1::'a) = a $ least_n\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have\"... = (\\<Sum>v\\<in>(R - {a}). f v *s v) $ least_n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a $ least_n = (\\<Sum>v\\<in>R - {a}. f v *s v) $ least_n", "using f"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>R - {a}. f v *s v) = a\n\ngoal (1 subgoal):\n 1. a $ least_n = (\\<Sum>v\\<in>R - {a}. f v *s v) $ least_n", "by auto"], ["proof (state)\nthis:\n  a $ least_n = (\\<Sum>v\\<in>R - {a}. f v *s v) $ least_n\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  a $ least_n = (\\<Sum>v\\<in>R - {a}. f v *s v) $ least_n\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have \"... = (\\<Sum>v\\<in>(R - {a}). (f v *s v) $ least_n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>R - {a}. f v *s v) $ least_n =\n    (\\<Sum>v\\<in>R - {a}. (f v *s v) $ least_n)", "unfolding sum_component"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>R - {a}. (f x *s x) $ least_n) =\n    (\\<Sum>v\\<in>R - {a}. (f v *s v) $ least_n)", ".."], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. f v *s v) $ least_n =\n  (\\<Sum>v\\<in>R - {a}. (f v *s v) $ least_n)\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. f v *s v) $ least_n =\n  (\\<Sum>v\\<in>R - {a}. (f v *s v) $ least_n)\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have \"... = (\\<Sum>v\\<in>(R - {a}). (f v) * (v $ least_n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>R - {a}. (f v *s v) $ least_n) =\n    (\\<Sum>v\\<in>R - {a}. f v * v $ least_n)", "unfolding vector_smult_component"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>R - {a}. f v * v $ least_n) =\n    (\\<Sum>v\\<in>R - {a}. f v * v $ least_n)", ".."], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. (f v *s v) $ least_n) =\n  (\\<Sum>v\\<in>R - {a}. f v * v $ least_n)\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. (f v *s v) $ least_n) =\n  (\\<Sum>v\\<in>R - {a}. f v * v $ least_n)\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have \"... = (\\<Sum>v\\<in>(R - {a}). 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>R - {a}. f v * v $ least_n) =\n    (\\<Sum>v\\<in>R - {a}. (0::'a))", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. R - {a} = R - {a}\n 2. \\<And>x. x \\<in> R - {a} \\<Longrightarrow> f x * x $ least_n = (0::'a)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. R - {a} = R - {a}\n 2. \\<And>x. x \\<in> R - {a} \\<Longrightarrow> f x * x $ least_n = (0::'a)", "assume x: \"x \\<in> R - {a}\""], ["proof (state)\nthis:\n  x \\<in> R - {a}\n\ngoal (2 subgoals):\n 1. R - {a} = R - {a}\n 2. \\<And>x. x \\<in> R - {a} \\<Longrightarrow> f x * x $ least_n = (0::'a)", "from this"], ["proof (chain)\npicking this:\n  x \\<in> R - {a}", "obtain j where x_eq_row_j_A: \"x=row j A\""], ["proof (prove)\nusing this:\n  x \\<in> R - {a}\n\ngoal (1 subgoal):\n 1. (\\<And>j. x = row j A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding R_def"], ["proof (prove)\nusing this:\n  x \\<in> {row i A |i. row i A \\<noteq> 0} - {a}\n\ngoal (1 subgoal):\n 1. (\\<And>j. x = row j A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x = row j A\n\ngoal (2 subgoals):\n 1. R - {a} = R - {a}\n 2. \\<And>x. x \\<in> R - {a} \\<Longrightarrow> f x * x $ least_n = (0::'a)", "hence i_not_j: \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  x = row j A\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "using a_eq_row_i_A x"], ["proof (prove)\nusing this:\n  x = row j A\n  a = row i A\n  x \\<in> R - {a}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. R - {a} = R - {a}\n 2. \\<And>x. x \\<in> R - {a} \\<Longrightarrow> f x * x $ least_n = (0::'a)", "have x_least_is_zero: \"x $ least_n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ least_n = (0::'a)", "using rref_condition4[OF rref_A] i_not_j row_i_A_not_zero"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n  i \\<noteq> j\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. x $ least_n = (0::'a)", "unfolding x_eq_row_j_A least_n_def row_def vec_nth_inverse"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n  i \\<noteq> j\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  x $ least_n = (0::'a)\n\ngoal (2 subgoals):\n 1. R - {a} = R - {a}\n 2. \\<And>x. x \\<in> R - {a} \\<Longrightarrow> f x * x $ least_n = (0::'a)", "show \"f x * x $ least_n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x * x $ least_n = (0::'a)", "unfolding x_least_is_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x * (0::'a) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  f x * x $ least_n = (0::'a)\n\ngoal (1 subgoal):\n 1. R - {a} = R - {a}", "qed rule"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. f v * v $ least_n) = (\\<Sum>v\\<in>R - {a}. (0::'a))\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. f v * v $ least_n) = (\\<Sum>v\\<in>R - {a}. (0::'a))\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>R - {a}. (0::'a)) = (0::'a)", "unfolding sum.neutral_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = (0::'a)", ".."], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>R - {a}. (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. vec.dependent {row i A |i. row i A \\<noteq> 0} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (1::'a) = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  (1::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Here we start to prove that the transformation from the original matrix to its reduced row echelon form has been carried out by means of elementary operations.\\<close>"], ["", "text\\<open>The following function eliminates all entries of the j-th column using the non-zero element situated in the position (i,j).\nIt is introduced to make easier the proof that each Gauss-Jordan step consists in applying suitable elementary operations.\\<close>"], ["", "primrec row_add_iterate :: \"'a::{semiring_1, uminus}^'n^'m::{mod_type} => nat => 'm => 'n => 'a^'n^'m::{mod_type}\"\n  where \"row_add_iterate A 0 i j = (if i=0 then A else row_add A 0 i (-A $ 0 $ j))\"\n  | \"row_add_iterate A (Suc n) i j = (if (Suc n = to_nat i) then row_add_iterate A n i j\n     else row_add_iterate (row_add A (from_nat (Suc n)) i (- A $ (from_nat (Suc n)) $ j)) n i j)\""], ["", "lemma invertible_row_add_iterate:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes n: \"n<nrows A\"\n  shows \"\\<exists>P. invertible P \\<and> row_add_iterate A n i j = P**A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A n i j = P ** A", "using n"], ["proof (prove)\nusing this:\n  n < nrows A\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A n i j = P ** A", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 < nrows A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "fix A::\"'a::{ring_1}^'n^'m::{mod_type}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       0 < nrows A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "show \"\\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "proof (cases \"i=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = (0::'m) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\n 2. i \\<noteq> (0::'m) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "case True"], ["proof (state)\nthis:\n  i = (0::'m)\n\ngoal (2 subgoals):\n 1. i = (0::'m) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\n 2. i \\<noteq> (0::'m) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "unfolding row_add_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       (if i = (0::'m) then A\n        else row_add A (0::'m) i (- A $ (0::'m) $ j)) =\n       P ** A", "by (metis True invertible_def matrix_mul_lid)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'m) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'m) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "case False"], ["proof (state)\nthis:\n  i \\<noteq> (0::'m)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'m) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A", "by (metis False invertible_row_add row_add_iterate.simps(1) row_add_mat_1)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> row_add_iterate A 0 i j = P ** A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "fix n and A::\"'a::{ring_1}^'n^'m::{mod_type}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "define A' where \"A' = row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)\""], ["proof (state)\nthis:\n  A' =\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j)\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "assume  hyp: \"\\<And>A::'a::{ring_1}^'n^'m::{mod_type}. n < nrows A \\<Longrightarrow> \\<exists>P. invertible P \\<and> row_add_iterate A n i j = P ** A\" and Suc_n: \"Suc n < nrows A\""], ["proof (state)\nthis:\n  n < nrows ?A \\<Longrightarrow>\n  \\<exists>P. invertible P \\<and> row_add_iterate ?A n i j = P ** ?A\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "hence \"\\<exists>P. invertible P \\<and> row_add_iterate A' n i j = P ** A'\""], ["proof (prove)\nusing this:\n  n < nrows ?A \\<Longrightarrow>\n  \\<exists>P. invertible P \\<and> row_add_iterate ?A n i j = P ** ?A\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A' n i j = P ** A'", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  n < CARD('m) \\<Longrightarrow>\n  \\<exists>P. invertible P \\<and> row_add_iterate ?A n i j = P ** ?A\n  Suc n < CARD('m)\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A' n i j = P ** A'", "by auto"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> row_add_iterate A' n i j = P ** A'\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P. invertible P \\<and> row_add_iterate A' n i j = P ** A'", "obtain P where inv_P: \"invertible P\"  and P: \"row_add_iterate A' n i j = P ** A'\""], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> row_add_iterate A' n i j = P ** A'\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P; row_add_iterate A' n i j = P ** A'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  invertible P\n  row_add_iterate A' n i j = P ** A'\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   n < nrows A \\<Longrightarrow>\n                   \\<exists>P.\n                      invertible P \\<and> row_add_iterate A n i j = P ** A;\n        Suc n < nrows A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            row_add_iterate A (Suc n) i j = P ** A", "show \"\\<exists>P. invertible P \\<and> row_add_iterate A (Suc n) i j = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A (Suc n) i j = P ** A", "unfolding row_add_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "show \"\\<exists>P. invertible P \\<and>\n      (if Suc n = to_nat i then row_add_iterate A n i j\n      else row_add_iterate (row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)) n i j) =\n      P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "unfolding if_P[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A n i j = P ** A", "using hyp Suc_n"], ["proof (prove)\nusing this:\n  n < nrows ?A \\<Longrightarrow>\n  \\<exists>P. invertible P \\<and> row_add_iterate ?A n i j = P ** ?A\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> row_add_iterate A n i j = P ** A", "by simp"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n      else row_add_iterate\n            (row_add A (mod_type_class.from_nat (Suc n)) i\n              (- A $ mod_type_class.from_nat (Suc n) $ j))\n            n i j) =\n     P ** A\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "show \"\\<exists>P. invertible P \\<and>\n      (if Suc n = to_nat i then row_add_iterate A n i j\n      else row_add_iterate (row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)) n i j) =\n      P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n        else row_add_iterate\n              (row_add A (mod_type_class.from_nat (Suc n)) i\n                (- A $ mod_type_class.from_nat (Suc n) $ j))\n              n i j) =\n       P ** A", "unfolding if_not_P[OF False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       row_add_iterate\n        (row_add A (mod_type_class.from_nat (Suc n)) i\n          (- A $ mod_type_class.from_nat (Suc n) $ j))\n        n i j =\n       P ** A", "unfolding P[unfolded A'_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Pa.\n       invertible Pa \\<and>\n       P **\n       row_add A (mod_type_class.from_nat (Suc n)) i\n        (- A $ mod_type_class.from_nat (Suc n) $ j) =\n       Pa ** A", "proof (rule exI[of _ \"P ** (row_add (mat 1) (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j))\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. invertible\n     (P **\n      row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n 2. P **\n    row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) =\n    P **\n    row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) **\n    A", "show \"invertible (P ** row_add (mat 1) (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible\n     (P **\n      row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))", "by (metis False Suc_n inv_P invertible_mult invertible_row_add to_nat_from_nat_id nrows_def)"], ["proof (state)\nthis:\n  invertible\n   (P **\n    row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j))\n\ngoal (1 subgoal):\n 1. P **\n    row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) =\n    P **\n    row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) **\n    A", "show \"P ** row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j) =\n        P ** row_add (mat 1) (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j) ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P **\n    row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) =\n    P **\n    row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) **\n    A", "using matrix_mul_assoc row_add_mat_1[of \"from_nat (Suc n)\" i \" (- A $ from_nat (Suc n) $ j)\"]"], ["proof (prove)\nusing this:\n  ?A ** (?B ** ?C) = ?A ** ?B ** ?C\n  row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j) **\n  ?A =\n  row_add ?A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j)\n\ngoal (1 subgoal):\n 1. P **\n    row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) =\n    P **\n    row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) **\n    A", "by metis"], ["proof (state)\nthis:\n  P **\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j) =\n  P **\n  row_add (mat (1::'a)) (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j) **\n  A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     (if Suc n = mod_type_class.to_nat i then row_add_iterate A n i j\n      else row_add_iterate\n            (row_add A (mod_type_class.from_nat (Suc n)) i\n              (- A $ mod_type_class.from_nat (Suc n) $ j))\n            n i j) =\n     P ** A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> row_add_iterate A (Suc n) i j = P ** A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_add_iterate_preserves_greater_than_n:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes n: \"n<nrows A\"\n  and a: \"to_nat a > n\"\n  shows \"(row_add_iterate A n i j) $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = A $ a $ b", "using assms"], ["proof (prove)\nusing this:\n  n < nrows A\n  n < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = A $ a $ b", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 < nrows A; 0 < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A 0 i j $ a $ b = A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     A $ a $ b;\n        Suc n < nrows A; Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "case 0"], ["proof (state)\nthis:\n  0 < nrows A\n  0 < mod_type_class.to_nat a\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 < nrows A; 0 < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A 0 i j $ a $ b = A $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     A $ a $ b;\n        Suc n < nrows A; Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A 0 i j $ a $ b = A $ a $ b", "unfolding row_add_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = (0::'m) then A else row_add A (0::'m) i (- A $ (0::'m) $ j)) $\n    a $\n    b =\n    A $ a $ b", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'m) \\<Longrightarrow>\n    row_add A (0::'m) i (- A $ (0::'m) $ j) $ a $ b = A $ a $ b", "assume \"i \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> (0::'m)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'m) \\<Longrightarrow>\n    row_add A (0::'m) i (- A $ (0::'m) $ j) $ a $ b = A $ a $ b", "hence \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> (0::'m)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'m)", "by (metis \"0.prems\"(2) less_numeral_extra(3) to_nat_0)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'m)\n\ngoal (1 subgoal):\n 1. i \\<noteq> (0::'m) \\<Longrightarrow>\n    row_add A (0::'m) i (- A $ (0::'m) $ j) $ a $ b = A $ a $ b", "thus \"row_add A 0 i (- A $ 0 $ j) $ a $ b = A $ a $ b\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'m)\n\ngoal (1 subgoal):\n 1. row_add A (0::'m) i (- A $ (0::'m) $ j) $ a $ b = A $ a $ b", "unfolding row_add_def"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'m)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = (0::'m)\n        then A $ (0::'m) $ ja + - A $ (0::'m) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b =\n    A $ a $ b", "by auto"], ["proof (state)\nthis:\n  row_add A (0::'m) i (- A $ (0::'m) $ j) $ a $ b = A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A 0 i j $ a $ b = A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     A $ a $ b;\n        Suc n < nrows A; Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     A $ a $ b;\n        Suc n < nrows A; Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "fix n and A::\"'a::{ring_1}^'n^'m::{mod_type}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     A $ a $ b;\n        Suc n < nrows A; Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "assume hyp: \"(\\<And>A::'a::{ring_1}^'n^'m::{mod_type}. n < nrows A \\<Longrightarrow> n < to_nat a \\<Longrightarrow> row_add_iterate A n i j $ a $ b = A $ a $ b)\"\n    and suc_n_less_card: \"Suc n < nrows A\" and suc_n_kess_a: \"Suc n < to_nat a\""], ["proof (state)\nthis:\n  \\<lbrakk>n < nrows ?A; n < mod_type_class.to_nat a\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ a $ b = ?A $ a $ b\n  Suc n < nrows A\n  Suc n < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     A $ a $ b;\n        Suc n < nrows A; Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "hence row_add_iterate_A: \"row_add_iterate A n i j $ a $ b = A $ a $ b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n < nrows ?A; n < mod_type_class.to_nat a\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ a $ b = ?A $ a $ b\n  Suc n < nrows A\n  Suc n < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = A $ a $ b", "by auto"], ["proof (state)\nthis:\n  row_add_iterate A n i j $ a $ b = A $ a $ b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    n < mod_type_class.to_nat a\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     A $ a $ b;\n        Suc n < nrows A; Suc n < mod_type_class.to_nat a\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "show \"row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "show \"row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "unfolding row_add_iterate.simps if_P[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = A $ a $ b", "using row_add_iterate_A"], ["proof (prove)\nusing this:\n  row_add_iterate A n i j $ a $ b = A $ a $ b\n\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = A $ a $ b", "."], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "define A' where \"A' = row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)\""], ["proof (state)\nthis:\n  A' =\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "have row_add_iterate_A': \"row_add_iterate A' n i j $ a $ b = A' $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ a $ b = A' $ a $ b", "using hyp suc_n_less_card suc_n_kess_a"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < nrows ?A; n < mod_type_class.to_nat a\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ a $ b = ?A $ a $ b\n  Suc n < nrows A\n  Suc n < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ a $ b = A' $ a $ b", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < CARD('m); n < mod_type_class.to_nat a\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ a $ b = ?A $ a $ b\n  Suc n < CARD('m)\n  Suc n < mod_type_class.to_nat a\n\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ a $ b = A' $ a $ b", "by auto"], ["proof (state)\nthis:\n  row_add_iterate A' n i j $ a $ b = A' $ a $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "have from_nat_not_a: \"from_nat (Suc n) \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) \\<noteq> a", "by (metis less_not_refl suc_n_kess_a suc_n_less_card to_nat_from_nat_id nrows_def)"], ["proof (state)\nthis:\n  mod_type_class.from_nat (Suc n) \\<noteq> a\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "show \"row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b", "unfolding row_add_iterate.simps if_not_P[OF False] row_add_iterate_A'[unfolded A'_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) $\n    a $\n    b =\n    A $ a $ b", "unfolding row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b =\n    A $ a $ b", "using from_nat_not_a"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (Suc n) \\<noteq> a\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b =\n    A $ a $ b", "by simp"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ a $ b = A $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_add_iterate_preserves_pivot_row:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes n: \"n<nrows A\"\n  and a: \"to_nat i \\<le> n\"\n  shows \"(row_add_iterate A n i j) $ i $ b = A $ i $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ i $ b = A $ i $ b", "using assms"], ["proof (prove)\nusing this:\n  n < nrows A\n  mod_type_class.to_nat i \\<le> n\n\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ i $ b = A $ i $ b", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 < nrows A; mod_type_class.to_nat i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A 0 i j $ i $ b = A $ i $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ i $ b =\n                                     A $ i $ b;\n        Suc n < nrows A; mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "case 0"], ["proof (state)\nthis:\n  0 < nrows A\n  mod_type_class.to_nat i \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 < nrows A; mod_type_class.to_nat i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A 0 i j $ i $ b = A $ i $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ i $ b =\n                                     A $ i $ b;\n        Suc n < nrows A; mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A 0 i j $ i $ b = A $ i $ b", "by (metis \"0.prems\"(2) le_0_eq least_mod_type row_add_iterate.simps(1) to_nat_eq to_nat_mono')"], ["proof (state)\nthis:\n  row_add_iterate A 0 i j $ i $ b = A $ i $ b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ i $ b =\n                                     A $ i $ b;\n        Suc n < nrows A; mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ i $ b =\n                                     A $ i $ b;\n        Suc n < nrows A; mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "fix n and A::\"'a::{ring_1}^'n^'m::{mod_type}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ i $ b =\n                                     A $ i $ b;\n        Suc n < nrows A; mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "assume hyp: \"\\<And>A::'a::{ring_1}^'n^'m::{mod_type}. n < nrows A \\<Longrightarrow> to_nat i \\<le> n \\<Longrightarrow> row_add_iterate A n i j $ i $ b = A $ i $ b\"\n    and Suc_n_less_card: \"Suc n < nrows A\" and i_less_suc: \"to_nat i \\<le> Suc n\""], ["proof (state)\nthis:\n  \\<lbrakk>n < nrows ?A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ i $ b = ?A $ i $ b\n  Suc n < nrows A\n  mod_type_class.to_nat i \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>n < nrows A;\n                    mod_type_class.to_nat i \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ i $ b =\n                                     A $ i $ b;\n        Suc n < nrows A; mod_type_class.to_nat i \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "show \"row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "unfolding row_add_iterate.simps if_P[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ i $ b = A $ i $ b", "apply (rule row_add_iterate_preserves_greater_than_n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < nrows A\n 2. n < mod_type_class.to_nat i", "using Suc_n_less_card True lessI"], ["proof (prove)\nusing this:\n  Suc n < nrows A\n  Suc n = mod_type_class.to_nat i\n  ?n < Suc ?n\n\ngoal (2 subgoals):\n 1. n < nrows A\n 2. n < mod_type_class.to_nat i", "by linarith+"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "define A' where \"A' = row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)\""], ["proof (state)\nthis:\n  A' =\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j)\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "have row_add_iterate_A': \"row_add_iterate A' n i j $ i $ b = A' $ i $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ i $ b = A' $ i $ b", "using hyp Suc_n_less_card i_less_suc False"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < nrows ?A; mod_type_class.to_nat i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ i $ b = ?A $ i $ b\n  Suc n < nrows A\n  mod_type_class.to_nat i \\<le> Suc n\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ i $ b = A' $ i $ b", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < CARD('m); mod_type_class.to_nat i \\<le> n\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ i $ b = ?A $ i $ b\n  Suc n < CARD('m)\n  mod_type_class.to_nat i \\<le> Suc n\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ i $ b = A' $ i $ b", "by auto"], ["proof (state)\nthis:\n  row_add_iterate A' n i j $ i $ b = A' $ i $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "have from_nat_noteq_i: \"from_nat (Suc n) \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) \\<noteq> i", "using False Suc_n_less_card from_nat_not_eq"], ["proof (prove)\nusing this:\n  Suc n \\<noteq> mod_type_class.to_nat i\n  Suc n < nrows A\n  \\<lbrakk>?a \\<noteq> mod_type_class.to_nat ?b; ?a < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?a \\<noteq> ?b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) \\<noteq> i", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc n \\<noteq> mod_type_class.to_nat i\n  Suc n < CARD('m)\n  \\<lbrakk>?a \\<noteq> mod_type_class.to_nat ?b; ?a < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?a \\<noteq> ?b\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat (Suc n) \\<noteq> i", "by blast"], ["proof (state)\nthis:\n  mod_type_class.from_nat (Suc n) \\<noteq> i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b", "unfolding row_add_iterate.simps if_not_P[OF False] row_add_iterate_A'[unfolded A'_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) $\n    i $\n    b =\n    A $ i $ b", "unfolding row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    i $\n    b =\n    A $ i $ b", "using from_nat_noteq_i"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (Suc n) \\<noteq> i\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    i $\n    b =\n    A $ i $ b", "by simp"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ i $ b = A $ i $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_add_iterate_eq_row_add:\n  fixes A::\"'a::{ring_1}^'n^'m::{mod_type}\"\n  assumes a_not_i: \"a \\<noteq> i\"\n  and n: \"n<nrows A\"\n  and \"to_nat a \\<le> n\"\n  shows \"(row_add_iterate A n i j) $ a $ b = (row_add A a i (- A $ a $ j)) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> i\n  n < nrows A\n  mod_type_class.to_nat a \\<le> n\n\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>a \\<noteq> i; 0 < nrows A;\n        mod_type_class.to_nat a \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A 0 i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a \\<noteq> i; n < nrows A;\n                    mod_type_class.to_nat a \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     row_add A a i (- A $ a $ j) $ a $ b;\n        a \\<noteq> i; Suc n < nrows A;\n        mod_type_class.to_nat a \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b", "case 0"], ["proof (state)\nthis:\n  a \\<noteq> i\n  0 < nrows A\n  mod_type_class.to_nat a \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>a \\<noteq> i; 0 < nrows A;\n        mod_type_class.to_nat a \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A 0 i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a \\<noteq> i; n < nrows A;\n                    mod_type_class.to_nat a \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     row_add A a i (- A $ a $ j) $ a $ b;\n        a \\<noteq> i; Suc n < nrows A;\n        mod_type_class.to_nat a \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A 0 i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b", "unfolding row_add_iterate.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = (0::'m) then A else row_add A (0::'m) i (- A $ (0::'m) $ j)) $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "using \"0.prems\"(3) a_not_i to_nat_eq_0 least_mod_type"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a \\<le> 0\n  a \\<noteq> i\n  (mod_type_class.to_nat ?x = 0) = (?x = (0::?'a))\n  (0::?'a) \\<le> ?n\n\ngoal (1 subgoal):\n 1. (if i = (0::'m) then A else row_add A (0::'m) i (- A $ (0::'m) $ j)) $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "by force"], ["proof (state)\nthis:\n  row_add_iterate A 0 i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a \\<noteq> i; n < nrows A;\n                    mod_type_class.to_nat a \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     row_add A a i (- A $ a $ j) $ a $ b;\n        a \\<noteq> i; Suc n < nrows A;\n        mod_type_class.to_nat a \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a \\<noteq> i; n < nrows A;\n                    mod_type_class.to_nat a \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     row_add A a i (- A $ a $ j) $ a $ b;\n        a \\<noteq> i; Suc n < nrows A;\n        mod_type_class.to_nat a \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b", "fix n and A::\"'a::{ring_1}^'n^'m::{mod_type}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a \\<noteq> i; n < nrows A;\n                    mod_type_class.to_nat a \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     row_add A a i (- A $ a $ j) $ a $ b;\n        a \\<noteq> i; Suc n < nrows A;\n        mod_type_class.to_nat a \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b", "assume hyp: \"(\\<And>A::'a::{ring_1}^'n^'m::{mod_type}. a \\<noteq> i \\<Longrightarrow> n < nrows A  \\<Longrightarrow> to_nat a \\<le> n \n    \\<Longrightarrow> row_add_iterate A n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b)\"\n    and a_not_i: \"a \\<noteq> i\"\n    and suc_n_less_card: \"Suc n < nrows A\"\n    and a_le_suc_n: \"to_nat a \\<le> Suc n\""], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> i; n < nrows ?A;\n   mod_type_class.to_nat a \\<le> n\\<rbrakk>\n  \\<Longrightarrow> row_add_iterate ?A n i j $ a $ b =\n                    row_add ?A a i (- ?A $ a $ j) $ a $ b\n  a \\<noteq> i\n  Suc n < nrows A\n  mod_type_class.to_nat a \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>a \\<noteq> i; n < nrows A;\n                    mod_type_class.to_nat a \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> row_add_iterate A n i j $ a $ b =\n                                     row_add A a i (- A $ a $ j) $ a $ b;\n        a \\<noteq> i; Suc n < nrows A;\n        mod_type_class.to_nat a \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> row_add_iterate A (Suc n) i j $ a $ b =\n                         row_add A a i (- A $ a $ j) $ a $ b", "show \"row_add_iterate A (Suc n) i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "proof (cases \"Suc n = to_nat i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "case True"], ["proof (state)\nthis:\n  Suc n = mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. Suc n = mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b\n 2. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "show \"row_add_iterate A (Suc n) i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "unfolding row_add_iterate.simps if_P[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b", "apply (rule hyp[OF a_not_i], auto simp add: Suc_lessD suc_n_less_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> n", "by (metis True a_le_suc_n a_not_i le_SucE to_nat_eq)"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ a $ b =\n  row_add A a i (- A $ a $ j) $ a $ b\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "case False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "note Suc_n_not_i=False"], ["proof (state)\nthis:\n  Suc n \\<noteq> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. Suc n \\<noteq> mod_type_class.to_nat i \\<Longrightarrow>\n    row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A (Suc n) i j $ a $ b =\n    row_add A a i (- A $ a $ j) $ a $ b", "unfolding row_add_iterate.simps if_not_P[OF False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "proof (cases \"to_nat a = Suc n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b\n 2. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "case True"], ["proof (state)\nthis:\n  mod_type_class.to_nat a = Suc n\n\ngoal (2 subgoals):\n 1. mod_type_class.to_nat a = Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b\n 2. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "show \"row_add_iterate (row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)) n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "by (metis Suc_le_lessD True order_refl less_imp_le row_add_iterate_preserves_greater_than_n suc_n_less_card to_nat_from_nat nrows_def)"], ["proof (state)\nthis:\n  row_add_iterate\n   (row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j))\n   n i j $\n  a $\n  b =\n  row_add A a i (- A $ a $ j) $ a $ b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "case False"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<noteq> Suc n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "define A' where \"A' = row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j)\""], ["proof (state)\nthis:\n  A' =\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "have rw: \"row_add_iterate A' n i j $ a $ b = row_add A' a i (- A' $ a $ j) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ a $ b = row_add A' a i (- A' $ a $ j) $ a $ b", "proof (rule hyp)"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<noteq> i\n 2. n < nrows A'\n 3. mod_type_class.to_nat a \\<le> n", "show \"a \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> i", "using a_not_i"], ["proof (prove)\nusing this:\n  a \\<noteq> i\n\ngoal (1 subgoal):\n 1. a \\<noteq> i", "."], ["proof (state)\nthis:\n  a \\<noteq> i\n\ngoal (2 subgoals):\n 1. n < nrows A'\n 2. mod_type_class.to_nat a \\<le> n", "show \"n < nrows A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < nrows A'", "using suc_n_less_card"], ["proof (prove)\nusing this:\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. n < nrows A'", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc n < CARD('m)\n\ngoal (1 subgoal):\n 1. n < CARD('m)", "by auto"], ["proof (state)\nthis:\n  n < nrows A'\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> n", "show \"to_nat a \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> n", "using False a_le_suc_n"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a \\<noteq> Suc n\n  mod_type_class.to_nat a \\<le> Suc n\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<le> n", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat a \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A' n i j $ a $ b = row_add A' a i (- A' $ a $ j) $ a $ b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "have rw1: \"row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j) $ a $ b = A $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) $\n    a $\n    b =\n    A $ a $ b", "unfolding row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b =\n    A $ a $ b", "using False suc_n_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a \\<noteq> Suc n\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b =\n    A $ a $ b", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a \\<noteq> Suc n\n  Suc n < CARD('m)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b =\n    A $ a $ b", "by (auto simp add: to_nat_from_nat_id)"], ["proof (state)\nthis:\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j) $\n  a $\n  b =\n  A $ a $ b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "have rw2: \"row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j) $ a $ j = A $ a $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) $\n    a $\n    j =\n    A $ a $ j", "unfolding row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    j =\n    A $ a $ j", "using False suc_n_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a \\<noteq> Suc n\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    j =\n    A $ a $ j", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat a \\<noteq> Suc n\n  Suc n < CARD('m)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    j =\n    A $ a $ j", "by (auto simp add: to_nat_from_nat_id)"], ["proof (state)\nthis:\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j) $\n  a $\n  j =\n  A $ a $ j\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "have rw3: \"row_add A (from_nat (Suc n)) i (- A $ from_nat (Suc n) $ j) $ i $ b = A $ i $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add A (mod_type_class.from_nat (Suc n)) i\n     (- A $ mod_type_class.from_nat (Suc n) $ j) $\n    i $\n    b =\n    A $ i $ b", "unfolding row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    i $\n    b =\n    A $ i $ b", "using Suc_n_not_i suc_n_less_card"], ["proof (prove)\nusing this:\n  Suc n \\<noteq> mod_type_class.to_nat i\n  Suc n < nrows A\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    i $\n    b =\n    A $ i $ b", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  Suc n \\<noteq> mod_type_class.to_nat i\n  Suc n < CARD('m)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = mod_type_class.from_nat (Suc n)\n        then A $ mod_type_class.from_nat (Suc n) $ ja +\n             - A $ mod_type_class.from_nat (Suc n) $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    i $\n    b =\n    A $ i $ b", "by (auto simp add: to_nat_from_nat_id)"], ["proof (state)\nthis:\n  row_add A (mod_type_class.from_nat (Suc n)) i\n   (- A $ mod_type_class.from_nat (Suc n) $ j) $\n  i $\n  b =\n  A $ i $ b\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat a \\<noteq> Suc n \\<Longrightarrow>\n    row_add_iterate\n     (row_add A (mod_type_class.from_nat (Suc n)) i\n       (- A $ mod_type_class.from_nat (Suc n) $ j))\n     n i j $\n    a $\n    b =\n    row_add A a i (- A $ a $ j) $ a $ b", "show  \"row_add_iterate A' n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b", "unfolding rw row_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia ja.\n        if ia = a then A' $ a $ ja + - A' $ a $ j * A' $ i $ ja\n        else A' $ ia $ ja) $\n    a $\n    b =\n    (\\<chi>ia ja.\n        if ia = a then A $ a $ ja + - A $ a $ j * A $ i $ ja\n        else A $ ia $ ja) $\n    a $\n    b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. A' $ a $ b - A' $ a $ j * A' $ i $ b = A $ a $ b - A $ a $ j * A $ i $ b", "unfolding A'_def rw1 rw2 rw3"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ a $ b - A $ a $ j * A $ i $ b = A $ a $ b - A $ a $ j * A $ i $ b", ".."], ["proof (state)\nthis:\n  row_add_iterate A' n i j $ a $ b = row_add A a i (- A $ a $ j) $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ a $ b =\n  row_add A a i (- A $ a $ j) $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A (Suc n) i j $ a $ b =\n  row_add A a i (- A $ a $ j) $ a $ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_add_iterate_eq_Gauss_Jordan_in_ij:\n  fixes A::\"'a::{field}^'n^'m::{mod_type}\" and i::\"'m\" and j::\"'n\"\n  defines A': \"A'== mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) $ i $ j)\"\n  shows \"row_add_iterate A' (nrows A - 1) i j = Gauss_Jordan_in_ij A i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' (nrows A - 1) i j = Gauss_Jordan_in_ij A i j", "proof (unfold Gauss_Jordan_in_ij_def Let_def, vector, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       row_add_iterate A' (nrows A - Suc 0) i j $ i $ ia =\n       mult_row\n        (interchange_rows A i\n          (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n        i ((1::'a) /\n           A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n       i $\n       ia\n 2. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "fix ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       row_add_iterate A' (nrows A - Suc 0) i j $ i $ ia =\n       mult_row\n        (interchange_rows A i\n          (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n        i ((1::'a) /\n           A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n       i $\n       ia\n 2. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "have interchange_rw: \"A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j = interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j =\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j", "using interchange_rows_j[symmetric, of A \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)\"]"], ["proof (prove)\nusing this:\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) =\n  interchange_rows A (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n   ?j $\n  ?j\n\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j =\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j", "by auto"], ["proof (state)\nthis:\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j =\n  interchange_rows A i\n   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n  i $\n  j\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       row_add_iterate A' (nrows A - Suc 0) i j $ i $ ia =\n       mult_row\n        (interchange_rows A i\n          (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n        i ((1::'a) /\n           A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n       i $\n       ia\n 2. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "show \"row_add_iterate A' (nrows A - Suc 0) i j $ i $ ia = \n    mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j) $ i $ ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' (nrows A - Suc 0) i j $ i $ ia =\n    mult_row\n     (interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n     i ((1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n    i $\n    ia", "unfolding interchange_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' (nrows A - Suc 0) i j $ i $ ia =\n    mult_row\n     (interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n     i ((1::'a) /\n        interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n        i $\n        j) $\n    i $\n    ia", "unfolding A'"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          i $\n          j))\n     (nrows A - Suc 0) i j $\n    i $\n    ia =\n    mult_row\n     (interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n     i ((1::'a) /\n        interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n        i $\n        j) $\n    i $\n    ia", "proof (rule row_add_iterate_preserves_pivot_row, unfold nrows_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. CARD('m) - Suc 0 < CARD('m)\n 2. mod_type_class.to_nat i \\<le> CARD('m) - Suc 0", "show \"CARD('m) - Suc 0 < CARD('m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('m) - Suc 0 < CARD('m)", "by simp"], ["proof (state)\nthis:\n  CARD('m) - Suc 0 < CARD('m)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> CARD('m) - Suc 0", "have \"to_nat i < CARD('m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('m)", "using bij_to_nat[where ?'a='m]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('m)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('m)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('m)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i < CARD('m)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i < CARD('m)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> CARD('m) - Suc 0", "thus \"to_nat i \\<le> CARD('m) - Suc 0\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i < CARD('m)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> CARD('m) - Suc 0", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> CARD('m) - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A' (nrows A - Suc 0) i j $ i $ ia =\n  mult_row\n   (interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n   i ((1::'a) /\n      A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n  i $\n  ia\n\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "fix ia iaa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "have interchange_rw: \"A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j = interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j =\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j", "using interchange_rows_j[symmetric, of A \"(LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)\"]"], ["proof (prove)\nusing this:\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) =\n  interchange_rows A (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n   ?j $\n  ?j\n\ngoal (1 subgoal):\n 1. A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j =\n    interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    i $\n    j", "by auto"], ["proof (state)\nthis:\n  A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j =\n  interchange_rows A i\n   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n  i $\n  j\n\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "assume ia_not_i: \"ia \\<noteq> i\""], ["proof (state)\nthis:\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "have rw: \"(- interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ ia $ j) \n    = - mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ i $ j) $ ia $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n      ia $\n      j =\n    - mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          i $\n          j) $\n      ia $\n      j", "unfolding interchange_rows_def mult_row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<chi>ia ja.\n          if ia = i\n          then A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n               ja\n          else if ia =\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n               then A $ i $ ja else A $ ia $ ja) $\n      ia $\n      j =\n    - (\\<chi>ia ja.\n          if ia = i\n          then (1::'a) /\n               (\\<chi>ia ja.\n                   if ia = i\n                   then A $\n                        (LEAST n.\n                            A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                        ja\n                   else if ia =\n                           (LEAST n.\n                               A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n                        then A $ i $ ja else A $ ia $ ja) $\n               i $\n               j *\n               (\\<chi>ia ja.\n                   if ia = i\n                   then A $\n                        (LEAST n.\n                            A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                        ja\n                   else if ia =\n                           (LEAST n.\n                               A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n                        then A $ i $ ja else A $ ia $ ja) $\n               i $\n               ja\n          else (\\<chi>ia ja.\n                   if ia = i\n                   then A $\n                        (LEAST n.\n                            A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                        ja\n                   else if ia =\n                           (LEAST n.\n                               A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n                        then A $ i $ ja else A $ ia $ ja) $\n               ia $\n               ja) $\n      ia $\n      j", "using ia_not_i"], ["proof (prove)\nusing this:\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. - (\\<chi>ia ja.\n          if ia = i\n          then A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n               ja\n          else if ia =\n                  (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n               then A $ i $ ja else A $ ia $ ja) $\n      ia $\n      j =\n    - (\\<chi>ia ja.\n          if ia = i\n          then (1::'a) /\n               (\\<chi>ia ja.\n                   if ia = i\n                   then A $\n                        (LEAST n.\n                            A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                        ja\n                   else if ia =\n                           (LEAST n.\n                               A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n                        then A $ i $ ja else A $ ia $ ja) $\n               i $\n               j *\n               (\\<chi>ia ja.\n                   if ia = i\n                   then A $\n                        (LEAST n.\n                            A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                        ja\n                   else if ia =\n                           (LEAST n.\n                               A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n                        then A $ i $ ja else A $ ia $ ja) $\n               i $\n               ja\n          else (\\<chi>ia ja.\n                   if ia = i\n                   then A $\n                        (LEAST n.\n                            A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                        ja\n                   else if ia =\n                           (LEAST n.\n                               A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)\n                        then A $ i $ ja else A $ ia $ ja) $\n               ia $\n               ja) $\n      ia $\n      j", "by auto"], ["proof (state)\nthis:\n  - interchange_rows A i\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n    ia $\n    j =\n  - mult_row\n     (interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n     i ((1::'a) /\n        interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n        i $\n        j) $\n    ia $\n    j\n\ngoal (1 subgoal):\n 1. \\<And>ia iaa.\n       ia \\<noteq> i \\<Longrightarrow>\n       row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n       row_add\n        (mult_row\n          (interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n          i ((1::'a) /\n             A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             j))\n        ia i\n        (- interchange_rows A i\n            (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n           ia $\n           j) $\n       ia $\n       iaa", "show \"row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n             row_add (mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j)) ia i\n              (- interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ ia $ j) $\n             ia $\n             iaa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n    row_add\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n     ia i\n     (- interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n        ia $\n        j) $\n    ia $\n    iaa", "unfolding interchange_rw A' rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          i $\n          j))\n     (nrows A - Suc 0) i j $\n    ia $\n    iaa =\n    row_add\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          i $\n          j))\n     ia i\n     (- mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            interchange_rows A i\n             (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n            i $\n            j) $\n        ia $\n        j) $\n    ia $\n    iaa", "proof (rule row_add_iterate_eq_row_add[of ia i \"(nrows A - Suc 0)\" _ j iaa], unfold nrows_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. ia \\<noteq> i\n 2. CARD('m) - Suc 0 < CARD('m)\n 3. mod_type_class.to_nat ia \\<le> CARD('m) - Suc 0", "show \"ia \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia \\<noteq> i", "using ia_not_i"], ["proof (prove)\nusing this:\n  ia \\<noteq> i\n\ngoal (1 subgoal):\n 1. ia \\<noteq> i", "."], ["proof (state)\nthis:\n  ia \\<noteq> i\n\ngoal (2 subgoals):\n 1. CARD('m) - Suc 0 < CARD('m)\n 2. mod_type_class.to_nat ia \\<le> CARD('m) - Suc 0", "show \"CARD('m) - Suc 0 < CARD('m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('m) - Suc 0 < CARD('m)", "by simp"], ["proof (state)\nthis:\n  CARD('m) - Suc 0 < CARD('m)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia \\<le> CARD('m) - Suc 0", "have \"to_nat ia < CARD('m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia < CARD('m)", "using bij_to_nat[where ?'a='m]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('m)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia < CARD('m)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('m)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia < CARD('m)", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat ia < CARD('m)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia \\<le> CARD('m) - Suc 0", "thus \"to_nat ia \\<le> CARD('m) - Suc 0\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ia < CARD('m)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat ia \\<le> CARD('m) - Suc 0", "by simp"], ["proof (state)\nthis:\n  mod_type_class.to_nat ia \\<le> CARD('m) - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_add_iterate A' (nrows A - Suc 0) i j $ ia $ iaa =\n  row_add\n   (mult_row\n     (interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n     i ((1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n   ia i\n   (- interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n      ia $\n      j) $\n  ia $\n  iaa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_Gauss_Jordan_column_k:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\" and k::nat\n  shows \"\\<exists>P. invertible P \\<and> (snd (Gauss_Jordan_column_k (i,A) k)) = P**A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> snd (Gauss_Jordan_column_k (i, A) k) = P ** A", "unfolding Gauss_Jordan_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       snd (if (\\<forall>m\\<ge>mod_type_class.from_nat (fst (i, A)).\n                   snd (i, A) $ m $ mod_type_class.from_nat k =\n                   (0::'a)) \\<or>\n               fst (i, A) = nrows (snd (i, A))\n            then (fst (i, A), snd (i, A))\n            else (fst (i, A) + 1,\n                  Gauss_Jordan_in_ij (snd (i, A))\n                   (mod_type_class.from_nat (fst (i, A)))\n                   (mod_type_class.from_nat k))) =\n       P ** A", "proof (auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>m\\<ge>mod_type_class.from_nat i.\n       A $ m $ mod_type_class.from_nat k = (0::'a) \\<Longrightarrow>\n    \\<exists>P. invertible P \\<and> A = P ** A\n 2. i = nrows A \\<Longrightarrow> \\<exists>P. invertible P \\<and> A = P ** A\n 3. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "show \"\\<exists>P. invertible P \\<and> A = P ** A\" and \"\\<exists>P. invertible P \\<and> A = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> A = P ** A &&&\n    \\<exists>P. invertible P \\<and> A = P ** A", "using invertible_mat_1 matrix_mul_lid[of A]"], ["proof (prove)\nusing this:\n  invertible (mat (1::?'a))\n  mat (1::'a) ** A = A\n\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> A = P ** A &&&\n    \\<exists>P. invertible P \\<and> A = P ** A", "by auto"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> A = P ** A\n  \\<exists>P. invertible P \\<and> A = P ** A\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "assume i: \"i \\<noteq> nrows A\"\n    and i_le_m: \"from_nat i \\<le> m\" and Amk_not_zero: \"A $ m $ from_nat k \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> nrows A\n  mod_type_class.from_nat i \\<le> m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "define A_interchange where \"A_interchange = interchange_rows A (from_nat i) (LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> n)\""], ["proof (state)\nthis:\n  A_interchange =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "define A_mult where \"A_mult = mult_row A_interchange (from_nat i) (1 / (A_interchange $ (from_nat i) $ from_nat k))\""], ["proof (state)\nthis:\n  A_mult =\n  mult_row A_interchange (mod_type_class.from_nat i)\n   ((1::'a) /\n    A_interchange $ mod_type_class.from_nat i $ mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "obtain P where inv_P: \"invertible P\" and PA: \"A_interchange = P**A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P; A_interchange = P ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding A_interchange_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n) =\n         P ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using interchange_rows_mat_1[of \"from_nat i\" \"(LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)\" A]"], ["proof (prove)\nusing this:\n  interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) **\n  A =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n) =\n         P ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_interchange_rows[of \"from_nat i\" \"(LEAST n. A $ n $ from_nat k \\<noteq> 0 \\<and> from_nat i \\<le> n)\"]"], ["proof (prove)\nusing this:\n  interchange_rows (mat (1::'a)) (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n) **\n  A =\n  interchange_rows A (mod_type_class.from_nat i)\n   (LEAST n.\n       A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> n)\n  invertible\n   (interchange_rows (mat (1::?'a)) (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n))\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         interchange_rows A (mod_type_class.from_nat i)\n          (LEAST n.\n              A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n              mod_type_class.from_nat i \\<le> n) =\n         P ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  invertible P\n  A_interchange = P ** A\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "define Q :: \"'a^'m::{mod_type}^'m::{mod_type}\"\n    where \"Q = mult_row (mat 1) (from_nat i) (1 / (A_interchange $ (from_nat i) $ from_nat k))\""], ["proof (state)\nthis:\n  Q =\n  mult_row (mat (1::'a)) (mod_type_class.from_nat i)\n   ((1::'a) /\n    A_interchange $ mod_type_class.from_nat i $ mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "have Q_A_interchange: \"A_mult = Q**A_interchange\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A_mult = Q ** A_interchange", "unfolding A_mult_def A_interchange_def Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_row\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (mod_type_class.from_nat i)\n     ((1::'a) /\n      interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n) $\n      mod_type_class.from_nat i $\n      mod_type_class.from_nat k) =\n    mult_row (mat (1::'a)) (mod_type_class.from_nat i)\n     ((1::'a) /\n      interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n) $\n      mod_type_class.from_nat i $\n      mod_type_class.from_nat k) **\n    interchange_rows A (mod_type_class.from_nat i)\n     (LEAST n.\n         A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n         mod_type_class.from_nat i \\<le> n)", "unfolding mult_row_mat_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. mult_row\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (mod_type_class.from_nat i)\n     ((1::'a) /\n      interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n) $\n      mod_type_class.from_nat i $\n      mod_type_class.from_nat k) =\n    mult_row\n     (interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n))\n     (mod_type_class.from_nat i)\n     ((1::'a) /\n      interchange_rows A (mod_type_class.from_nat i)\n       (LEAST n.\n           A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n           mod_type_class.from_nat i \\<le> n) $\n      mod_type_class.from_nat i $\n      mod_type_class.from_nat k)", ".."], ["proof (state)\nthis:\n  A_mult = Q ** A_interchange\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "have inv_Q: \"invertible Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible Q", "proof (unfold Q_def, rule invertible_mult_row', unfold A_interchange_def, rule LeastI2_ex)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a.\n       A $ a $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> a\n 2. \\<And>x.\n       A $ x $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> x \\<Longrightarrow>\n       (1::'a) /\n       interchange_rows A (mod_type_class.from_nat i) x $\n       mod_type_class.from_nat i $\n       mod_type_class.from_nat k \\<noteq>\n       (0::'a)", "show \"\\<exists>a. A $ a $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       A $ a $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> a", "using i_le_m Amk_not_zero"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat i \\<le> m\n  A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       A $ a $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a.\n     A $ a $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n     mod_type_class.from_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ x $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> x \\<Longrightarrow>\n       (1::'a) /\n       interchange_rows A (mod_type_class.from_nat i) x $\n       mod_type_class.from_nat i $\n       mod_type_class.from_nat k \\<noteq>\n       (0::'a)", "show \"\\<And>x. A $ x $ from_nat k \\<noteq> 0 \\<and> (from_nat i) \\<le> x \\<Longrightarrow> 1 / interchange_rows A (from_nat i) x $ (from_nat i) $ from_nat k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ x $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> x \\<Longrightarrow>\n       (1::'a) /\n       interchange_rows A (mod_type_class.from_nat i) x $\n       mod_type_class.from_nat i $\n       mod_type_class.from_nat k \\<noteq>\n       (0::'a)", "using interchange_rows_i mult_zero_left nonzero_divide_eq_eq zero_neq_one"], ["proof (prove)\nusing this:\n  interchange_rows ?A ?i ?j $ ?i = ?A $ ?j\n  (0::?'a) * ?a = (0::?'a)\n  ?c \\<noteq> (0::?'a) \\<Longrightarrow> (?b / ?c = ?a) = (?b = ?a * ?c)\n  (0::?'a) \\<noteq> (1::?'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       A $ x $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n       mod_type_class.from_nat i \\<le> x \\<Longrightarrow>\n       (1::'a) /\n       interchange_rows A (mod_type_class.from_nat i) x $\n       mod_type_class.from_nat i $\n       mod_type_class.from_nat k \\<noteq>\n       (0::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ ?x $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n  mod_type_class.from_nat i \\<le> ?x \\<Longrightarrow>\n  (1::'a) /\n  interchange_rows A (mod_type_class.from_nat i) ?x $\n  mod_type_class.from_nat i $\n  mod_type_class.from_nat k \\<noteq>\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invertible Q\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "obtain Pa where inv_Pa: \"invertible Pa\" and Pa: \"row_add_iterate (Q ** (P ** A)) (nrows A - 1) (from_nat i) (from_nat k) = Pa ** (Q ** (P ** A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Pa.\n        \\<lbrakk>invertible Pa;\n         row_add_iterate (Q ** (P ** A)) (nrows A - 1)\n          (mod_type_class.from_nat i) (mod_type_class.from_nat k) =\n         Pa ** (Q ** (P ** A))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_row_add_iterate"], ["proof (prove)\nusing this:\n  ?n < nrows ?A \\<Longrightarrow>\n  \\<exists>P. invertible P \\<and> row_add_iterate ?A ?n ?i ?j = P ** ?A\n\ngoal (1 subgoal):\n 1. (\\<And>Pa.\n        \\<lbrakk>invertible Pa;\n         row_add_iterate (Q ** (P ** A)) (nrows A - 1)\n          (mod_type_class.from_nat i) (mod_type_class.from_nat k) =\n         Pa ** (Q ** (P ** A))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) diff_less nrows_def zero_less_card_finite zero_less_one)"], ["proof (state)\nthis:\n  invertible Pa\n  row_add_iterate (Q ** (P ** A)) (nrows A - 1) (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** (Q ** (P ** A))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>i \\<noteq> nrows A; mod_type_class.from_nat i \\<le> m;\n        A $ m $ mod_type_class.from_nat k \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            invertible P \\<and>\n                            Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                             (mod_type_class.from_nat k) =\n                            P ** A", "show \"\\<exists>P. invertible P \\<and> Gauss_Jordan_in_ij A (from_nat i) (from_nat k) = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n        (mod_type_class.from_nat k) =\n       P ** A", "proof (rule exI[of _ \"Pa**Q**P\"], rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. invertible (Pa ** Q ** P)\n 2. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "show \"invertible (Pa ** Q ** P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Pa ** Q ** P)", "using inv_P inv_Pa inv_Q invertible_mult"], ["proof (prove)\nusing this:\n  invertible P\n  invertible Pa\n  invertible Q\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible (Pa ** Q ** P)", "by auto"], ["proof (state)\nthis:\n  invertible (Pa ** Q ** P)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "have \"Gauss_Jordan_in_ij A (from_nat i) (from_nat k) = row_add_iterate A_mult (nrows A - 1) (from_nat i) (from_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k)", "unfolding row_add_iterate_eq_Gauss_Jordan_in_ij[symmetric]  A_mult_def A_interchange_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate\n     (mult_row\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (mod_type_class.from_nat i)\n       ((1::'a) /\n        interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n) $\n        mod_type_class.from_nat i $\n        mod_type_class.from_nat k))\n     (nrows A - 1) (mod_type_class.from_nat i) (mod_type_class.from_nat k) =\n    row_add_iterate\n     (mult_row\n       (interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n))\n       (mod_type_class.from_nat i)\n       ((1::'a) /\n        interchange_rows A (mod_type_class.from_nat i)\n         (LEAST n.\n             A $ n $ mod_type_class.from_nat k \\<noteq> (0::'a) \\<and>\n             mod_type_class.from_nat i \\<le> n) $\n        mod_type_class.from_nat i $\n        mod_type_class.from_nat k))\n     (nrows A - 1) (mod_type_class.from_nat i) (mod_type_class.from_nat k)", ".."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "also"], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "have \"... = Pa ** (Q ** (P ** A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** (Q ** (P ** A))", "using Pa"], ["proof (prove)\nusing this:\n  row_add_iterate (Q ** (P ** A)) (nrows A - 1) (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** (Q ** (P ** A))\n\ngoal (1 subgoal):\n 1. row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** (Q ** (P ** A))", "unfolding PA[symmetric] Q_A_interchange[symmetric]"], ["proof (prove)\nusing this:\n  row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** A_mult\n\ngoal (1 subgoal):\n 1. row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** A_mult", "."], ["proof (state)\nthis:\n  row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** (Q ** (P ** A))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "also"], ["proof (state)\nthis:\n  row_add_iterate A_mult (nrows A - 1) (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** (Q ** (P ** A))\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "have \"... = Pa ** Q ** P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pa ** (Q ** (P ** A)) = Pa ** Q ** P ** A", "unfolding matrix_mul_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pa ** Q ** P ** A = Pa ** Q ** P ** A", ".."], ["proof (state)\nthis:\n  Pa ** (Q ** (P ** A)) = Pa ** Q ** P ** A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "finally"], ["proof (chain)\npicking this:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** Q ** P ** A", "show \"Gauss_Jordan_in_ij A (from_nat i) (from_nat k) = Pa ** Q ** P ** A\""], ["proof (prove)\nusing this:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** Q ** P ** A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k) =\n    Pa ** Q ** P ** A", "."], ["proof (state)\nthis:\n  Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n   (mod_type_class.from_nat k) =\n  Pa ** Q ** P ** A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n      (mod_type_class.from_nat k) =\n     P ** A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invertible_Gauss_Jordan_up_to_k:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"\\<exists>P. invertible P \\<and> (Gauss_Jordan_upt_k A k) = P**A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A k = P ** A", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A 0 = P ** A\n 2. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A 0 = P ** A\n 2. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "have rw: \"[0..<Suc 0] = [0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc 0] = [0]", "by fastforce"], ["proof (state)\nthis:\n  [0..<Suc 0] = [0]\n\ngoal (2 subgoals):\n 1. \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A 0 = P ** A\n 2. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A 0 = P ** A", "unfolding Gauss_Jordan_upt_k_def rw foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> snd (Gauss_Jordan_column_k (0, A) 0) = P ** A", "using invertible_Gauss_Jordan_column_k"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> snd (Gauss_Jordan_column_k (?i, ?A) ?k) = P ** ?A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> snd (Gauss_Jordan_column_k (0, A) 0) = P ** A", "."], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A 0 = P ** A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "case (Suc k)"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A k = P ** A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "have rw2: \"[0..<Suc (Suc k)] = [0..< Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by simp"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "obtain P' where inv_P': \"invertible P'\" and Gk_eq_P'A: \"Gauss_Jordan_upt_k A k = P' ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>invertible P'; Gauss_Jordan_upt_k A k = P' ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.hyps"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A k = P ** A\n\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>invertible P'; Gauss_Jordan_upt_k A k = P' ** A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  invertible P'\n  Gauss_Jordan_upt_k A k = P' ** A\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "have g: \"Gauss_Jordan_upt_k A k = snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan_upt_k A k =\n    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])", "unfolding Gauss_Jordan_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) =\n    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])", "by auto"], ["proof (state)\nthis:\n  Gauss_Jordan_upt_k A k =\n  snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<exists>P.\n          invertible P \\<and>\n          Gauss_Jordan_upt_k A k = P ** A \\<Longrightarrow>\n       \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A", "unfolding Gauss_Jordan_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) = P ** A", "unfolding rw2 foldl_append foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       snd (Gauss_Jordan_column_k\n             (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k)) =\n       P ** A", "apply (subst prod.collapse[symmetric, of \"(foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\", unfolded g[symmetric]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       snd (Gauss_Jordan_column_k\n             (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n              Gauss_Jordan_upt_k A k)\n             (Suc k)) =\n       P ** A", "using invertible_Gauss_Jordan_column_k"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> snd (Gauss_Jordan_column_k (?i, ?A) ?k) = P ** ?A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       snd (Gauss_Jordan_column_k\n             (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n              Gauss_Jordan_upt_k A k)\n             (Suc k)) =\n       P ** A", "using Suc.hyps"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> snd (Gauss_Jordan_column_k (?i, ?A) ?k) = P ** ?A\n  \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A k = P ** A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       snd (Gauss_Jordan_column_k\n             (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n              Gauss_Jordan_upt_k A k)\n             (Suc k)) =\n       P ** A", "using invertible_mult matrix_mul_assoc"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     invertible P \\<and> snd (Gauss_Jordan_column_k (?i, ?A) ?k) = P ** ?A\n  \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A k = P ** A\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n  ?A ** (?B ** ?C) = ?A ** ?B ** ?C\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       snd (Gauss_Jordan_column_k\n             (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n              Gauss_Jordan_upt_k A k)\n             (Suc k)) =\n       P ** A", "by metis"], ["proof (state)\nthis:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k A (Suc k) = P ** A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_index_independent_rows:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and x: \"row x A \\<in> {row i A |i. row i A \\<noteq> 0}\"\n  and eq: \"A $ x = A $ y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "assume x_not_y: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have not_zero_x: \"\\<not> is_zero_row x A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row x A", "using x"], ["proof (prove)\nusing this:\n  row x A \\<in> {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row x A", "unfolding is_zero_row_def"], ["proof (prove)\nusing this:\n  row x A \\<in> {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row_upt_k x (ncols A) A", "unfolding is_zero_row_upt_k_def"], ["proof (prove)\nusing this:\n  row x A \\<in> {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < ncols A \\<longrightarrow>\n               A $ x $ j = (0::'a))", "unfolding row_def vec_eq_iff \n    ncols_def"], ["proof (prove)\nusing this:\n  vec_lambda (($) (A $ x))\n  \\<in> {uu_.\n         \\<exists>i.\n            (\\<forall>ia. uu_ $ ia = vec_lambda (($) (A $ i)) $ ia) \\<and>\n            \\<not> (\\<forall>ia. vec_lambda (($) (A $ i)) $ ia = 0 $ ia)}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j.\n               mod_type_class.to_nat j < CARD('m) \\<longrightarrow>\n               A $ x $ j = (0::'a))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row x A\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "hence not_zero_y: \"\\<not> is_zero_row y A\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row x A\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row y A", "using eq"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row x A\n  A $ x = A $ y\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row y A", "unfolding is_zero_row_def'"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j. A $ x $ j = (0::'a))\n  A $ x = A $ y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j. A $ y $ j = (0::'a))", "by simp"], ["proof (state)\nthis:\n  \\<not> is_zero_row y A\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have Ax: \"A $ x $ (LEAST k. A $ x $ k \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ x $ (LEAST k. A $ x $ k \\<noteq> (0::'a)) = (1::'a)", "using not_zero_x rref_condition2[OF rref_A]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row x A\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     A $ i $ (LEAST k. A $ i $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ x $ (LEAST k. A $ x $ k \\<noteq> (0::'a)) = (1::'a)", "by simp"], ["proof (state)\nthis:\n  A $ x $ (LEAST k. A $ x $ k \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have Ay: \"A $ x $ (LEAST k. A $ y $ k \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ x $ (LEAST k. A $ y $ k \\<noteq> (0::'a)) = (0::'a)", "using not_zero_y x_not_y rref_condition4[OF rref_A]"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row y A\n  x \\<noteq> y\n  \\<forall>i.\n     \\<not> is_zero_row i A \\<longrightarrow>\n     (\\<forall>j.\n         i \\<noteq> j \\<longrightarrow>\n         A $ j $ (LEAST n. A $ i $ n \\<noteq> (0::'a)) = (0::'a))\n\ngoal (1 subgoal):\n 1. A $ x $ (LEAST k. A $ y $ k \\<noteq> (0::'a)) = (0::'a)", "by fast"], ["proof (state)\nthis:\n  A $ x $ (LEAST k. A $ y $ k \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using Ax Ay"], ["proof (prove)\nusing this:\n  A $ x $ (LEAST k. A $ x $ k \\<noteq> (0::'a)) = (1::'a)\n  A $ x $ (LEAST k. A $ y $ k \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "unfolding eq"], ["proof (prove)\nusing this:\n  A $ y $ (LEAST k. A $ y $ k \\<noteq> (0::'a)) = (1::'a)\n  A $ y $ (LEAST k. A $ y $ k \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The final results:\\<close>"], ["", "lemma invertible_Gauss_Jordan:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"\\<exists>P. invertible P \\<and> (Gauss_Jordan A) = P**A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P. invertible P \\<and> Gauss_Jordan A = P ** A", "unfolding Gauss_Jordan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Gauss_Jordan_upt_k A (ncols A - 1) = P ** A", "using invertible_Gauss_Jordan_up_to_k"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan_upt_k ?A ?k = P ** ?A\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and> Gauss_Jordan_upt_k A (ncols A - 1) = P ** A", "."], ["", "lemma Gauss_Jordan:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"\\<exists>P. invertible P \\<and> (Gauss_Jordan A) = P**A \\<and> reduced_row_echelon_form (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       Gauss_Jordan A = P ** A \\<and>\n       reduced_row_echelon_form (Gauss_Jordan A)", "by (simp add: invertible_Gauss_Jordan rref_Gauss_Jordan)"], ["", "text\\<open>Some properties about the rank of a matrix, obtained thanks to the Gauss-Jordan algorithm and\n  the reduced row echelon form.\\<close>"], ["", "lemma rref_rank:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"rank A = card {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = card {row i A |i. row i A \\<noteq> 0}", "unfolding rank_def row_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (row_space A) = card {row i A |i. row i A \\<noteq> 0}", "proof (rule vec.dim_unique[of \"{row i A | i. row i A \\<noteq> 0}\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. {row i A |i. row i A \\<noteq> 0} \\<subseteq> row_space A\n 2. row_space A \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n 3. vec.independent {row i A |i. row i A \\<noteq> 0}\n 4. card {row i A |i. row i A \\<noteq> 0} =\n    card {row i A |i. row i A \\<noteq> 0}", "show \"{row i A |i. row i A \\<noteq> 0} \\<subseteq> row_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i A |i. row i A \\<noteq> 0} \\<subseteq> row_space A", "proof (auto, unfold row_space_def rows_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       row i A \\<in> vec.span {row i A |i. i \\<in> UNIV}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       row i A \\<in> vec.span {row i A |i. i \\<in> UNIV}", "assume \"row i A \\<noteq> 0\""], ["proof (state)\nthis:\n  row i A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       row i A \\<in> vec.span {row i A |i. i \\<in> UNIV}", "show \"row i A \\<in> vec.span {row i A |i. i \\<in> UNIV}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i A \\<in> vec.span {row i A |i. i \\<in> UNIV}", "by (rule vec.span_base, auto)"], ["proof (state)\nthis:\n  row i A \\<in> vec.span {row i A |i. i \\<in> UNIV}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {row i A |i. row i A \\<noteq> 0} \\<subseteq> row_space A\n\ngoal (3 subgoals):\n 1. row_space A \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n 2. vec.independent {row i A |i. row i A \\<noteq> 0}\n 3. card {row i A |i. row i A \\<noteq> 0} =\n    card {row i A |i. row i A \\<noteq> 0}", "show \"row_space A \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_space A \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "proof (unfold row_space_def rows_def, cases \"\\<exists>i. row i A = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n 2. \\<nexists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "case True"], ["proof (state)\nthis:\n  \\<exists>i. row i A = 0\n\ngoal (2 subgoals):\n 1. \\<exists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n 2. \\<nexists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "have set_rw: \"{row i A |i. i \\<in> UNIV} = insert 0 {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {row i A |i. i \\<in> UNIV} = insert 0 {row i A |i. row i A \\<noteq> 0}", "using True"], ["proof (prove)\nusing this:\n  \\<exists>i. row i A = 0\n\ngoal (1 subgoal):\n 1. {row i A |i. i \\<in> UNIV} = insert 0 {row i A |i. row i A \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  {row i A |i. i \\<in> UNIV} = insert 0 {row i A |i. row i A \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. \\<exists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n 2. \\<nexists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "have \"vec.span {row i A |i. i \\<in> UNIV} = vec.span {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span {row i A |i. i \\<in> UNIV} =\n    vec.span {row i A |i. row i A \\<noteq> 0}", "unfolding set_rw"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span (insert 0 {row i A |i. row i A \\<noteq> 0}) =\n    vec.span {row i A |i. row i A \\<noteq> 0}", "using vec.span_insert_0"], ["proof (prove)\nusing this:\n  vec.span (insert 0 ?S) = vec.span ?S\n\ngoal (1 subgoal):\n 1. vec.span (insert 0 {row i A |i. row i A \\<noteq> 0}) =\n    vec.span {row i A |i. row i A \\<noteq> 0}", "."], ["proof (state)\nthis:\n  vec.span {row i A |i. i \\<in> UNIV} =\n  vec.span {row i A |i. row i A \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. \\<exists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n 2. \\<nexists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "thus \"vec.span {row i A |i. i \\<in> UNIV} \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  vec.span {row i A |i. i \\<in> UNIV} =\n  vec.span {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  vec.span {row i A |i. i \\<in> UNIV}\n  \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<nexists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "case False"], ["proof (state)\nthis:\n  \\<nexists>i. row i A = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>i. row i A = 0 \\<Longrightarrow>\n    vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "show \"vec.span {row i A |i. i \\<in> UNIV} \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "using False"], ["proof (prove)\nusing this:\n  \\<nexists>i. row i A = 0\n\ngoal (1 subgoal):\n 1. vec.span {row i A |i. i \\<in> UNIV}\n    \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  vec.span {row i A |i. i \\<in> UNIV}\n  \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_space A \\<subseteq> vec.span {row i A |i. row i A \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. vec.independent {row i A |i. row i A \\<noteq> 0}\n 2. card {row i A |i. row i A \\<noteq> 0} =\n    card {row i A |i. row i A \\<noteq> 0}", "show \"vec.independent {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent {row i A |i. row i A \\<noteq> 0}", "by (rule independent_not_zero_rows_rref[OF rref_A])"], ["proof (state)\nthis:\n  vec.independent {row i A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. card {row i A |i. row i A \\<noteq> 0} =\n    card {row i A |i. row i A \\<noteq> 0}", "show \"card {row i A |i. row i A \\<noteq> 0} = card {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {row i A |i. row i A \\<noteq> 0} =\n    card {row i A |i. row i A \\<noteq> 0}", ".."], ["proof (state)\nthis:\n  card {row i A |i. row i A \\<noteq> 0} =\n  card {row i A |i. row i A \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_leading_coefficient_component_eq:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and v: \"v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\" \n  and vx: \"v $ x \\<noteq> 0\"\n  and vy: \"v $ y \\<noteq> 0\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "obtain b where b: \"v = column (LEAST n. A $ b $ n \\<noteq> 0) A\" and row_b: \"row b A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A;\n         row b A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v"], ["proof (prove)\nusing this:\n  v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A;\n         row b A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A\n  row b A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = y", "have vb_not_zero: \"v $ b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ b \\<noteq> (0::'a)", "unfolding b column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (LEAST n. A $ b $ n \\<noteq> (0::'a))) $ b \\<noteq>\n    (0::'a)", "by (auto, metis is_zero_row_eq_row_zero row_b rref_A rref_condition2 zero_neq_one)"], ["proof (state)\nthis:\n  v $ b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x = y", "have b_eq_x: \"b = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow> False", "assume b_not_x: \"b\\<noteq>x\""], ["proof (state)\nthis:\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow> False", "have \"A $ x $ (LEAST n. A $ b $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ x $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)", "by (rule rref_condition4_explicit[OF rref_A _ b_not_x], simp add: is_zero_row_eq_row_zero row_b)"], ["proof (state)\nthis:\n  A $ x $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> x \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  A $ x $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using vx"], ["proof (prove)\nusing this:\n  A $ x $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n  v $ x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "unfolding b column_def"], ["proof (prove)\nusing this:\n  A $ x $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n  (\\<chi>i. A $ i $ (LEAST n. A $ b $ n \\<noteq> (0::'a))) $ x \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = x\n\ngoal (1 subgoal):\n 1. x = y", "moreover"], ["proof (state)\nthis:\n  b = x\n\ngoal (1 subgoal):\n 1. x = y", "have b_eq_y: \"b = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> y \\<Longrightarrow> False", "assume b_not_y: \"b\\<noteq>y\""], ["proof (state)\nthis:\n  b \\<noteq> y\n\ngoal (1 subgoal):\n 1. b \\<noteq> y \\<Longrightarrow> False", "have \"A $ y $ (LEAST n. A $ b $ n \\<noteq> 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ y $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)", "by (rule rref_condition4_explicit[OF rref_A _ b_not_y], simp add: is_zero_row_eq_row_zero row_b)"], ["proof (state)\nthis:\n  A $ y $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  A $ y $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using vy"], ["proof (prove)\nusing this:\n  A $ y $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n  v $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "unfolding b column_def"], ["proof (prove)\nusing this:\n  A $ y $ (LEAST n. A $ b $ n \\<noteq> (0::'a)) = (0::'a)\n  (\\<chi>i. A $ i $ (LEAST n. A $ b $ n \\<noteq> (0::'a))) $ y \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = y\n\ngoal (1 subgoal):\n 1. x = y", "ultimately"], ["proof (chain)\npicking this:\n  b = x\n  b = y", "show ?thesis"], ["proof (prove)\nusing this:\n  b = x\n  b = y\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_leading_coefficient_component_1:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and v: \"v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\" \n  and vx: \"v $ x \\<noteq> 0\"\n  shows \"v $ x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ x = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v $ x = (1::'a)", "obtain b where b: \"v = column (LEAST n. A $ b $ n \\<noteq> 0) A\" and row_b: \"row b A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A;\n         row b A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v"], ["proof (prove)\nusing this:\n  v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A;\n         row b A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A\n  row b A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v $ x = (1::'a)", "have vb_not_zero: \"v $ b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ b \\<noteq> (0::'a)", "unfolding b column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (LEAST n. A $ b $ n \\<noteq> (0::'a))) $ b \\<noteq>\n    (0::'a)", "by (auto, metis is_zero_row_eq_row_zero row_b rref_A rref_condition2 zero_neq_one)"], ["proof (state)\nthis:\n  v $ b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. v $ x = (1::'a)", "have b_eq_x: \"b = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = x", "by (metis b column_def is_zero_row_eq_row_zero row_b rref_A rref_condition4 transpose_row_code transpose_row_def vx)"], ["proof (state)\nthis:\n  b = x\n\ngoal (1 subgoal):\n 1. v $ x = (1::'a)", "show?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ x = (1::'a)", "using rref_condition2_explicit[OF rref_A, of b] row_b"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row b A \\<Longrightarrow>\n  A $ b $ (LEAST k. A $ b $ k \\<noteq> (0::'a)) = (1::'a)\n  row b A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v $ x = (1::'a)", "unfolding b column_def is_zero_row_def'"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j. A $ b $ j = (0::'a)) \\<Longrightarrow>\n  A $ b $ (LEAST k. A $ b $ k \\<noteq> (0::'a)) = (1::'a)\n  row b A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (LEAST n. A $ b $ n \\<noteq> (0::'a))) $ x = (1::'a)", "by (metis (mono_tags) \\<open>\\<not> is_zero_row b A \\<Longrightarrow> A $ b $ (LEAST k. A $ b $ k \\<noteq> 0) = 1\\<close>\n          b_eq_x is_zero_row_eq_row_zero vec_lambda_beta)"], ["proof (state)\nthis:\n  v $ x = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma column_leading_coefficient_component_0:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  and v: \"v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\" \n  and vx: \"v $ x \\<noteq> 0\"\n  and x_not_y: \"x \\<noteq> y\"\n  shows \"v $ y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ y = (0::'a)", "using column_leading_coefficient_component_eq[OF rref_A v vx] x_not_y"], ["proof (prove)\nusing this:\n  v $ ?y \\<noteq> (0::'a) \\<Longrightarrow> x = ?y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. v $ y = (0::'a)", "by auto"], ["", "lemma rref_col_rank:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{mod_type}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"col_rank A = card {column (LEAST n. A $ i $ n \\<noteq> 0) A | i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "proof (unfold col_rank_def, rule vec.dim_unique[of \"{column (LEAST n. A $ i $ n \\<noteq> 0) A | i. row i A \\<noteq> 0}\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n    \\<subseteq> col_space A\n 2. col_space A\n    \\<subseteq> vec.span\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}\n 3. vec.independent\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n 4. card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n      row i A \\<noteq> 0} =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "show \"{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} \\<subseteq> col_space A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n    \\<subseteq> col_space A", "by (auto simp add: col_space_def, rule vec.span_base, unfold columns_def, auto)"], ["proof (state)\nthis:\n  {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n  \\<subseteq> col_space A\n\ngoal (3 subgoals):\n 1. col_space A\n    \\<subseteq> vec.span\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}\n 2. vec.independent\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n 3. card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n      row i A \\<noteq> 0} =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "show \"vec.independent {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.independent\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "proof (rule vec.independent_if_scalars_zero, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "fix f i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "let ?x = \"column (LEAST n. A $ i $ n \\<noteq> 0) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "have sum0: \"(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} - {?x}. f x * (x $ i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0} -\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n       f x * x $ i) =\n    (0::'a)", "proof (rule sum.neutral, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                 A} \\<Longrightarrow>\n       f x * x $ i = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                 A} \\<Longrightarrow>\n       f x * x $ i = (0::'a)", "assume x: \"x \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} - {?x}\""], ["proof (state)\nthis:\n  x \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0} -\n          {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                 A} \\<Longrightarrow>\n       f x * x $ i = (0::'a)", "obtain j where x_eq: \"x=column (LEAST n. A $ j $ n \\<noteq> 0) A\" and row_j_not_0: \"row j A \\<noteq> 0\" \n          and j_not_i: \"j\\<noteq>i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x = column (LEAST n. A $ j $ n \\<noteq> (0::'a)) A;\n         row j A \\<noteq> 0; j \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0} -\n          {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>x = column (LEAST n. A $ j $ n \\<noteq> (0::'a)) A;\n         row j A \\<noteq> 0; j \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = column (LEAST n. A $ j $ n \\<noteq> (0::'a)) A\n  row j A \\<noteq> 0\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                 A} \\<Longrightarrow>\n       f x * x $ i = (0::'a)", "have \"x$i=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ i = (0::'a)", "unfolding x_eq column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (LEAST n. A $ j $ n \\<noteq> (0::'a))) $ i = (0::'a)", "by (auto, metis is_zero_row_eq_row_zero j_not_i row_j_not_0 rref_A rref_condition4_explicit)"], ["proof (state)\nthis:\n  x $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                 A} \\<Longrightarrow>\n       f x * x $ i = (0::'a)", "thus \"f x * x $ i = 0\""], ["proof (prove)\nusing this:\n  x $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. f x * x $ i = (0::'a)", "by simp"], ["proof (state)\nthis:\n  f x * x $ i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n     f x * x $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "assume eq_0: \"(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}. f x *s x) = 0\"\n        and i: \"row i A \\<noteq> 0\""], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x *s x) =\n  0\n  row i A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "have xi_1: \"(?x $ i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i = (1::'a)", "unfolding column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $ i = (1::'a)", "by (auto, metis i is_zero_row_eq_row_zero rref_A rref_condition2_explicit)"], ["proof (state)\nthis:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "have \"0 = (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}. f x *s x) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       f x *s x) $\n    i", "using eq_0"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x *s x) =\n  0\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       f x *s x) $\n    i", "by auto"], ["proof (state)\nthis:\n  (0::'a) =\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x *s x) $\n  i\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "also"], ["proof (state)\nthis:\n  (0::'a) =\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x *s x) $\n  i\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "have \"... = (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}. f x * (x $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       f x *s x) $\n    i =\n    (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       f x * x $ i)", "unfolding sum_component vector_smult_component"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       f x * x $ i) =\n    (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       f x * x $ i)", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x *s x) $\n  i =\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x *s x) $\n  i =\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "have \"... = f ?x * (?x $ i) \n      + (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} - {?x}. f x * (x $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       f x * x $ i) =\n    f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n    column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i +\n    (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0} -\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n       f x * x $ i)", "by (rule sum.remove, auto, rule exI[of _ i], simp add: i)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x * x $ i) =\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i +\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n     f x * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     f x * x $ i) =\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i +\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n     f x * x $ i)\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "have \"... = f ?x * (?x $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n    column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i +\n    (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0} -\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n       f x * x $ i) =\n    f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n    column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i", "unfolding sum0"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n    column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i +\n    (0::'a) =\n    f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n    column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i", "by simp"], ["proof (state)\nthis:\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i +\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n     f x * x $ i) =\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "also"], ["proof (state)\nthis:\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i +\n  (\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A}.\n     f x * x $ i) =\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "have \"... = f (column (LEAST n. A $ i $ n \\<noteq> 0) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n    column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i =\n    f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A)", "unfolding xi_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) * (1::'a) =\n    f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A)", "by simp"], ["proof (state)\nthis:\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) *\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i =\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A)\n\ngoal (1 subgoal):\n 1. \\<And>f i.\n       \\<lbrakk>(\\<Sum>x\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                               A |\n                              i. row i A \\<noteq> 0}.\n                   f x *s x) =\n                0;\n        row i A \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> f (column (LEAST n. A $ i $ n \\<noteq> (0::'a))\n                             A) =\n                         (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (0::'a) = f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A)", "show \"f (column (LEAST n. A $ i $ n \\<noteq> 0) A) = 0\""], ["proof (prove)\nusing this:\n  (0::'a) = f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A)\n\ngoal (1 subgoal):\n 1. f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  f (column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec.independent\n   {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. col_space A\n    \\<subseteq> vec.span\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}\n 2. card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n      row i A \\<noteq> 0} =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "show \"col_space A \\<subseteq> vec.span {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_space A\n    \\<subseteq> vec.span\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}", "unfolding col_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.span (columns A)\n    \\<subseteq> vec.span\n                 {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}", "proof (rule vec.span_mono[of \"(columns A)\" \n        \"vec.span {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\", unfolded vec.span_span], auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> columns A \\<Longrightarrow>\n       x \\<in> vec.span\n                {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> columns A \\<Longrightarrow>\n       x \\<in> vec.span\n                {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0}", "assume x: \"x \\<in> columns A\""], ["proof (state)\nthis:\n  x \\<in> columns A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> columns A \\<Longrightarrow>\n       x \\<in> vec.span\n                {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0}", "have f: \"finite {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  finite\n   {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> columns A \\<Longrightarrow>\n       x \\<in> vec.span\n                {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0}", "let ?f=\"\\<lambda>v. x $ (THE i. v $ i \\<noteq> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> columns A \\<Longrightarrow>\n       x \\<in> vec.span\n                {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0}", "show \"x \\<in> vec.span {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> vec.span\n             {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0}", "unfolding vec.span_finite[OF f] image_iff bex_UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       x =\n       (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                     row i A \\<noteq> 0}.\n          xa v *s v)", "proof (rule exI[of _ ?f], subst (1) vec_eq_iff, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       x $ i =\n       (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                     row i A \\<noteq> 0}.\n          x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n       i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       x $ i =\n       (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                     row i A \\<noteq> 0}.\n          x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n       i", "show \"x $ i = (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}. x $ (THE i. v $ i \\<noteq> 0) *s v) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "proof (cases \"\\<exists>v. v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} \\<and> v $ i \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i\n 2. \\<nexists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "case False"], ["proof (state)\nthis:\n  \\<nexists>v.\n     v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0} \\<and>\n     v $ i \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i\n 2. \\<nexists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have xi_0: \"x $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ i = (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x $ i \\<noteq> (0::'a) \\<Longrightarrow> False", "assume xi_not_0: \"x $ i \\<noteq> 0\""], ["proof (state)\nthis:\n  x $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x $ i \\<noteq> (0::'a) \\<Longrightarrow> False", "hence row_iA_not_zero: \"row i A \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. row i A \\<noteq> 0", "using x"], ["proof (prove)\nusing this:\n  x $ i \\<noteq> (0::'a)\n  x \\<in> columns A\n\ngoal (1 subgoal):\n 1. row i A \\<noteq> 0", "unfolding columns_def column_def row_def"], ["proof (prove)\nusing this:\n  x $ i \\<noteq> (0::'a)\n  x \\<in> {\\<chi>ia. A $ ia $ i |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. vec_lambda (($) (A $ i)) \\<noteq> 0", "by (vector, metis vec_lambda_unique)"], ["proof (state)\nthis:\n  row i A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x $ i \\<noteq> (0::'a) \\<Longrightarrow> False", "let ?v=\"column (LEAST n. A $ i $ n \\<noteq> 0) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. x $ i \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"?v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n    \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0}", "using row_iA_not_zero"], ["proof (prove)\nusing this:\n  row i A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n    \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n  \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n         row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. x $ i \\<noteq> (0::'a) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n  \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n         row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. x $ i \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"?v $ i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i = (1::'a)", "unfolding column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) $ i = (1::'a)", "by (auto, metis is_zero_row_eq_row_zero row_iA_not_zero rref_A rref_condition2)"], ["proof (state)\nthis:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. x $ i \\<noteq> (0::'a) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n  \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n         row i A \\<noteq> 0}\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i = (1::'a)", "show False"], ["proof (prove)\nusing this:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n  \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n         row i A \\<noteq> 0}\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n  \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n         row i A \\<noteq> 0}\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A $ i = (1::'a)\n  \\<nexists>v.\n     v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0} \\<and>\n     v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x $ i = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i\n 2. \\<nexists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "unfolding xi_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "proof (unfold sum_component vector_smult_component, rule sum.neutral[symmetric], rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} \\<Longrightarrow>\n       x $ (THE i. xa $ i \\<noteq> (0::'a)) * xa $ i = (0::'a)", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} \\<Longrightarrow>\n       x $ (THE i. xa $ i \\<noteq> (0::'a)) * xa $ i = (0::'a)", "assume xa: \"xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\""], ["proof (state)\nthis:\n  xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n            row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} \\<Longrightarrow>\n       x $ (THE i. xa $ i \\<noteq> (0::'a)) * xa $ i = (0::'a)", "have \"xa $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa $ i = (0::'a)", "using False xa"], ["proof (prove)\nusing this:\n  \\<nexists>v.\n     v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0} \\<and>\n     v $ i \\<noteq> (0::'a)\n  xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n            row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. xa $ i = (0::'a)", "by auto"], ["proof (state)\nthis:\n  xa $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} \\<Longrightarrow>\n       x $ (THE i. xa $ i \\<noteq> (0::'a)) * xa $ i = (0::'a)", "thus \"x $ (THE i. xa $ i \\<noteq> 0) * xa $ i = 0\""], ["proof (prove)\nusing this:\n  xa $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. x $ (THE i. xa $ i \\<noteq> (0::'a)) * xa $ i = (0::'a)", "by simp"], ["proof (state)\nthis:\n  x $ (THE i. xa $ i \\<noteq> (0::'a)) * xa $ i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x $ i =\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n  i\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "case True"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0} \\<and>\n     v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "obtain v where v: \"v \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\" and vi: \"v $ i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                          row i A \\<noteq> 0};\n         v $ i \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0} \\<and>\n     v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                          row i A \\<noteq> 0};\n         v $ i \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0}\n  v $ i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "obtain b where b: \"v = column (LEAST n. A $ b $ n \\<noteq> 0) A\" and row_b: \"row b A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A;\n         row b A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v"], ["proof (prove)\nusing this:\n  v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n           row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A;\n         row b A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v = column (LEAST n. A $ b $ n \\<noteq> (0::'a)) A\n  row b A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have vb: \"v $ b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ b \\<noteq> (0::'a)", "unfolding b column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (LEAST n. A $ b $ n \\<noteq> (0::'a))) $ b \\<noteq>\n    (0::'a)", "by (auto, metis is_zero_row_eq_row_zero row_b rref_A rref_condition2 zero_neq_one)"], ["proof (state)\nthis:\n  v $ b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have b_eq_i: \"b = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = i", "by (rule column_leading_coefficient_component_eq[OF rref_A v vb vi])"], ["proof (state)\nthis:\n  b = i\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have the_vi: \"(THE a. v $ a \\<noteq> 0) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE a. v $ a \\<noteq> (0::'a)) = i", "proof (rule the_equality, rule vi)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. v $ a \\<noteq> (0::'a) \\<Longrightarrow> a = i", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. v $ a \\<noteq> (0::'a) \\<Longrightarrow> a = i", "assume va: \"v $ a \\<noteq> 0\""], ["proof (state)\nthis:\n  v $ a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a. v $ a \\<noteq> (0::'a) \\<Longrightarrow> a = i", "show \"a=i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = i", "by (rule column_leading_coefficient_component_eq[OF rref_A v va vi])"], ["proof (state)\nthis:\n  a = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (THE a. v $ a \\<noteq> (0::'a)) = i\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have vi_1: \"v $ i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v $ i = (1::'a)", "by (rule column_leading_coefficient_component_1[OF rref_A v vi])"], ["proof (state)\nthis:\n  v $ i = (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have sum0: \"(\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} - {v}. x $ (THE a. v $ a \\<noteq> 0) * (v $ i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0} -\n                 {v}.\n       x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n    (0::'a)", "proof (rule sum.neutral, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} -\n                {v} \\<Longrightarrow>\n       x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)", "fix xa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} -\n                {v} \\<Longrightarrow>\n       x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)", "assume xa: \"xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} - {v}\""], ["proof (state)\nthis:\n  xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n            row i A \\<noteq> 0} -\n           {v}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} -\n                {v} \\<Longrightarrow>\n       x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)", "obtain y where y: \"xa = column (LEAST n. A $ y $ n \\<noteq> 0) A\" and row_b: \"row y A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>xa = column (LEAST n. A $ y $ n \\<noteq> (0::'a)) A;\n         row y A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using xa"], ["proof (prove)\nusing this:\n  xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n            row i A \\<noteq> 0} -\n           {v}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>xa = column (LEAST n. A $ y $ n \\<noteq> (0::'a)) A;\n         row y A \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xa = column (LEAST n. A $ y $ n \\<noteq> (0::'a)) A\n  row y A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} -\n                {v} \\<Longrightarrow>\n       x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)", "have xa_in_V: \"xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0}", "using xa"], ["proof (prove)\nusing this:\n  xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n            row i A \\<noteq> 0} -\n           {v}\n\ngoal (1 subgoal):\n 1. xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n              row i A \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n            row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} -\n                {v} \\<Longrightarrow>\n       x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)", "have \"xa $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa $ i = (0::'a)", "proof (rule column_leading_coefficient_component_0[OF rref_A xa_in_V])"], ["proof (state)\ngoal (2 subgoals):\n 1. xa $ ?x \\<noteq> (0::'a)\n 2. ?x \\<noteq> i", "show \"xa $ y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa $ y \\<noteq> (0::'a)", "unfolding y column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i. A $ i $ (LEAST n. A $ y $ n \\<noteq> (0::'a))) $ y \\<noteq>\n    (0::'a)", "by (auto, metis (lifting, full_types) LeastI2_ex is_zero_row_def' is_zero_row_eq_row_zero row_b)"], ["proof (state)\nthis:\n  xa $ y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<noteq> i", "have \"y \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> b", "by (metis (mono_tags) Diff_iff b mem_Collect_eq singleton_conv2 xa y)"], ["proof (state)\nthis:\n  y \\<noteq> b\n\ngoal (1 subgoal):\n 1. y \\<noteq> i", "thus \"y \\<noteq> i\""], ["proof (prove)\nusing this:\n  y \\<noteq> b\n\ngoal (1 subgoal):\n 1. y \\<noteq> i", "unfolding b_eq_i[symmetric]"], ["proof (prove)\nusing this:\n  y \\<noteq> b\n\ngoal (1 subgoal):\n 1. y \\<noteq> b", "."], ["proof (state)\nthis:\n  y \\<noteq> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xa $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                 row i A \\<noteq> 0} -\n                {v} \\<Longrightarrow>\n       x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)", "thus \"x $ (THE a. xa $ a \\<noteq> 0) * xa $ i = 0\""], ["proof (prove)\nusing this:\n  xa $ i = (0::'a)\n\ngoal (1 subgoal):\n 1. x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)", "by simp"], ["proof (state)\nthis:\n  x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {v}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have \"(\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}. x $ (THE a. v $ a \\<noteq> 0) *s v) $ i =\n          (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0}. x $ (THE a. v $ a \\<noteq> 0) * (v $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE a. v $ a \\<noteq> (0::'a)) *s v) $\n    i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i)", "unfolding sum_component vector_smult_component"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                   row i A \\<noteq> 0}.\n       x $ (THE a. xa $ a \\<noteq> (0::'a)) * xa $ i) =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i)", ".."], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) *s v) $\n  i =\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) *s v) $\n  i =\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have \"... = x $ (THE a. v $ a \\<noteq> 0) * (v $ i)\n          + (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> 0) A |i. row i A \\<noteq> 0} - {v}. x $ (THE a. v $ a \\<noteq> 0) * (v $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n    x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i +\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0} -\n                 {v}.\n       x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i)", "by (simp add: sum.remove[OF _ v])"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i +\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {v}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i +\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {v}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have \"... = x $ (THE a. v $ a \\<noteq> 0) * (v $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i +\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0} -\n                 {v}.\n       x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n    x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i", "unfolding sum0"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i + (0::'a) =\n    x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i", "by simp"], ["proof (state)\nthis:\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i +\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {v}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "also"], ["proof (state)\nthis:\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i +\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} -\n               {v}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i) =\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have \"... = x $ (THE a. v $ a \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i =\n    x $ (THE a. v $ a \\<noteq> (0::'a))", "unfolding vi_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ (THE a. v $ a \\<noteq> (0::'a)) * (1::'a) =\n    x $ (THE a. v $ a \\<noteq> (0::'a))", "by simp"], ["proof (state)\nthis:\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i =\n  x $ (THE a. v $ a \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "also"], ["proof (state)\nthis:\n  x $ (THE a. v $ a \\<noteq> (0::'a)) * v $ i =\n  x $ (THE a. v $ a \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "have \"... = x $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ (THE a. v $ a \\<noteq> (0::'a)) = x $ i", "unfolding the_vi"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ i = x $ i", ".."], ["proof (state)\nthis:\n  x $ (THE a. v $ a \\<noteq> (0::'a)) = x $ i\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0} \\<and>\n       v $ i \\<noteq> (0::'a) \\<Longrightarrow>\n    x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) *s v) $\n  i =\n  x $ i", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE a. v $ a \\<noteq> (0::'a)) *s v) $\n  i =\n  x $ i\n\ngoal (1 subgoal):\n 1. x $ i =\n    (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                  row i A \\<noteq> 0}.\n       x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n    i", "by simp"], ["proof (state)\nthis:\n  x $ i =\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n  i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x $ i =\n  (\\<Sum>v\\<in>{column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}.\n     x $ (THE i. v $ i \\<noteq> (0::'a)) *s v) $\n  i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> vec.span\n           {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n            row i A \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  col_space A\n  \\<subseteq> vec.span\n               {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n                row i A \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n      row i A \\<noteq> 0} =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "qed (simp)"], ["", "lemma rref_row_rank:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{finite,one,plus,ord}\"\n  assumes rref_A: \"reduced_row_echelon_form A\"\n  shows \"row_rank A = card {column (LEAST n. A $ i $ n \\<noteq> 0) A | i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_rank A =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row_rank A =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "let ?f=\"\\<lambda>x. column ((LEAST n. x $ n \\<noteq> 0)) A\""], ["proof (state)\ngoal (1 subgoal):\n 1. row_rank A =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_rank A =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "unfolding rref_rank[OF rref_A, unfolded rank_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {row i A |i. row i A \\<noteq> 0} =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", "proof (rule bij_betw_same_card[of ?f], unfold bij_betw_def, auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A)\n     {row i A |i. row i A \\<noteq> 0}\n 2. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n          column (LEAST n. A $ ia $ n \\<noteq> (0::'a)) A \\<and>\n          row ia A \\<noteq> 0\n 3. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "show \"inj_on (\\<lambda>x. column (LEAST n. x $ n \\<noteq> 0) A) {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A)\n     {row i A |i. row i A \\<noteq> 0}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{row i A |i. row i A \\<noteq> 0}.\n       \\<forall>y\\<in>{row i A |i. row i A \\<noteq> 0}.\n          column (LEAST n. x $ n \\<noteq> (0::'a)) A =\n          column (LEAST n. y $ n \\<noteq> (0::'a)) A \\<longrightarrow>\n          x = y", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>row i A \\<noteq> 0; row ia A \\<noteq> 0;\n        column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n        column (LEAST n. row ia A $ n \\<noteq> (0::'a)) A\\<rbrakk>\n       \\<Longrightarrow> row i A = row ia A", "fix i ia"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>row i A \\<noteq> 0; row ia A \\<noteq> 0;\n        column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n        column (LEAST n. row ia A $ n \\<noteq> (0::'a)) A\\<rbrakk>\n       \\<Longrightarrow> row i A = row ia A", "assume i: \"row i A \\<noteq> 0\" and ia: \"row ia A \\<noteq> 0\"\n         and c_eq: \"column (LEAST n. row i A $ n \\<noteq> 0) A = column (LEAST n. row ia A $ n \\<noteq> 0) A\""], ["proof (state)\nthis:\n  row i A \\<noteq> 0\n  row ia A \\<noteq> 0\n  column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n  column (LEAST n. row ia A $ n \\<noteq> (0::'a)) A\n\ngoal (1 subgoal):\n 1. \\<And>i ia.\n       \\<lbrakk>row i A \\<noteq> 0; row ia A \\<noteq> 0;\n        column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n        column (LEAST n. row ia A $ n \\<noteq> (0::'a)) A\\<rbrakk>\n       \\<Longrightarrow> row i A = row ia A", "show \"row i A = row ia A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row i A = row ia A", "using c_eq"], ["proof (prove)\nusing this:\n  column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n  column (LEAST n. row ia A $ n \\<noteq> (0::'a)) A\n\ngoal (1 subgoal):\n 1. row i A = row ia A", "unfolding column_def"], ["proof (prove)\nusing this:\n  (\\<chi>ia. A $ ia $ (LEAST n. row i A $ n \\<noteq> (0::'a))) =\n  (\\<chi>i. A $ i $ (LEAST n. row ia A $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. row i A = row ia A", "unfolding row_def vec_nth_inverse"], ["proof (prove)\nusing this:\n  (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n  (\\<chi>i. A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a)))\n\ngoal (1 subgoal):\n 1. A $ i = A $ ia", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (\\<chi>i.\n        A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))) \\<Longrightarrow>\n    A $ i = A $ ia", "have \"transpose_row A (LEAST R. A $ ia $ R \\<noteq> 0) = transpose_row A (LEAST R. A $ i $ R \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transpose_row A (LEAST R. A $ ia $ R \\<noteq> (0::'a)) =\n    transpose_row A (LEAST R. A $ i $ R \\<noteq> (0::'a))", "by (metis c_eq column_def row_def transpose_row_def vec_nth_inverse)"], ["proof (state)\nthis:\n  transpose_row A (LEAST R. A $ ia $ R \\<noteq> (0::'a)) =\n  transpose_row A (LEAST R. A $ i $ R \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (\\<chi>i.\n        A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))) \\<Longrightarrow>\n    A $ i = A $ ia", "hence f1: \"\\<And>x\\<^sub>1. A $ x\\<^sub>1 $ (LEAST R. A $ ia $ R \\<noteq> 0) = A $ x\\<^sub>1 $ (LEAST R. A $ i $ R \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  transpose_row A (LEAST R. A $ ia $ R \\<noteq> (0::'a)) =\n  transpose_row A (LEAST R. A $ i $ R \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1.\n       A $ x\\<^sub>1 $ (LEAST R. A $ ia $ R \\<noteq> (0::'a)) =\n       A $ x\\<^sub>1 $ (LEAST R. A $ i $ R \\<noteq> (0::'a))", "by (metis (no_types) transpose_row_def vec_lambda_beta)"], ["proof (state)\nthis:\n  A $ ?x\\<^sub>11 $ (LEAST R. A $ ia $ R \\<noteq> (0::'a)) =\n  A $ ?x\\<^sub>11 $ (LEAST R. A $ i $ R \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (\\<chi>i.\n        A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))) \\<Longrightarrow>\n    A $ i = A $ ia", "have f2: \"is_zero_row ia A = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero_row ia A = False", "using ia is_zero_row_eq_row_zero"], ["proof (prove)\nusing this:\n  row ia A \\<noteq> 0\n  is_zero_row ?a ?A = (row ?a ?A = 0)\n\ngoal (1 subgoal):\n 1. is_zero_row ia A = False", "by auto"], ["proof (state)\nthis:\n  is_zero_row ia A = False\n\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (\\<chi>i.\n        A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))) \\<Longrightarrow>\n    A $ i = A $ ia", "have f3: \"\\<not> is_zero_row i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A", "using i is_zero_row_eq_row_zero"], ["proof (prove)\nusing this:\n  row i A \\<noteq> 0\n  is_zero_row ?a ?A = (row ?a ?A = 0)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i A", "by auto"], ["proof (state)\nthis:\n  \\<not> is_zero_row i A\n\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (\\<chi>i.\n        A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))) \\<Longrightarrow>\n    A $ i = A $ ia", "have \"A $ ia $ (LEAST R. A $ i $ R \\<noteq> 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST R. A $ i $ R \\<noteq> (0::'a)) = (1::'a)", "using f1 f2 rref_A rref_condition2"], ["proof (prove)\nusing this:\n  A $ ?x\\<^sub>11 $ (LEAST R. A $ ia $ R \\<noteq> (0::'a)) =\n  A $ ?x\\<^sub>11 $ (LEAST R. A $ i $ R \\<noteq> (0::'a))\n  is_zero_row ia A = False\n  reduced_row_echelon_form A\n  reduced_row_echelon_form ?A \\<Longrightarrow>\n  \\<forall>i.\n     \\<not> is_zero_row i ?A \\<longrightarrow>\n     ?A $ i $ (LEAST k. ?A $ i $ k \\<noteq> (0::?'a)) = (1::?'a)\n\ngoal (1 subgoal):\n 1. A $ ia $ (LEAST R. A $ i $ R \\<noteq> (0::'a)) = (1::'a)", "by fastforce"], ["proof (state)\nthis:\n  A $ ia $ (LEAST R. A $ i $ R \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a))) =\n    (\\<chi>i.\n        A $ i $ (LEAST n. A $ ia $ n \\<noteq> (0::'a))) \\<Longrightarrow>\n    A $ i = A $ ia", "thus \"A $ i = A $ ia\""], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST R. A $ i $ R \\<noteq> (0::'a)) = (1::'a)\n\ngoal (1 subgoal):\n 1. A $ i = A $ ia", "using f3 rref_A rref_condition4_explicit"], ["proof (prove)\nusing this:\n  A $ ia $ (LEAST R. A $ i $ R \\<noteq> (0::'a)) = (1::'a)\n  \\<not> is_zero_row i A\n  reduced_row_echelon_form A\n  \\<lbrakk>reduced_row_echelon_form ?A; \\<not> is_zero_row ?i ?A;\n   ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> ?A $ ?j $ (LEAST n. ?A $ ?i $ n \\<noteq> (0::?'a)) =\n                    (0::?'a)\n\ngoal (1 subgoal):\n 1. A $ i = A $ ia", "by fastforce"], ["proof (state)\nthis:\n  A $ i = A $ ia\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row i A = row ia A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A)\n   {row i A |i. row i A \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n          column (LEAST n. A $ ia $ n \\<noteq> (0::'a)) A \\<and>\n          row ia A \\<noteq> 0\n 2. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n          column (LEAST n. A $ ia $ n \\<noteq> (0::'a)) A \\<and>\n          row ia A \\<noteq> 0\n 2. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n          column (LEAST n. A $ ia $ n \\<noteq> (0::'a)) A \\<and>\n          row ia A \\<noteq> 0\n 2. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "assume i: \"row i A \\<noteq> 0\""], ["proof (state)\nthis:\n  row i A \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n          column (LEAST n. A $ ia $ n \\<noteq> (0::'a)) A \\<and>\n          row ia A \\<noteq> 0\n 2. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "show \"\\<exists>ia. column (LEAST n. row i A $ n \\<noteq> 0) A = column (LEAST n. A $ ia $ n \\<noteq> 0) A \\<and> row ia A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n       column (LEAST n. A $ ia $ n \\<noteq> (0::'a)) A \\<and>\n       row ia A \\<noteq> 0", "by (rule exI[of _ \"i\"], simp add: row_def vec_lambda_eta)\n         (metis i is_zero_row_def' is_zero_row_eq_row_zero zero_index)"], ["proof (state)\nthis:\n  \\<exists>ia.\n     column (LEAST n. row i A $ n \\<noteq> (0::'a)) A =\n     column (LEAST n. A $ ia $ n \\<noteq> (0::'a)) A \\<and>\n     row ia A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "assume i: \"row i A \\<noteq> 0\""], ["proof (state)\nthis:\n  row i A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i A \\<noteq> 0 \\<Longrightarrow>\n       column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n       \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n             {row i A |i. row i A \\<noteq> 0}", "show \"column (LEAST n. A $ i $ n \\<noteq> 0) A \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> 0) A) ` {row i A |i. row i A \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n    \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n          {row i A |i. row i A \\<noteq> 0}", "unfolding column_def row_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia. A $ ia $ (LEAST n. A $ i $ n \\<noteq> (0::'a)))\n    \\<in> {y. \\<exists>x\\<in>{vec_lambda (($) (A $ i)) |i.\n                              vec_lambda (($) (A $ i)) \\<noteq> 0}.\n                 y = (\\<chi>i. A $ i $ (LEAST n. x $ n \\<noteq> (0::'a)))}", "by (auto, metis i row_def vec_lambda_eta)"], ["proof (state)\nthis:\n  column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A\n  \\<in> (\\<lambda>x. column (LEAST n. x $ n \\<noteq> (0::'a)) A) `\n        {row i A |i. row i A \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row_rank A =\n  card\n   {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_rank_eq_col_rank_rref:\n  fixes A::\"'a::{field}^'m::{mod_type}^'n::{mod_type}\"\nassumes r: \"reduced_row_echelon_form A\"\nshows \"row_rank A = col_rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "unfolding rref_row_rank[OF r] rref_col_rank[OF r]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i.\n      row i A \\<noteq> 0} =\n    card\n     {column (LEAST n. A $ i $ n \\<noteq> (0::'a)) A |i. row i A \\<noteq> 0}", ".."], ["", "lemma row_rank_eq_col_rank:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"row_rank A = col_rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "obtain P where inv_P: \"invertible P\" and G_PA: \"(Gauss_Jordan A) = P**A\"\n  and rref_G: \"reduced_row_echelon_form (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P; Gauss_Jordan A = P ** A;\n         reduced_row_echelon_form (Gauss_Jordan A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_Gauss_Jordan rref_Gauss_Jordan"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan ?A = P ** ?A\n  reduced_row_echelon_form (Gauss_Jordan ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P; Gauss_Jordan A = P ** A;\n         reduced_row_echelon_form (Gauss_Jordan A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible P\n  Gauss_Jordan A = P ** A\n  reduced_row_echelon_form (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "have \"row_rank A = row_rank (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_rank A = row_rank (Gauss_Jordan A)", "by (metis row_space_is_preserved invertible_Gauss_Jordan row_rank_def)"], ["proof (state)\nthis:\n  row_rank A = row_rank (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "moreover"], ["proof (state)\nthis:\n  row_rank A = row_rank (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "have \"col_rank A = col_rank (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = col_rank (Gauss_Jordan A)", "by (metis invertible_Gauss_Jordan crk_is_preserved)"], ["proof (state)\nthis:\n  col_rank A = col_rank (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "moreover"], ["proof (state)\nthis:\n  col_rank A = col_rank (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "have \"col_rank (Gauss_Jordan A) = row_rank (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank (Gauss_Jordan A) = row_rank (Gauss_Jordan A)", "using row_rank_eq_col_rank_rref[OF rref_G]"], ["proof (prove)\nusing this:\n  row_rank (Gauss_Jordan A) = col_rank (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. col_rank (Gauss_Jordan A) = row_rank (Gauss_Jordan A)", "by simp"], ["proof (state)\nthis:\n  col_rank (Gauss_Jordan A) = row_rank (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "ultimately"], ["proof (chain)\npicking this:\n  row_rank A = row_rank (Gauss_Jordan A)\n  col_rank A = col_rank (Gauss_Jordan A)\n  col_rank (Gauss_Jordan A) = row_rank (Gauss_Jordan A)", "show ?thesis"], ["proof (prove)\nusing this:\n  row_rank A = row_rank (Gauss_Jordan A)\n  col_rank A = col_rank (Gauss_Jordan A)\n  col_rank (Gauss_Jordan A) = row_rank (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row_rank A = col_rank A", "by simp"], ["proof (state)\nthis:\n  row_rank A = col_rank A\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem rank_col_rank:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = col_rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = col_rank A", "unfolding rank_def row_rank_eq_col_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. col_rank A = col_rank A", ".."], ["", "theorem rank_eq_dim_image:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = vec.dim (range (\\<lambda>x. A *v x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = vec.dim (range ((*v) A))", "unfolding rank_col_rank col_rank_def col_space_eq'"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (range ((*v) A)) = vec.dim (range ((*v) A))", ".."], ["", "theorem rank_eq_dim_col_space:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = vec.dim (col_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = vec.dim (col_space A)", "using rank_col_rank"], ["proof (prove)\nusing this:\n  rank ?A = col_rank ?A\n\ngoal (1 subgoal):\n 1. rank A = vec.dim (col_space A)", "unfolding col_rank_def"], ["proof (prove)\nusing this:\n  rank ?A = vec.dim (col_space ?A)\n\ngoal (1 subgoal):\n 1. rank A = vec.dim (col_space A)", "."], ["", "lemma rank_transpose: \n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows  \"rank (transpose A) = rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (Finite_Cartesian_Product.transpose A) = rank A", "by (metis rank_def rank_eq_dim_col_space row_rank_def row_space_eq_col_space_transpose)"], ["", "lemma rank_le_nrows:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A \\<le> nrows A", "unfolding rank_eq_dim_col_space nrows_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) \\<le> CARD('m)", "by (metis top_greatest vec.dim_subset vec_dim_card)"], ["", "lemma rank_le_ncols:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A \\<le> ncols A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A \\<le> ncols A", "unfolding rank_def row_rank_def ncols_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (row_space A) \\<le> CARD('n)", "by (metis top_greatest vec.dim_subset vec_dim_card)"], ["", "lemma rank_Gauss_Jordan:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = rank (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = rank (Gauss_Jordan A)", "by (metis Gauss_Jordan_def invertible_Gauss_Jordan_up_to_k \n      row_rank_eq_col_rank rank_def crk_is_preserved)"], ["", "text\\<open>Other interesting properties:\\<close>"], ["", "lemma A_0_imp_Gauss_Jordan_0:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  assumes \"A=0\"\n  shows \"Gauss_Jordan A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gauss_Jordan A = 0", "obtain P where PA: \"Gauss_Jordan A = P ** A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        Gauss_Jordan A = P ** A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using invertible_Gauss_Jordan"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> Gauss_Jordan ?A = P ** ?A\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        Gauss_Jordan A = P ** A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Gauss_Jordan A = P ** A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A = 0", "also"], ["proof (state)\nthis:\n  Gauss_Jordan A = P ** A\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** A = 0", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ** 0 = 0", "by (metis eq_add_iff matrix_add_ldistrib)"], ["proof (state)\nthis:\n  P ** A = 0\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A = 0", "finally"], ["proof (chain)\npicking this:\n  Gauss_Jordan A = 0", "show \"Gauss_Jordan A = 0\""], ["proof (prove)\nusing this:\n  Gauss_Jordan A = 0\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A = 0", "."], ["proof (state)\nthis:\n  Gauss_Jordan A = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_0: \"rank 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank 0 = 0", "unfolding rank_def row_rank_def row_space_def rows_def row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (vec.span {vec_lambda (($) (0 $ i)) |i. i \\<in> UNIV}) = 0", "by (simp add: vec.dim_span vec.dim_zero_eq' vec_nth_inverse)"], ["", "lemma rank_greater_zero:\n  assumes \"A \\<noteq> 0\"\n  shows \"rank A > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < rank A", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. rank A = 0 \\<Longrightarrow> False", "assume \"rank A = 0\""], ["proof (state)\nthis:\n  rank A = 0\n\ngoal (1 subgoal):\n 1. rank A = 0 \\<Longrightarrow> False", "hence \"row_space A = {} \\<or> row_space A = {0}\""], ["proof (prove)\nusing this:\n  rank A = 0\n\ngoal (1 subgoal):\n 1. row_space A = {} \\<or> row_space A = {0}", "unfolding rank_def row_rank_def"], ["proof (prove)\nusing this:\n  vec.dim (row_space A) = 0\n\ngoal (1 subgoal):\n 1. row_space A = {} \\<or> row_space A = {0}", "using vec.dim_zero_eq"], ["proof (prove)\nusing this:\n  vec.dim (row_space A) = 0\n  vec.dim ?A = 0 \\<Longrightarrow> ?A = {} \\<or> ?A = {0}\n\ngoal (1 subgoal):\n 1. row_space A = {} \\<or> row_space A = {0}", "by blast"], ["proof (state)\nthis:\n  row_space A = {} \\<or> row_space A = {0}\n\ngoal (1 subgoal):\n 1. rank A = 0 \\<Longrightarrow> False", "hence \"row_space A = {0}\""], ["proof (prove)\nusing this:\n  row_space A = {} \\<or> row_space A = {0}\n\ngoal (1 subgoal):\n 1. row_space A = {0}", "unfolding row_space_def"], ["proof (prove)\nusing this:\n  vec.span (rows A) = {} \\<or> vec.span (rows A) = {0}\n\ngoal (1 subgoal):\n 1. vec.span (rows A) = {0}", "using vec.span_zero"], ["proof (prove)\nusing this:\n  vec.span (rows A) = {} \\<or> vec.span (rows A) = {0}\n  0 \\<in> vec.span ?S\n\ngoal (1 subgoal):\n 1. vec.span (rows A) = {0}", "by auto"], ["proof (state)\nthis:\n  row_space A = {0}\n\ngoal (1 subgoal):\n 1. rank A = 0 \\<Longrightarrow> False", "hence \"rows A = {} \\<or> rows A = {0}\""], ["proof (prove)\nusing this:\n  row_space A = {0}\n\ngoal (1 subgoal):\n 1. rows A = {} \\<or> rows A = {0}", "unfolding row_space_def"], ["proof (prove)\nusing this:\n  vec.span (rows A) = {0}\n\ngoal (1 subgoal):\n 1. rows A = {} \\<or> rows A = {0}", "using vec.span_0_imp_set_empty_or_0"], ["proof (prove)\nusing this:\n  vec.span (rows A) = {0}\n  vec.span ?A = {0} \\<Longrightarrow> ?A = {} \\<or> ?A = {0}\n\ngoal (1 subgoal):\n 1. rows A = {} \\<or> rows A = {0}", "by auto"], ["proof (state)\nthis:\n  rows A = {} \\<or> rows A = {0}\n\ngoal (1 subgoal):\n 1. rank A = 0 \\<Longrightarrow> False", "hence \"rows A = {0}\""], ["proof (prove)\nusing this:\n  rows A = {} \\<or> rows A = {0}\n\ngoal (1 subgoal):\n 1. rows A = {0}", "unfolding rows_def row_def"], ["proof (prove)\nusing this:\n  {vec_lambda (($) (A $ i)) |i. i \\<in> UNIV} = {} \\<or>\n  {vec_lambda (($) (A $ i)) |i. i \\<in> UNIV} = {0}\n\ngoal (1 subgoal):\n 1. {vec_lambda (($) (A $ i)) |i. i \\<in> UNIV} = {0}", "by force"], ["proof (state)\nthis:\n  rows A = {0}\n\ngoal (1 subgoal):\n 1. rank A = 0 \\<Longrightarrow> False", "hence \"A = 0\""], ["proof (prove)\nusing this:\n  rows A = {0}\n\ngoal (1 subgoal):\n 1. A = 0", "unfolding rows_def row_def vec_nth_inverse"], ["proof (prove)\nusing this:\n  {A $ i |i. i \\<in> UNIV} = {0}\n\ngoal (1 subgoal):\n 1. A = 0", "by (auto, metis (mono_tags) mem_Collect_eq singleton_iff vec_lambda_unique zero_index)"], ["proof (state)\nthis:\n  A = 0\n\ngoal (1 subgoal):\n 1. rank A = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  A = 0\n  A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gauss_Jordan_not_0:\nfixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes \"A \\<noteq> 0\"\nshows \"Gauss_Jordan A \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A \\<noteq> 0", "by (metis assms less_not_refl3 rank_0 rank_Gauss_Jordan rank_greater_zero)"], ["", "lemma rank_eq_suc_to_nat_greatest:\nassumes A_not_0: \"A \\<noteq> 0\"\nshows \"rank A = to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "have rref: \"reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))", "using rref_Gauss_Jordan"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form (Gauss_Jordan ?A)\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))", "unfolding reduced_row_echelon_form_def"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan ?A) (ncols (Gauss_Jordan ?A))\n\ngoal (1 subgoal):\n 1. reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))", "by auto"], ["proof (state)\nthis:\n  reduced_row_echelon_form_upt_k (Gauss_Jordan A) (ncols (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "have not_all_zero: \"\\<not> (\\<forall>a. is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a.\n               is_zero_row_upt_k a (ncols (Gauss_Jordan A))\n                (Gauss_Jordan A))", "unfolding is_zero_row_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row a (Gauss_Jordan A))", "using Gauss_Jordan_not_0[OF A_not_0]"], ["proof (prove)\nusing this:\n  Gauss_Jordan A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a. is_zero_row a (Gauss_Jordan A))", "unfolding is_zero_row_def'"], ["proof (prove)\nusing this:\n  Gauss_Jordan A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>a j. Gauss_Jordan A $ a $ j = (0::'a))", "by (metis vec_eq_iff zero_index)"], ["proof (state)\nthis:\n  \\<not> (\\<forall>a.\n             is_zero_row_upt_k a (ncols (Gauss_Jordan A)) (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "have \"rank A = card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "unfolding rank_Gauss_Jordan[of A]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (Gauss_Jordan A) =\n    card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "unfolding rref_rank[OF rref_Gauss_Jordan]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0} =\n    card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", ".."], ["proof (state)\nthis:\n  rank A =\n  card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "also"], ["proof (state)\nthis:\n  rank A =\n  card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "have \"... = card {i. i\\<le>(GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0} =\n    card {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "proof (rule bij_betw_same_card[symmetric, of \"\\<lambda>i. row i (Gauss_Jordan A)\"], unfold bij_betw_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>i. row i (Gauss_Jordan A))\n     {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n 2. (\\<lambda>i. row i (Gauss_Jordan A)) `\n    {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "show \"inj_on (\\<lambda>i. row i (Gauss_Jordan A)) {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. row i (Gauss_Jordan A))\n     {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "proof (unfold inj_on_def, auto, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A));\n        y \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A));\n        row x (Gauss_Jordan A) = row y (Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A));\n        y \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A));\n        row x (Gauss_Jordan A) = row y (Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume x: \"x \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\" and y: \"y \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\"\n         and xy_eq_row: \"row x (Gauss_Jordan A) = row y (Gauss_Jordan A)\" and x_not_y: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  y \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  row x (Gauss_Jordan A) = row y (Gauss_Jordan A)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A));\n        y \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A));\n        row x (Gauss_Jordan A) = row y (Gauss_Jordan A);\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"x<y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> False\n 2. \\<not> x < y \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  x < y\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> False\n 2. \\<not> x < y \\<Longrightarrow> False", "have \"(LEAST n. (Gauss_Jordan A) $ x $ n \\<noteq> 0) < (LEAST n. (Gauss_Jordan A) $ y $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Gauss_Jordan A $ x $ n \\<noteq> (0::'a))\n    < (LEAST n. Gauss_Jordan A $ y $ n \\<noteq> (0::'a))", "proof (rule rref_condition3_equiv[OF rref_Gauss_Jordan True])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row x (Gauss_Jordan A)\n 2. \\<not> is_zero_row y (Gauss_Jordan A)", "show \"\\<not> is_zero_row x (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row x (Gauss_Jordan A)", "by (unfold is_zero_row_def, \n                    rule greatest_ge_nonzero_row'[OF rref x[unfolded is_zero_row_def] not_all_zero])"], ["proof (state)\nthis:\n  \\<not> is_zero_row x (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row y (Gauss_Jordan A)", "show \"\\<not> is_zero_row y (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row y (Gauss_Jordan A)", "by (unfold is_zero_row_def, rule greatest_ge_nonzero_row'[OF rref y[unfolded is_zero_row_def] not_all_zero])"], ["proof (state)\nthis:\n  \\<not> is_zero_row y (Gauss_Jordan A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ x $ n \\<noteq> (0::'a))\n  < (LEAST n. Gauss_Jordan A $ y $ n \\<noteq> (0::'a))\n\ngoal (2 subgoals):\n 1. x < y \\<Longrightarrow> False\n 2. \\<not> x < y \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ x $ n \\<noteq> (0::'a))\n  < (LEAST n. Gauss_Jordan A $ y $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. False", "by (metis less_irrefl row_def vec_nth_inverse xy_eq_row)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> x < y\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> False", "hence x_ge_y: \"x>y\""], ["proof (prove)\nusing this:\n  \\<not> x < y\n\ngoal (1 subgoal):\n 1. y < x", "using x_not_y"], ["proof (prove)\nusing this:\n  \\<not> x < y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. y < x", "by simp"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> False", "have \"(LEAST n. (Gauss_Jordan A) $ y $ n \\<noteq> 0) < (LEAST n. (Gauss_Jordan A) $ x $ n \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. Gauss_Jordan A $ y $ n \\<noteq> (0::'a))\n    < (LEAST n. Gauss_Jordan A $ x $ n \\<noteq> (0::'a))", "proof (rule rref_condition3_equiv[OF rref_Gauss_Jordan x_ge_y])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_zero_row y (Gauss_Jordan A)\n 2. \\<not> is_zero_row x (Gauss_Jordan A)", "show \"\\<not> is_zero_row x (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row x (Gauss_Jordan A)", "by (unfold is_zero_row_def, rule greatest_ge_nonzero_row'[OF rref x[unfolded is_zero_row_def] not_all_zero])"], ["proof (state)\nthis:\n  \\<not> is_zero_row x (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row y (Gauss_Jordan A)", "show \"\\<not> is_zero_row y (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row y (Gauss_Jordan A)", "by (unfold is_zero_row_def, rule greatest_ge_nonzero_row'[OF rref y[unfolded is_zero_row_def] not_all_zero])"], ["proof (state)\nthis:\n  \\<not> is_zero_row y (Gauss_Jordan A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. Gauss_Jordan A $ y $ n \\<noteq> (0::'a))\n  < (LEAST n. Gauss_Jordan A $ x $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> x < y \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  (LEAST n. Gauss_Jordan A $ y $ n \\<noteq> (0::'a))\n  < (LEAST n. Gauss_Jordan A $ x $ n \\<noteq> (0::'a))\n\ngoal (1 subgoal):\n 1. False", "by (metis less_irrefl row_def vec_nth_inverse xy_eq_row)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>i. row i (Gauss_Jordan A))\n   {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. row i (Gauss_Jordan A)) `\n    {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "show \"(\\<lambda>i. row i (Gauss_Jordan A)) ` {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} = {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. row i (Gauss_Jordan A)) `\n    {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "proof (unfold image_def, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<le> (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>i.\n          row xa (Gauss_Jordan A) = row i (Gauss_Jordan A) \\<and>\n          row i (Gauss_Jordan A) \\<noteq> 0\n 2. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "fix xa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<le> (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>i.\n          row xa (Gauss_Jordan A) = row i (Gauss_Jordan A) \\<and>\n          row i (Gauss_Jordan A) \\<noteq> 0\n 2. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "assume  xa: \"xa \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\""], ["proof (state)\nthis:\n  xa \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<le> (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>i.\n          row xa (Gauss_Jordan A) = row i (Gauss_Jordan A) \\<and>\n          row i (Gauss_Jordan A) \\<noteq> 0\n 2. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "show \"\\<exists>i. row xa (Gauss_Jordan A) = row i (Gauss_Jordan A) \\<and> row i (Gauss_Jordan A) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       row xa (Gauss_Jordan A) = row i (Gauss_Jordan A) \\<and>\n       row i (Gauss_Jordan A) \\<noteq> 0", "proof (rule exI[of _ xa], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. row xa (Gauss_Jordan A) \\<noteq> 0", "have \"\\<not> is_zero_row xa (Gauss_Jordan A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_row xa (Gauss_Jordan A)", "by (unfold is_zero_row_def, rule greatest_ge_nonzero_row'[OF rref xa[unfolded is_zero_row_def] not_all_zero])"], ["proof (state)\nthis:\n  \\<not> is_zero_row xa (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row xa (Gauss_Jordan A) \\<noteq> 0", "thus \"row xa (Gauss_Jordan A) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row xa (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row xa (Gauss_Jordan A) \\<noteq> 0", "unfolding row_def is_zero_row_def'"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>j. Gauss_Jordan A $ xa $ j = (0::'a))\n\ngoal (1 subgoal):\n 1. vec_lambda (($) (Gauss_Jordan A $ xa)) \\<noteq> 0", "by (metis vec_nth_inverse zero_index)"], ["proof (state)\nthis:\n  row xa (Gauss_Jordan A) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i.\n     row xa (Gauss_Jordan A) = row i (Gauss_Jordan A) \\<and>\n     row i (Gauss_Jordan A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "assume  \"row i (Gauss_Jordan A) \\<noteq> 0\""], ["proof (state)\nthis:\n  row i (Gauss_Jordan A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "hence \"\\<not> is_zero_row i (Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  row i (Gauss_Jordan A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row i (Gauss_Jordan A)", "unfolding row_def is_zero_row_def'"], ["proof (prove)\nusing this:\n  vec_lambda (($) (Gauss_Jordan A $ i)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>j. Gauss_Jordan A $ i $ j = (0::'a))", "by (metis vec_eq_iff vec_nth_inverse zero_index)"], ["proof (state)\nthis:\n  \\<not> is_zero_row i (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "hence \"i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))", "using Greatest_ge"], ["proof (prove)\nusing this:\n  \\<not> is_zero_row i (Gauss_Jordan A)\n  ?P ?k \\<Longrightarrow> ?k \\<le> (GREATEST x. ?P x)\n\ngoal (1 subgoal):\n 1. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))", "by fast"], ["proof (state)\nthis:\n  i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "thus \"\\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A). row i (Gauss_Jordan A) = row x (Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n       row i (Gauss_Jordan A) = row x (Gauss_Jordan A)", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n     row i (Gauss_Jordan A) = row x (Gauss_Jordan A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>i. row i (Gauss_Jordan A)) `\n  {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n  {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0} =\n  card {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "also"], ["proof (state)\nthis:\n  card {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0} =\n  card {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "have \"... = card {i. i \\<le> to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    card\n     {i. i \\<le> mod_type_class.to_nat\n                  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "proof (rule bij_betw_same_card[of \"\\<lambda>i. to_nat i\"], unfold bij_betw_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on mod_type_class.to_nat\n     {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n 2. mod_type_class.to_nat `\n    {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    {i. i \\<le> mod_type_class.to_nat\n                 (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "show \"inj_on to_nat {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mod_type_class.to_nat\n     {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "using bij_to_nat"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD(?'a)}\n\ngoal (1 subgoal):\n 1. inj_on mod_type_class.to_nat\n     {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "by (metis bij_betw_imp_inj_on subset_inj_on top_greatest)"], ["proof (state)\nthis:\n  inj_on mod_type_class.to_nat\n   {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat `\n    {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    {i. i \\<le> mod_type_class.to_nat\n                 (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "show \"to_nat ` {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} = {i. i \\<le> to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat `\n    {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    {i. i \\<le> mod_type_class.to_nat\n                 (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}", "proof (unfold image_def, auto simp add: to_nat_mono')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> mod_type_class.to_nat\n                (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          x = mod_type_class.to_nat xa", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> mod_type_class.to_nat\n                (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          x = mod_type_class.to_nat xa", "assume x: \"x \\<le> to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\""], ["proof (state)\nthis:\n  x \\<le> mod_type_class.to_nat\n           (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> mod_type_class.to_nat\n                (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          x = mod_type_class.to_nat xa", "hence \"from_nat x \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\""], ["proof (prove)\nusing this:\n  x \\<le> mod_type_class.to_nat\n           (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. mod_type_class.from_nat x\n    \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))", "by (metis (full_types) leD not_le_imp_less to_nat_le)"], ["proof (state)\nthis:\n  mod_type_class.from_nat x\n  \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> mod_type_class.to_nat\n                (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          x = mod_type_class.to_nat xa", "moreover"], ["proof (state)\nthis:\n  mod_type_class.from_nat x\n  \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> mod_type_class.to_nat\n                (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          x = mod_type_class.to_nat xa", "have \"x < CARD('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < CARD('c)", "using x bij_to_nat[where ?'a='b]"], ["proof (prove)\nusing this:\n  x \\<le> mod_type_class.to_nat\n           (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('b)}\n\ngoal (1 subgoal):\n 1. x < CARD('c)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  x \\<le> mod_type_class.to_nat\n           (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('b)}\n\ngoal (1 subgoal):\n 1. x < CARD('c)", "by (metis less_le_trans not_le to_nat_less_card)"], ["proof (state)\nthis:\n  x < CARD('c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> mod_type_class.to_nat\n                (GREATEST a.\n                    \\<not> is_zero_row a (Gauss_Jordan A)) \\<Longrightarrow>\n       \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n          x = mod_type_class.to_nat xa", "ultimately"], ["proof (chain)\npicking this:\n  mod_type_class.from_nat x\n  \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  x < CARD('c)", "show \"\\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A). x = to_nat xa\""], ["proof (prove)\nusing this:\n  mod_type_class.from_nat x\n  \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  x < CARD('c)\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n       x = mod_type_class.to_nat xa", "using to_nat_from_nat_id"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat x\n  \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\n  x < CARD('c)\n  ?x < CARD(?'a) \\<Longrightarrow>\n  mod_type_class.to_nat (mod_type_class.from_nat ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n       x = mod_type_class.to_nat xa", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xa\\<le>GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A).\n     x = mod_type_class.to_nat xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.to_nat `\n  {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n  {i. i \\<le> mod_type_class.to_nat\n               (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n  card\n   {i. i \\<le> mod_type_class.to_nat\n                (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "also"], ["proof (state)\nthis:\n  card {i. i \\<le> (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n  card\n   {i. i \\<le> mod_type_class.to_nat\n                (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))}\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "have \"... = to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {i. i \\<le> mod_type_class.to_nat\n                  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "unfolding card_Collect_le_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (mod_type_class.to_nat\n          (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))) =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "by simp"], ["proof (state)\nthis:\n  card\n   {i. i \\<le> mod_type_class.to_nat\n                (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))} =\n  mod_type_class.to_nat\n   (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n  1\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "finally"], ["proof (chain)\npicking this:\n  rank A =\n  mod_type_class.to_nat\n   (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  rank A =\n  mod_type_class.to_nat\n   (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n  1\n\ngoal (1 subgoal):\n 1. rank A =\n    mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1", "."], ["proof (state)\nthis:\n  rank A =\n  mod_type_class.to_nat\n   (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_less_row_i_imp_i_is_zero:\nassumes rank_less_i: \"to_nat i \\<ge> rank A\"\nshows \"Gauss_Jordan A $ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i = 0", "proof (cases \"A=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0\n 2. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "case True"], ["proof (state)\nthis:\n  A = 0\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0\n 2. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i = 0", "by (metis A_0_imp_Gauss_Jordan_0 zero_index)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i = 0\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "case False"], ["proof (state)\nthis:\n  A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "have \"to_nat i \\<ge> to_nat (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1\n    \\<le> mod_type_class.to_nat i", "using rank_less_i"], ["proof (prove)\nusing this:\n  rank A \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1\n    \\<le> mod_type_class.to_nat i", "unfolding rank_eq_suc_to_nat_greatest[OF False]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n  1\n  \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n    1\n    \\<le> mod_type_class.to_nat i", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat\n   (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n  1\n  \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "hence \"i>(GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A))\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat\n   (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) +\n  1\n  \\<le> mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < i", "by (metis One_nat_def add.commute add_strict_increasing \n    add_strict_increasing2 le0 lessI neq_iff not_le to_nat_mono)"], ["proof (state)\nthis:\n  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < i\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "hence \"is_zero_row i (Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < i\n\ngoal (1 subgoal):\n 1. is_zero_row i (Gauss_Jordan A)", "using not_greater_Greatest"], ["proof (prove)\nusing this:\n  (GREATEST a. \\<not> is_zero_row a (Gauss_Jordan A)) < i\n  (GREATEST x. ?P x) < ?k \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. is_zero_row i (Gauss_Jordan A)", "by auto"], ["proof (state)\nthis:\n  is_zero_row i (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow> Gauss_Jordan A $ i = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_zero_row i (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ i = 0", "unfolding is_zero_row_def' vec_eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>j. Gauss_Jordan A $ i $ j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>ia. Gauss_Jordan A $ i $ ia = 0 $ ia", "by auto"], ["proof (state)\nthis:\n  Gauss_Jordan A $ i = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_Gauss_Jordan_eq:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = (let A'=(Gauss_Jordan A) in card {row i A' |i. row i A' \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    (let A' = Gauss_Jordan A in card {row i A' |i. row i A' \\<noteq> 0})", "by (metis (mono_tags) rank_Gauss_Jordan rref_Gauss_Jordan rref_rank)"], ["", "subsection\\<open>Lemmas for code generation and rank computation\\<close>"], ["", "lemma [code abstract]: \nshows \"vec_nth (Gauss_Jordan_in_ij A i j) = (let n = (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n); \n  interchange_A = (interchange_rows A i n); \n  A' = mult_row interchange_A i (1/interchange_A$i$j) in \n  (% s. if s=i then A' $ s else (row_add A' s i (-(interchange_A$s$j))) $ s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (Gauss_Jordan_in_ij A i j) =\n    (let n = LEAST n. A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n;\n         interchange_A = interchange_rows A i n;\n         A' = mult_row interchange_A i ((1::'b) / interchange_A $ i $ j)\n     in (\\<lambda>s.\n            if s = i then A' $ s\n            else row_add A' s i (- interchange_A $ s $ j) $ s))", "unfolding Gauss_Jordan_in_ij_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ($) (\\<chi>s.\n            if s = i\n            then mult_row\n                  (interchange_rows A i\n                    (LEAST n. A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n))\n                  i ((1::'b) /\n                     interchange_rows A i\n                      (LEAST n.\n                          A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n) $\n                     i $\n                     j) $\n                 s\n            else row_add\n                  (mult_row\n                    (interchange_rows A i\n                      (LEAST n.\n                          A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n))\n                    i ((1::'b) /\n                       interchange_rows A i\n                        (LEAST n.\n                            A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n) $\n                       i $\n                       j))\n                  s i\n                  (- interchange_rows A i\n                      (LEAST n.\n                          A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n) $\n                     s $\n                     j) $\n                 s) =\n    (\\<lambda>s.\n        if s = i\n        then mult_row\n              (interchange_rows A i\n                (LEAST n. A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n))\n              i ((1::'b) /\n                 interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n) $\n                 i $\n                 j) $\n             s\n        else row_add\n              (mult_row\n                (interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n))\n                i ((1::'b) /\n                   interchange_rows A i\n                    (LEAST n. A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n) $\n                   i $\n                   j))\n              s i\n              (- interchange_rows A i\n                  (LEAST n. A $ n $ j \\<noteq> (0::'b) \\<and> i \\<le> n) $\n                 s $\n                 j) $\n             s)", "by fastforce"], ["", "lemma rank_Gauss_Jordan_code[code]:\n  fixes A::\"'a::{field}^'n::{mod_type}^'m::{mod_type}\"\n  shows \"rank A = (if A = 0 then 0 else (let A'=(Gauss_Jordan A) in to_nat (GREATEST a. row a A' \\<noteq> 0) + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "proof (cases \"A = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow>\n    rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)\n 2. A \\<noteq> 0 \\<Longrightarrow>\n    rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "case True"], ["proof (state)\nthis:\n  A = 0\n\ngoal (2 subgoals):\n 1. A = 0 \\<Longrightarrow>\n    rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)\n 2. A \\<noteq> 0 \\<Longrightarrow>\n    rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "unfolding if_P[OF True]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = 0", "unfolding True  rank_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", ".."], ["proof (state)\nthis:\n  rank A =\n  (if A = 0 then 0\n   else let A' = Gauss_Jordan A\n        in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "case False"], ["proof (state)\nthis:\n  A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    (if A = 0 then 0\n     else let A' = Gauss_Jordan A\n          in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "unfolding if_not_P[OF False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    (let A' = Gauss_Jordan A\n     in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)", "unfolding rank_eq_suc_to_nat_greatest[OF False] Let_def is_zero_row_eq_row_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n    1 =\n    mod_type_class.to_nat (GREATEST a. row a (Gauss_Jordan A) \\<noteq> 0) +\n    1", ".."], ["proof (state)\nthis:\n  rank A =\n  (if A = 0 then 0\n   else let A' = Gauss_Jordan A\n        in mod_type_class.to_nat (GREATEST a. row a A' \\<noteq> 0) + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_null_space[code_unfold]:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (null_space A) = (vec.dimension TYPE('a) TYPE('cols)) - rank (A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space A) =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", "apply (rule add_implies_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space A) + rank A =\n    finite_dimensional_vector_space.dimension cart_basis", "using rank_nullity_theorem_matrices"], ["proof (prove)\nusing this:\n  ncols ?A = vec.dim (null_space ?A) + vec.dim (col_space ?A)\n\ngoal (1 subgoal):\n 1. vec.dim (null_space A) + rank A =\n    finite_dimensional_vector_space.dimension cart_basis", "unfolding rank_eq_dim_col_space[of A]"], ["proof (prove)\nusing this:\n  ncols ?A = vec.dim (null_space ?A) + vec.dim (col_space ?A)\n\ngoal (1 subgoal):\n 1. vec.dim (null_space A) + vec.dim (col_space A) =\n    finite_dimensional_vector_space.dimension cart_basis", "unfolding dimension_vector ncols_def"], ["proof (prove)\nusing this:\n  CARD(?'cols) = vec.dim (null_space ?A) + vec.dim (col_space ?A)\n\ngoal (1 subgoal):\n 1. vec.dim (null_space A) + vec.dim (col_space A) = CARD('cols)", ".."], ["", "lemma rank_eq_dim_col_space'[code_unfold]:\n fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n shows \"vec.dim (col_space A) = rank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = rank A", "unfolding  rank_eq_dim_col_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = vec.dim (col_space A)", ".."], ["", "lemma dim_left_null_space[code_unfold]:\n  fixes A::\"'a::{field}^'cols::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (left_null_space A) = (vec.dimension TYPE('a) TYPE('rows)) - rank (A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", "unfolding left_null_space_eq_null_space_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space (Finite_Cartesian_Product.transpose A)) =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", "unfolding dim_null_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis -\n    rank (Finite_Cartesian_Product.transpose A) =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", "unfolding rank_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space.dimension cart_basis - rank A =\n    finite_dimensional_vector_space.dimension cart_basis - rank A", ".."], ["", "lemmas rank_col_rank[symmetric, code_unfold]"], ["", "lemmas rank_def[symmetric, code_unfold]"], ["", "lemmas row_rank_def[symmetric, code_unfold]"], ["", "lemmas col_rank_def[symmetric, code_unfold]"], ["", "lemmas DIM_cart[code_unfold]"], ["", "lemmas DIM_real[code_unfold]"], ["", "end"]]}