{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan/Gauss_Jordan_IArrays.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Jordan", "problem_names": ["lemma vector_all_zero_from_index_eq:\nfixes A::\"'a::{zero}^'n::{mod_type}\"\nshows \"(\\<forall>m\\<ge>i. A $ m = 0) = (vector_all_zero_from_index (to_nat i, vec_to_iarray A))\"", "lemma matrix_vector_all_zero_from_index:\n  fixes A::\"'a::{zero}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"(\\<forall>m\\<ge>i. A $ m $ k = 0) = (vector_all_zero_from_index (to_nat i, vec_to_iarray (column k A)))\"", "lemma vec_to_iarray_least_non_zero_position_of_vector_from_index:\nfixes A::\"'a::{zero}^'n::{mod_type}\"\nassumes not_all_zero: \"\\<not> (vector_all_zero_from_index (to_nat i,  vec_to_iarray A))\"\nshows \"least_non_zero_position_of_vector_from_index (vec_to_iarray A) (to_nat i) = to_nat (LEAST n. A $ n \\<noteq> 0 \\<and> i \\<le> n)\"", "lemma matrix_to_iarray_Gauss_Jordan_in_ij[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes not_all_zero: \"\\<not> (vector_all_zero_from_index (to_nat i, vec_to_iarray (column j A)))\"\n  shows \"matrix_to_iarray (Gauss_Jordan_in_ij A i j) = Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) (to_nat i) (to_nat j)\"", "lemma matrix_to_iarray_Gauss_Jordan_column_k_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"(fst (Gauss_Jordan_column_k (i, A) k)) = fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\"", "lemma matrix_to_iarray_Gauss_Jordan_column_k_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) = snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\"", "lemma foldl_Gauss_Jordan_column_k_eq:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows matrix_to_iarray_Gauss_Jordan_upt_k[code_unfold]: \"matrix_to_iarray (Gauss_Jordan_upt_k A k) = Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\"\n  and fst_foldl_Gauss_Jordan_column_k_eq: \"fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k]) = fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\"\n  and fst_foldl_Gauss_Jordan_column_k_less: \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\"", "lemma matrix_to_iarray_Gauss_Jordan[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (Gauss_Jordan A) = Gauss_Jordan_iarrays (matrix_to_iarray A)\"", "lemmas card'_code(2)[code del]", "lemmas rank_Gauss_Jordan_code[code del]", "lemma rank_eq_card_iarrays:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"rank A = card {vec_to_iarray (row i (Gauss_Jordan A)) |i. \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))}\"", "lemma rank_eq_card_iarrays':\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"rank A = (let A' = (Gauss_Jordan_iarrays (matrix_to_iarray A)) in card {row_iarray (to_nat i) A' |i::'rows. \\<not> is_zero_iarray (A' !! (to_nat i))})\"", "lemma rank_eq_card_iarrays_code:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"rank A = (let A' = (Gauss_Jordan_iarrays (matrix_to_iarray A)) in card {i::'rows. \\<not> is_zero_iarray (A' !! (to_nat i))})\"", "lemma rank_iarrays_code[code]:\n  \"rank_iarray A = length (filter (\\<lambda>x. \\<not> is_zero_iarray x) (IArray.list_of (Gauss_Jordan_iarrays A)))\"", "lemma matrix_to_iarray_rank[code_unfold]:\n  shows \"rank A = rank_iarray (matrix_to_iarray A)\"", "lemma dim_null_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (null_space A) = ncols_iarray (matrix_to_iarray A) - rank_iarray (matrix_to_iarray A)\"", "lemma dim_col_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (col_space A) = rank_iarray (matrix_to_iarray A)\"", "lemma dim_row_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (row_space A) = rank_iarray (matrix_to_iarray A)\"", "lemma dim_left_null_space_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (left_null_space A) = nrows_iarray (matrix_to_iarray A) - rank_iarray (matrix_to_iarray A)\""], "translations": [["", "lemma vector_all_zero_from_index_eq:\nfixes A::\"'a::{zero}^'n::{mod_type}\"\nshows \"(\\<forall>m\\<ge>i. A $ m = 0) = (vector_all_zero_from_index (to_nat i, vec_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<ge>i. A $ m = (0::'a)) =\n    vector_all_zero_from_index (mod_type_class.to_nat i, vec_to_iarray A)", "proof (auto simp add: vector_all_zero_from_index_def Let_def Option.is_none_def find_None_iff)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "assume zero: \"\\<forall>m\\<ge>i. A $ m = 0\"\n    and x_length: \"x<length (IArray.list_of (vec_to_iarray A))\" and i_le_x: \"to_nat i \\<le> x\""], ["proof (state)\nthis:\n  \\<forall>m\\<ge>i. A $ m = (0::'a)\n  x < length (IArray.list_of (vec_to_iarray A))\n  mod_type_class.to_nat i \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have x_le_card: \"x < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < CARD('n)", "using x_length"], ["proof (prove)\nusing this:\n  x < length (IArray.list_of (vec_to_iarray A))\n\ngoal (1 subgoal):\n 1. x < CARD('n)", "unfolding vec_to_iarray_def"], ["proof (prove)\nusing this:\n  x < length\n       (IArray.list_of\n         (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i)\n           CARD('n)))\n\ngoal (1 subgoal):\n 1. x < CARD('n)", "by auto"], ["proof (state)\nthis:\n  x < CARD('n)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have i_le_from_nat_x: \"i \\<le> from_nat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat x", "using from_nat_mono'[OF i_le_x x_le_card]"], ["proof (prove)\nusing this:\n  mod_type_class.from_nat (mod_type_class.to_nat i)\n  \\<le> mod_type_class.from_nat x\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat x", "unfolding from_nat_to_nat_id"], ["proof (prove)\nusing this:\n  i \\<le> mod_type_class.from_nat x\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat x", "."], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat x\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "hence Axk: \"A $ (from_nat x) = 0\""], ["proof (prove)\nusing this:\n  i \\<le> mod_type_class.from_nat x\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat x = (0::'a)", "using zero"], ["proof (prove)\nusing this:\n  i \\<le> mod_type_class.from_nat x\n  \\<forall>m\\<ge>i. A $ m = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have \"vec_to_iarray A !! x = vec_to_iarray A !! to_nat (from_nat x::'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! x =\n    vec_to_iarray A !! mod_type_class.to_nat (mod_type_class.from_nat x)", "unfolding to_nat_from_nat_id[OF x_le_card]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! x = vec_to_iarray A !! x", ".."], ["proof (state)\nthis:\n  vec_to_iarray A !! x =\n  vec_to_iarray A !! mod_type_class.to_nat (mod_type_class.from_nat x)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "also"], ["proof (state)\nthis:\n  vec_to_iarray A !! x =\n  vec_to_iarray A !! mod_type_class.to_nat (mod_type_class.from_nat x)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have \"... = A $ (from_nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat (mod_type_class.from_nat x) =\n    A $ mod_type_class.from_nat x", "unfolding vec_to_iarray_nth'"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat x = A $ mod_type_class.from_nat x", ".."], ["proof (state)\nthis:\n  vec_to_iarray A !! mod_type_class.to_nat (mod_type_class.from_nat x) =\n  A $ mod_type_class.from_nat x\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "also"], ["proof (state)\nthis:\n  vec_to_iarray A !! mod_type_class.to_nat (mod_type_class.from_nat x) =\n  A $ mod_type_class.from_nat x\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat x = (0::'a)", "unfolding Axk"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = (0::'a)", ".."], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>m\\<ge>i. A $ m = (0::'a);\n        mod_type_class.to_nat i \\<le> a;\n        a < length (IArray.list_of (vec_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> IArray.list_of (vec_to_iarray A) ! a = (0::'a)\n 2. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  vec_to_iarray A !! x = (0::'a)", "show\" IArray.list_of (vec_to_iarray A) ! x = 0\""], ["proof (prove)\nusing this:\n  vec_to_iarray A !! x = (0::'a)\n\ngoal (1 subgoal):\n 1. IArray.list_of (vec_to_iarray A) ! x = (0::'a)", "unfolding IArray.sub_def"], ["proof (prove)\nusing this:\n  IArray.list_of (vec_to_iarray A) ! x = (0::'a)\n\ngoal (1 subgoal):\n 1. IArray.list_of (vec_to_iarray A) ! x = (0::'a)", "."], ["proof (state)\nthis:\n  IArray.list_of (vec_to_iarray A) ! x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "fix m::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "assume zero_assm: \"\\<forall>x\\<in>{mod_type_class.to_nat i..<length (IArray.list_of (vec_to_iarray A))}. IArray.list_of (vec_to_iarray A) ! x = 0\"\n   and i_le_m: \"i \\<le> m\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>{mod_type_class.to_nat\n                   i..<length (IArray.list_of (vec_to_iarray A))}.\n     IArray.list_of (vec_to_iarray A) ! x = (0::'a)\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have zero: \"\\<forall>x<length (IArray.list_of (vec_to_iarray A)). mod_type_class.to_nat i \\<le> x \\<longrightarrow> IArray.list_of (vec_to_iarray A) ! x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x<length (IArray.list_of (vec_to_iarray A)).\n       mod_type_class.to_nat i \\<le> x \\<longrightarrow>\n       IArray.list_of (vec_to_iarray A) ! x = (0::'a)", "using zero_assm"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{mod_type_class.to_nat\n                   i..<length (IArray.list_of (vec_to_iarray A))}.\n     IArray.list_of (vec_to_iarray A) ! x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x<length (IArray.list_of (vec_to_iarray A)).\n       mod_type_class.to_nat i \\<le> x \\<longrightarrow>\n       IArray.list_of (vec_to_iarray A) ! x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x<length (IArray.list_of (vec_to_iarray A)).\n     mod_type_class.to_nat i \\<le> x \\<longrightarrow>\n     IArray.list_of (vec_to_iarray A) ! x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have to_nat_i_le_m:\"to_nat i \\<le> to_nat m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> mod_type_class.to_nat m", "using to_nat_mono'[OF i_le_m]"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat i \\<le> mod_type_class.to_nat m\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> mod_type_class.to_nat m", "."], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> mod_type_class.to_nat m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have m_le_length: \"to_nat m < IArray.length (vec_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat m < IArray.length (vec_to_iarray A)", "unfolding vec_to_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat m\n    < IArray.length\n       (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('n))", "using to_nat_less_card"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat ?j < CARD(?'a)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat m\n    < IArray.length\n       (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('n))", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat m < IArray.length (vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have \"A $ m = vec_to_iarray A !! (to_nat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ m = vec_to_iarray A !! mod_type_class.to_nat m", "unfolding vec_to_iarray_nth'"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ m = A $ m", ".."], ["proof (state)\nthis:\n  A $ m = vec_to_iarray A !! mod_type_class.to_nat m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "also"], ["proof (state)\nthis:\n  A $ m = vec_to_iarray A !! mod_type_class.to_nat m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat m = (0::'a)", "using zero to_nat_i_le_m m_le_length"], ["proof (prove)\nusing this:\n  \\<forall>x<length (IArray.list_of (vec_to_iarray A)).\n     mod_type_class.to_nat i \\<le> x \\<longrightarrow>\n     IArray.list_of (vec_to_iarray A) ! x = (0::'a)\n  mod_type_class.to_nat i \\<le> mod_type_class.to_nat m\n  mod_type_class.to_nat m < IArray.length (vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat m = (0::'a)", "unfolding nrows_iarray_def"], ["proof (prove)\nusing this:\n  \\<forall>x<length (IArray.list_of (vec_to_iarray A)).\n     mod_type_class.to_nat i \\<le> x \\<longrightarrow>\n     IArray.list_of (vec_to_iarray A) ! x = (0::'a)\n  mod_type_class.to_nat i \\<le> mod_type_class.to_nat m\n  mod_type_class.to_nat m < IArray.length (vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat m = (0::'a)", "by (metis IArray.sub_def IArray.length_def)"], ["proof (state)\nthis:\n  vec_to_iarray A !! mod_type_class.to_nat m = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>a\\<in>{mod_type_class.to_nat\n                                 i..<length\n(IArray.list_of (vec_to_iarray A))}.\n                   IArray.list_of (vec_to_iarray A) ! a = (0::'a);\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> A $ m = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  A $ m = (0::'a)", "show \"A $ m = 0\""], ["proof (prove)\nusing this:\n  A $ m = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ m = (0::'a)", "."], ["proof (state)\nthis:\n  A $ m = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_vector_all_zero_from_index:\n  fixes A::\"'a::{zero}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"(\\<forall>m\\<ge>i. A $ m $ k = 0) = (vector_all_zero_from_index (to_nat i, vec_to_iarray (column k A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<ge>i. A $ m $ k = (0::'a)) =\n    vector_all_zero_from_index\n     (mod_type_class.to_nat i, vec_to_iarray (column k A))", "unfolding vector_all_zero_from_index_eq[symmetric] column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m\\<ge>i. A $ m $ k = (0::'a)) =\n    (\\<forall>m\\<ge>i. (\\<chi>i. A $ i $ k) $ m = (0::'a))", "by simp"], ["", "lemma vec_to_iarray_least_non_zero_position_of_vector_from_index:\nfixes A::\"'a::{zero}^'n::{mod_type}\"\nassumes not_all_zero: \"\\<not> (vector_all_zero_from_index (to_nat i,  vec_to_iarray A))\"\nshows \"least_non_zero_position_of_vector_from_index (vec_to_iarray A) (to_nat i) = to_nat (LEAST n. A $ n \\<noteq> 0 \\<and> i \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "have \"\\<exists>a. List.find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> 0) [to_nat i..<IArray.length (vec_to_iarray A)] = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n        [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n       Some a", "proof (rule ccontr, simp, unfold IArray.sub_def[symmetric] IArray.length_def[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n     [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n    None \\<Longrightarrow>\n    False", "assume \"List.find (\\<lambda>x. (vec_to_iarray A) !! x \\<noteq> 0) [to_nat i..<IArray.length (vec_to_iarray A)] = None\""], ["proof (state)\nthis:\n  find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n   [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n  None\n\ngoal (1 subgoal):\n 1. find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n     [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n    None \\<Longrightarrow>\n    False", "hence \"\\<not> (\\<exists>x. x \\<in> set [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] \\<and> vec_to_iarray A !! x \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n   [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n  None\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> set [mod_type_class.to_nat i..<\n                    IArray.length (vec_to_iarray A)] \\<and>\n       vec_to_iarray A !! x \\<noteq> (0::'a)", "unfolding find_None_iff"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [mod_type_class.to_nat i..<\n                  IArray.length (vec_to_iarray A)] \\<and>\n     vec_to_iarray A !! x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> set [mod_type_class.to_nat i..<\n                    IArray.length (vec_to_iarray A)] \\<and>\n       vec_to_iarray A !! x \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  \\<nexists>x.\n     x \\<in> set [mod_type_class.to_nat i..<\n                  IArray.length (vec_to_iarray A)] \\<and>\n     vec_to_iarray A !! x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n     [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n    None \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [mod_type_class.to_nat i..<\n                  IArray.length (vec_to_iarray A)] \\<and>\n     vec_to_iarray A !! x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using not_all_zero"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [mod_type_class.to_nat i..<\n                  IArray.length (vec_to_iarray A)] \\<and>\n     vec_to_iarray A !! x \\<noteq> (0::'a)\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat i, vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. False", "unfolding vector_all_zero_from_index_eq[symmetric]"], ["proof (prove)\nusing this:\n  \\<nexists>x.\n     x \\<in> set [mod_type_class.to_nat i..<\n                  IArray.length (vec_to_iarray A)] \\<and>\n     vec_to_iarray A !! x \\<noteq> (0::'a)\n  \\<not> (\\<forall>m\\<ge>i. A $ m = (0::'a))\n\ngoal (1 subgoal):\n 1. False", "by (simp del: IArray.length_def IArray.sub_def, unfold length_vec_to_iarray, metis to_nat_less_card to_nat_mono' vec_to_iarray_nth')"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a.\n     find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n      [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n     Some a\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n      [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n     Some a", "obtain a where a: \"List.find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> 0) [to_nat i..<IArray.length (vec_to_iarray A)] = Some a\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n      [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n     Some a\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n         [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n        Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n   [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n  Some a\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "from this"], ["proof (chain)\npicking this:\n  find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n   [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n  Some a", "obtain ia where \n    ia_less_length: \"ia<length [to_nat i..<IArray.length (vec_to_iarray A)]\" and\n    not_eq_zero: \"vec_to_iarray A !! ([to_nat i..<IArray.length (vec_to_iarray A)] ! ia) \\<noteq> 0\" and\n    a_eq: \"a = [to_nat i..<IArray.length (vec_to_iarray A)] ! ia\"\n    and least: \"(\\<forall>ja<ia. \\<not> vec_to_iarray A !! ([to_nat i..<IArray.length (vec_to_iarray A)] ! ja) \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n   [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] =\n  Some a\n\ngoal (1 subgoal):\n 1. (\\<And>ia.\n        \\<lbrakk>ia < length\n                       [mod_type_class.to_nat i..<\n                        IArray.length (vec_to_iarray A)];\n         vec_to_iarray A !!\n         ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n          ia) \\<noteq>\n         (0::'a);\n         a =\n         [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ia;\n         \\<forall>ja<ia.\n            \\<not> vec_to_iarray A !!\n                   ([mod_type_class.to_nat i..<\n                     IArray.length (vec_to_iarray A)] !\n                    ja) \\<noteq>\n                   (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding find_Some_iff"], ["proof (prove)\nusing this:\n  \\<exists>ia<length\n               [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)].\n     vec_to_iarray A !!\n     ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n      ia) \\<noteq>\n     (0::'a) \\<and>\n     a =\n     [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ia \\<and>\n     (\\<forall>j<ia.\n         \\<not> vec_to_iarray A !!\n                ([mod_type_class.to_nat i..<\n                  IArray.length (vec_to_iarray A)] !\n                 j) \\<noteq>\n                (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>ia.\n        \\<lbrakk>ia < length\n                       [mod_type_class.to_nat i..<\n                        IArray.length (vec_to_iarray A)];\n         vec_to_iarray A !!\n         ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n          ia) \\<noteq>\n         (0::'a);\n         a =\n         [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ia;\n         \\<forall>ja<ia.\n            \\<not> vec_to_iarray A !!\n                   ([mod_type_class.to_nat i..<\n                     IArray.length (vec_to_iarray A)] !\n                    ja) \\<noteq>\n                   (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ia < length [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)]\n  vec_to_iarray A !!\n  ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n   ia) \\<noteq>\n  (0::'a)\n  a = [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ia\n  \\<forall>ja<ia.\n     \\<not> vec_to_iarray A !!\n            ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n             ja) \\<noteq>\n            (0::'a)\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "have not_eq_zero': \"vec_to_iarray A !! a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !! a \\<noteq> (0::'a)", "using not_eq_zero"], ["proof (prove)\nusing this:\n  vec_to_iarray A !!\n  ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n   ia) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! a \\<noteq> (0::'a)", "unfolding a_eq"], ["proof (prove)\nusing this:\n  vec_to_iarray A !!\n  ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n   ia) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !!\n    ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n     ia) \\<noteq>\n    (0::'a)", "."], ["proof (state)\nthis:\n  vec_to_iarray A !! a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "have i_less_a: \"to_nat i \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> a", "using  ia_less_length length_upt nth_upt a_eq"], ["proof (prove)\nusing this:\n  ia < length [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)]\n  length [?i..<?j] = ?j - ?i\n  ?i + ?k < ?j \\<Longrightarrow> [?i..<?j] ! ?k = ?i + ?k\n  a = [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ia\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i \\<le> a", "by auto"], ["proof (state)\nthis:\n  mod_type_class.to_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "have a_less_card: \"a<CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < CARD('n)", "using a_eq ia_less_length"], ["proof (prove)\nusing this:\n  a = [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ia\n  ia < length [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)]\n\ngoal (1 subgoal):\n 1. a < CARD('n)", "unfolding vec_to_iarray_def"], ["proof (prove)\nusing this:\n  a =\n  [mod_type_class.to_nat i..<\n   IArray.length\n    (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('n))] !\n  ia\n  ia < length\n        [mod_type_class.to_nat i..<\n         IArray.length\n          (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i)\n            CARD('n))]\n\ngoal (1 subgoal):\n 1. a < CARD('n)", "by auto"], ["proof (state)\nthis:\n  a < CARD('n)\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "have \"(LEAST n. A $ n \\<noteq> 0 \\<and> i \\<le> n) = from_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n) =\n    mod_type_class.from_nat a", "proof (rule Least_equality, rule conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. A $ mod_type_class.from_nat a \\<noteq> (0::'a)\n 2. i \\<le> mod_type_class.from_nat a\n 3. \\<And>y.\n       A $ y \\<noteq> (0::'a) \\<and> i \\<le> y \\<Longrightarrow>\n       mod_type_class.from_nat a \\<le> y", "show \"A $ from_nat a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A $ mod_type_class.from_nat a \\<noteq> (0::'a)", "unfolding vec_to_iarray_nth'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray A !!\n    mod_type_class.to_nat (mod_type_class.from_nat a) \\<noteq>\n    (0::'a)", "using not_eq_zero'"], ["proof (prove)\nusing this:\n  vec_to_iarray A !! a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !!\n    mod_type_class.to_nat (mod_type_class.from_nat a) \\<noteq>\n    (0::'a)", "unfolding to_nat_from_nat_id[OF a_less_card]"], ["proof (prove)\nusing this:\n  vec_to_iarray A !! a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! a \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  A $ mod_type_class.from_nat a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. i \\<le> mod_type_class.from_nat a\n 2. \\<And>y.\n       A $ y \\<noteq> (0::'a) \\<and> i \\<le> y \\<Longrightarrow>\n       mod_type_class.from_nat a \\<le> y", "show \"i \\<le> from_nat a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat a", "using a_less_card from_nat_mono' from_nat_to_nat_id i_less_a"], ["proof (prove)\nusing this:\n  a < CARD('n)\n  \\<lbrakk>?i \\<le> ?j; ?j < CARD(?'a)\\<rbrakk>\n  \\<Longrightarrow> mod_type_class.from_nat ?i\n                    \\<le> mod_type_class.from_nat ?j\n  mod_type_class.from_nat (mod_type_class.to_nat ?x) = ?x\n  mod_type_class.to_nat i \\<le> a\n\ngoal (1 subgoal):\n 1. i \\<le> mod_type_class.from_nat a", "by fastforce"], ["proof (state)\nthis:\n  i \\<le> mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'a) \\<and> i \\<le> y \\<Longrightarrow>\n       mod_type_class.from_nat a \\<le> y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'a) \\<and> i \\<le> y \\<Longrightarrow>\n       mod_type_class.from_nat a \\<le> y", "assume \"A $ x  \\<noteq> 0 \\<and> i \\<le> x\""], ["proof (state)\nthis:\n  A $ x \\<noteq> (0::'a) \\<and> i \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'a) \\<and> i \\<le> y \\<Longrightarrow>\n       mod_type_class.from_nat a \\<le> y", "hence Axj: \"A $ x \\<noteq> 0\" and i_le_x: \"i \\<le> x\""], ["proof (prove)\nusing this:\n  A $ x \\<noteq> (0::'a) \\<and> i \\<le> x\n\ngoal (1 subgoal):\n 1. A $ x \\<noteq> (0::'a) &&& i \\<le> x", "by fast+"], ["proof (state)\nthis:\n  A $ x \\<noteq> (0::'a)\n  i \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       A $ y \\<noteq> (0::'a) \\<and> i \\<le> y \\<Longrightarrow>\n       mod_type_class.from_nat a \\<le> y", "show \"from_nat a \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.from_nat a \\<le> x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "assume \"\\<not> from_nat a \\<le> x\""], ["proof (state)\nthis:\n  \\<not> mod_type_class.from_nat a \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "hence x_less_from_nat_a: \"x < from_nat a\""], ["proof (prove)\nusing this:\n  \\<not> mod_type_class.from_nat a \\<le> x\n\ngoal (1 subgoal):\n 1. x < mod_type_class.from_nat a", "by simp"], ["proof (state)\nthis:\n  x < mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "define ja where \"ja = (to_nat x) - (to_nat i)\""], ["proof (state)\nthis:\n  ja = mod_type_class.to_nat x - mod_type_class.to_nat i\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "have to_nat_x_less_card: \"to_nat x < CARD ('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x < CARD('n)", "using bij_to_nat[where ?'a='n]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x < CARD('n)", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x < CARD('n)", "by fastforce"], ["proof (state)\nthis:\n  mod_type_class.to_nat x < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "hence ja_less_length: \"ja < IArray.length (vec_to_iarray A)\""], ["proof (prove)\nusing this:\n  mod_type_class.to_nat x < CARD('n)\n\ngoal (1 subgoal):\n 1. ja < IArray.length (vec_to_iarray A)", "unfolding ja_def vec_to_iarray_def"], ["proof (prove)\nusing this:\n  mod_type_class.to_nat x < CARD('n)\n\ngoal (1 subgoal):\n 1. mod_type_class.to_nat x - mod_type_class.to_nat i\n    < IArray.length\n       (IArray.of_fun (\\<lambda>i. A $ mod_type_class.from_nat i) CARD('n))", "by auto"], ["proof (state)\nthis:\n  ja < IArray.length (vec_to_iarray A)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "have \"[to_nat i..<IArray.length (vec_to_iarray A)] ! ja = to_nat i + ja\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n    mod_type_class.to_nat i + ja", "by (rule nth_upt, unfold vec_to_iarray_def,auto, metis add_diff_inverse diff_add_zero ja_def not_less_iff_gr_or_eq to_nat_less_card)"], ["proof (state)\nthis:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat i + ja\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat i + ja\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "have i_plus_ja: \"... = to_nat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i + ja = mod_type_class.to_nat x", "unfolding ja_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat i +\n    (mod_type_class.to_nat x - mod_type_class.to_nat i) =\n    mod_type_class.to_nat x", "by (simp add: i_le_x to_nat_mono')"], ["proof (state)\nthis:\n  mod_type_class.to_nat i + ja = mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat x", "have list_rw: \"[to_nat i..<IArray.length (vec_to_iarray A)] ! ja = to_nat x\""], ["proof (prove)\nusing this:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n    mod_type_class.to_nat x", "."], ["proof (state)\nthis:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat x\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "have \"ja<ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ja < ia", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ja < ia", "have \"a = to_nat i + ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = mod_type_class.to_nat i + ia", "unfolding a_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ia =\n    mod_type_class.to_nat i + ia", "by (rule nth_upt, metis ia_less_length length_upt less_diff_conv add.commute)"], ["proof (state)\nthis:\n  a = mod_type_class.to_nat i + ia\n\ngoal (1 subgoal):\n 1. ja < ia", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = mod_type_class.to_nat i + ia\n\ngoal (1 subgoal):\n 1. ja < ia", "by (metis i_plus_ja add_less_cancel_right add.commute to_nat_le x_less_from_nat_a)"], ["proof (state)\nthis:\n  ja < ia\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ja < ia\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat x\n  ja < ia", "have \"vec_to_iarray A !! (to_nat x) = 0\""], ["proof (prove)\nusing this:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat x\n  ja < ia\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat x = (0::'a)", "using least"], ["proof (prove)\nusing this:\n  [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] ! ja =\n  mod_type_class.to_nat x\n  ja < ia\n  \\<forall>ja<ia.\n     \\<not> vec_to_iarray A !!\n            ([mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)] !\n             ja) \\<noteq>\n            (0::'a)\n\ngoal (1 subgoal):\n 1. vec_to_iarray A !! mod_type_class.to_nat x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  vec_to_iarray A !! mod_type_class.to_nat x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "hence \"A $ x = 0\""], ["proof (prove)\nusing this:\n  vec_to_iarray A !! mod_type_class.to_nat x = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ x = (0::'a)", "unfolding vec_to_iarray_nth'"], ["proof (prove)\nusing this:\n  A $ x = (0::'a)\n\ngoal (1 subgoal):\n 1. A $ x = (0::'a)", "."], ["proof (state)\nthis:\n  A $ x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> mod_type_class.from_nat a \\<le> x \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  A $ x = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using Axj"], ["proof (prove)\nusing this:\n  A $ x = (0::'a)\n  A $ x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_type_class.from_nat a \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n) =\n  mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "hence \"a = to_nat (LEAST n. A $ n \\<noteq> 0 \\<and> i \\<le> n)\""], ["proof (prove)\nusing this:\n  (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n) =\n  mod_type_class.from_nat a\n\ngoal (1 subgoal):\n 1. a =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "using to_nat_from_nat_id[OF a_less_card]"], ["proof (prove)\nusing this:\n  (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n) =\n  mod_type_class.from_nat a\n  mod_type_class.to_nat (mod_type_class.from_nat a) = a\n\ngoal (1 subgoal):\n 1. a =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "by simp"], ["proof (state)\nthis:\n  a =\n  mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a =\n  mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n     (mod_type_class.to_nat i) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "unfolding least_non_zero_position_of_vector_from_index_def"], ["proof (prove)\nusing this:\n  a =\n  mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (1 subgoal):\n 1. the (find (\\<lambda>x. vec_to_iarray A !! x \\<noteq> (0::'a))\n          [mod_type_class.to_nat i..<IArray.length (vec_to_iarray A)]) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "unfolding a"], ["proof (prove)\nusing this:\n  a =\n  mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal (1 subgoal):\n 1. the (Some a) =\n    mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)", "by simp"], ["proof (state)\nthis:\n  least_non_zero_position_of_vector_from_index (vec_to_iarray A)\n   (mod_type_class.to_nat i) =\n  mod_type_class.to_nat (LEAST n. A $ n \\<noteq> (0::'a) \\<and> i \\<le> n)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary vec_to_iarray_least_non_zero_position_of_vector_from_index':\nfixes A::\"'a::{zero}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes not_all_zero: \"\\<not> (vector_all_zero_from_index (to_nat i, vec_to_iarray (column j A)))\"\nshows \"least_non_zero_position_of_vector_from_index (vec_to_iarray (column j A)) (to_nat i) = to_nat (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index\n     (vec_to_iarray (column j A)) (mod_type_class.to_nat i) =\n    mod_type_class.to_nat\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)", "unfolding vec_to_iarray_least_non_zero_position_of_vector_from_index[OF not_all_zero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n. column j A $ n \\<noteq> (0::'a) \\<and> i \\<le> n) =\n    mod_type_class.to_nat\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)", "unfolding column_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n. (\\<chi>i. A $ i $ j) $ n \\<noteq> (0::'a) \\<and> i \\<le> n) =\n    mod_type_class.to_nat\n     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)", "by fastforce"], ["", "corollary vec_to_iarray_least_non_zero_position_of_vector_from_index'':\nfixes A::\"'a::{zero}^'cols::{mod_type}^'rows::{mod_type}\"\nassumes not_all_zero: \"\\<not> (vector_all_zero_from_index (to_nat j, vec_to_iarray (row i A)))\"\nshows \"least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A)) (to_nat j) = to_nat (LEAST n. A $ i $ n \\<noteq> 0 \\<and> j \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_non_zero_position_of_vector_from_index (vec_to_iarray (row i A))\n     (mod_type_class.to_nat j) =\n    mod_type_class.to_nat\n     (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> j \\<le> n)", "unfolding vec_to_iarray_least_non_zero_position_of_vector_from_index[OF not_all_zero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n. row i A $ n \\<noteq> (0::'a) \\<and> j \\<le> n) =\n    mod_type_class.to_nat\n     (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> j \\<le> n)", "unfolding row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_type_class.to_nat\n     (LEAST n.\n         vec_lambda (($) (A $ i)) $ n \\<noteq> (0::'a) \\<and> j \\<le> n) =\n    mod_type_class.to_nat\n     (LEAST n. A $ i $ n \\<noteq> (0::'a) \\<and> j \\<le> n)", "by fastforce"], ["", "lemma matrix_to_iarray_Gauss_Jordan_in_ij[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes not_all_zero: \"\\<not> (vector_all_zero_from_index (to_nat i, vec_to_iarray (column j A)))\"\n  shows \"matrix_to_iarray (Gauss_Jordan_in_ij A i j) = Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) (to_nat i) (to_nat j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan_in_ij A i j) =\n    Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A)\n     (mod_type_class.to_nat i) (mod_type_class.to_nat j)", "proof (unfold Gauss_Jordan_in_ij_def Gauss_Jordan_in_ij_iarrays_def Let_def, rule matrix_to_iarray_eq_of_fun, auto simp del: IArray.sub_def IArray.length_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    mult_row_iarray\n     (interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n         (mod_type_class.to_nat i)))\n     (mod_type_class.to_nat i)\n     ((1::'a) /\n      interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n         (mod_type_class.to_nat i)) !!\n      mod_type_class.to_nat i !!\n      mod_type_class.to_nat j) !!\n    mod_type_class.to_nat i\n 2. \\<And>ia.\n       ia \\<noteq> i \\<Longrightarrow>\n       vec_to_iarray\n        (row_add\n          (mult_row\n            (interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n            i ((1::'a) /\n               A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n               j))\n          ia i\n          (- interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             ia $\n             j) $\n         ia) =\n       row_add_iarray\n        (mult_row_iarray\n          (interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)))\n          (mod_type_class.to_nat i)\n          ((1::'a) /\n           interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat i !!\n           mod_type_class.to_nat j))\n        (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n        (- interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat ia !!\n           mod_type_class.to_nat j) !!\n       mod_type_class.to_nat ia\n 3. nrows_iarray (matrix_to_iarray A) =\n    IArray.length\n     (matrix_to_iarray\n       (\\<chi>s.\n           if s = i\n           then mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j) $\n                s\n           else row_add\n                 (mult_row\n                   (interchange_rows A i\n                     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                   i ((1::'a) /\n                      interchange_rows A i\n                       (LEAST n.\n                           A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                      i $\n                      j))\n                 s i\n                 (- interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    s $\n                    j) $\n                s))", "show \"vec_to_iarray (mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j) $ i) =\n    mult_row_iarray\n     (interchange_rows_iarray (matrix_to_iarray A) (to_nat i)\n       (least_non_zero_position_of_vector_from_index (column_iarray (to_nat j) (matrix_to_iarray A)) (to_nat i)))\n     (to_nat i) (1 / interchange_rows_iarray (matrix_to_iarray A) (to_nat i)\n           (least_non_zero_position_of_vector_from_index (column_iarray (to_nat j) (matrix_to_iarray A)) (to_nat i)) !! to_nat i !! to_nat j) !! to_nat i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    mult_row_iarray\n     (interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n         (mod_type_class.to_nat i)))\n     (mod_type_class.to_nat i)\n     ((1::'a) /\n      interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n         (mod_type_class.to_nat i)) !!\n      mod_type_class.to_nat i !!\n      mod_type_class.to_nat j) !!\n    mod_type_class.to_nat i", "unfolding vec_to_iarray_column[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    mult_row_iarray\n     (interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (vec_to_iarray (column j A)) (mod_type_class.to_nat i)))\n     (mod_type_class.to_nat i)\n     ((1::'a) /\n      interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (vec_to_iarray (column j A)) (mod_type_class.to_nat i)) !!\n      mod_type_class.to_nat i !!\n      mod_type_class.to_nat j) !!\n    mod_type_class.to_nat i", "unfolding vec_to_iarray_least_non_zero_position_of_vector_from_index'[OF not_all_zero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    mult_row_iarray\n     (interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (mod_type_class.to_nat\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)))\n     (mod_type_class.to_nat i)\n     ((1::'a) /\n      interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (mod_type_class.to_nat\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n      mod_type_class.to_nat i !!\n      mod_type_class.to_nat j) !!\n    mod_type_class.to_nat i", "unfolding matrix_to_iarray_interchange_rows[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    mult_row_iarray\n     (matrix_to_iarray\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)))\n     (mod_type_class.to_nat i)\n     ((1::'a) /\n      matrix_to_iarray\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n      mod_type_class.to_nat i !!\n      mod_type_class.to_nat j) !!\n    mod_type_class.to_nat i", "unfolding matrix_to_iarray_mult_row[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    matrix_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          matrix_to_iarray\n           (interchange_rows A i\n             (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n          mod_type_class.to_nat i !!\n          mod_type_class.to_nat j)) !!\n    mod_type_class.to_nat i", "unfolding matrix_to_iarray_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    matrix_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          i $\n          j)) !!\n    mod_type_class.to_nat i", "unfolding interchange_rows_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n      i) =\n    matrix_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          j)) !!\n    mod_type_class.to_nat i", "unfolding vec_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          j)) !!\n    mod_type_class.to_nat i =\n    matrix_to_iarray\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          j)) !!\n    mod_type_class.to_nat i", ".."], ["proof (state)\nthis:\n  vec_to_iarray\n   (mult_row\n     (interchange_rows A i\n       (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n     i ((1::'a) /\n        A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j) $\n    i) =\n  mult_row_iarray\n   (interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (least_non_zero_position_of_vector_from_index\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n       (mod_type_class.to_nat i)))\n   (mod_type_class.to_nat i)\n   ((1::'a) /\n    interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n     (least_non_zero_position_of_vector_from_index\n       (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n       (mod_type_class.to_nat i)) !!\n    mod_type_class.to_nat i !!\n    mod_type_class.to_nat j) !!\n  mod_type_class.to_nat i\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia \\<noteq> i \\<Longrightarrow>\n       vec_to_iarray\n        (row_add\n          (mult_row\n            (interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n            i ((1::'a) /\n               A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n               j))\n          ia i\n          (- interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             ia $\n             j) $\n         ia) =\n       row_add_iarray\n        (mult_row_iarray\n          (interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)))\n          (mod_type_class.to_nat i)\n          ((1::'a) /\n           interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat i !!\n           mod_type_class.to_nat j))\n        (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n        (- interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat ia !!\n           mod_type_class.to_nat j) !!\n       mod_type_class.to_nat ia\n 2. nrows_iarray (matrix_to_iarray A) =\n    IArray.length\n     (matrix_to_iarray\n       (\\<chi>s.\n           if s = i\n           then mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j) $\n                s\n           else row_add\n                 (mult_row\n                   (interchange_rows A i\n                     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                   i ((1::'a) /\n                      interchange_rows A i\n                       (LEAST n.\n                           A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                      i $\n                      j))\n                 s i\n                 (- interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    s $\n                    j) $\n                s))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia \\<noteq> i \\<Longrightarrow>\n       vec_to_iarray\n        (row_add\n          (mult_row\n            (interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n            i ((1::'a) /\n               A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n               j))\n          ia i\n          (- interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             ia $\n             j) $\n         ia) =\n       row_add_iarray\n        (mult_row_iarray\n          (interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)))\n          (mod_type_class.to_nat i)\n          ((1::'a) /\n           interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat i !!\n           mod_type_class.to_nat j))\n        (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n        (- interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat ia !!\n           mod_type_class.to_nat j) !!\n       mod_type_class.to_nat ia\n 2. nrows_iarray (matrix_to_iarray A) =\n    IArray.length\n     (matrix_to_iarray\n       (\\<chi>s.\n           if s = i\n           then mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j) $\n                s\n           else row_add\n                 (mult_row\n                   (interchange_rows A i\n                     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                   i ((1::'a) /\n                      interchange_rows A i\n                       (LEAST n.\n                           A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                      i $\n                      j))\n                 s i\n                 (- interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    s $\n                    j) $\n                s))", "fix ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       ia \\<noteq> i \\<Longrightarrow>\n       vec_to_iarray\n        (row_add\n          (mult_row\n            (interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n            i ((1::'a) /\n               A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n               j))\n          ia i\n          (- interchange_rows A i\n              (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n             ia $\n             j) $\n         ia) =\n       row_add_iarray\n        (mult_row_iarray\n          (interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)))\n          (mod_type_class.to_nat i)\n          ((1::'a) /\n           interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat i !!\n           mod_type_class.to_nat j))\n        (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n        (- interchange_rows_iarray (matrix_to_iarray A)\n            (mod_type_class.to_nat i)\n            (least_non_zero_position_of_vector_from_index\n              (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n              (mod_type_class.to_nat i)) !!\n           mod_type_class.to_nat ia !!\n           mod_type_class.to_nat j) !!\n       mod_type_class.to_nat ia\n 2. nrows_iarray (matrix_to_iarray A) =\n    IArray.length\n     (matrix_to_iarray\n       (\\<chi>s.\n           if s = i\n           then mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j) $\n                s\n           else row_add\n                 (mult_row\n                   (interchange_rows A i\n                     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                   i ((1::'a) /\n                      interchange_rows A i\n                       (LEAST n.\n                           A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                      i $\n                      j))\n                 s i\n                 (- interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    s $\n                    j) $\n                s))", "show \"vec_to_iarray\n          (row_add (mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / A $ (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ j)) ia i\n            (- interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ ia $ j) $ ia) =\n         row_add_iarray\n          (mult_row_iarray\n            (interchange_rows_iarray (matrix_to_iarray A) (to_nat i)\n              (least_non_zero_position_of_vector_from_index (column_iarray (to_nat j) (matrix_to_iarray A)) (to_nat i)))\n            (to_nat i)\n            (1 / interchange_rows_iarray (matrix_to_iarray A) (to_nat i)\n                  (least_non_zero_position_of_vector_from_index (column_iarray (to_nat j) (matrix_to_iarray A)) (to_nat i)) !!\n                 to_nat i !! to_nat j))\n          (to_nat ia) (to_nat i)\n          (- interchange_rows_iarray (matrix_to_iarray A) (to_nat i)\n              (least_non_zero_position_of_vector_from_index (column_iarray (to_nat j) (matrix_to_iarray A)) (to_nat i)) !!\n             to_nat ia !! to_nat j) !! to_nat ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    row_add_iarray\n     (mult_row_iarray\n       (interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (least_non_zero_position_of_vector_from_index\n           (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n           (mod_type_class.to_nat i)))\n       (mod_type_class.to_nat i)\n       ((1::'a) /\n        interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (least_non_zero_position_of_vector_from_index\n           (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n           (mod_type_class.to_nat i)) !!\n        mod_type_class.to_nat i !!\n        mod_type_class.to_nat j))\n     (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n     (- interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (least_non_zero_position_of_vector_from_index\n           (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n           (mod_type_class.to_nat i)) !!\n        mod_type_class.to_nat ia !!\n        mod_type_class.to_nat j) !!\n    mod_type_class.to_nat ia", "unfolding vec_to_iarray_column[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    row_add_iarray\n     (mult_row_iarray\n       (interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (least_non_zero_position_of_vector_from_index\n           (vec_to_iarray (column j A)) (mod_type_class.to_nat i)))\n       (mod_type_class.to_nat i)\n       ((1::'a) /\n        interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (least_non_zero_position_of_vector_from_index\n           (vec_to_iarray (column j A)) (mod_type_class.to_nat i)) !!\n        mod_type_class.to_nat i !!\n        mod_type_class.to_nat j))\n     (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n     (- interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (least_non_zero_position_of_vector_from_index\n           (vec_to_iarray (column j A)) (mod_type_class.to_nat i)) !!\n        mod_type_class.to_nat ia !!\n        mod_type_class.to_nat j) !!\n    mod_type_class.to_nat ia", "unfolding vec_to_iarray_least_non_zero_position_of_vector_from_index'[OF not_all_zero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    row_add_iarray\n     (mult_row_iarray\n       (interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (mod_type_class.to_nat\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)))\n       (mod_type_class.to_nat i)\n       ((1::'a) /\n        interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (mod_type_class.to_nat\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n        mod_type_class.to_nat i !!\n        mod_type_class.to_nat j))\n     (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n     (- interchange_rows_iarray (matrix_to_iarray A)\n         (mod_type_class.to_nat i)\n         (mod_type_class.to_nat\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n        mod_type_class.to_nat ia !!\n        mod_type_class.to_nat j) !!\n    mod_type_class.to_nat ia", "unfolding matrix_to_iarray_interchange_rows[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    row_add_iarray\n     (mult_row_iarray\n       (matrix_to_iarray\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)))\n       (mod_type_class.to_nat i)\n       ((1::'a) /\n        matrix_to_iarray\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n        mod_type_class.to_nat i !!\n        mod_type_class.to_nat j))\n     (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n     (- matrix_to_iarray\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n        mod_type_class.to_nat ia !!\n        mod_type_class.to_nat j) !!\n    mod_type_class.to_nat ia", "unfolding matrix_to_iarray_mult_row[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    row_add_iarray\n     (matrix_to_iarray\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            matrix_to_iarray\n             (interchange_rows A i\n               (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n            mod_type_class.to_nat i !!\n            mod_type_class.to_nat j)))\n     (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n     (- matrix_to_iarray\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n)) !!\n        mod_type_class.to_nat ia !!\n        mod_type_class.to_nat j) !!\n    mod_type_class.to_nat ia", "unfolding matrix_to_iarray_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    row_add_iarray\n     (matrix_to_iarray\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            interchange_rows A i\n             (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n            i $\n            j)))\n     (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n     (- interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n        ia $\n        j) !!\n    mod_type_class.to_nat ia", "unfolding interchange_rows_i"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    row_add_iarray\n     (matrix_to_iarray\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n            j)))\n     (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n     (- interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n        ia $\n        j) !!\n    mod_type_class.to_nat ia", "unfolding matrix_to_iarray_row_add[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j) $\n      ia) =\n    matrix_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j)) !!\n    mod_type_class.to_nat ia", "unfolding vec_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j)) !!\n    mod_type_class.to_nat ia =\n    matrix_to_iarray\n     (row_add\n       (mult_row\n         (interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n         i ((1::'a) /\n            A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n       ia i\n       (- interchange_rows A i\n           (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n          ia $\n          j)) !!\n    mod_type_class.to_nat ia", ".."], ["proof (state)\nthis:\n  vec_to_iarray\n   (row_add\n     (mult_row\n       (interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n       i ((1::'a) /\n          A $ (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $ j))\n     ia i\n     (- interchange_rows A i\n         (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n        ia $\n        j) $\n    ia) =\n  row_add_iarray\n   (mult_row_iarray\n     (interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n         (mod_type_class.to_nat i)))\n     (mod_type_class.to_nat i)\n     ((1::'a) /\n      interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n         (mod_type_class.to_nat i)) !!\n      mod_type_class.to_nat i !!\n      mod_type_class.to_nat j))\n   (mod_type_class.to_nat ia) (mod_type_class.to_nat i)\n   (- interchange_rows_iarray (matrix_to_iarray A) (mod_type_class.to_nat i)\n       (least_non_zero_position_of_vector_from_index\n         (column_iarray (mod_type_class.to_nat j) (matrix_to_iarray A))\n         (mod_type_class.to_nat i)) !!\n      mod_type_class.to_nat ia !!\n      mod_type_class.to_nat j) !!\n  mod_type_class.to_nat ia\n\ngoal (1 subgoal):\n 1. nrows_iarray (matrix_to_iarray A) =\n    IArray.length\n     (matrix_to_iarray\n       (\\<chi>s.\n           if s = i\n           then mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j) $\n                s\n           else row_add\n                 (mult_row\n                   (interchange_rows A i\n                     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                   i ((1::'a) /\n                      interchange_rows A i\n                       (LEAST n.\n                           A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                      i $\n                      j))\n                 s i\n                 (- interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    s $\n                    j) $\n                s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nrows_iarray (matrix_to_iarray A) =\n    IArray.length\n     (matrix_to_iarray\n       (\\<chi>s.\n           if s = i\n           then mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j) $\n                s\n           else row_add\n                 (mult_row\n                   (interchange_rows A i\n                     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                   i ((1::'a) /\n                      interchange_rows A i\n                       (LEAST n.\n                           A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                      i $\n                      j))\n                 s i\n                 (- interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    s $\n                    j) $\n                s))", "show \"nrows_iarray (matrix_to_iarray A) =\n    IArray.length (matrix_to_iarray\n    (\\<chi> s. if s = i then mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ i $ j) $ s\n    else row_add (mult_row (interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n)) i (1 / interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ i $ j)) s i\n    (- interchange_rows A i (LEAST n. A $ n $ j \\<noteq> 0 \\<and> i \\<le> n) $ s $ j) $ s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrows_iarray (matrix_to_iarray A) =\n    IArray.length\n     (matrix_to_iarray\n       (\\<chi>s.\n           if s = i\n           then mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j) $\n                s\n           else row_add\n                 (mult_row\n                   (interchange_rows A i\n                     (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                   i ((1::'a) /\n                      interchange_rows A i\n                       (LEAST n.\n                           A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                      i $\n                      j))\n                 s i\n                 (- interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    s $\n                    j) $\n                s))", "unfolding length_eq_card_rows nrows_eq_card_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) = CARD('rows)", ".."], ["proof (state)\nthis:\n  nrows_iarray (matrix_to_iarray A) =\n  IArray.length\n   (matrix_to_iarray\n     (\\<chi>s.\n         if s = i\n         then mult_row\n               (interchange_rows A i\n                 (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n               i ((1::'a) /\n                  interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                  i $\n                  j) $\n              s\n         else row_add\n               (mult_row\n                 (interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n))\n                 i ((1::'a) /\n                    interchange_rows A i\n                     (LEAST n.\n                         A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                    i $\n                    j))\n               s i\n               (- interchange_rows A i\n                   (LEAST n. A $ n $ j \\<noteq> (0::'a) \\<and> i \\<le> n) $\n                  s $\n                  j) $\n              s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_Gauss_Jordan_column_k_1:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"(fst (Gauss_Jordan_column_k (i, A) k)) = fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "proof (cases \"i<nrows A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "case True"], ["proof (state)\nthis:\n  i < nrows A\n\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "unfolding Gauss_Jordan_column_k_def Let_def Gauss_Jordan_column_k_iarrays_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (i, A)\n         else (i + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                (mod_type_class.from_nat k))) =\n    fst (if vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "unfolding vec_to_iarray_column[of \"from_nat k\" A, unfolded to_nat_from_nat_id[OF k[unfolded ncols_def]], symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (i, A)\n         else (i + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                (mod_type_class.from_nat k))) =\n    fst (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "using matrix_vector_all_zero_from_index[symmetric, of \"from_nat i::'rows\" \"from_nat k::'columns\"]"], ["proof (prove)\nusing this:\n  vector_all_zero_from_index\n   (mod_type_class.to_nat (mod_type_class.from_nat i),\n    vec_to_iarray (column (mod_type_class.from_nat k) ?A)) =\n  (\\<forall>m\\<ge>mod_type_class.from_nat i.\n      ?A $ m $ mod_type_class.from_nat k = (0::?'a))\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (i, A)\n         else (i + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                (mod_type_class.from_nat k))) =\n    fst (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "unfolding to_nat_from_nat_id[OF True[unfolded nrows_def]] to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  vector_all_zero_from_index\n   (i, vec_to_iarray (column (mod_type_class.from_nat k) ?A)) =\n  (\\<forall>m\\<ge>mod_type_class.from_nat i.\n      ?A $ m $ mod_type_class.from_nat k = (0::?'a))\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (i, A)\n         else (i + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                (mod_type_class.from_nat k))) =\n    fst (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "using matrix_to_iarray_Gauss_Jordan_in_ij"], ["proof (prove)\nusing this:\n  vector_all_zero_from_index\n   (i, vec_to_iarray (column (mod_type_class.from_nat k) ?A)) =\n  (\\<forall>m\\<ge>mod_type_class.from_nat i.\n      ?A $ m $ mod_type_class.from_nat k = (0::?'a))\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat ?i,\n           vec_to_iarray (column ?j ?A)) \\<Longrightarrow>\n  matrix_to_iarray (Gauss_Jordan_in_ij ?A ?i ?j) =\n  Gauss_Jordan_in_ij_iarrays (matrix_to_iarray ?A)\n   (mod_type_class.to_nat ?i) (mod_type_class.to_nat ?j)\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows A\n         then (i, A)\n         else (i + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                (mod_type_class.from_nat k))) =\n    fst (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "unfolding matrix_to_iarray_nrows snd_conv"], ["proof (prove)\nusing this:\n  vector_all_zero_from_index\n   (i, vec_to_iarray (column (mod_type_class.from_nat k) ?A)) =\n  (\\<forall>m\\<ge>mod_type_class.from_nat i.\n      ?A $ m $ mod_type_class.from_nat k = (0::?'a))\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat ?i,\n           vec_to_iarray (column ?j ?A)) \\<Longrightarrow>\n  matrix_to_iarray (Gauss_Jordan_in_ij ?A ?i ?j) =\n  Gauss_Jordan_in_ij_iarrays (matrix_to_iarray ?A)\n   (mod_type_class.to_nat ?i) (mod_type_class.to_nat ?j)\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, A)\n         else (i + 1,\n               Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                (mod_type_class.from_nat k))) =\n    fst (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "by auto"], ["proof (state)\nthis:\n  fst (Gauss_Jordan_column_k (i, A) k) =\n  fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n\ngoal (1 subgoal):\n 1. \\<not> i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "case False"], ["proof (state)\nthis:\n  \\<not> i < nrows A\n\ngoal (1 subgoal):\n 1. \\<not> i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "have \"vector_all_zero_from_index (nrows A, column_iarray k (matrix_to_iarray A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_all_zero_from_index\n     (nrows A, column_iarray k (matrix_to_iarray A))", "unfolding vector_all_zero_from_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let i = fst (nrows A, column_iarray k (matrix_to_iarray A));\n        A = snd (nrows A, column_iarray k (matrix_to_iarray A))\n    in IArray.all (\\<lambda>x. A !! x = (0::'a))\n        (IArray [i..<IArray.length A])", "unfolding Let_def  snd_conv fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.all\n     (\\<lambda>x. column_iarray k (matrix_to_iarray A) !! x = (0::'a))\n     (IArray\n       [nrows A..<IArray.length (column_iarray k (matrix_to_iarray A))])", "unfolding nrows_def column_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.all\n     (\\<lambda>x.\n         IArray.of_fun (\\<lambda>m. matrix_to_iarray A !! m !! k)\n          (IArray.length (matrix_to_iarray A)) !!\n         x =\n         (0::'a))\n     (IArray\n       [CARD('rows)..<\n        IArray.length\n         (IArray.of_fun (\\<lambda>m. matrix_to_iarray A !! m !! k)\n           (IArray.length (matrix_to_iarray A)))])", "unfolding length_eq_card_rows"], ["proof (prove)\ngoal (1 subgoal):\n 1. IArray.all\n     (\\<lambda>x.\n         IArray.of_fun (\\<lambda>m. matrix_to_iarray A !! m !! k)\n          CARD('rows) !!\n         x =\n         (0::'a))\n     (IArray\n       [CARD('rows)..<\n        IArray.length\n         (IArray.of_fun (\\<lambda>m. matrix_to_iarray A !! m !! k)\n           CARD('rows))])", "by (simp add: is_none_code(1))"], ["proof (state)\nthis:\n  vector_all_zero_from_index (nrows A, column_iarray k (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. \\<not> i < nrows A \\<Longrightarrow>\n    fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  vector_all_zero_from_index (nrows A, column_iarray k (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "using i False"], ["proof (prove)\nusing this:\n  vector_all_zero_from_index (nrows A, column_iarray k (matrix_to_iarray A))\n  i \\<le> nrows A\n  \\<not> i < nrows A\n\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k (i, A) k) =\n    fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "unfolding Gauss_Jordan_column_k_iarrays_def Gauss_Jordan_column_k_def Let_def"], ["proof (prove)\nusing this:\n  vector_all_zero_from_index (nrows A, column_iarray k (matrix_to_iarray A))\n  i \\<le> nrows A\n  \\<not> i < nrows A\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat (fst (i, A)).\n                snd (i, A) $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n            fst (i, A) = nrows (snd (i, A))\n         then (fst (i, A), snd (i, A))\n         else (fst (i, A) + 1,\n               Gauss_Jordan_in_ij (snd (i, A))\n                (mod_type_class.from_nat (fst (i, A)))\n                (mod_type_class.from_nat k))) =\n    fst (if vector_all_zero_from_index\n             (fst (i, matrix_to_iarray A),\n              column_iarray k (snd (i, matrix_to_iarray A))) \\<or>\n            fst (i, matrix_to_iarray A) =\n            nrows_iarray (snd (i, matrix_to_iarray A))\n         then (fst (i, matrix_to_iarray A), snd (i, matrix_to_iarray A))\n         else (Suc (fst (i, matrix_to_iarray A)),\n               Gauss_Jordan_in_ij_iarrays (snd (i, matrix_to_iarray A))\n                (fst (i, matrix_to_iarray A)) k))", "by auto"], ["proof (state)\nthis:\n  fst (Gauss_Jordan_column_k (i, A) k) =\n  fst (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_Gauss_Jordan_column_k_2:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  and i: \"i\\<le>nrows A\"\n  shows \"matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) = snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "proof (cases \"i<nrows A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "case True"], ["proof (state)\nthis:\n  i < nrows A\n\ngoal (2 subgoals):\n 1. i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n 2. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "unfolding Gauss_Jordan_column_k_def Let_def Gauss_Jordan_column_k_iarrays_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (i, A)\n           else (i + 1,\n                 Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                  (mod_type_class.from_nat k)))) =\n    snd (if vector_all_zero_from_index\n             (i, column_iarray k (matrix_to_iarray A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "unfolding vec_to_iarray_column[of \"from_nat k\" A, unfolded to_nat_from_nat_id[OF k[unfolded ncols_def]], symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat i.\n                  A $ m $ mod_type_class.from_nat k = (0::'a)) \\<or>\n              i = nrows A\n           then (i, A)\n           else (i + 1,\n                 Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                  (mod_type_class.from_nat k)))) =\n    snd (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "unfolding matrix_vector_all_zero_from_index[symmetric, of \"from_nat i::'rows\" \"from_nat k::'columns\", symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (if vector_all_zero_from_index\n               (mod_type_class.to_nat (mod_type_class.from_nat i),\n                vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n              i = nrows A\n           then (i, A)\n           else (i + 1,\n                 Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                  (mod_type_class.from_nat k)))) =\n    snd (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "using matrix_to_iarray_Gauss_Jordan_in_ij[of \"from_nat i::'rows\" \"from_nat k::'columns\"]"], ["proof (prove)\nusing this:\n  \\<not> vector_all_zero_from_index\n          (mod_type_class.to_nat (mod_type_class.from_nat i),\n           vec_to_iarray\n            (column (mod_type_class.from_nat k) ?A)) \\<Longrightarrow>\n  matrix_to_iarray\n   (Gauss_Jordan_in_ij ?A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k)) =\n  Gauss_Jordan_in_ij_iarrays (matrix_to_iarray ?A)\n   (mod_type_class.to_nat (mod_type_class.from_nat i))\n   (mod_type_class.to_nat (mod_type_class.from_nat k))\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (if vector_all_zero_from_index\n               (mod_type_class.to_nat (mod_type_class.from_nat i),\n                vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n              i = nrows A\n           then (i, A)\n           else (i + 1,\n                 Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                  (mod_type_class.from_nat k)))) =\n    snd (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "unfolding to_nat_from_nat_id[OF True[unfolded nrows_def]] to_nat_from_nat_id[OF k[unfolded ncols_def]]"], ["proof (prove)\nusing this:\n  \\<not> vector_all_zero_from_index\n          (i, vec_to_iarray\n               (column (mod_type_class.from_nat k) ?A)) \\<Longrightarrow>\n  matrix_to_iarray\n   (Gauss_Jordan_in_ij ?A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k)) =\n  Gauss_Jordan_in_ij_iarrays (matrix_to_iarray ?A) i k\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (if vector_all_zero_from_index\n               (i, vec_to_iarray\n                    (column (mod_type_class.from_nat k) A)) \\<or>\n              i = nrows A\n           then (i, A)\n           else (i + 1,\n                 Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                  (mod_type_class.from_nat k)))) =\n    snd (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "unfolding matrix_to_iarray_nrows"], ["proof (prove)\nusing this:\n  \\<not> vector_all_zero_from_index\n          (i, vec_to_iarray\n               (column (mod_type_class.from_nat k) ?A)) \\<Longrightarrow>\n  matrix_to_iarray\n   (Gauss_Jordan_in_ij ?A (mod_type_class.from_nat i)\n     (mod_type_class.from_nat k)) =\n  Gauss_Jordan_in_ij_iarrays (matrix_to_iarray ?A) i k\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (if vector_all_zero_from_index\n               (i, vec_to_iarray\n                    (column (mod_type_class.from_nat k) A)) \\<or>\n              i = nrows_iarray (matrix_to_iarray A)\n           then (i, A)\n           else (i + 1,\n                 Gauss_Jordan_in_ij A (mod_type_class.from_nat i)\n                  (mod_type_class.from_nat k)))) =\n    snd (if vector_all_zero_from_index\n             (i, vec_to_iarray (column (mod_type_class.from_nat k) A)) \\<or>\n            i = nrows_iarray (matrix_to_iarray A)\n         then (i, matrix_to_iarray A)\n         else (Suc i, Gauss_Jordan_in_ij_iarrays (matrix_to_iarray A) i k))", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n  snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n\ngoal (1 subgoal):\n 1. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "case False"], ["proof (state)\nthis:\n  \\<not> i < nrows A\n\ngoal (1 subgoal):\n 1. \\<not> i < nrows A \\<Longrightarrow>\n    matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "using assms False"], ["proof (prove)\nusing this:\n  k < ncols A\n  i \\<le> nrows A\n  \\<not> i < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n    snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)", "unfolding Gauss_Jordan_column_k_def Let_def Gauss_Jordan_column_k_iarrays_def"], ["proof (prove)\nusing this:\n  k < ncols A\n  i \\<le> nrows A\n  \\<not> i < nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (if (\\<forall>m\\<ge>mod_type_class.from_nat (fst (i, A)).\n                  snd (i, A) $ m $ mod_type_class.from_nat k =\n                  (0::'a)) \\<or>\n              fst (i, A) = nrows (snd (i, A))\n           then (fst (i, A), snd (i, A))\n           else (fst (i, A) + 1,\n                 Gauss_Jordan_in_ij (snd (i, A))\n                  (mod_type_class.from_nat (fst (i, A)))\n                  (mod_type_class.from_nat k)))) =\n    snd (if vector_all_zero_from_index\n             (fst (i, matrix_to_iarray A),\n              column_iarray k (snd (i, matrix_to_iarray A))) \\<or>\n            fst (i, matrix_to_iarray A) =\n            nrows_iarray (snd (i, matrix_to_iarray A))\n         then (fst (i, matrix_to_iarray A), snd (i, matrix_to_iarray A))\n         else (Suc (fst (i, matrix_to_iarray A)),\n               Gauss_Jordan_in_ij_iarrays (snd (i, matrix_to_iarray A))\n                (fst (i, matrix_to_iarray A)) k))", "by (auto simp add: matrix_to_iarray_nrows)"], ["proof (state)\nthis:\n  matrix_to_iarray (snd (Gauss_Jordan_column_k (i, A) k)) =\n  snd (Gauss_Jordan_column_k_iarrays (i, matrix_to_iarray A) k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Due to the assumptions presented in @{thm \"matrix_to_iarray_Gauss_Jordan_column_k_2\"}, the following lemma must have three shows.\nThe proof style is similar to @{thm \"rref_and_index_Gauss_Jordan_upt_k\"}.\\<close>"], ["", "lemma foldl_Gauss_Jordan_column_k_eq:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  assumes k: \"k<ncols A\"\n  shows matrix_to_iarray_Gauss_Jordan_upt_k[code_unfold]: \"matrix_to_iarray (Gauss_Jordan_upt_k A k) = Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\"\n  and fst_foldl_Gauss_Jordan_column_k_eq: \"fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k]) = fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\"\n  and fst_foldl_Gauss_Jordan_column_k_less: \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k &&&\n    fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc k]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) &&&\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A", "using assms"], ["proof (prove)\nusing this:\n  k < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k &&&\n    fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc k]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) &&&\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A", "proof (induct k)"], ["proof (state)\ngoal (6 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    matrix_to_iarray (Gauss_Jordan_upt_k A 0) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) 0\n 2. 0 < ncols A \\<Longrightarrow>\n    fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc 0]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])\n 3. 0 < ncols A \\<Longrightarrow>\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]) \\<le> nrows A\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 5. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 6. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"matrix_to_iarray (Gauss_Jordan_upt_k A 0) = Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan_upt_k A 0) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) 0", "unfolding Gauss_Jordan_upt_k_def Gauss_Jordan_upt_k_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])) =\n    snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc 0])", "by (auto, metis k le0 less_nat_zero_code matrix_to_iarray_Gauss_Jordan_column_k_2 neq0_conv)"], ["proof (state)\nthis:\n  matrix_to_iarray (Gauss_Jordan_upt_k A 0) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) 0\n\ngoal (5 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc 0]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])\n 2. 0 < ncols A \\<Longrightarrow>\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]) \\<le> nrows A\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 5. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc 0]) = fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc 0]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])", "unfolding Gauss_Jordan_upt_k_def Gauss_Jordan_upt_k_iarrays_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc 0]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])", "by (auto, metis gr_implies_not0 k le0 matrix_to_iarray_Gauss_Jordan_column_k_1 neq0_conv)"], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc 0]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0])\n\ngoal (4 subgoals):\n 1. 0 < ncols A \\<Longrightarrow>\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]) \\<le> nrows A\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 4. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]) \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]) \\<le> nrows A", "unfolding Gauss_Jordan_upt_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]) \\<le> nrows A", "by (simp add: Gauss_Jordan_column_k_def Let_def size1 nrows_def)"], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc 0]) \\<le> nrows A\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "fix k"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "assume \"(k < ncols A \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A k) = Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k)\" and\n    \"(k < ncols A \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k]) = fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\"\n    and \"(k < ncols A \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A)\"\n    and Suc_k_less_card: \"Suc k < ncols A\""], ["proof (state)\nthis:\n  k < ncols A \\<Longrightarrow>\n  matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\n  k < ncols A \\<Longrightarrow>\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n  k < ncols A \\<Longrightarrow>\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n  Suc k < ncols A\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "hence hyp1: \"matrix_to_iarray (Gauss_Jordan_upt_k A k) = Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\"\n    and hyp2: \"fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k]) = fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\"\n    and hyp3: \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\""], ["proof (prove)\nusing this:\n  k < ncols A \\<Longrightarrow>\n  matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\n  k < ncols A \\<Longrightarrow>\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n  k < ncols A \\<Longrightarrow>\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k &&&\n    fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc k]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) &&&\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A", "by auto"], ["proof (state)\nthis:\n  matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "hence hyp1_unfolded: \"matrix_to_iarray (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) = snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k])\""], ["proof (prove)\nusing this:\n  matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n    snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc k])", "using hyp1"], ["proof (prove)\nusing this:\n  matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n  matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n    snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc k])", "unfolding Gauss_Jordan_upt_k_def Gauss_Jordan_upt_k_iarrays_def"], ["proof (prove)\nusing this:\n  matrix_to_iarray (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n  snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k])\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n  matrix_to_iarray (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n  snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k])\n\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n    snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc k])", "by simp"], ["proof (state)\nthis:\n  matrix_to_iarray (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n  snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc k])\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "have upt_rw: \"[0..<Suc (Suc k)] = [0..<Suc k] @ [(Suc k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]", "by auto"], ["proof (state)\nthis:\n  [0..<Suc (Suc k)] = [0..<Suc k] @ [Suc k]\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "have fold_rw: \"(foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k]) \n    = (fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k]), snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n     [0..<Suc k] =\n    (fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n           [0..<Suc k]),\n     snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n           [0..<Suc k]))", "by simp"], ["proof (state)\nthis:\n  foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc k] =\n  (fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n         [0..<Suc k]),\n   snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n         [0..<Suc k]))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "have fold_rw': \"(foldl Gauss_Jordan_column_k (0, A) [0..<(Suc k)]) \n    = (fst (foldl Gauss_Jordan_column_k (0, A) [0..<(Suc k)]), snd (foldl Gauss_Jordan_column_k (0, A) [0..<(Suc k)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n    (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "by simp"], ["proof (state)\nthis:\n  foldl Gauss_Jordan_column_k (0, A) [0..<Suc k] =\n  (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k_iarrays\n                               (0, matrix_to_iarray A) [0..<Suc (Suc k)]) =\n                         fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n 3. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A) [0..<Suc (Suc k)]) = fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n          [0..<Suc (Suc k)]) =\n    fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)])", "unfolding upt_rw foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k_iarrays\n          (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n            [0..<Suc k])\n          [Suc k]) =\n    fst (foldl Gauss_Jordan_column_k\n          (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) [Suc k])", "unfolding List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_iarrays\n          (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n            [0..<Suc k])\n          (Suc k)) =\n    fst (Gauss_Jordan_column_k\n          (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k))", "apply (subst fold_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_iarrays\n          (fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]))\n          (Suc k)) =\n    fst (Gauss_Jordan_column_k\n          (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k))", "apply (subst fold_rw')"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_iarrays\n          (fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]))\n          (Suc k)) =\n    fst (Gauss_Jordan_column_k\n          (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n          (Suc k))", "unfolding hyp2"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_iarrays\n          (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]))\n          (Suc k)) =\n    fst (Gauss_Jordan_column_k\n          (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n          (Suc k))", "unfolding hyp1_unfolded[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k_iarrays\n          (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n           matrix_to_iarray\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n          (Suc k)) =\n    fst (Gauss_Jordan_column_k\n          (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n          (Suc k))", "proof (rule matrix_to_iarray_Gauss_Jordan_column_k_1[symmetric, of \"Suc k\" \"(snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc k < ncols (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n 2. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n    \\<le> nrows (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "show \"Suc k < ncols (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < ncols (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "using Suc_k_less_card"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k < ncols (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('columns)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('columns)", "."], ["proof (state)\nthis:\n  Suc k < ncols (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n    \\<le> nrows (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "show \" fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n    \\<le> nrows (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "using hyp3"], ["proof (prove)\nusing this:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n    \\<le> nrows (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)", "."], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])\n  \\<le> nrows (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n        [0..<Suc (Suc k)]) =\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)])\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n                         Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n                          (Suc k)\n 2. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) = Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) (Suc k)", "unfolding Gauss_Jordan_upt_k_def Gauss_Jordan_upt_k_iarrays_def  upt_rw foldl_append  List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (Gauss_Jordan_column_k\n            (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k))) =\n    snd (Gauss_Jordan_column_k_iarrays\n          (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n            [0..<Suc k])\n          (Suc k))", "apply (subst fold_rw)"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (Gauss_Jordan_column_k\n            (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k))) =\n    snd (Gauss_Jordan_column_k_iarrays\n          (fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]))\n          (Suc k))", "apply (subst fold_rw')"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (Gauss_Jordan_column_k\n            (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n             snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n            (Suc k))) =\n    snd (Gauss_Jordan_column_k_iarrays\n          (fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n                 [0..<Suc k]))\n          (Suc k))", "unfolding hyp2 hyp1_unfolded[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray\n     (snd (Gauss_Jordan_column_k\n            (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n             snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n            (Suc k))) =\n    snd (Gauss_Jordan_column_k_iarrays\n          (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n           matrix_to_iarray\n            (snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n          (Suc k))", "proof (rule matrix_to_iarray_Gauss_Jordan_column_k_2, unfold ncols_def nrows_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc k < CARD('columns)\n 2. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)", "show \"Suc k < CARD('columns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc k < CARD('columns)", "using Suc_k_less_card"], ["proof (prove)\nusing this:\n  Suc k < ncols A\n\ngoal (1 subgoal):\n 1. Suc k < CARD('columns)", "unfolding ncols_def"], ["proof (prove)\nusing this:\n  Suc k < CARD('columns)\n\ngoal (1 subgoal):\n 1. Suc k < CARD('columns)", "."], ["proof (state)\nthis:\n  Suc k < CARD('columns)\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)", "show \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)", "using hyp3"], ["proof (prove)\nusing this:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)\n\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)", "."], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_to_iarray (Gauss_Jordan_upt_k A (Suc k)) =\n  Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < ncols A \\<Longrightarrow>\n                matrix_to_iarray (Gauss_Jordan_upt_k A k) =\n                Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) k;\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k_iarrays (0, matrix_to_iarray A)\n              [0..<Suc k]) =\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]);\n        k < ncols A \\<Longrightarrow>\n        fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A;\n        Suc k < ncols A\\<rbrakk>\n       \\<Longrightarrow> fst (foldl Gauss_Jordan_column_k (0, A)\n                               [0..<Suc (Suc k)])\n                         \\<le> nrows A", "show \"fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) \\<le> nrows A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) \\<le> nrows A", "using [[unfold_abs_def = false]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) \\<le> nrows A", "unfolding upt_rw foldl_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl Gauss_Jordan_column_k\n          (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) [Suc k])\n    \\<le> nrows A", "unfolding List.foldl.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k\n          (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) (Suc k))\n    \\<le> nrows A", "apply (subst fold_rw')"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Gauss_Jordan_column_k\n          (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n           snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]))\n          (Suc k))\n    \\<le> nrows A", "unfolding Gauss_Jordan_column_k_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (fst (fst (foldl Gauss_Jordan_column_k (0, A)\n   [0..<Suc k]),\n                                   snd (foldl Gauss_Jordan_column_k (0, A)\n   [0..<Suc k]))).\n                snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) $\n                m $\n                mod_type_class.from_nat (Suc k) =\n                (0::'a)) \\<or>\n            fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                 snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n            nrows\n             (snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n         then (fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])),\n               snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n         else (fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) +\n               1,\n               Gauss_Jordan_in_ij\n                (snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                      snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n                (mod_type_class.from_nat\n                  (fst (fst (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]),\n                        snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))))\n                (mod_type_class.from_nat (Suc k))))\n    \\<le> nrows A", "using hyp3 le_antisym not_less_eq_eq"], ["proof (prove)\nusing this:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> nrows A\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (fst (fst (foldl Gauss_Jordan_column_k (0, A)\n   [0..<Suc k]),\n                                   snd (foldl Gauss_Jordan_column_k (0, A)\n   [0..<Suc k]))).\n                snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) $\n                m $\n                mod_type_class.from_nat (Suc k) =\n                (0::'a)) \\<or>\n            fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                 snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n            nrows\n             (snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                   snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n         then (fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])),\n               snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n         else (fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) +\n               1,\n               Gauss_Jordan_in_ij\n                (snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                      snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n                (mod_type_class.from_nat\n                  (fst (fst (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]),\n                        snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))))\n                (mod_type_class.from_nat (Suc k))))\n    \\<le> nrows A", "unfolding nrows_def"], ["proof (prove)\nusing this:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]) \\<le> CARD('rows)\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. fst (if (\\<forall>m\\<ge>mod_type_class.from_nat\n                             (fst (fst (foldl Gauss_Jordan_column_k (0, A)\n   [0..<Suc k]),\n                                   snd (foldl Gauss_Jordan_column_k (0, A)\n   [0..<Suc k]))).\n                snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                     snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) $\n                m $\n                mod_type_class.from_nat (Suc k) =\n                (0::'a)) \\<or>\n            fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                 snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) =\n            CARD('rows)\n         then (fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])),\n               snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n         else (fst (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                    snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])) +\n               1,\n               Gauss_Jordan_in_ij\n                (snd (fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k]),\n                      snd (foldl Gauss_Jordan_column_k (0, A) [0..<Suc k])))\n                (mod_type_class.from_nat\n                  (fst (fst (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]),\n                        snd (foldl Gauss_Jordan_column_k (0, A)\n                              [0..<Suc k]))))\n                (mod_type_class.from_nat (Suc k))))\n    \\<le> CARD('rows)", "by fastforce"], ["proof (state)\nthis:\n  fst (foldl Gauss_Jordan_column_k (0, A) [0..<Suc (Suc k)]) \\<le> nrows A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_Gauss_Jordan[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"matrix_to_iarray (Gauss_Jordan A) = Gauss_Jordan_iarrays (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan A) =\n    Gauss_Jordan_iarrays (matrix_to_iarray A)", "unfolding Gauss_Jordan_iarrays_def ncols_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan A) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A)\n     (IArray.length (matrix_to_iarray A !! 0) - 1)", "unfolding length_eq_card_columns"], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_to_iarray (Gauss_Jordan A) =\n    Gauss_Jordan_upt_k_iarrays (matrix_to_iarray A) (CARD('columns) - 1)", "by (auto simp add: Gauss_Jordan_def matrix_to_iarray_Gauss_Jordan_upt_k ncols_def)"], ["", "subsection\\<open>Implementation over IArrays of the computation of the @{term \"rank\"} of a matrix\\<close>"], ["", "definition rank_iarray :: \"'a::{field} iarray iarray => nat\"\n  where \"rank_iarray A = (let A' = (Gauss_Jordan_iarrays A); nrows = (IArray.length A') in card {i. i<nrows \\<and> \\<not> is_zero_iarray (A' !! i)})\""], ["", "subsubsection\\<open>Proving the equivalence between @{term \"rank\"} and @{term \"rank_iarray\"}.\\<close>"], ["", "text\\<open>First of all, some code equations are removed to allow the execution of Gauss-Jordan algorithm using iarrays\\<close>"], ["", "lemmas card'_code(2)[code del]"], ["", "lemmas rank_Gauss_Jordan_code[code del]"], ["", "lemma rank_eq_card_iarrays:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"rank A = card {vec_to_iarray (row i (Gauss_Jordan A)) |i. \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    card\n     {vec_to_iarray (row i (Gauss_Jordan A)) |i.\n      \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))}", "proof (unfold rank_Gauss_Jordan_eq Let_def, rule bij_betw_same_card[of \"vec_to_iarray\"], auto simp add: bij_betw_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on vec_to_iarray\n     {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n 2. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          vec_to_iarray (row i (Gauss_Jordan A)) =\n          vec_to_iarray (row ia (Gauss_Jordan A)) \\<and>\n          \\<not> is_zero_iarray (vec_to_iarray (row ia (Gauss_Jordan A)))\n 3. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "show \"inj_on vec_to_iarray {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on vec_to_iarray\n     {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "using inj_vec_to_iarray"], ["proof (prove)\nusing this:\n  inj vec_to_iarray\n\ngoal (1 subgoal):\n 1. inj_on vec_to_iarray\n     {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        vec_to_iarray x = vec_to_iarray y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{row i (Gauss_Jordan A) |i.\n                    row i (Gauss_Jordan A) \\<noteq> 0}.\n       \\<forall>y\\<in>{row i (Gauss_Jordan A) |i.\n                       row i (Gauss_Jordan A) \\<noteq> 0}.\n          vec_to_iarray x = vec_to_iarray y \\<longrightarrow> x = y", "by blast"], ["proof (state)\nthis:\n  inj_on vec_to_iarray\n   {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          vec_to_iarray (row i (Gauss_Jordan A)) =\n          vec_to_iarray (row ia (Gauss_Jordan A)) \\<and>\n          \\<not> is_zero_iarray (vec_to_iarray (row ia (Gauss_Jordan A)))\n 2. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          vec_to_iarray (row i (Gauss_Jordan A)) =\n          vec_to_iarray (row ia (Gauss_Jordan A)) \\<and>\n          \\<not> is_zero_iarray (vec_to_iarray (row ia (Gauss_Jordan A)))\n 2. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "assume r: \"row i (Gauss_Jordan A) \\<noteq> 0\""], ["proof (state)\nthis:\n  row i (Gauss_Jordan A) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       row i (Gauss_Jordan A) \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>ia.\n          vec_to_iarray (row i (Gauss_Jordan A)) =\n          vec_to_iarray (row ia (Gauss_Jordan A)) \\<and>\n          \\<not> is_zero_iarray (vec_to_iarray (row ia (Gauss_Jordan A)))\n 2. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "show \"\\<exists>ia. vec_to_iarray (row i (Gauss_Jordan A)) = vec_to_iarray (row ia (Gauss_Jordan A)) \\<and> \\<not> is_zero_iarray (vec_to_iarray (row ia (Gauss_Jordan A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       vec_to_iarray (row i (Gauss_Jordan A)) =\n       vec_to_iarray (row ia (Gauss_Jordan A)) \\<and>\n       \\<not> is_zero_iarray (vec_to_iarray (row ia (Gauss_Jordan A)))", "proof (rule exI[of _ i], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))", "show \"\\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))", "using r"], ["proof (prove)\nusing this:\n  row i (Gauss_Jordan A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))", "unfolding is_zero_iarray_eq_iff"], ["proof (prove)\nusing this:\n  \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))", "."], ["proof (state)\nthis:\n  \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ia.\n     vec_to_iarray (row i (Gauss_Jordan A)) =\n     vec_to_iarray (row ia (Gauss_Jordan A)) \\<and>\n     \\<not> is_zero_iarray (vec_to_iarray (row ia (Gauss_Jordan A)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "assume not_zero_iarray: \"\\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))\""], ["proof (state)\nthis:\n  \\<not> is_zero_iarray (vec_to_iarray (row i (Gauss_Jordan A)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<not> is_zero_iarray\n               (vec_to_iarray (row i (Gauss_Jordan A))) \\<Longrightarrow>\n       vec_to_iarray (row i (Gauss_Jordan A))\n       \\<in> vec_to_iarray `\n             {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "show \"vec_to_iarray (row i (Gauss_Jordan A)) \\<in> vec_to_iarray ` {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_to_iarray (row i (Gauss_Jordan A))\n    \\<in> vec_to_iarray `\n          {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "by (rule imageI, auto simp add: not_zero_iarray  is_zero_iarray_eq_iff)"], ["proof (state)\nthis:\n  vec_to_iarray (row i (Gauss_Jordan A))\n  \\<in> vec_to_iarray `\n        {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_eq_card_iarrays':\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"rank A = (let A' = (Gauss_Jordan_iarrays (matrix_to_iarray A)) in card {row_iarray (to_nat i) A' |i::'rows. \\<not> is_zero_iarray (A' !! (to_nat i))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    (let A' = Gauss_Jordan_iarrays (matrix_to_iarray A)\n     in card\n         {row_iarray (mod_type_class.to_nat i) A' |i.\n          \\<not> is_zero_iarray (A' !! mod_type_class.to_nat i)})", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    card\n     {row_iarray (mod_type_class.to_nat i)\n       (Gauss_Jordan_iarrays (matrix_to_iarray A)) |\n      i. \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                  mod_type_class.to_nat i)}", "unfolding rank_eq_card_iarrays vec_to_iarray_row'  matrix_to_iarray_Gauss_Jordan row_iarray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {Gauss_Jordan_iarrays (matrix_to_iarray A) !! mod_type_class.to_nat i |\n      i. \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                  mod_type_class.to_nat i)} =\n    card\n     {Gauss_Jordan_iarrays (matrix_to_iarray A) !! mod_type_class.to_nat i |\n      i. \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                  mod_type_class.to_nat i)}", ".."], ["", "lemma rank_eq_card_iarrays_code:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"rank A = (let A' = (Gauss_Jordan_iarrays (matrix_to_iarray A)) in card {i::'rows. \\<not> is_zero_iarray (A' !! (to_nat i))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A =\n    (let A' = Gauss_Jordan_iarrays (matrix_to_iarray A)\n     in card {i. \\<not> is_zero_iarray (A' !! mod_type_class.to_nat i)})", "proof (unfold rank_eq_card_iarrays' Let_def, rule bij_betw_same_card[symmetric, of \"\\<lambda>i. row_iarray (to_nat i) (Gauss_Jordan_iarrays (matrix_to_iarray A))\"],\n    unfold bij_betw_def inj_on_def, auto, unfold IArray.sub_def[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> is_zero_iarray\n                        (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                         mod_type_class.to_nat x);\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                 mod_type_class.to_nat y);\n        row_iarray (mod_type_class.to_nat x)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A)) =\n        row_iarray (mod_type_class.to_nat y)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y::'rows"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> is_zero_iarray\n                        (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                         mod_type_class.to_nat x);\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                 mod_type_class.to_nat y);\n        row_iarray (mod_type_class.to_nat x)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A)) =\n        row_iarray (mod_type_class.to_nat y)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume x: \"\\<not> is_zero_iarray (Gauss_Jordan_iarrays (matrix_to_iarray A) !! to_nat x)\"\n    and y: \"\\<not> is_zero_iarray (Gauss_Jordan_iarrays (matrix_to_iarray A) !! to_nat y)\"\n    and eq: \"row_iarray (to_nat x) (Gauss_Jordan_iarrays (matrix_to_iarray A)) = row_iarray (to_nat y) (Gauss_Jordan_iarrays (matrix_to_iarray A))\""], ["proof (state)\nthis:\n  \\<not> is_zero_iarray\n          (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n           mod_type_class.to_nat x)\n  \\<not> is_zero_iarray\n          (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n           mod_type_class.to_nat y)\n  row_iarray (mod_type_class.to_nat x)\n   (Gauss_Jordan_iarrays (matrix_to_iarray A)) =\n  row_iarray (mod_type_class.to_nat y)\n   (Gauss_Jordan_iarrays (matrix_to_iarray A))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> is_zero_iarray\n                        (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                         mod_type_class.to_nat x);\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                 mod_type_class.to_nat y);\n        row_iarray (mod_type_class.to_nat x)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A)) =\n        row_iarray (mod_type_class.to_nat y)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> x = y", "have eq': \"(Gauss_Jordan A) $ x = (Gauss_Jordan A) $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gauss_Jordan A $ x = Gauss_Jordan A $ y", "by (metis eq matrix_to_iarray_Gauss_Jordan row_iarray_def vec_matrix vec_to_iarray_morph)"], ["proof (state)\nthis:\n  Gauss_Jordan A $ x = Gauss_Jordan A $ y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> is_zero_iarray\n                        (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                         mod_type_class.to_nat x);\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                 mod_type_class.to_nat y);\n        row_iarray (mod_type_class.to_nat x)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A)) =\n        row_iarray (mod_type_class.to_nat y)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence not_zero_x: \"\\<not> is_zero_row x (Gauss_Jordan A)\" and not_zero_y: \"\\<not> is_zero_row y (Gauss_Jordan A)\""], ["proof (prove)\nusing this:\n  Gauss_Jordan A $ x = Gauss_Jordan A $ y\n\ngoal (1 subgoal):\n 1. \\<not> is_zero_row x (Gauss_Jordan A) &&&\n    \\<not> is_zero_row y (Gauss_Jordan A)", "by (metis  is_zero_iarray_eq_iff is_zero_row_def' matrix_to_iarray_Gauss_Jordan vec_eq_iff vec_matrix x zero_index)+"], ["proof (state)\nthis:\n  \\<not> is_zero_row x (Gauss_Jordan A)\n  \\<not> is_zero_row y (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> is_zero_iarray\n                        (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                         mod_type_class.to_nat x);\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                 mod_type_class.to_nat y);\n        row_iarray (mod_type_class.to_nat x)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A)) =\n        row_iarray (mod_type_class.to_nat y)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence x_in: \"row x (Gauss_Jordan A) \\<in> {row i (Gauss_Jordan A) |i::'rows. row i (Gauss_Jordan A) \\<noteq> 0}\"\n    and y_in: \"row y (Gauss_Jordan A) \\<in> {row i (Gauss_Jordan A) |i::'rows. row i (Gauss_Jordan A) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  \\<not> is_zero_row x (Gauss_Jordan A)\n  \\<not> is_zero_row y (Gauss_Jordan A)\n\ngoal (1 subgoal):\n 1. row x (Gauss_Jordan A)\n    \\<in> {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0} &&&\n    row y (Gauss_Jordan A)\n    \\<in> {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}", "by (metis (lifting, mono_tags) is_zero_iarray_eq_iff matrix_to_iarray_Gauss_Jordan mem_Collect_eq vec_to_iarray_row' x y)+"], ["proof (state)\nthis:\n  row x (Gauss_Jordan A)\n  \\<in> {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n  row y (Gauss_Jordan A)\n  \\<in> {row i (Gauss_Jordan A) |i. row i (Gauss_Jordan A) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<not> is_zero_iarray\n                        (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                         mod_type_class.to_nat x);\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                 mod_type_class.to_nat y);\n        row_iarray (mod_type_class.to_nat x)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A)) =\n        row_iarray (mod_type_class.to_nat y)\n         (Gauss_Jordan_iarrays (matrix_to_iarray A))\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using inj_index_independent_rows[OF _ x_in eq'] rref_Gauss_Jordan"], ["proof (prove)\nusing this:\n  reduced_row_echelon_form (Gauss_Jordan A) \\<Longrightarrow> x = y\n  reduced_row_echelon_form (Gauss_Jordan ?A)\n\ngoal (1 subgoal):\n 1. x = y", "by fast"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Code equations for computing the rank over nested iarrays and the dimensions of the elementary subspaces\\<close>"], ["", "lemma rank_iarrays_code[code]:\n  \"rank_iarray A = length (filter (\\<lambda>x. \\<not> is_zero_iarray x) (IArray.list_of (Gauss_Jordan_iarrays A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_iarray A =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rank_iarray A =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "obtain xs where A_eq_xs: \"(Gauss_Jordan_iarrays A) = IArray xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        Gauss_Jordan_iarrays A = IArray xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis iarray.exhaust)"], ["proof (state)\nthis:\n  Gauss_Jordan_iarrays A = IArray xs\n\ngoal (1 subgoal):\n 1. rank_iarray A =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "have \"rank_iarray A = card {i. i<(IArray.length (Gauss_Jordan_iarrays A)) \\<and> \\<not> is_zero_iarray ((Gauss_Jordan_iarrays A) !! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_iarray A =\n    card\n     {i. i < IArray.length (Gauss_Jordan_iarrays A) \\<and>\n         \\<not> is_zero_iarray (Gauss_Jordan_iarrays A !! i)}", "unfolding rank_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {i. i < IArray.length (Gauss_Jordan_iarrays A) \\<and>\n         \\<not> is_zero_iarray (Gauss_Jordan_iarrays A !! i)} =\n    card\n     {i. i < IArray.length (Gauss_Jordan_iarrays A) \\<and>\n         \\<not> is_zero_iarray (Gauss_Jordan_iarrays A !! i)}", ".."], ["proof (state)\nthis:\n  rank_iarray A =\n  card\n   {i. i < IArray.length (Gauss_Jordan_iarrays A) \\<and>\n       \\<not> is_zero_iarray (Gauss_Jordan_iarrays A !! i)}\n\ngoal (1 subgoal):\n 1. rank_iarray A =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "also"], ["proof (state)\nthis:\n  rank_iarray A =\n  card\n   {i. i < IArray.length (Gauss_Jordan_iarrays A) \\<and>\n       \\<not> is_zero_iarray (Gauss_Jordan_iarrays A !! i)}\n\ngoal (1 subgoal):\n 1. rank_iarray A =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "have \"... = length (filter (\\<lambda>x. \\<not> is_zero_iarray x) (IArray.list_of (Gauss_Jordan_iarrays A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {i. i < IArray.length (Gauss_Jordan_iarrays A) \\<and>\n         \\<not> is_zero_iarray (Gauss_Jordan_iarrays A !! i)} =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "unfolding A_eq_xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {i. i < IArray.length (IArray xs) \\<and>\n         \\<not> is_zero_iarray (IArray xs !! i)} =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (IArray xs)))", "using length_filter_conv_card[symmetric]"], ["proof (prove)\nusing this:\n  card {i. i < length ?xs \\<and> ?p (?xs ! i)} = length (filter ?p ?xs)\n\ngoal (1 subgoal):\n 1. card\n     {i. i < IArray.length (IArray xs) \\<and>\n         \\<not> is_zero_iarray (IArray xs !! i)} =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (IArray xs)))", "by force"], ["proof (state)\nthis:\n  card\n   {i. i < IArray.length (Gauss_Jordan_iarrays A) \\<and>\n       \\<not> is_zero_iarray (Gauss_Jordan_iarrays A !! i)} =\n  length\n   (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n     (IArray.list_of (Gauss_Jordan_iarrays A)))\n\ngoal (1 subgoal):\n 1. rank_iarray A =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "finally"], ["proof (chain)\npicking this:\n  rank_iarray A =\n  length\n   (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n     (IArray.list_of (Gauss_Jordan_iarrays A)))", "show ?thesis"], ["proof (prove)\nusing this:\n  rank_iarray A =\n  length\n   (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n     (IArray.list_of (Gauss_Jordan_iarrays A)))\n\ngoal (1 subgoal):\n 1. rank_iarray A =\n    length\n     (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n       (IArray.list_of (Gauss_Jordan_iarrays A)))", "."], ["proof (state)\nthis:\n  rank_iarray A =\n  length\n   (filter (\\<lambda>x. \\<not> is_zero_iarray x)\n     (IArray.list_of (Gauss_Jordan_iarrays A)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_to_iarray_rank[code_unfold]:\n  shows \"rank A = rank_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank A = rank_iarray (matrix_to_iarray A)", "unfolding rank_eq_card_iarrays_code rank_iarray_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {i. \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                  mod_type_class.to_nat i)} =\n    card\n     {i. i < IArray.length\n              (Gauss_Jordan_iarrays (matrix_to_iarray A)) \\<and>\n         \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !! i)}", "apply (rule bij_betw_same_card[of \"to_nat\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw mod_type_class.to_nat\n     {i. \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                  mod_type_class.to_nat i)}\n     {i. i < IArray.length\n              (Gauss_Jordan_iarrays (matrix_to_iarray A)) \\<and>\n         \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !! i)}", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mod_type_class.to_nat\n     {i. \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                  mod_type_class.to_nat i)} \\<and>\n    mod_type_class.to_nat `\n    {i. \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                 mod_type_class.to_nat i)} =\n    {i. i < IArray.length (Gauss_Jordan_iarrays (matrix_to_iarray A)) \\<and>\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !! i)}", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on mod_type_class.to_nat\n     {i. \\<not> is_zero_iarray\n                 (IArray.list_of\n                   (Gauss_Jordan_iarrays (matrix_to_iarray A)) !\n                  mod_type_class.to_nat i)}\n 2. \\<And>xa.\n       \\<not> is_zero_iarray\n               (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)) !\n                mod_type_class.to_nat xa) \\<Longrightarrow>\n       mod_type_class.to_nat xa\n       < length (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)))\n 3. \\<And>x.\n       \\<lbrakk>x < length\n                     (IArray.list_of\n                       (Gauss_Jordan_iarrays (matrix_to_iarray A)));\n        \\<not> is_zero_iarray\n                (IArray.list_of\n                  (Gauss_Jordan_iarrays (matrix_to_iarray A)) !\n                 x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mod_type_class.to_nat `\n                                 {i. \\<not> is_zero_iarray\n       (IArray.list_of (Gauss_Jordan_iarrays (matrix_to_iarray A)) !\n        mod_type_class.to_nat i)}", "unfolding IArray.length_def[symmetric] IArray.sub_def[symmetric]"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on mod_type_class.to_nat\n     {i. \\<not> is_zero_iarray\n                 (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                  mod_type_class.to_nat i)}\n 2. \\<And>xa.\n       \\<not> is_zero_iarray\n               (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                mod_type_class.to_nat xa) \\<Longrightarrow>\n       mod_type_class.to_nat xa\n       < IArray.length (Gauss_Jordan_iarrays (matrix_to_iarray A))\n 3. \\<And>x.\n       \\<lbrakk>x < IArray.length\n                     (Gauss_Jordan_iarrays (matrix_to_iarray A));\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !! x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mod_type_class.to_nat `\n                                 {i. \\<not> is_zero_iarray\n       (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n        mod_type_class.to_nat i)}", "apply (metis inj_onI to_nat_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<not> is_zero_iarray\n               (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n                mod_type_class.to_nat xa) \\<Longrightarrow>\n       mod_type_class.to_nat xa\n       < IArray.length (Gauss_Jordan_iarrays (matrix_to_iarray A))\n 2. \\<And>x.\n       \\<lbrakk>x < IArray.length\n                     (Gauss_Jordan_iarrays (matrix_to_iarray A));\n        \\<not> is_zero_iarray\n                (Gauss_Jordan_iarrays (matrix_to_iarray A) !! x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mod_type_class.to_nat `\n                                 {i. \\<not> is_zero_iarray\n       (Gauss_Jordan_iarrays (matrix_to_iarray A) !!\n        mod_type_class.to_nat i)}", "unfolding  matrix_to_iarray_Gauss_Jordan[symmetric] length_eq_card_rows"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<not> is_zero_iarray\n               (matrix_to_iarray (Gauss_Jordan A) !!\n                mod_type_class.to_nat xa) \\<Longrightarrow>\n       mod_type_class.to_nat xa < CARD('c)\n 2. \\<And>x.\n       \\<lbrakk>x < CARD('c);\n        \\<not> is_zero_iarray\n                (matrix_to_iarray (Gauss_Jordan A) !! x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mod_type_class.to_nat `\n                                 {i. \\<not> is_zero_iarray\n       (matrix_to_iarray (Gauss_Jordan A) !! mod_type_class.to_nat i)}", "using bij_to_nat[where ?'a='c]"], ["proof (prove)\nusing this:\n  bij_betw mod_type_class.to_nat UNIV {0..<CARD('c)}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<not> is_zero_iarray\n               (matrix_to_iarray (Gauss_Jordan A) !!\n                mod_type_class.to_nat xa) \\<Longrightarrow>\n       mod_type_class.to_nat xa < CARD('c)\n 2. \\<And>x.\n       \\<lbrakk>x < CARD('c);\n        \\<not> is_zero_iarray\n                (matrix_to_iarray (Gauss_Jordan A) !! x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mod_type_class.to_nat `\n                                 {i. \\<not> is_zero_iarray\n       (matrix_to_iarray (Gauss_Jordan A) !! mod_type_class.to_nat i)}", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj mod_type_class.to_nat \\<and>\n  range mod_type_class.to_nat = {0..<CARD('c)}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<not> is_zero_iarray\n               (matrix_to_iarray (Gauss_Jordan A) !!\n                mod_type_class.to_nat xa) \\<Longrightarrow>\n       mod_type_class.to_nat xa < CARD('c)\n 2. \\<And>x.\n       \\<lbrakk>x < CARD('c);\n        \\<not> is_zero_iarray\n                (matrix_to_iarray (Gauss_Jordan A) !! x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mod_type_class.to_nat `\n                                 {i. \\<not> is_zero_iarray\n       (matrix_to_iarray (Gauss_Jordan A) !! mod_type_class.to_nat i)}", "by auto"], ["", "lemma dim_null_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (null_space A) = ncols_iarray (matrix_to_iarray A) - rank_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (null_space A) =\n    ncols_iarray (matrix_to_iarray A) - rank_iarray (matrix_to_iarray A)", "unfolding dim_null_space ncols_eq_card_columns matrix_to_iarray_rank dimension_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('columns) - rank_iarray (matrix_to_iarray A) =\n    CARD('columns) - rank_iarray (matrix_to_iarray A)", "by simp"], ["", "lemma dim_col_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (col_space A) = rank_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (col_space A) = rank_iarray (matrix_to_iarray A)", "unfolding rank_eq_dim_col_space[of A, symmetric]  matrix_to_iarray_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_iarray (matrix_to_iarray A) = rank_iarray (matrix_to_iarray A)", ".."], ["", "lemma dim_row_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (row_space A) = rank_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (row_space A) = rank_iarray (matrix_to_iarray A)", "unfolding row_rank_def[symmetric] rank_def[symmetric] matrix_to_iarray_rank"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank_iarray (matrix_to_iarray A) = rank_iarray (matrix_to_iarray A)", ".."], ["", "lemma dim_left_null_space_space_iarray[code_unfold]:\n  fixes A::\"'a::{field}^'columns::{mod_type}^'rows::{mod_type}\"\n  shows \"vec.dim (left_null_space A) = nrows_iarray (matrix_to_iarray A) - rank_iarray (matrix_to_iarray A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec.dim (left_null_space A) =\n    nrows_iarray (matrix_to_iarray A) - rank_iarray (matrix_to_iarray A)", "unfolding dim_left_null_space nrows_eq_card_rows matrix_to_iarray_rank dimension_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('rows) - rank_iarray (matrix_to_iarray A) =\n    CARD('rows) - rank_iarray (matrix_to_iarray A)", "by auto"], ["", "end"]]}