{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Worklists.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma valid_W_invD0:\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s; p \\<noteq> q \\<rbrakk> \\<Longrightarrow> r \\<notin> WL q s\"\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s q)\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> r \\<notin> W (s q)\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); valid_W_inv s; p \\<noteq> q \\<rbrakk> \\<Longrightarrow> r \\<notin> WL q s\"", "lemma valid_W_distinct_simps:\n  \"\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s\\<rbrakk> \\<Longrightarrow> (r \\<in> ghost_honorary_grey (s q)) \\<longleftrightarrow> (p = q)\"\n  \"\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk> \\<Longrightarrow> (r \\<in> W (s q)) \\<longleftrightarrow> (p = q)\"\n  \"\\<lbrakk>r \\<in> WL p s; valid_W_inv s\\<rbrakk> \\<Longrightarrow> (r \\<in> WL q s) \\<longleftrightarrow> (p = q)\"", "lemma valid_W_inv_sys_mem_store_buffersD:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mutate r' f r'' # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_fA fl' # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_fM fl' # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Phase ph # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\"", "lemma valid_W_invE2:\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s; \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj\\<rbrakk> \\<Longrightarrow> obj_at P r s\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); sys_mem_lock s \\<noteq> Some p; valid_W_inv s; \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj \\<rbrakk> \\<Longrightarrow> obj_at P r s\"", "lemma (in sys) valid_W_inv[intro]:\n  notes if_split_asm[split del]\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP (fM_rel_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> tso_store_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     sys\n   \\<lbrace> LSTP valid_W_inv \\<rbrace>\"", "lemma valid_W_inv_ghg_disjoint:\n  \"\\<lbrakk> white y s; sys_mem_lock s = Some p; valid_W_inv s; p0 \\<noteq> p1 \\<rbrakk>\n     \\<Longrightarrow> WL p0 (s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>)) \\<inter> WL p1 (s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>)) = {}\"", "lemma valid_W_inv_mo_co_mark:\n  \"\\<lbrakk> valid_W_inv s; white y s; sys_mem_lock s = Some p; filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys \\<rbrakk>\n    \\<Longrightarrow> valid_W_inv (s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>, sys := s sys\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(p := sys_mem_store_buffers p s @ [mw_Mark y (sys_fM s)])\\<rparr>))\"", "lemma valid_W_inv_mo_co_lock:\n  \"\\<lbrakk> valid_W_inv s; sys_mem_lock s = None \\<rbrakk>\n    \\<Longrightarrow> valid_W_inv (s(sys := s sys\\<lparr>mem_lock := Some p\\<rparr>))\"", "lemma valid_W_inv_mo_co_W:\n  \"\\<lbrakk> valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y}; p \\<noteq> sys \\<rbrakk>\n    \\<Longrightarrow> valid_W_inv (s(p := s p\\<lparr>W := insert y (W (s p)), ghost_honorary_grey := {}\\<rparr>))\"", "lemma valid_W_inv_mo_co_unlock:\n  \"\\<lbrakk> sys_mem_lock s = Some p; sys_mem_store_buffers p s = [];\n     \\<And>r. r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> marked r s;\n     valid_W_inv s\n   \\<rbrakk> \\<Longrightarrow> valid_W_inv (s(sys := mem_lock_update Map.empty (s sys)))\"", "lemma (in gc) valid_W_inv[intro]:\n  notes if_split_asm[split del]\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> gc_mark.mark_object_invL \\<^bold>\\<and> gc_W_empty_invL\n       \\<^bold>\\<and> obj_fields_marked_invL\n       \\<^bold>\\<and> sweep_loop_invL \\<^bold>\\<and> tso_lock_invL\n       \\<^bold>\\<and> LSTP valid_W_inv \\<rbrace>\n     gc\n   \\<lbrace> LSTP valid_W_inv \\<rbrace>\"", "lemma (in mut_m) valid_W_inv[intro]:\n  notes if_split_asm[split del]\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> handshake_invL \\<^bold>\\<and> mark_object_invL \\<^bold>\\<and> tso_lock_invL\n      \\<^bold>\\<and> mut_get_roots.mark_object_invL m\n      \\<^bold>\\<and> mut_store_del.mark_object_invL m\n      \\<^bold>\\<and> mut_store_ins.mark_object_invL m\n       \\<^bold>\\<and> LSTP (fM_rel_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     mutator m\n   \\<lbrace> LSTP valid_W_inv \\<rbrace>\""], "translations": [["", "lemma valid_W_invD0:\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s; p \\<noteq> q \\<rbrakk> \\<Longrightarrow> r \\<notin> WL q s\"\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s q)\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> r \\<notin> W (s q)\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); valid_W_inv s; p \\<noteq> q \\<rbrakk> \\<Longrightarrow> r \\<notin> WL q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>r \\<in> W (s p); valid_W_inv s; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> r \\<notin> WL q s) &&&\n     (\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n      \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s q))) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> r \\<notin> W (s q)) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s;\n      p \\<noteq> q\\<rbrakk>\n     \\<Longrightarrow> r \\<notin> WL q s)", "using marked_not_white"], ["proof (prove)\nusing this:\n  white ?r ?s \\<Longrightarrow> \\<not> marked ?r ?s\n\ngoal (1 subgoal):\n 1. ((\\<lbrakk>r \\<in> W (s p); valid_W_inv s; p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> r \\<notin> WL q s) &&&\n     (\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n      \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s q))) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> r \\<notin> W (s q)) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s;\n      p \\<noteq> q\\<rbrakk>\n     \\<Longrightarrow> r \\<notin> WL q s)", "unfolding valid_W_inv_def WL_def"], ["proof (prove)\nusing this:\n  white ?r ?s \\<Longrightarrow> \\<not> marked ?r ?s\n\ngoal (1 subgoal):\n 1. ((\\<lbrakk>r \\<in> W (s p);\n       (\\<forall>x xa.\n           xa \\<in> W (s x) \\<or>\n           sys_mem_lock s \\<noteq> Some x \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           marked xa s) \\<and>\n       (\\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {}) \\<and>\n       (\\<forall>x xa xb.\n           \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                   xb \\<in> W (s xa))) \\<and>\n       sys_ghost_honorary_grey s = {} \\<and>\n       (\\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb]);\n       p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> r \\<notin> W (s q) \\<union>\n                                   ghost_honorary_grey (s q)) &&&\n     (\\<lbrakk>r \\<in> W (s p);\n       (\\<forall>x xa.\n           xa \\<in> W (s x) \\<or>\n           sys_mem_lock s \\<noteq> Some x \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           marked xa s) \\<and>\n       (\\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {}) \\<and>\n       (\\<forall>x xa xb.\n           \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                   xb \\<in> W (s xa))) \\<and>\n       sys_ghost_honorary_grey s = {} \\<and>\n       (\\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) =\n           [mw_Mark xa xb])\\<rbrakk>\n      \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s q))) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n          (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n          {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> r \\<notin> W (s q)) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n          (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n          {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb]);\n      p \\<noteq> q\\<rbrakk>\n     \\<Longrightarrow> r \\<notin> W (s q) \\<union>\n                                  ghost_honorary_grey (s q))", "by (auto 0 5 split: obj_at_splits)"], ["", "lemma valid_W_distinct_simps:\n  \"\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s\\<rbrakk> \\<Longrightarrow> (r \\<in> ghost_honorary_grey (s q)) \\<longleftrightarrow> (p = q)\"\n  \"\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk> \\<Longrightarrow> (r \\<in> W (s q)) \\<longleftrightarrow> (p = q)\"\n  \"\\<lbrakk>r \\<in> WL p s; valid_W_inv s\\<rbrakk> \\<Longrightarrow> (r \\<in> WL q s) \\<longleftrightarrow> (p = q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> (r \\<in> ghost_honorary_grey (s q)) = (p = q)) &&&\n    (\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> (r \\<in> W (s q)) = (p = q)) &&&\n    (\\<lbrakk>r \\<in> WL p s; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> (r \\<in> WL q s) = (p = q))", "using valid_W_invD0(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<in> ghost_honorary_grey (?s ?p); valid_W_inv ?s;\n   ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> ?r \\<notin> WL ?q ?s\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<in> ghost_honorary_grey (s p); valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> (r \\<in> ghost_honorary_grey (s q)) = (p = q)) &&&\n    (\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> (r \\<in> W (s q)) = (p = q)) &&&\n    (\\<lbrakk>r \\<in> WL p s; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> (r \\<in> WL q s) = (p = q))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> (r \\<in> W (s q)) = (p = q)\n 2. \\<lbrakk>r \\<in> WL p s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> (r \\<in> WL q s) = (p = q)", "using valid_W_invD0(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<in> W (?s ?p); valid_W_inv ?s; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> ?r \\<notin> WL ?q ?s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> (r \\<in> W (s q)) = (p = q)\n 2. \\<lbrakk>r \\<in> WL p s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> (r \\<in> WL q s) = (p = q)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> WL p s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> (r \\<in> WL q s) = (p = q)", "apply (metis UnE WL_def valid_W_invD0(1) valid_W_invD0(4))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_W_inv_sys_mem_store_buffersD:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mutate r' f r'' # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_fA fl' # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_fM fl' # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Phase ph # ws; mw_Mark r fl \\<in> set ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = [mw_Mark r fl]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r' f r'' # ws;\n       mw_Mark r fl \\<in> set ws; valid_W_inv s\\<rbrakk>\n      \\<Longrightarrow> fl = sys_fM s \\<and>\n                        r \\<in> ghost_honorary_grey (s p) \\<and>\n                        sys_mem_lock s = Some p \\<and>\n                        white r s \\<and>\n                        filter is_mw_Mark ws = [mw_Mark r fl]) &&&\n     (\\<lbrakk>sys_mem_store_buffers p s = mw_fA fl' # ws;\n       mw_Mark r fl \\<in> set ws; valid_W_inv s\\<rbrakk>\n      \\<Longrightarrow> fl = sys_fM s \\<and>\n                        r \\<in> ghost_honorary_grey (s p) \\<and>\n                        sys_mem_lock s = Some p \\<and>\n                        white r s \\<and>\n                        filter is_mw_Mark ws = [mw_Mark r fl])) &&&\n    (\\<lbrakk>sys_mem_store_buffers p s = mw_fM fl' # ws;\n      mw_Mark r fl \\<in> set ws; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       white r s \\<and>\n                       filter is_mw_Mark ws = [mw_Mark r fl]) &&&\n    (\\<lbrakk>sys_mem_store_buffers p s = mw_Phase ph # ws;\n      mw_Mark r fl \\<in> set ws; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       white r s \\<and>\n                       filter is_mw_Mark ws = [mw_Mark r fl])", "unfolding valid_W_inv_def white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r' f r'' # ws;\n       mw_Mark r fl \\<in> set ws;\n       (\\<forall>x xa.\n           xa \\<in> W (s x) \\<or>\n           sys_mem_lock s \\<noteq> Some x \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           marked xa s) \\<and>\n       (\\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           WL x s \\<inter> WL xa s = {}) \\<and>\n       (\\<forall>x xa xb.\n           \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                   xb \\<in> W (s xa))) \\<and>\n       sys_ghost_honorary_grey s = {} \\<and>\n       (\\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) =\n           [mw_Mark xa xb])\\<rbrakk>\n      \\<Longrightarrow> fl = sys_fM s \\<and>\n                        r \\<in> ghost_honorary_grey (s p) \\<and>\n                        sys_mem_lock s = Some p \\<and>\n                        obj_at\n                         (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r\n                         s \\<and>\n                        filter is_mw_Mark ws = [mw_Mark r fl]) &&&\n     (\\<lbrakk>sys_mem_store_buffers p s = mw_fA fl' # ws;\n       mw_Mark r fl \\<in> set ws;\n       (\\<forall>x xa.\n           xa \\<in> W (s x) \\<or>\n           sys_mem_lock s \\<noteq> Some x \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           marked xa s) \\<and>\n       (\\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           WL x s \\<inter> WL xa s = {}) \\<and>\n       (\\<forall>x xa xb.\n           \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                   xb \\<in> W (s xa))) \\<and>\n       sys_ghost_honorary_grey s = {} \\<and>\n       (\\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) =\n           [mw_Mark xa xb])\\<rbrakk>\n      \\<Longrightarrow> fl = sys_fM s \\<and>\n                        r \\<in> ghost_honorary_grey (s p) \\<and>\n                        sys_mem_lock s = Some p \\<and>\n                        obj_at\n                         (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r\n                         s \\<and>\n                        filter is_mw_Mark ws = [mw_Mark r fl])) &&&\n    (\\<lbrakk>sys_mem_store_buffers p s = mw_fM fl' # ws;\n      mw_Mark r fl \\<in> set ws;\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s)\n                        r s \\<and>\n                       filter is_mw_Mark ws = [mw_Mark r fl]) &&&\n    (\\<lbrakk>sys_mem_store_buffers p s = mw_Phase ph # ws;\n      mw_Mark r fl \\<in> set ws;\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s)\n                        r s \\<and>\n                       filter is_mw_Mark ws = [mw_Mark r fl])", "by (clarsimp dest!: spec[where x=p], blast)+"], ["", "lemma valid_W_invE2:\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s; \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj\\<rbrakk> \\<Longrightarrow> obj_at P r s\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); sys_mem_lock s \\<noteq> Some p; valid_W_inv s; \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj \\<rbrakk> \\<Longrightarrow> obj_at P r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<in> W (s p); valid_W_inv s;\n      \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj\\<rbrakk>\n     \\<Longrightarrow> obj_at P r s) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n      sys_mem_lock s \\<noteq> Some p; valid_W_inv s;\n      \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj\\<rbrakk>\n     \\<Longrightarrow> obj_at P r s)", "unfolding valid_W_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>r \\<in> W (s p);\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb]);\n      \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj\\<rbrakk>\n     \\<Longrightarrow> obj_at P r s) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n      sys_mem_lock s \\<noteq> Some p;\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb]);\n      \\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj\\<rbrakk>\n     \\<Longrightarrow> obj_at P r s)", "apply (simp_all add:  split: obj_at_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj;\n     r \\<in> W (s p);\n     \\<forall>x xa.\n        ((\\<exists>y. sys_heap s xa = Some y) \\<or>\n         xa \\<notin> W (s x) \\<and>\n         (sys_mem_lock s = Some x \\<or>\n          xa \\<notin> ghost_honorary_grey (s x))) \\<and>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            (xa \\<in> W (s x) \\<longrightarrow>\n             obj_mark obj = sys_fM s) \\<and>\n            (xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n             sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s));\n     \\<forall>x xa.\n        x \\<noteq> xa \\<longrightarrow> WL x s \\<inter> WL xa s = {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) =\n        [mw_Mark xa xb]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. sys_heap s r = Some y\n 2. \\<lbrakk>\\<And>obj. obj_mark obj = sys_fM s \\<Longrightarrow> P obj;\n     r \\<in> ghost_honorary_grey (s p); sys_mem_lock s \\<noteq> Some p;\n     \\<forall>x xa.\n        ((\\<exists>y. sys_heap s xa = Some y) \\<or>\n         xa \\<notin> W (s x) \\<and>\n         (sys_mem_lock s = Some x \\<or>\n          xa \\<notin> ghost_honorary_grey (s x))) \\<and>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            (xa \\<in> W (s x) \\<longrightarrow>\n             obj_mark obj = sys_fM s) \\<and>\n            (xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n             sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s));\n     \\<forall>x xa.\n        x \\<noteq> xa \\<longrightarrow> WL x s \\<inter> WL xa s = {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) =\n        [mw_Mark xa xb]\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>y. sys_heap s r = Some y) \\<and>\n                      (\\<forall>obj.\n                          sys_heap s r = Some obj \\<longrightarrow> P obj)", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in sys) valid_W_inv[intro]:\n  notes if_split_asm[split del]\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP (fM_rel_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> tso_store_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     sys\n   \\<lbrace> LSTP valid_W_inv \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                fM_rel_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv\n                 s\\<down>\\<rbrace> sys \\<lbrace>\\<lambda>s.\n             valid_W_inv s\\<down>\\<rbrace>", "proof(vcg_jackhammer (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "case (tso_dequeue_store_buffer s s' p w ws)"], ["proof (state)\nthis:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  tso_store_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  tso_store_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  tso_store_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "proof(cases w)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark x11 x12\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 4. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 5. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 6. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "case (mw_Mark r fl)"], ["proof (state)\nthis:\n  w = mw_Mark r fl\n\ngoal (6 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark x11 x12\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 4. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 5. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 6. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  tso_store_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mark r fl", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  tso_store_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mark r fl\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := do_store_action w (s\\<down> sys)\n        \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                  (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys; valid_refs_inv s\\<down>;\n     valid_W_inv s\\<down>; w = mw_Mark r fl\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (sys := do_store_action w (s\\<down> sys)\n    \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n              (p := ws)\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (sys := do_store_action w (s\\<down> sys)\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(sys := do_store_action w (s\\<down> sys)\n   \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (sys := do_store_action w (s\\<down> sys)\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (sys := do_store_action w (s\\<down> sys)\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (sys := do_store_action w (s\\<down> sys)\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (sys := do_store_action w (s\\<down> sys)\n                           \\<lparr>mem_store_buffers :=\n                                     (mem_store_buffers (s\\<down> sys))\n                                     (p := ws)\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (sys := do_store_action w (s\\<down> sys)\n    \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n              (p := ws)\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (sys := do_store_action w (s\\<down> sys)\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(sys := do_store_action w (s\\<down> sys)\n   \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (sys := do_store_action w (s\\<down> sys)\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (sys := do_store_action w (s\\<down> sys)\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (sys := do_store_action w (s\\<down> sys)\n                                 \\<lparr>mem_store_buffers :=\n     (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mark r fl # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mark r fl\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x.\n                               (x \\<in> sys_W s\\<down> \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (x = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (x \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 x s\\<down>) \\<and>\n                               (sys_mem_lock s\\<down> \\<noteq>\n                                Some sys \\<and>\n                                x \\<in> sys_ghost_honorary_grey\n   s\\<down> \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (x = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (x \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 x s\\<down>))) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (\\<forall>xa.\n                               (xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (xa = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (xa \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 xa s\\<down>) \\<and>\n                               (sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                                xa \\<in> ghost_honorary_grey\n    (s\\<down> x) \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (xa = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (xa \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 xa s\\<down>)))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x s\\<down> \\<inter> WL xa s\\<down> = {}) \\<and>\n                      (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x.\n                               (x = sys \\<longrightarrow>\n                                (\\<forall>x.\n                                    x \\<in> sys_ghost_honorary_grey\n       s\\<down> \\<longrightarrow>\n                                    x \\<notin> sys_W s\\<down>)) \\<and>\n                               (x \\<noteq> sys \\<longrightarrow>\n                                (\\<forall>xa.\n                                    xa \\<in> sys_ghost_honorary_grey\n        s\\<down> \\<longrightarrow>\n                                    xa \\<notin> W (s\\<down> x))))) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (\\<forall>xa.\n                               (xa = sys \\<longrightarrow>\n                                (\\<forall>xa.\n                                    xa \\<in> ghost_honorary_grey\n        (s\\<down> x) \\<longrightarrow>\n                                    xa \\<notin> sys_W s\\<down>)) \\<and>\n                               (xa \\<noteq> sys \\<longrightarrow>\n                                (\\<forall>xb.\n                                    xb \\<in> ghost_honorary_grey\n        (s\\<down> x) \\<longrightarrow>\n                                    xb \\<notin> W (s\\<down> xa)))))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x xa.\n                               mw_Mark x xa\n                               \\<in> set\n(sys_mem_store_buffers sys s\\<down>) \\<longrightarrow>\n                               xa = sys_fM s\\<down> \\<and>\n                               x \\<in> sys_ghost_honorary_grey\n  s\\<down> \\<and>\n                               sys_mem_lock s\\<down> = Some sys \\<and>\n                               white x\n                                (s\\<down>\n                                 (sys := s\\<down> sys\n                                    \\<lparr>heap := (sys_heap s\\<down>)\n        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n               (sys_heap s\\<down> r)),\n mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n   (p := ws)\\<rparr>)) \\<and>\n                               filter is_mw_Mark\n                                (sys_mem_store_buffers sys s\\<down>) =\n                               [mw_Mark x xa])) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (x = p \\<longrightarrow>\n                            (\\<forall>x xa.\n                                mw_Mark x xa \\<in> set ws \\<longrightarrow>\n                                xa = sys_fM s\\<down> \\<and>\n                                x \\<in> ghost_honorary_grey\n   (s\\<down> p) \\<and>\n                                sys_mem_lock s\\<down> = Some p \\<and>\n                                white x\n                                 (s\\<down>\n                                  (sys := s\\<down> sys\n                                     \\<lparr>heap := (sys_heap s\\<down>)\n         (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                (sys_heap s\\<down> r)),\n  mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n    (p := ws)\\<rparr>)) \\<and>\n                                filter is_mw_Mark ws =\n                                [mw_Mark x xa])) \\<and>\n                           (x \\<noteq> p \\<longrightarrow>\n                            (\\<forall>xa xb.\n                                mw_Mark xa xb\n                                \\<in> set\n (sys_mem_store_buffers x s\\<down>) \\<longrightarrow>\n                                xb = sys_fM s\\<down> \\<and>\n                                xa \\<in> ghost_honorary_grey\n    (s\\<down> x) \\<and>\n                                sys_mem_lock s\\<down> = Some x \\<and>\n                                white xa\n                                 (s\\<down>\n                                  (sys := s\\<down> sys\n                                     \\<lparr>heap := (sys_heap s\\<down>)\n         (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                (sys_heap s\\<down> r)),\n  mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n    (p := ws)\\<rparr>)) \\<and>\n                                filter is_mw_Mark\n                                 (sys_mem_store_buffers x s\\<down>) =\n                                [mw_Mark xa xb]))))", "apply (frule (1) valid_W_invD(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mark r fl # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_Mark r fl;\n     fl = sys_fM s\\<down> \\<and>\n     r \\<in> ghost_honorary_grey (s\\<down> p) \\<and>\n     sys_mem_lock s\\<down> = Some p \\<and>\n     white r s\\<down> \\<and> filter is_mw_Mark ws = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x.\n                               (x \\<in> sys_W s\\<down> \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (x = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (x \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 x s\\<down>) \\<and>\n                               (sys_mem_lock s\\<down> \\<noteq>\n                                Some sys \\<and>\n                                x \\<in> sys_ghost_honorary_grey\n   s\\<down> \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (x = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (x \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 x s\\<down>))) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (\\<forall>xa.\n                               (xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (xa = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (xa \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 xa s\\<down>) \\<and>\n                               (sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                                xa \\<in> ghost_honorary_grey\n    (s\\<down> x) \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     (xa = r \\<longrightarrow>\nfl = sys_fM s\\<down>) \\<and>\n                                     (xa \\<noteq> r \\<longrightarrow>\nobj_mark obj = sys_fM s\\<down>))\n                                 xa s\\<down>)))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x s\\<down> \\<inter> WL xa s\\<down> = {}) \\<and>\n                      (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x.\n                               (x = sys \\<longrightarrow>\n                                (\\<forall>x.\n                                    x \\<in> sys_ghost_honorary_grey\n       s\\<down> \\<longrightarrow>\n                                    x \\<notin> sys_W s\\<down>)) \\<and>\n                               (x \\<noteq> sys \\<longrightarrow>\n                                (\\<forall>xa.\n                                    xa \\<in> sys_ghost_honorary_grey\n        s\\<down> \\<longrightarrow>\n                                    xa \\<notin> W (s\\<down> x))))) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (\\<forall>xa.\n                               (xa = sys \\<longrightarrow>\n                                (\\<forall>xa.\n                                    xa \\<in> ghost_honorary_grey\n        (s\\<down> x) \\<longrightarrow>\n                                    xa \\<notin> sys_W s\\<down>)) \\<and>\n                               (xa \\<noteq> sys \\<longrightarrow>\n                                (\\<forall>xb.\n                                    xb \\<in> ghost_honorary_grey\n        (s\\<down> x) \\<longrightarrow>\n                                    xb \\<notin> W (s\\<down> xa)))))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x xa.\n                               mw_Mark x xa\n                               \\<in> set\n(sys_mem_store_buffers sys s\\<down>) \\<longrightarrow>\n                               xa = sys_fM s\\<down> \\<and>\n                               x \\<in> sys_ghost_honorary_grey\n  s\\<down> \\<and>\n                               sys_mem_lock s\\<down> = Some sys \\<and>\n                               white x\n                                (s\\<down>\n                                 (sys := s\\<down> sys\n                                    \\<lparr>heap := (sys_heap s\\<down>)\n        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n               (sys_heap s\\<down> r)),\n mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n   (p := ws)\\<rparr>)) \\<and>\n                               filter is_mw_Mark\n                                (sys_mem_store_buffers sys s\\<down>) =\n                               [mw_Mark x xa])) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (x = p \\<longrightarrow>\n                            (\\<forall>x xa.\n                                mw_Mark x xa \\<in> set ws \\<longrightarrow>\n                                xa = sys_fM s\\<down> \\<and>\n                                x \\<in> ghost_honorary_grey\n   (s\\<down> p) \\<and>\n                                sys_mem_lock s\\<down> = Some p \\<and>\n                                white x\n                                 (s\\<down>\n                                  (sys := s\\<down> sys\n                                     \\<lparr>heap := (sys_heap s\\<down>)\n         (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                (sys_heap s\\<down> r)),\n  mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n    (p := ws)\\<rparr>)) \\<and>\n                                filter is_mw_Mark ws =\n                                [mw_Mark x xa])) \\<and>\n                           (x \\<noteq> p \\<longrightarrow>\n                            (\\<forall>xa xb.\n                                mw_Mark xa xb\n                                \\<in> set\n (sys_mem_store_buffers x s\\<down>) \\<longrightarrow>\n                                xb = sys_fM s\\<down> \\<and>\n                                xa \\<in> ghost_honorary_grey\n    (s\\<down> x) \\<and>\n                                sys_mem_lock s\\<down> = Some x \\<and>\n                                white xa\n                                 (s\\<down>\n                                  (sys := s\\<down> sys\n                                     \\<lparr>heap := (sys_heap s\\<down>)\n         (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                (sys_heap s\\<down> r)),\n  mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n    (p := ws)\\<rparr>)) \\<and>\n                                filter is_mw_Mark\n                                 (sys_mem_store_buffers x s\\<down>) =\n                                [mw_Mark xa xb]))))", "apply (clarsimp simp: all_conj_distrib white_def valid_W_inv_sys_ghg_empty_iff filter_empty_conv obj_at_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n     r \\<in> ghost_honorary_grey (s\\<down> p);\n     sys_mem_lock s\\<down> = Some p;\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n      s\\<down>;\n     \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s\\<down> \\<longrightarrow>\n                          obj_at\n                           (\\<lambda>obj.\n                               x \\<noteq> r \\<longrightarrow>\n                               obj_mark obj = sys_fM s\\<down>)\n                           x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj.\n                                   xa \\<noteq> r \\<longrightarrow>\n                                   obj_mark obj = sys_fM s\\<down>)\n                               xa s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              p \\<noteq> x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj.\n                                   xa \\<noteq> r \\<longrightarrow>\n                                   obj_mark obj = sys_fM s\\<down>)\n                               xa s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x s\\<down> \\<inter> WL xa s\\<down> = {}) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> sys_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xb.\n                                  xb \\<in> ghost_honorary_grey\n      (s\\<down> x) \\<longrightarrow>\n                                  xb \\<notin> W (s\\<down> xa)))) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers sys\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> sys \\<longrightarrow>\n                          (x = p \\<longrightarrow>\n                           (\\<forall>x xa.\n                               mw_Mark x xa \\<notin> set ws)) \\<and>\n                          (x \\<noteq> p \\<longrightarrow>\n                           (\\<forall>xa xb.\n                               mw_Mark xa xb\n                               \\<notin> set\n   (sys_mem_store_buffers x s\\<down>))))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<in> sys_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> obj_at\n                          (\\<lambda>obj.\n                              x \\<noteq> r \\<longrightarrow>\n                              obj_mark obj = sys_fM s\\<down>)\n                          x s\\<down>\n 2. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<in> W (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> obj_at\n                          (\\<lambda>obj.\n                              xa \\<noteq> r \\<longrightarrow>\n                              obj_mark obj = sys_fM s\\<down>)\n                          xa s\\<down>\n 3. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys;\n        p \\<noteq> x \\<and>\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> obj_at\n                          (\\<lambda>obj.\n                              xa \\<noteq> r \\<longrightarrow>\n                              obj_mark obj = sys_fM s\\<down>)\n                          xa s\\<down>\n 4. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> WL x s\\<down> \\<inter> WL xa s\\<down> = {}\n 5. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 6. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 7. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws.\n           \\<forall>r fl. x \\<noteq> mw_Mark r fl\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 8. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x = p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb \\<notin> set ws\n 9. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "apply (auto elim: valid_W_invE2)[3]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> WL x s\\<down> \\<inter> WL xa s\\<down> = {}\n 2. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 3. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 4. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws.\n           \\<forall>r fl. x \\<noteq> mw_Mark r fl\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 5. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x = p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb \\<notin> set ws\n 6. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "apply (meson Int_emptyI valid_W_distinct_simps(3))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 2. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 3. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws.\n           \\<forall>r fl. x \\<noteq> mw_Mark r fl\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 4. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x = p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb \\<notin> set ws\n 5. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "apply (meson valid_W_invD0(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 2. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws.\n           \\<forall>r fl. x \\<noteq> mw_Mark r fl\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 3. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x = p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb \\<notin> set ws\n 4. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "apply (meson valid_W_invD0(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws.\n           \\<forall>r fl. x \\<noteq> mw_Mark r fl\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 2. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x = p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb \\<notin> set ws\n 3. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "using valid_W_invD(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mw_Mark ?r ?fl \\<in> set (sys_mem_store_buffers ?p ?s);\n   valid_W_inv ?s\\<rbrakk>\n  \\<Longrightarrow> ?fl = sys_fM ?s \\<and>\n                    ?r \\<in> ghost_honorary_grey (?s ?p) \\<and>\n                    sys_mem_lock ?s = Some ?p \\<and>\n                    white ?r ?s \\<and>\n                    filter is_mw_Mark (sys_mem_store_buffers ?p ?s) =\n                    [mw_Mark ?r ?fl]\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws.\n           \\<forall>r fl. x \\<noteq> mw_Mark r fl\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 2. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x = p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb \\<notin> set ws\n 3. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x = p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb \\<notin> set ws\n 2. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "using valid_W_invD(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>mw_Mark ?r ?fl \\<in> set (sys_mem_store_buffers ?p ?s);\n   valid_W_inv ?s\\<rbrakk>\n  \\<Longrightarrow> ?fl = sys_fM ?s \\<and>\n                    ?r \\<in> ghost_honorary_grey (?s ?p) \\<and>\n                    sys_mem_lock ?s = Some ?p \\<and>\n                    white ?r ?s \\<and>\n                    filter is_mw_Mark (sys_mem_store_buffers ?p ?s) =\n                    [mw_Mark ?r ?fl]\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mark r (sys_fM s\\<down>) # ws;\n        tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mark r (sys_fM s\\<down>); fl = sys_fM s\\<down>;\n        r \\<in> ghost_honorary_grey (s\\<down> p);\n        sys_mem_lock s\\<down> = Some p;\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) r\n         s\\<down>;\n        \\<forall>x\\<in>set ws. \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        x \\<noteq> sys; x \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> mw_Mark xa xb\n                         \\<notin> set (sys_mem_store_buffers x s\\<down>)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 3. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 4. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 5. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 3. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 4. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 5. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "case (mw_fM fl)"], ["proof (state)\nthis:\n  w = mw_fM fl\n\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 3. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 4. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 5. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  tso_store_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_fM fl", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  tso_store_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_fM fl\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "apply (clarsimp simp: fM_rel_inv_def fM_rel_def p_not_sys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fl,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     sys_fM s\\<down> = gc_fM s\\<down> \\<and>\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [] \\<and>\n     (sys_ghost_hs_phase s\\<down> = hp_Idle \\<longrightarrow>\n      (\\<exists>x. \\<not> sys_ghost_hs_in_sync x s\\<down>)) \\<or>\n     sys_ghost_hs_phase s\\<down> = hp_Idle \\<and>\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [] \\<and>\n     All (ghost_hs_in_sync (s\\<down> sys)) \\<or>\n     sys_ghost_hs_phase s\\<down> = hp_Idle \\<and>\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>) \\<and>\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) =\n     [mw_fM (\\<not> sys_fM s\\<down>)] \\<and>\n     sys_mem_lock s\\<down> \\<noteq> Some gc \\<and>\n     All (ghost_hs_in_sync (s\\<down> sys));\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fl # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p = gc \\<or> (\\<exists>m. p = mutator m); valid_refs_inv s\\<down>;\n     valid_W_inv s\\<down>; w = mw_fM fl\\<rbrakk>\n    \\<Longrightarrow> valid_W_inv\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>fM := fl,\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>))", "apply (elim disjE; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) gc;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     if sys_fA s\\<down> = sys_fM s\\<down> then black_heap s\\<down>\n     else white_heap s\\<down>;\n     no_grey_refs s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fl = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys))\\<rbrakk>\n    \\<Longrightarrow> valid_W_inv\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (gc := ws)\\<rparr>))", "apply (frule (1) no_grey_refs_no_pending_marks)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) gc;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     if sys_fA s\\<down> = sys_fM s\\<down> then black_heap s\\<down>\n     else white_heap s\\<down>;\n     no_grey_refs s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fl = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys));\n     \\<forall>x.\n        filter is_mw_Mark (sys_mem_store_buffers x s\\<down>) = []\\<rbrakk>\n    \\<Longrightarrow> valid_W_inv\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (gc := ws)\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) gc;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     if sys_fA s\\<down> = sys_fM s\\<down> then black_heap s\\<down>\n     else white_heap s\\<down>;\n     no_grey_refs s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fl = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys));\n     \\<forall>x.\n        filter is_mw_Mark (sys_mem_store_buffers x s\\<down>) = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (sys := s\\<down> sys\n    \\<lparr>fM := \\<not> sys_fM s\\<down>,\n       mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n         (gc := ws)\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s\\<down> sys))\n                                    (gc := ws)\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(sys := s\\<down> sys\n   \\<lparr>fM := \\<not> sys_fM s\\<down>,\n      mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n        (gc := ws)\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s\\<down> sys))\n                                    (gc := ws)\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s\\<down> sys))\n                                    (gc := ws)\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s\\<down> sys))\n                                    (gc := ws)\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>fM := \\<not> sys_fM s\\<down>,\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (gc := ws)\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>fM := \\<not> sys_fM s\\<down>,\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (gc := ws)\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (gc := ws)\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (sys := s\\<down> sys\n    \\<lparr>fM := \\<not> sys_fM s\\<down>,\n       mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n         (gc := ws)\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s\\<down> sys))\n                                    (gc := ws)\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(sys := s\\<down> sys\n   \\<lparr>fM := \\<not> sys_fM s\\<down>,\n      mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n        (gc := ws)\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s\\<down> sys))\n                                    (gc := ws)\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s\\<down> sys))\n                                    (gc := ws)\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (sys := s\\<down> sys\n                                 \\<lparr>fM := \\<not> sys_fM s\\<down>,\n                                    mem_store_buffers :=\n(mem_store_buffers (s\\<down> sys))(gc := ws)\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     tso_store_inv s\\<down>; not_blocked (s\\<down> sys) gc;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     if sys_fA s\\<down> = sys_fM s\\<down> then black_heap s\\<down>\n     else white_heap s\\<down>;\n     no_grey_refs s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fl = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys));\n     \\<forall>x.\n        filter is_mw_Mark (sys_mem_store_buffers x s\\<down>) = []\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x.\n                               (x \\<in> sys_W s\\<down> \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     obj_mark obj =\n                                     (\\<not> sys_fM s\\<down>))\n                                 x s\\<down>) \\<and>\n                               (sys_mem_lock s\\<down> \\<noteq>\n                                Some sys \\<and>\n                                x \\<in> sys_ghost_honorary_grey\n   s\\<down> \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     obj_mark obj =\n                                     (\\<not> sys_fM s\\<down>))\n                                 x s\\<down>))) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (\\<forall>xa.\n                               (xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     obj_mark obj =\n                                     (\\<not> sys_fM s\\<down>))\n                                 xa s\\<down>) \\<and>\n                               (sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                                xa \\<in> ghost_honorary_grey\n    (s\\<down> x) \\<longrightarrow>\n                                obj_at\n                                 (\\<lambda>obj.\n                                     obj_mark obj =\n                                     (\\<not> sys_fM s\\<down>))\n                                 xa s\\<down>)))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x s\\<down> \\<inter> WL xa s\\<down> = {}) \\<and>\n                      (\\<forall>x.\n                          (x = sys \\<longrightarrow>\n                           (\\<forall>x.\n                               (x = sys \\<longrightarrow>\n                                (\\<forall>x.\n                                    x \\<in> sys_ghost_honorary_grey\n       s\\<down> \\<longrightarrow>\n                                    x \\<notin> sys_W s\\<down>)) \\<and>\n                               (x \\<noteq> sys \\<longrightarrow>\n                                (\\<forall>xa.\n                                    xa \\<in> sys_ghost_honorary_grey\n        s\\<down> \\<longrightarrow>\n                                    xa \\<notin> W (s\\<down> x))))) \\<and>\n                          (x \\<noteq> sys \\<longrightarrow>\n                           (\\<forall>xa.\n                               (xa = sys \\<longrightarrow>\n                                (\\<forall>xa.\n                                    xa \\<in> ghost_honorary_grey\n        (s\\<down> x) \\<longrightarrow>\n                                    xa \\<notin> sys_W s\\<down>)) \\<and>\n                               (xa \\<noteq> sys \\<longrightarrow>\n                                (\\<forall>xb.\n                                    xb \\<in> ghost_honorary_grey\n        (s\\<down> x) \\<longrightarrow>\n                                    xb \\<notin> W (s\\<down> xa)))))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x.\n                          (x = gc \\<longrightarrow>\n                           (\\<forall>x xa.\n                               mw_Mark x xa \\<notin> set ws)) \\<and>\n                          (x \\<noteq> gc \\<longrightarrow>\n                           (\\<forall>xa xb.\n                               mw_Mark xa xb\n                               \\<notin> set\n   (sys_mem_store_buffers x s\\<down>))))", "apply (meson Int_emptyI no_grey_refsD(1) no_grey_refsD(3) valid_W_distinct_simps(3) valid_W_invD(2) valid_W_inv_sys_ghg_empty_iff valid_W_inv_sys_mem_store_buffersD(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 3. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>; w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n 4. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws; tso_store_inv s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "qed simp_all"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Lemmas for key mark_object transitions *)"], ["", "lemma valid_W_inv_ghg_disjoint:\n  \"\\<lbrakk> white y s; sys_mem_lock s = Some p; valid_W_inv s; p0 \\<noteq> p1 \\<rbrakk>\n     \\<Longrightarrow> WL p0 (s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>)) \\<inter> WL p1 (s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>white y s; sys_mem_lock s = Some p; valid_W_inv s;\n     p0 \\<noteq> p1\\<rbrakk>\n    \\<Longrightarrow> WL p0\n                       (s(p := s p\n                            \\<lparr>ghost_honorary_grey :=\n{y}\\<rparr>)) \\<inter>\n                      WL p1\n                       (s(p := s p\n                            \\<lparr>ghost_honorary_grey := {y}\\<rparr>)) =\n                      {}", "unfolding valid_W_inv_def WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>white y s; sys_mem_lock s = Some p;\n     (\\<forall>x xa.\n         xa \\<in> W (s x) \\<or>\n         sys_mem_lock s \\<noteq> Some x \\<and>\n         xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n         marked xa s) \\<and>\n     (\\<forall>x xa.\n         x \\<noteq> xa \\<longrightarrow>\n         (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n         (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n         {}) \\<and>\n     (\\<forall>x xa xb.\n         \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                 xb \\<in> W (s xa))) \\<and>\n     sys_ghost_honorary_grey s = {} \\<and>\n     (\\<forall>x xa xb.\n         mw_Mark xa xb\n         \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n         xb = sys_fM s \\<and>\n         xa \\<in> ghost_honorary_grey (s x) \\<and>\n         sys_mem_lock s = Some x \\<and>\n         white xa s \\<and>\n         filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb]);\n     p0 \\<noteq> p1\\<rbrakk>\n    \\<Longrightarrow> (W ((s(p := s p\n                               \\<lparr>ghost_honorary_grey := {y}\\<rparr>))\n                           p0) \\<union>\n                       ghost_honorary_grey\n                        ((s(p := s p\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>))\n                          p0)) \\<inter>\n                      (W ((s(p := s p\n                               \\<lparr>ghost_honorary_grey := {y}\\<rparr>))\n                           p1) \\<union>\n                       ghost_honorary_grey\n                        ((s(p := s p\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>))\n                          p1)) =\n                      {}", "by (auto 5 5 simp: fun_upd_apply)"], ["", "lemma valid_W_inv_mo_co_mark:\n  \"\\<lbrakk> valid_W_inv s; white y s; sys_mem_lock s = Some p; filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys \\<rbrakk>\n    \\<Longrightarrow> valid_W_inv (s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>, sys := s sys\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(p := sys_mem_store_buffers p s @ [mw_Mark y (sys_fM s)])\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n     filter is_mw_Mark (sys_mem_store_buffers p s) = [];\n     p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> valid_W_inv\n                       (s(p := s p\n                            \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                          sys := s sys\n                            \\<lparr>mem_store_buffers :=\n(mem_store_buffers (s sys))\n(p := sys_mem_store_buffers p s @ [mw_Mark y (sys_fM s)])\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n     filter is_mw_Mark (sys_mem_store_buffers p s) = [];\n     p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\n (p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n  sys := s sys\n    \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n              (p := sys_mem_store_buffers p s @\n                    [mw_Mark y (sys_fM s)])\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                              sys := s sys\n                                \\<lparr>mem_store_buffers :=\n    (mem_store_buffers (s sys))\n    (p := sys_mem_store_buffers p s @\n          [mw_Mark y (sys_fM s)])\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\n(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n sys := s sys\n   \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n             (p := sys_mem_store_buffers p s @\n                   [mw_Mark y (sys_fM s)])\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                              sys := s sys\n                                \\<lparr>mem_store_buffers :=\n    (mem_store_buffers (s sys))\n    (p := sys_mem_store_buffers p s @\n          [mw_Mark y (sys_fM s)])\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                              sys := s sys\n                                \\<lparr>mem_store_buffers :=\n    (mem_store_buffers (s sys))\n    (p := sys_mem_store_buffers p s @\n          [mw_Mark y (sys_fM s)])\\<rparr>)) \\<inter>\n                          WL xa\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                              sys := s sys\n                                \\<lparr>mem_store_buffers :=\n    (mem_store_buffers (s sys))\n    (p := sys_mem_store_buffers p s @ [mw_Mark y (sys_fM s)])\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n          sys := s sys\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                      (p := sys_mem_store_buffers p s @\n                            [mw_Mark y (sys_fM s)])\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n          sys := s sys\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                      (p := sys_mem_store_buffers p s @\n                            [mw_Mark y (sys_fM s)])\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s(p := s p\n                            \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                          sys := s sys\n                            \\<lparr>mem_store_buffers :=\n(mem_store_buffers (s sys))\n(p := sys_mem_store_buffers p s @ [mw_Mark y (sys_fM s)])\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n               (p := sys_mem_store_buffers p s @\n                     [mw_Mark y (sys_fM s)])\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                              sys := s sys\n                                \\<lparr>mem_store_buffers :=\n    (mem_store_buffers (s sys))\n    (p := sys_mem_store_buffers p s @\n          [mw_Mark y (sys_fM s)])\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\n(p := s p\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n sys := s sys\n   \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n             (p := sys_mem_store_buffers p s @\n                   [mw_Mark y (sys_fM s)])\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                              sys := s sys\n                                \\<lparr>mem_store_buffers :=\n    (mem_store_buffers (s sys))\n    (p := sys_mem_store_buffers p s @ [mw_Mark y (sys_fM s)])\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                              sys := s sys\n                                \\<lparr>mem_store_buffers :=\n    (mem_store_buffers (s sys))\n    (p := sys_mem_store_buffers p s @\n          [mw_Mark y (sys_fM s)])\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s(p := s p\n                                  \\<lparr>ghost_honorary_grey :=\n      {y}\\<rparr>,\n                                sys := s sys\n                                  \\<lparr>mem_store_buffers :=\n      (mem_store_buffers (s sys))\n      (p := sys_mem_store_buffers p s @ [mw_Mark y (sys_fM s)])\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (clarsimp simp: all_conj_distrib fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n     filter is_mw_Mark (sys_mem_store_buffers p s) = [];\n     p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s \\<longrightarrow>\n                          marked x s) \\<and>\n                      (\\<forall>x.\n                          x \\<in> W (s p) \\<longrightarrow>\n                          marked x s) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s x) \\<longrightarrow>\n                              marked xa s)) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s \\<longrightarrow>\n                          marked x s) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s x) \\<longrightarrow>\n                              marked xa s)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey :=\n    {y}\\<rparr>)) \\<inter>\n                          WL xa\n                           (s(p := s p\n                                \\<lparr>ghost_honorary_grey :=\n    {y}\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s \\<longrightarrow>\n                          x \\<notin> sys_W s) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s \\<longrightarrow>\n                          x \\<notin> W (s p)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> sys_ghost_honorary_grey\n  s \\<longrightarrow>\n                              xa \\<notin> W (s x))) \\<and>\n                      y \\<notin> sys_W s \\<and>\n                      y \\<notin> W (s p) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          y \\<notin> W (s x)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s x) \\<longrightarrow>\n                              xa \\<notin> sys_W s) \\<and>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s x) \\<longrightarrow>\n                              xa \\<notin> W (s p)) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> p \\<longrightarrow>\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xb.\n                                  xb \\<in> ghost_honorary_grey\n      (s x) \\<longrightarrow>\n                                  xb \\<notin> W (s xa)))) \\<and>\n                      sys_ghost_honorary_grey s = {} \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<in> set (sys_mem_store_buffers p\ns) \\<longrightarrow>\n                          xa = sys_fM s \\<and>\n                          x = y \\<and>\n                          white x s \\<and>\n                          y = x \\<and> sys_fM s = xa) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          (\\<forall>xa xb.\n                              mw_Mark xa xb\n                              \\<notin> set (sys_mem_store_buffers x s)))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<in> sys_W s\\<rbrakk>\n       \\<Longrightarrow> marked x s\n 2. \\<And>x.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<in> W (s p)\\<rbrakk>\n       \\<Longrightarrow> marked x s\n 3. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<noteq> p; x \\<noteq> sys; xa \\<in> W (s x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\n 4. \\<And>x.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<in> sys_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> marked x s\n 5. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<noteq> p; x \\<noteq> sys;\n        xa \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\n 6. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> WL x\n                          (s(p := s p\n                               \\<lparr>ghost_honorary_grey :=\n   {y}\\<rparr>)) \\<inter>\n                         WL xa\n                          (s(p := s p\n                               \\<lparr>ghost_honorary_grey :=\n   {y}\\<rparr>)) =\n                         {}\n 7. \\<And>x.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<in> sys_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> sys_W s\n 8. \\<And>x.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<in> sys_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> W (s p)\n 9. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n        filter is_mw_Mark (sys_mem_store_buffers p s) = []; p \\<noteq> sys;\n        x \\<noteq> p; x \\<noteq> sys;\n        xa \\<in> sys_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> W (s x)\n 10. \\<lbrakk>valid_W_inv s; white y s; sys_mem_lock s = Some p;\n      filter is_mw_Mark (sys_mem_store_buffers p s) = [];\n      p \\<noteq> sys\\<rbrakk>\n     \\<Longrightarrow> y \\<notin> sys_W s\nA total of 22 subgoals...", "apply (auto simp: valid_W_invD valid_W_distinct_simps(3) valid_W_inv_sys_ghg_empty_iff valid_W_invD0 valid_W_inv_ghg_disjoint valid_W_inv_colours)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_W_inv_mo_co_lock:\n  \"\\<lbrakk> valid_W_inv s; sys_mem_lock s = None \\<rbrakk>\n    \\<Longrightarrow> valid_W_inv (s(sys := s sys\\<lparr>mem_lock := Some p\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_W_inv s; sys_mem_lock s = None\\<rbrakk>\n    \\<Longrightarrow> valid_W_inv\n                       (s(sys := s sys\\<lparr>mem_lock := Some p\\<rparr>))", "by (auto simp: valid_W_inv_def fun_upd_apply)"], ["", "(* FIXME some eager rule expects valid_W_inv *)"], ["", "lemma valid_W_inv_mo_co_W:\n  \"\\<lbrakk> valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y}; p \\<noteq> sys \\<rbrakk>\n    \\<Longrightarrow> valid_W_inv (s(p := s p\\<lparr>W := insert y (W (s p)), ghost_honorary_grey := {}\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n     p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> valid_W_inv\n                       (s(p := s p\n                            \\<lparr>W := insert y (W (s p)),\n                               ghost_honorary_grey := {}\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n     p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\n (p := s p\n    \\<lparr>W := insert y (W (s p)), ghost_honorary_grey := {}\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s(p := s p\n                                \\<lparr>W := insert y (W (s p)),\n                                   ghost_honorary_grey :=\n                                     {}\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\n(p := s p\n   \\<lparr>W := insert y (W (s p)), ghost_honorary_grey := {}\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s(p := s p\n                                \\<lparr>W := insert y (W (s p)),\n                                   ghost_honorary_grey :=\n                                     {}\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s(p := s p\n                                \\<lparr>W := insert y (W (s p)),\n                                   ghost_honorary_grey :=\n                                     {}\\<rparr>)) \\<inter>\n                          WL xa\n                           (s(p := s p\n                                \\<lparr>W := insert y (W (s p)),\n                                   ghost_honorary_grey := {}\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s(p := s p\n            \\<lparr>W := insert y (W (s p)),\n               ghost_honorary_grey := {}\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s(p := s p\n            \\<lparr>W := insert y (W (s p)),\n               ghost_honorary_grey := {}\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s(p := s p\n                            \\<lparr>W := insert y (W (s p)),\n                               ghost_honorary_grey := {}\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s(p := s p\n     \\<lparr>W := insert y (W (s p)),\n        ghost_honorary_grey := {}\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s(p := s p\n                                \\<lparr>W := insert y (W (s p)),\n                                   ghost_honorary_grey :=\n                                     {}\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\n(p := s p\n   \\<lparr>W := insert y (W (s p)), ghost_honorary_grey := {}\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s(p := s p\n                                \\<lparr>W := insert y (W (s p)),\n                                   ghost_honorary_grey := {}\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s(p := s p\n                                \\<lparr>W := insert y (W (s p)),\n                                   ghost_honorary_grey :=\n                                     {}\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s(p := s p\n                                  \\<lparr>W := insert y (W (s p)),\n                                     ghost_honorary_grey := {}\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (clarsimp simp: all_conj_distrib valid_W_invD0(2) fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n     p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> W (s p) \\<longrightarrow>\n                          marked x s) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s x) \\<longrightarrow>\n                              marked xa s)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s x) \\<longrightarrow>\n                              marked xa s)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x s \\<inter> WL xa s = {}) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s x) \\<longrightarrow>\n                              xa \\<noteq> y \\<and>\n                              xa \\<notin> W (s p)) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> p \\<longrightarrow>\n                              (\\<forall>xb.\n                                  xb \\<in> ghost_honorary_grey\n      (s x) \\<longrightarrow>\n                                  xb \\<notin> W (s xa)))) \\<and>\n                      sys_ghost_honorary_grey s = {} \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers p s)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> p \\<longrightarrow>\n                          (\\<forall>xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s) \\<longrightarrow>\n                              xb = sys_fM s \\<and>\n                              xa \\<in> ghost_honorary_grey (s x) \\<and>\n                              sys_mem_lock s = Some x \\<and>\n                              white xa s \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s) =\n                              [mw_Mark xa xb]))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<in> W (s p)\\<rbrakk>\n       \\<Longrightarrow> marked x s\n 2. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> p; xa \\<in> W (s x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\n 3. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> p;\n        sys_mem_lock s \\<noteq> Some x \\<and>\n        xa \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\n 4. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> WL x s \\<inter> WL xa s = {}\n 5. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> p;\n        xa \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> y\n 6. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> p;\n        xa \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> W (s p)\n 7. \\<And>x xa xb.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> p; xa \\<noteq> p;\n        xb \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s xa)\n 8. \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n     p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> sys_ghost_honorary_grey s = {}\n 9. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers p s)\n 10. \\<And>x xa xb.\n        \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n         p \\<noteq> sys; x \\<noteq> p;\n         mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s)\\<rbrakk>\n        \\<Longrightarrow> xb = sys_fM s\nA total of 14 subgoals...", "apply (auto simp: valid_W_invD valid_W_invD0(2) valid_W_distinct_simps(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> p;\n        y \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys;\n        mw_Mark x xa \\<in> set (sys_mem_store_buffers p s)\\<rbrakk>\n       \\<Longrightarrow> False", "using valid_W_distinct_simps(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<in> ghost_honorary_grey (?s ?p); valid_W_inv ?s\\<rbrakk>\n  \\<Longrightarrow> (?r \\<in> ghost_honorary_grey (?s ?q)) = (?p = ?q)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys; x \\<noteq> p;\n        y \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys;\n        mw_Mark x xa \\<in> set (sys_mem_store_buffers p s)\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>valid_W_inv s; marked y s; ghost_honorary_grey (s p) = {y};\n        p \\<noteq> sys;\n        mw_Mark x xa \\<in> set (sys_mem_store_buffers p s)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis marked_not_white singletonD valid_W_invD(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_W_inv_mo_co_unlock:\n  \"\\<lbrakk> sys_mem_lock s = Some p; sys_mem_store_buffers p s = [];\n     \\<And>r. r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> marked r s;\n     valid_W_inv s\n   \\<rbrakk> \\<Longrightarrow> valid_W_inv (s(sys := mem_lock_update Map.empty (s sys)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_lock s = Some p; sys_mem_store_buffers p s = [];\n     \\<And>r.\n        r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> marked r s;\n     valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> valid_W_inv\n                       (s(sys := mem_lock_update Map.empty (s sys)))", "unfolding valid_W_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_lock s = Some p; sys_mem_store_buffers p s = [];\n     \\<And>r.\n        r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> marked r s;\n     (\\<forall>x xa.\n         xa \\<in> W (s x) \\<or>\n         sys_mem_lock s \\<noteq> Some x \\<and>\n         xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n         marked xa s) \\<and>\n     (\\<forall>x xa.\n         x \\<noteq> xa \\<longrightarrow>\n         WL x s \\<inter> WL xa s = {}) \\<and>\n     (\\<forall>x xa xb.\n         \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                 xb \\<in> W (s xa))) \\<and>\n     sys_ghost_honorary_grey s = {} \\<and>\n     (\\<forall>x xa xb.\n         mw_Mark xa xb\n         \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n         xb = sys_fM s \\<and>\n         xa \\<in> ghost_honorary_grey (s x) \\<and>\n         sys_mem_lock s = Some x \\<and>\n         white xa s \\<and>\n         filter is_mw_Mark (sys_mem_store_buffers x s) =\n         [mw_Mark xa xb])\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\n (sys := mem_lock_update Map.empty (s sys)))\n x) \\<or>\n                          sys_mem_lock\n                           (s(sys :=\n                                mem_lock_update Map.empty (s sys))) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\n(sys := mem_lock_update Map.empty (s sys)))\nx) \\<longrightarrow>\n                          marked xa\n                           (s(sys :=\n                                mem_lock_update Map.empty (s sys)))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s(sys :=\n                                mem_lock_update Map.empty (s sys))) \\<inter>\n                          WL xa\n                           (s(sys := mem_lock_update Map.empty (s sys))) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s(sys := mem_lock_update Map.empty (s sys))) x) \\<and>\n                                  xb \\<in> W\n      ((s(sys := mem_lock_update Map.empty (s sys))) xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s(sys := mem_lock_update Map.empty (s sys))) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s(sys := mem_lock_update Map.empty (s sys)))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s(sys :=\n                                mem_lock_update Map.empty (s sys))) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\n(sys := mem_lock_update Map.empty (s sys)))\nx) \\<and>\n                          sys_mem_lock\n                           (s(sys := mem_lock_update Map.empty (s sys))) =\n                          Some x \\<and>\n                          white xa\n                           (s(sys :=\n                                mem_lock_update Map.empty (s sys))) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s(sys :=\n                                  mem_lock_update Map.empty (s sys)))) =\n                          [mw_Mark xa xb])", "by (clarsimp simp: fun_upd_apply) (metis emptyE empty_set)"], ["", "lemma (in gc) valid_W_inv[intro]:\n  notes if_split_asm[split del]\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> gc_mark.mark_object_invL \\<^bold>\\<and> gc_W_empty_invL\n       \\<^bold>\\<and> obj_fields_marked_invL\n       \\<^bold>\\<and> sweep_loop_invL \\<^bold>\\<and> tso_lock_invL\n       \\<^bold>\\<and> LSTP valid_W_inv \\<rbrace>\n     gc\n   \\<lbrace> LSTP valid_W_inv \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                gc_mark.mark_object_invL s \\<and>\n                gc_W_empty_invL s \\<and>\n                obj_fields_marked_invL s \\<and>\n                sweep_loop_invL s \\<and>\n                tso_lock_invL s \\<and>\n                valid_W_inv\n                 s\\<down>\\<rbrace> gc \\<lbrace>\\<lambda>s.\n            valid_W_inv s\\<down>\\<rbrace>", "proof(vcg_jackhammer (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (gc_tmp_ref s\\<down> := None)\\<rparr>);\n        taken gc sweep_loop_free s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        \\<forall>x.\n           x \\<notin> gc_refs s\\<down> \\<and>\n           obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        no_grey_refs s\\<down>; gc_W s\\<down> = {};\n        gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_mark s\\<down> = Some (\\<not> gc_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> gc_fM s\\<down>))\n         (gc_tmp_ref s\\<down>) s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (gc_tmp_ref s\\<down> := None)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (sweep_loop_free s s')"], ["proof (state)\nthis:\n  at gc sweep_loop_free s\n  at sys sys.sys_free s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (gc_tmp_ref s\\<down> := None)\\<rparr>)\n  taken gc sweep_loop_free s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  \\<forall>x.\n     x \\<notin> gc_refs s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  no_grey_refs s\\<down>\n  gc_W s\\<down> = {}\n  gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_mark s\\<down> = Some (\\<not> gc_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> gc_fM s\\<down>))\n   (gc_tmp_ref s\\<down>) s\\<down>\n\ngoal (8 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (gc_tmp_ref s\\<down> := None)\\<rparr>);\n        taken gc sweep_loop_free s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        \\<forall>x.\n           x \\<notin> gc_refs s\\<down> \\<and>\n           obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        no_grey_refs s\\<down>; gc_W s\\<down> = {};\n        gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_mark s\\<down> = Some (\\<not> gc_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> gc_fM s\\<down>))\n         (gc_tmp_ref s\\<down>) s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (gc_tmp_ref s\\<down> := None)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc sweep_loop_free s\n  at sys sys.sys_free s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (gc_tmp_ref s\\<down> := None)\\<rparr>)\n  taken gc sweep_loop_free s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  \\<forall>x.\n     x \\<notin> gc_refs s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  no_grey_refs s\\<down>\n  gc_W s\\<down> = {}\n  gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_mark s\\<down> = Some (\\<not> gc_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> gc_fM s\\<down>))\n   (gc_tmp_ref s\\<down>) s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at gc sweep_loop_free s\n  at sys sys.sys_free s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (gc_tmp_ref s\\<down> := None)\\<rparr>)\n  taken gc sweep_loop_free s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  \\<forall>x.\n     x \\<notin> gc_refs s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  no_grey_refs s\\<down>\n  gc_W s\\<down> = {}\n  gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_mark s\\<down> = Some (\\<not> gc_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> gc_fM s\\<down>))\n   (gc_tmp_ref s\\<down>) s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (sys := s\\<down> sys\n         \\<lparr>heap := (sys_heap s\\<down>)\n                   (gc_tmp_ref s\\<down> := None)\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (gc_tmp_ref s\\<down> := None)\\<rparr>);\n     taken gc sweep_loop_free s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n     \\<forall>x.\n        x \\<notin> gc_refs s\\<down> \\<and>\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        marked x s\\<down>;\n     no_grey_refs s\\<down>; gc_W s\\<down> = {};\n     gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n     gc_ghost_honorary_grey s\\<down> = {};\n     gc_mark s\\<down> = Some (\\<not> gc_fM s\\<down>);\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> gc_fM s\\<down>))\n      (gc_tmp_ref s\\<down>) s\\<down>\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (sys := s\\<down> sys\n    \\<lparr>heap := (sys_heap s\\<down>)\n              (gc_tmp_ref s\\<down> := None)\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>heap := (sys_heap s\\<down>)\n   (gc_tmp_ref s\\<down> := None)\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(sys := s\\<down> sys\n   \\<lparr>heap := (sys_heap s\\<down>)\n             (gc_tmp_ref s\\<down> := None)\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>heap := (sys_heap s\\<down>)\n   (gc_tmp_ref s\\<down> := None)\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>heap := (sys_heap s\\<down>)\n   (gc_tmp_ref s\\<down> := None)\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>heap := (sys_heap s\\<down>)\n   (gc_tmp_ref s\\<down> := None)\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (gc_tmp_ref s\\<down> := None)\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (gc_tmp_ref s\\<down> := None)\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (gc_tmp_ref s\\<down> :=\n  None)\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (sys := s\\<down> sys\n    \\<lparr>heap := (sys_heap s\\<down>)\n              (gc_tmp_ref s\\<down> := None)\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>heap := (sys_heap s\\<down>)\n   (gc_tmp_ref s\\<down> := None)\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(sys := s\\<down> sys\n   \\<lparr>heap := (sys_heap s\\<down>)\n             (gc_tmp_ref s\\<down> := None)\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>heap := (sys_heap s\\<down>)\n   (gc_tmp_ref s\\<down> := None)\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>heap := (sys_heap s\\<down>)\n   (gc_tmp_ref s\\<down> := None)\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (sys := s\\<down> sys\n                                 \\<lparr>heap := (sys_heap s\\<down>)\n     (gc_tmp_ref s\\<down> := None)\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (clarsimp simp: all_conj_distrib white_def valid_W_inv_sys_ghg_empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (gc_tmp_ref s\\<down> := None)\\<rparr>);\n     taken gc sweep_loop_free s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n     \\<forall>x.\n        x \\<notin> gc_refs s\\<down> \\<and>\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        marked x s\\<down>;\n     no_grey_refs s\\<down>; gc_W s\\<down> = {};\n     gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n     gc_ghost_honorary_grey s\\<down> = {};\n     gc_mark s\\<down> = Some (\\<not> gc_fM s\\<down>);\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> gc_fM s\\<down>))\n      (gc_tmp_ref s\\<down>) s\\<down>\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down> \\<and>\n                          x \\<noteq> gc_tmp_ref s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down> \\<and>\n                              xa \\<noteq> gc_tmp_ref s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down> \\<and>\n                              xa \\<noteq> gc_tmp_ref s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x s\\<down> \\<inter> WL xa s\\<down> = {}) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> sys_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xb.\n                                  xb \\<in> ghost_honorary_grey\n      (s\\<down> x) \\<longrightarrow>\n                                  xb \\<notin> W (s\\<down> xa)))) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers sys\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s\\<down>) \\<longrightarrow>\n                              xb = sys_fM s\\<down> \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<and>\n                              sys_mem_lock s\\<down> = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s\\<down>))\n                               xa s\\<down> \\<and>\n                              xa \\<noteq> gc_tmp_ref s\\<down> \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s\\<down>) =\n                              [mw_Mark xa xb]))", "apply (meson disjoint_iff_not_equal no_grey_refsD(1) no_grey_refsD(2) no_grey_refsD(3) valid_W_invE(5))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (sys := s\\<down> sys\n       \\<lparr>heap := (sys_heap s\\<down>)\n                 (gc_tmp_ref s\\<down> := None)\\<rparr>))\n\ngoal (7 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (mark_loop_get_work_load_W s s')"], ["proof (state)\nthis:\n  at gc mark_loop_get_work_load_W s\n  at sys sys.sys_hs_gc_load_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n   sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)\n  taken gc mark_loop_get_work_load_W s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>\n  \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_W s\\<down> = {}\n  gc_ghost_honorary_grey s\\<down> = {}\n\ngoal (7 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc mark_loop_get_work_load_W s\n  at sys sys.sys_hs_gc_load_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n   sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)\n  taken gc mark_loop_get_work_load_W s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>\n  \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_W s\\<down> = {}\n  gc_ghost_honorary_grey s\\<down> = {}", "show ?case"], ["proof (prove)\nusing this:\n  at gc mark_loop_get_work_load_W s\n  at sys sys.sys_hs_gc_load_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n   sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)\n  taken gc mark_loop_get_work_load_W s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>\n  \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_W s\\<down> = {}\n  gc_ghost_honorary_grey s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n       sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc mark_loop_get_work_load_W s;\n     at sys sys.sys_hs_gc_load_W s;\n     s'\\<down> = s\\<down>\n     (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n      sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n     taken gc mark_loop_get_work_load_W s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     valid_W_inv s\\<down>;\n     sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n     \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n     gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n  sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (gc := s\\<down> gc\n                           \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n  sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (gc := s\\<down> gc\n                                 \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                               sys := s\\<down> sys\n                                 \\<lparr>W := {}\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (clarsimp simp: all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc mark_loop_get_work_load_W s;\n     at sys sys.sys_hs_gc_load_W s;\n     s'\\<down> = s\\<down>\n     (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n      sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n     taken gc mark_loop_get_work_load_W s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     valid_W_inv s\\<down>;\n     sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n     \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n     gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          sys_mem_lock s\\<down> \\<noteq> Some sys \\<and>\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          (case x of\n                           mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                           | gc \\<Rightarrow>\n                               WL gc s\\<down> \\<union> sys_W s\\<down>\n                           | sys \\<Rightarrow>\n                               sys_ghost_honorary_grey s\\<down>) \\<inter>\n                          (case xa of\n                           mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                           | gc \\<Rightarrow>\n                               WL gc s\\<down> \\<union> sys_W s\\<down>\n                           | sys \\<Rightarrow>\n                               sys_ghost_honorary_grey s\\<down>) =\n                          {}) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          x \\<notin> sys_W s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> sys_ghost_honorary_grey\n  s\\<down> \\<longrightarrow>\n                              xa \\<notin> W (s\\<down> x))) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> sys_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> gc \\<longrightarrow>\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xaa.\n                                  xaa\n                                  \\<in> ghost_honorary_grey\n   (s\\<down> x) \\<longrightarrow>\n                                  xaa \\<notin> W (s\\<down> xa)))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<in> set (sys_mem_store_buffers sys\ns\\<down>) \\<longrightarrow>\n                          xa = sys_fM s\\<down> \\<and>\n                          x \\<in> sys_ghost_honorary_grey s\\<down> \\<and>\n                          sys_mem_lock s\\<down> = Some sys \\<and>\n                          white x s\\<down> \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers sys s\\<down>) =\n                          [mw_Mark x xa]) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers gc\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa xaa.\n                              mw_Mark xa xaa\n                              \\<in> set (sys_mem_store_buffers x\n    s\\<down>) \\<longrightarrow>\n                              xaa = sys_fM s\\<down> \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<and>\n                              sys_mem_lock s\\<down> = Some x \\<and>\n                              white xa s\\<down> \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s\\<down>) =\n                              [mw_Mark xa xaa]))", "apply (intro allI conjI impI; auto dest: valid_W_invD0 valid_W_invD simp: valid_W_distinct_simps split: if_splits process_name.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n     sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n\ngoal (6 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (mark_loop_blacken s s')"], ["proof (state)\nthis:\n  at gc mark_loop_blacken s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\n     \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)\n  taken gc mark_loop_blacken s'\n  \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  gc_field_set s\\<down> = {}\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_ghost_honorary_grey s\\<down> = {}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n\ngoal (6 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; gc_field_set s\\<down> = {};\n        sys_mem_lock s\\<down> \\<noteq> Some gc;\n        gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc mark_loop_blacken s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\n     \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)\n  taken gc mark_loop_blacken s'\n  \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  gc_field_set s\\<down> = {}\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_ghost_honorary_grey s\\<down> = {}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at gc mark_loop_blacken s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\n     \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)\n  taken gc mark_loop_blacken s'\n  \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  gc_field_set s\\<down> = {}\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_ghost_honorary_grey s\\<down> = {}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (gc := s\\<down> gc\n         \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc mark_loop_blacken s;\n     s'\\<down> = s\\<down>\n     (gc := s\\<down> gc\n        \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n     taken gc mark_loop_blacken s';\n     \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''; valid_W_inv s\\<down>;\n     gc_field_set s\\<down> = {}; sys_mem_lock s\\<down> \\<noteq> Some gc;\n     gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n     gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (gc := s\\<down> gc\n    \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W :=\n   gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(gc := s\\<down> gc\n   \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W :=\n   gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W :=\n   gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W :=\n   gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (gc := s\\<down> gc\n                           \\<lparr>W := gc_W s\\<down> -\n  {gc_tmp_ref s\\<down>}\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (gc := s\\<down> gc\n    \\<lparr>W := gc_W s\\<down> -\n                 {gc_tmp_ref s\\<down>}\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W :=\n   gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(gc := s\\<down> gc\n   \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W :=\n   gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W :=\n   gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (gc := s\\<down> gc\n                                 \\<lparr>W :=\n     gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (clarsimp simp: all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc mark_loop_blacken s;\n     s'\\<down> = s\\<down>\n     (gc := s\\<down> gc\n        \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n     taken gc mark_loop_blacken s';\n     \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''; valid_W_inv s\\<down>;\n     gc_field_set s\\<down> = {}; sys_mem_lock s\\<down> \\<noteq> Some gc;\n     gc_ghost_honorary_grey s\\<down> = {}; obj_fields_marked s\\<down>;\n     gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> gc_W s\\<down> \\<and>\n                          x \\<noteq> gc_tmp_ref s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          (WL x s\\<down> -\n                           {uu_.\n                            uu_ = gc_tmp_ref s\\<down> \\<and>\n                            x = gc}) \\<inter>\n                          (WL xa s\\<down> -\n                           {uu_.\n                            uu_ = gc_tmp_ref s\\<down> \\<and> xa = gc}) =\n                          {}) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<in> gc_W s\\<down> \\<longrightarrow>\n                              xa = gc_tmp_ref s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> gc \\<longrightarrow>\n                              (\\<forall>xb.\n                                  xb \\<in> ghost_honorary_grey\n      (s\\<down> x) \\<longrightarrow>\n                                  xb \\<notin> W (s\\<down> xa)))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers gc\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          (\\<forall>xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s\\<down>) \\<longrightarrow>\n                              xb = sys_fM s\\<down> \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<and>\n                              sys_mem_lock s\\<down> = Some x \\<and>\n                              white xa s\\<down> \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s\\<down>) =\n                              [mw_Mark xa xb]))", "apply (intro allI conjI impI; auto dest: valid_W_invD0 valid_W_invD simp: valid_W_distinct_simps split: if_splits process_name.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (gc := s\\<down> gc\n       \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (mark_loop_mo_co_W s s' y)"], ["proof (state)\nthis:\n  at gc mark_loop_mo_co_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\n     \\<lparr>W := insert y (gc_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken gc mark_loop_mo_co_W s'\n  \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {y}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers gc s\\<down>) =\n  []\n\ngoal (5 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := insert y (gc_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken gc mark_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> \\<noteq> Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {y}; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers gc s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := insert y (gc_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc mark_loop_mo_co_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\n     \\<lparr>W := insert y (gc_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken gc mark_loop_mo_co_W s'\n  \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {y}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers gc s\\<down>) =\n  []", "show ?case"], ["proof (prove)\nusing this:\n  at gc mark_loop_mo_co_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\n     \\<lparr>W := insert y (gc_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken gc mark_loop_mo_co_W s'\n  \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {y}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers gc s\\<down>) =\n  []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (gc := s\\<down> gc\n         \\<lparr>W := insert y (gc_W s\\<down>),\n            ghost_honorary_grey := {}\\<rparr>))", "by - (erule valid_W_inv_mo_co_W; blast)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (gc := s\\<down> gc\n       \\<lparr>W := insert y (gc_W s\\<down>),\n          ghost_honorary_grey := {}\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (mark_loop_mo_co_unlock s s' y)"], ["proof (state)\nthis:\n  at gc mark_loop_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken gc mark_loop_mo_co_unlock s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_store_buffers gc s\\<down> = []\n  sys_mem_lock s\\<down> = Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  if gc_cas_mark s\\<down> = gc_mark s\\<down>\n  then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n  else gc_ghost_honorary_grey s\\<down> = {}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (4 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_unlock s; at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken gc mark_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_store_buffers gc s\\<down> = [];\n        sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        if gc_cas_mark s\\<down> = gc_mark s\\<down>\n        then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n        else gc_ghost_honorary_grey s\\<down> = {};\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_ref s\\<down> = Some y; gc_fM s\\<down> = sys_fM s\\<down>;\n        marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc mark_loop_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken gc mark_loop_mo_co_unlock s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_store_buffers gc s\\<down> = []\n  sys_mem_lock s\\<down> = Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  if gc_cas_mark s\\<down> = gc_mark s\\<down>\n  then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n  else gc_ghost_honorary_grey s\\<down> = {}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at gc mark_loop_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken gc mark_loop_mo_co_unlock s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_store_buffers gc s\\<down> = []\n  sys_mem_lock s\\<down> = Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  if gc_cas_mark s\\<down> = gc_mark s\\<down>\n  then gc_ghost_honorary_grey s\\<down> = {gc_the_ref s\\<down>}\n  else gc_ghost_honorary_grey s\\<down> = {}\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))", "by - (erule valid_W_inv_mo_co_unlock; simp split: if_splits)"], ["proof (state)\nthis:\n  valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))\n\ngoal (3 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (mark_loop_mo_co_mark s s' y)"], ["proof (state)\nthis:\n  at gc mark_loop_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc :=\n                  sys_mem_store_buffers gc s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken gc mark_loop_mo_co_mark s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_cas_mark s\\<down> = gc_mark s\\<down>\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\n\ngoal (3 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = Some gc;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        gc_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (gc :=\n     sys_mem_store_buffers gc s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc mark_loop_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc :=\n                  sys_mem_store_buffers gc s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken gc mark_loop_mo_co_mark s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_cas_mark s\\<down> = gc_mark s\\<down>\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at gc mark_loop_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc :=\n                  sys_mem_store_buffers gc s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken gc mark_loop_mo_co_mark s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some gc\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_cas_mark s\\<down> = gc_mark s\\<down>\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_ref s\\<down> = Some y\n  gc_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (gc :=\n                      sys_mem_store_buffers gc s\\<down> @\n                      [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))", "by - (erule valid_W_inv_mo_co_mark; blast)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (gc :=\n                    sys_mem_store_buffers gc s\\<down> @\n                    [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (mark_loop_mo_co_lock s s' y)"], ["proof (state)\nthis:\n  at gc mark_loop_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>)\n  taken gc mark_loop_mo_co_lock s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = None\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_ref s\\<down> = Some y\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  gc_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\n\ngoal (2 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_lock s; at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>);\n        taken gc mark_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>; sys_mem_lock s\\<down> = None;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {}; gc_ref s\\<down> = Some y;\n        obj_fields_marked s\\<down>; gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some gc\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc mark_loop_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>)\n  taken gc mark_loop_mo_co_lock s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = None\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_ref s\\<down> = Some y\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  gc_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at gc mark_loop_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>)\n  taken gc mark_loop_mo_co_lock s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = None\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>\n  \\<forall>x.\n     (y reaches x) s\\<down> \\<longrightarrow>\n     obj_at (\\<lambda>s. True) x s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  gc_ref s\\<down> = Some y\n  obj_fields_marked s\\<down>\n  gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\n  gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  gc_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>(sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>))", "by - (erule valid_W_inv_mo_co_lock; assumption+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>(sys := s\\<down> sys\\<lparr>mem_lock := Some gc\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (mark_loop_get_roots_load_W s s')"], ["proof (state)\nthis:\n  at gc mark_loop_get_roots_load_W s\n  at sys sys.sys_hs_gc_load_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n   sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)\n  taken gc mark_loop_get_roots_load_W s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>\n  \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_W s\\<down> = {}\n  gc_ghost_honorary_grey s\\<down> = {}\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc mark_loop_get_roots_load_W s\n  at sys sys.sys_hs_gc_load_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n   sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)\n  taken gc mark_loop_get_roots_load_W s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>\n  \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_W s\\<down> = {}\n  gc_ghost_honorary_grey s\\<down> = {}", "show ?case"], ["proof (prove)\nusing this:\n  at gc mark_loop_get_roots_load_W s\n  at sys sys.sys_hs_gc_load_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n   sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)\n  taken gc mark_loop_get_roots_load_W s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>\n  \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_W s\\<down> = {}\n  gc_ghost_honorary_grey s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n       sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "(* FIXME ran out of patience. Something makes auto diverge on some subgoals *)"], ["proof (prove)\nusing this:\n  at gc mark_loop_get_roots_load_W s\n  at sys sys.sys_hs_gc_load_W s\n  s'\\<down> = s\\<down>\n  (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n   sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)\n  taken gc mark_loop_get_roots_load_W s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  valid_W_inv s\\<down>\n  sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>\n  \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some gc\n  gc_W s\\<down> = {}\n  gc_ghost_honorary_grey s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n       sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n     at sys sys.sys_hs_gc_load_W s;\n     s'\\<down> = s\\<down>\n     (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n      sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n     taken gc mark_loop_get_roots_load_W s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     valid_W_inv s\\<down>;\n     sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n     \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n     gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n  sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (gc := s\\<down> gc\n                           \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n  sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\\<lparr>W := {}\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (gc := s\\<down> gc\n                               \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>W := {}\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (gc := s\\<down> gc\n                                 \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                               sys := s\\<down> sys\n                                 \\<lparr>W := {}\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (clarsimp simp: all_conj_distrib valid_W_inv_sys_ghg_empty_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n     at sys sys.sys_hs_gc_load_W s;\n     s'\\<down> = s\\<down>\n     (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n      sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n     taken gc mark_loop_get_roots_load_W s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     valid_W_inv s\\<down>;\n     sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n     \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n     gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          (case x of\n                           mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                           | gc \\<Rightarrow>\n                               WL gc s\\<down> \\<union> sys_W s\\<down>\n                           | sys \\<Rightarrow> {}) \\<inter>\n                          (case xa of\n                           mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                           | gc \\<Rightarrow>\n                               WL gc s\\<down> \\<union> sys_W s\\<down>\n                           | sys \\<Rightarrow> {}) =\n                          {}) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> sys_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> gc \\<longrightarrow>\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xaa.\n                                  xaa\n                                  \\<in> ghost_honorary_grey\n   (s\\<down> x) \\<longrightarrow>\n                                  xaa \\<notin> W (s\\<down> xa)))) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers sys\n   s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers gc\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> gc \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa xaa.\n                              mw_Mark xa xaa\n                              \\<in> set (sys_mem_store_buffers x\n    s\\<down>) \\<longrightarrow>\n                              xaa = sys_fM s\\<down> \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<and>\n                              sys_mem_lock s\\<down> = Some x \\<and>\n                              white xa s\\<down> \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s\\<down>) =\n                              [mw_Mark xa xaa]))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {};\n        x \\<in> sys_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> marked x s\\<down>\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> W (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\\<down>\n 3. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\\<down>\n 4. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) \\<inter>\n                         (case xa of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) =\n                         {}\n 5. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<noteq> gc; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 7. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 8. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 9. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 10. \\<And>x xa xb.\n        \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n         at sys sys.sys_hs_gc_load_W s;\n         s'\\<down> = s\\<down>\n         (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n          sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n         taken gc mark_loop_get_roots_load_W s';\n         \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n         valid_W_inv s\\<down>;\n         sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n         \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n         gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc;\n         x \\<noteq> sys;\n         mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n        \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\nA total of 13 subgoals...", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> W (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\\<down>\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\\<down>\n 3. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) \\<inter>\n                         (case xa of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) =\n                         {}\n 4. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 5. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<noteq> gc; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 6. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 7. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 8. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 9. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 10. \\<And>x xa xb.\n        \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n         at sys sys.sys_hs_gc_load_W s;\n         s'\\<down> = s\\<down>\n         (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n          sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n         taken gc mark_loop_get_roots_load_W s';\n         \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n         valid_W_inv s\\<down>;\n         sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n         \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n         gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc;\n         x \\<noteq> sys;\n         mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n        \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\nA total of 12 subgoals...", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\\<down>\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) \\<inter>\n                         (case xa of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) =\n                         {}\n 3. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 4. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<noteq> gc; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 5. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 6. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 7. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 8. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 9. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 10. \\<And>x xa xb.\n        \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n         at sys sys.sys_hs_gc_load_W s;\n         s'\\<down> = s\\<down>\n         (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n          sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n         taken gc mark_loop_get_roots_load_W s';\n         \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n         valid_W_inv s\\<down>;\n         sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n         \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n         gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc;\n         x \\<noteq> sys;\n         mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n        \\<Longrightarrow> white xa s\\<down>\nA total of 11 subgoals...", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) \\<inter>\n                         (case xa of\n                          mutator m \\<Rightarrow> WL (mutator m) s\\<down>\n                          | gc \\<Rightarrow>\n                              WL gc s\\<down> \\<union> sys_W s\\<down>\n                          | sys \\<Rightarrow> {}) =\n                         {}\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<noteq> gc; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 4. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 5. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 7. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 8. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 9. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 10. \\<And>x xa xb.\n        \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n         at sys sys.sys_hs_gc_load_W s;\n         s'\\<down> = s\\<down>\n         (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n          sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n         taken gc mark_loop_get_roots_load_W s';\n         \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n         valid_W_inv s\\<down>;\n         sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n         \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n         gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc;\n         x \\<noteq> sys;\n         mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n        \\<Longrightarrow> filter is_mw_Mark\n                           (sys_mem_store_buffers x s\\<down>) =\n                          [mw_Mark xa xb]", "apply (clarsimp split: process_name.splits)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1.\n                             x = mutator x1 \\<longrightarrow>\n                             (\\<forall>x1a.\n                                 xa = mutator x1a \\<longrightarrow>\n                                 WL (mutator x1) s\\<down> \\<inter>\n                                 WL (mutator x1a) s\\<down> =\n                                 {}) \\<and>\n                             (xa = gc \\<longrightarrow>\n                              WL (mutator x1) s\\<down> \\<inter>\n                              (WL gc s\\<down> \\<union> sys_W s\\<down>) =\n                              {})) \\<and>\n                         (x = gc \\<longrightarrow>\n                          (\\<forall>x1.\n                              xa = mutator x1 \\<longrightarrow>\n                              (WL gc s\\<down> \\<union>\n                               sys_W s\\<down>) \\<inter>\n                              WL (mutator x1) s\\<down> =\n                              {}) \\<and>\n                          (xa = gc \\<longrightarrow>\n                           WL gc s\\<down> = {} \\<and> sys_W s\\<down> = {}))\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<noteq> gc; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 4. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 5. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 7. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 8. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 9. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 10. \\<And>x xa xb.\n        \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n         at sys sys.sys_hs_gc_load_W s;\n         s'\\<down> = s\\<down>\n         (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n          sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n         taken gc mark_loop_get_roots_load_W s';\n         \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n         valid_W_inv s\\<down>;\n         sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n         \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n         gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc;\n         x \\<noteq> sys;\n         mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n        \\<Longrightarrow> filter is_mw_Mark\n                           (sys_mem_store_buffers x s\\<down>) =\n                          [mw_Mark xa xb]", "apply (meson Int_emptyI Un_iff process_name.distinct(4) valid_W_distinct_simps(3) valid_W_invD0(1))"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\n 2. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<noteq> gc; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 3. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 4. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 5. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 7. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 8. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 9. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        xa \\<noteq> gc; xa \\<noteq> sys;\n        xb \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> W (s\\<down> xa)\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 3. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 4. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 5. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 7. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 8. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 4. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 5. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 7. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "using valid_W_invD(2) valid_W_inv_sys_ghg_empty_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>mw_Mark ?r ?fl \\<in> set (sys_mem_store_buffers ?p ?s);\n   valid_W_inv ?s\\<rbrakk>\n  \\<Longrightarrow> ?fl = sys_fM ?s \\<and>\n                    ?r \\<in> ghost_honorary_grey (?s ?p) \\<and>\n                    sys_mem_lock ?s = Some ?p \\<and>\n                    white ?r ?s \\<and>\n                    filter is_mw_Mark (sys_mem_store_buffers ?p ?s) =\n                    [mw_Mark ?r ?fl]\n  valid_W_inv ?s \\<Longrightarrow> sys_ghost_honorary_grey ?s = {}\n\ngoal (7 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers sys s\\<down>)\n 2. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 4. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 5. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 7. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply fastforce"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> mw_Mark x xa\n                         \\<notin> set (sys_mem_store_buffers gc s\\<down>)\n 2. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 4. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 5. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 6. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xb = sys_fM s\\<down>\n 2. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 4. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 5. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ghost_honorary_grey (s\\<down> x)\n 2. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 4. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> sys_mem_lock s\\<down> = Some x\n 2. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 3. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> white xa s\\<down>\n 2. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some gc; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {}; x \\<noteq> gc; x \\<noteq> sys;\n        mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> filter is_mw_Mark\n                          (sys_mem_store_buffers x s\\<down>) =\n                         [mw_Mark xa xb]", "apply (auto simp: valid_W_invD valid_W_invD0 valid_W_inv_sys_ghg_empty_iff split: process_name.splits; fail)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n     sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in mut_m) valid_W_inv[intro]:\n  notes if_split_asm[split del]\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> handshake_invL \\<^bold>\\<and> mark_object_invL \\<^bold>\\<and> tso_lock_invL\n      \\<^bold>\\<and> mut_get_roots.mark_object_invL m\n      \\<^bold>\\<and> mut_store_del.mark_object_invL m\n      \\<^bold>\\<and> mut_store_ins.mark_object_invL m\n       \\<^bold>\\<and> LSTP (fM_rel_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     mutator m\n   \\<lbrace> LSTP valid_W_inv \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                handshake_invL s \\<and>\n                mark_object_invL s \\<and>\n                tso_lock_invL s \\<and>\n                mut_get_roots.mark_object_invL m s \\<and>\n                mut_store_del.mark_object_invL m s \\<and>\n                mut_store_ins.mark_object_invL m s \\<and>\n                fM_rel_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv\n                 s\\<down>\\<rbrace> mutator\n                                    m \\<lbrace>\\<lambda>s.\n            valid_W_inv s\\<down>\\<rbrace>", "proof(vcg_jackhammer (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>s p's' s' opt_r.\n       \\<lbrakk>at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>roots :=\n                     mut_roots s\\<down> \\<union> set_option opt_r\\<rparr>,\n         sys := p's');\n        taken (mutator m) Proofs_Basis.mut_m.alloc s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        (p's', mv_Ref opt_r)\n        \\<in> (if {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV\n               then {uu_. uu_ = (s\\<down> sys, mv_Ref None)}\n               else {(s\\<down> sys\n                      \\<lparr>heap := sys_heap s\\<down>(r \\<mapsto>\n                                \\<lparr>obj_mark = sys_fA s\\<down>,\n                                   obj_fields = Map.empty,\n                                   obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                      mv_Ref (Some r)) |\n                     r. r \\<notin> dom (sys_heap s\\<down>)});\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>roots :=\n  mut_roots s\\<down> \\<union> set_option opt_r\\<rparr>,\n                            sys := p's'))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_ins_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {y}; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 10. \\<And>s s'.\n        \\<lbrakk>at (mutator m) hs_get_work_done s;\n         at sys sys.sys_hs_mut_done s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                      (m := False),\n               W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n               ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                 (m := True)\\<rparr>);\n         taken (mutator m) hs_get_work_done s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetWork;\n         mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>))\nA total of 15 subgoals...", "case (alloc s s' r)"], ["proof (state)\nthis:\n  at (mutator m) Proofs_Basis.mut_m.alloc s\n  at sys Proofs_Basis.sys.alloc s\n  r\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>roots := mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n   sys := s')\n  taken (mutator m) Proofs_Basis.mut_m.alloc r\n  \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p''\n  (s', mv_Ref opt_r_)\n  \\<in> (if {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV\n         then {uu_. uu_ = (s\\<down> sys, mv_Ref None)}\n         else {(s\\<down> sys\n                \\<lparr>heap := sys_heap s\\<down>(r \\<mapsto>\n                          \\<lparr>obj_mark = sys_fA s\\<down>,\n                             obj_fields = Map.empty,\n                             obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                mv_Ref (Some r)) |\n               r. r \\<notin> dom (sys_heap s\\<down>)})\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (15 subgoals):\n 1. \\<And>s p's' s' opt_r.\n       \\<lbrakk>at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>roots :=\n                     mut_roots s\\<down> \\<union> set_option opt_r\\<rparr>,\n         sys := p's');\n        taken (mutator m) Proofs_Basis.mut_m.alloc s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        (p's', mv_Ref opt_r)\n        \\<in> (if {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV\n               then {uu_. uu_ = (s\\<down> sys, mv_Ref None)}\n               else {(s\\<down> sys\n                      \\<lparr>heap := sys_heap s\\<down>(r \\<mapsto>\n                                \\<lparr>obj_mark = sys_fA s\\<down>,\n                                   obj_fields = Map.empty,\n                                   obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                      mv_Ref (Some r)) |\n                     r. r \\<notin> dom (sys_heap s\\<down>)});\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>roots :=\n  mut_roots s\\<down> \\<union> set_option opt_r\\<rparr>,\n                            sys := p's'))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_ins_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {y}; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 10. \\<And>s s'.\n        \\<lbrakk>at (mutator m) hs_get_work_done s;\n         at sys sys.sys_hs_mut_done s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                      (m := False),\n               W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n               ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                 (m := True)\\<rparr>);\n         taken (mutator m) hs_get_work_done s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetWork;\n         mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>))\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  at (mutator m) Proofs_Basis.mut_m.alloc s\n  at sys Proofs_Basis.sys.alloc s\n  r\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>roots := mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n   sys := s')\n  taken (mutator m) Proofs_Basis.mut_m.alloc r\n  \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p''\n  (s', mv_Ref opt_r_)\n  \\<in> (if {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV\n         then {uu_. uu_ = (s\\<down> sys, mv_Ref None)}\n         else {(s\\<down> sys\n                \\<lparr>heap := sys_heap s\\<down>(r \\<mapsto>\n                          \\<lparr>obj_mark = sys_fA s\\<down>,\n                             obj_fields = Map.empty,\n                             obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                mv_Ref (Some r)) |\n               r. r \\<notin> dom (sys_heap s\\<down>)})\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) Proofs_Basis.mut_m.alloc s\n  at sys Proofs_Basis.sys.alloc s\n  r\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>roots := mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n   sys := s')\n  taken (mutator m) Proofs_Basis.mut_m.alloc r\n  \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p''\n  (s', mv_Ref opt_r_)\n  \\<in> (if {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV\n         then {uu_. uu_ = (s\\<down> sys, mv_Ref None)}\n         else {(s\\<down> sys\n                \\<lparr>heap := sys_heap s\\<down>(r \\<mapsto>\n                          \\<lparr>obj_mark = sys_fA s\\<down>,\n                             obj_fields = Map.empty,\n                             obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                mv_Ref (Some r)) |\n               r. r \\<notin> dom (sys_heap s\\<down>)})\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>roots :=\n                   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n       sys := s'))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at (mutator m) Proofs_Basis.mut_m.alloc s;\n     at sys Proofs_Basis.sys.alloc s;\n     r\\<down> = s\\<down>\n     (mutator m := s\\<down> (mutator m)\n        \\<lparr>roots :=\n                  mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n      sys := s');\n     taken (mutator m) Proofs_Basis.mut_m.alloc r;\n     \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n     (s', mv_Ref opt_r_)\n     \\<in> (if {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV\n            then {uu_. uu_ = (s\\<down> sys, mv_Ref None)}\n            else {(s\\<down> sys\n                   \\<lparr>heap := sys_heap s\\<down>(r \\<mapsto>\n                             \\<lparr>obj_mark = sys_fA s\\<down>,\n                                obj_fields = Map.empty,\n                                obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                   mv_Ref (Some r)) |\n                  r. r \\<notin> dom (sys_heap s\\<down>)});\n     fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n     mut_ghost_honorary_grey s\\<down> = {};\n     mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (mutator m := s\\<down> (mutator m)\n    \\<lparr>roots := mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n  sys := s'))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                             sys := s')) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(mutator m := s\\<down> (mutator m)\n   \\<lparr>roots := mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n sys := s'))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                             sys := s'))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                             sys := s')) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                             sys := s')) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>roots :=\n                     mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n         sys := s'))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>roots :=\n                     mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n         sys := s'))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (mutator m := s\\<down> (mutator m)\n                           \\<lparr>roots :=\n                                     mut_roots s\\<down> \\<union>\n                                     set_option opt_r_\\<rparr>,\n                         sys := s')) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (mutator m := s\\<down> (mutator m)\n    \\<lparr>roots := mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n  sys := s'))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                             sys := s')) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(mutator m := s\\<down> (mutator m)\n   \\<lparr>roots := mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n sys := s'))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                             sys := s')) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                             sys := s')) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (mutator m := s\\<down> (mutator m)\n                                 \\<lparr>roots :=\n     mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n                               sys := s'))) =\n                          [mw_Mark xa xb])", "apply (clarsimp simp: all_conj_distrib split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n     mut_ghost_honorary_grey s\\<down> = {};\n     mut_ghost_honorary_root s\\<down> = {};\n     at (mutator m) Proofs_Basis.mut_m.alloc s;\n     at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n     taken (mutator m) Proofs_Basis.mut_m.alloc r;\n     \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n     {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n     s' = s\\<down> sys; opt_r_ = None\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<in> mut_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          sys_mem_lock s\\<down> \\<noteq> Some sys \\<and>\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x s\\<down> \\<inter> WL xa s\\<down> = {}) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          x \\<notin> sys_W s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          x \\<notin> mut_W s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> sys_ghost_honorary_grey\n  s\\<down> \\<longrightarrow>\n                              xa \\<notin> W (s\\<down> x))) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> sys_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> mut_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> mutator m \\<longrightarrow>\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xb.\n                                  xb \\<in> ghost_honorary_grey\n      (s\\<down> x) \\<longrightarrow>\n                                  xb \\<notin> W (s\\<down> xa)))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<in> set (sys_mem_store_buffers sys\ns\\<down>) \\<longrightarrow>\n                          xa = sys_fM s\\<down> \\<and>\n                          x \\<in> sys_ghost_honorary_grey s\\<down> \\<and>\n                          sys_mem_lock s\\<down> = Some sys \\<and>\n                          white x s\\<down> \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers sys s\\<down>) =\n                          [mw_Mark x xa]) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers (mutator m)\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s\\<down>) \\<longrightarrow>\n                              xb = sys_fM s\\<down> \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<and>\n                              sys_mem_lock s\\<down> = Some x \\<and>\n                              white xa s\\<down> \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s\\<down>) =\n                              [mw_Mark xa xb]))\n 2. \\<And>ra.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s;\n        r\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>roots := insert ra (mut_roots s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>heap := sys_heap s\\<down>(ra \\<mapsto>\n                     \\<lparr>obj_mark = sys_fA s\\<down>,\n                        obj_fields = Map.empty,\n                        obj_payload = Map.empty\\<rparr>)\\<rparr>);\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} \\<noteq> UNIV;\n        s' = s\\<down> sys\n        \\<lparr>heap := sys_heap s\\<down>(ra \\<mapsto>\n                  \\<lparr>obj_mark = sys_fA s\\<down>,\n                     obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>;\n        sys_heap s\\<down> ra = None; opt_r_ = Some ra\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             x \\<in> sys_W s\\<down> \\<longrightarrow>\n                             marked x s\\<down> \\<or>\n                             x = ra \\<and>\n                             sys_fA s\\<down> = sys_fM s\\<down>) \\<and>\n                         (\\<forall>x.\n                             x \\<in> mut_W s\\<down> \\<longrightarrow>\n                             marked x s\\<down> \\<or>\n                             x = ra \\<and>\n                             sys_fA s\\<down> = sys_fM s\\<down>) \\<and>\n                         (\\<forall>x.\n                             x \\<noteq> mutator m \\<longrightarrow>\n                             x \\<noteq> sys \\<longrightarrow>\n                             (\\<forall>xa.\n                                 xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                                 marked xa s\\<down> \\<or>\n                                 xa = ra \\<and>\n                                 sys_fA s\\<down> = sys_fM s\\<down>)) \\<and>\n                         (\\<forall>x.\n                             sys_mem_lock s\\<down> \\<noteq> Some sys \\<and>\n                             x \\<in> sys_ghost_honorary_grey\ns\\<down> \\<longrightarrow>\n                             marked x s\\<down> \\<or>\n                             x = ra \\<and>\n                             sys_fA s\\<down> = sys_fM s\\<down>) \\<and>\n                         (\\<forall>x.\n                             x \\<noteq> mutator m \\<longrightarrow>\n                             x \\<noteq> sys \\<longrightarrow>\n                             (\\<forall>xa.\n                                 sys_mem_lock s\\<down> \\<noteq>\n                                 Some x \\<and>\n                                 xa \\<in> ghost_honorary_grey\n     (s\\<down> x) \\<longrightarrow>\n                                 marked xa s\\<down> \\<or>\n                                 xa = ra \\<and>\n                                 sys_fA s\\<down> = sys_fM s\\<down>)) \\<and>\n                         (\\<forall>x xa.\n                             x \\<noteq> xa \\<longrightarrow>\n                             WL x s\\<down> \\<inter> WL xa s\\<down> =\n                             {}) \\<and>\n                         (\\<forall>x.\n                             x \\<in> sys_ghost_honorary_grey\ns\\<down> \\<longrightarrow>\n                             x \\<notin> sys_W s\\<down>) \\<and>\n                         (\\<forall>x.\n                             x \\<in> sys_ghost_honorary_grey\ns\\<down> \\<longrightarrow>\n                             x \\<notin> mut_W s\\<down>) \\<and>\n                         (\\<forall>x.\n                             x \\<noteq> mutator m \\<longrightarrow>\n                             x \\<noteq> sys \\<longrightarrow>\n                             (\\<forall>xa.\n                                 xa \\<in> sys_ghost_honorary_grey\n     s\\<down> \\<longrightarrow>\n                                 xa \\<notin> W (s\\<down> x))) \\<and>\n                         (\\<forall>x.\n                             x \\<noteq> mutator m \\<longrightarrow>\n                             x \\<noteq> sys \\<longrightarrow>\n                             (\\<forall>xa.\n                                 xa \\<in> ghost_honorary_grey\n     (s\\<down> x) \\<longrightarrow>\n                                 xa \\<notin> sys_W s\\<down>) \\<and>\n                             (\\<forall>xa.\n                                 xa \\<in> ghost_honorary_grey\n     (s\\<down> x) \\<longrightarrow>\n                                 xa \\<notin> mut_W s\\<down>) \\<and>\n                             (\\<forall>xa.\n                                 xa \\<noteq> mutator m \\<longrightarrow>\n                                 xa \\<noteq> sys \\<longrightarrow>\n                                 (\\<forall>xb.\n                                     xb \\<in> ghost_honorary_grey\n         (s\\<down> x) \\<longrightarrow>\n                                     xb \\<notin> W (s\\<down> xa)))) \\<and>\n                         sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                         (\\<forall>x xa.\n                             mw_Mark x xa\n                             \\<in> set (sys_mem_store_buffers sys\n   s\\<down>) \\<longrightarrow>\n                             xa = sys_fM s\\<down> \\<and>\n                             x \\<in> sys_ghost_honorary_grey s\\<down> \\<and>\n                             sys_mem_lock s\\<down> = Some sys \\<and>\n                             (white x s\\<down> \\<or>\n                              ra = x \\<and>\n                              sys_fA s\\<down> =\n                              (\\<not> sys_fM s\\<down>)) \\<and>\n                             filter is_mw_Mark\n                              (sys_mem_store_buffers sys s\\<down>) =\n                             [mw_Mark x xa]) \\<and>\n                         (\\<forall>x xa.\n                             mw_Mark x xa\n                             \\<notin> set\n (sys_mem_store_buffers (mutator m) s\\<down>)) \\<and>\n                         (\\<forall>x.\n                             x \\<noteq> mutator m \\<longrightarrow>\n                             x \\<noteq> sys \\<longrightarrow>\n                             (\\<forall>xa xb.\n                                 mw_Mark xa xb\n                                 \\<in> set\n  (sys_mem_store_buffers x s\\<down>) \\<longrightarrow>\n                                 xb = sys_fM s\\<down> \\<and>\n                                 xa \\<in> ghost_honorary_grey\n     (s\\<down> x) \\<and>\n                                 sys_mem_lock s\\<down> = Some x \\<and>\n                                 (white xa s\\<down> \\<or>\n                                  ra = xa \\<and>\n                                  sys_fA s\\<down> =\n                                  (\\<not> sys_fM s\\<down>)) \\<and>\n                                 filter is_mw_Mark\n                                  (sys_mem_store_buffers x s\\<down>) =\n                                 [mw_Mark xa xb]))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None; x \\<in> sys_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> marked x s\\<down>\n 2. \\<And>x.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None; x \\<in> mut_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> marked x s\\<down>\n 3. \\<And>x xa.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None; x \\<noteq> mutator m;\n        x \\<noteq> sys; xa \\<in> W (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\\<down>\n 4. \\<And>x.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None;\n        sys_mem_lock s\\<down> \\<noteq> Some sys \\<and>\n        x \\<in> sys_ghost_honorary_grey s\\<down>\\<rbrakk>\n       \\<Longrightarrow> marked x s\\<down>\n 5. \\<And>x xa.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None; x \\<noteq> mutator m;\n        x \\<noteq> sys;\n        sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n        xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n       \\<Longrightarrow> marked xa s\\<down>\n 6. \\<And>x xa.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> WL x s\\<down> \\<inter> WL xa s\\<down> = {}\n 7. \\<And>x.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None;\n        x \\<in> sys_ghost_honorary_grey s\\<down>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> sys_W s\\<down>\n 8. \\<And>x.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None;\n        x \\<in> sys_ghost_honorary_grey s\\<down>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> mut_W s\\<down>\n 9. \\<And>x xa.\n       \\<lbrakk>fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        at (mutator m) Proofs_Basis.mut_m.alloc s;\n        at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n        taken (mutator m) Proofs_Basis.mut_m.alloc r;\n        \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n        {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n        s' = s\\<down> sys; opt_r_ = None; x \\<noteq> mutator m;\n        x \\<noteq> sys; xa \\<in> sys_ghost_honorary_grey s\\<down>\\<rbrakk>\n       \\<Longrightarrow> xa \\<notin> W (s\\<down> x)\n 10. \\<And>x xa.\n        \\<lbrakk>fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {};\n         at (mutator m) Proofs_Basis.mut_m.alloc s;\n         at sys Proofs_Basis.sys.alloc s; r\\<down> = s\\<down>;\n         taken (mutator m) Proofs_Basis.mut_m.alloc r;\n         \\<forall>p''\\<in>- {mutator m, sys}. GST r p'' = GST s p'';\n         {a. \\<exists>y. sys_heap s\\<down> a = Some y} = UNIV;\n         s' = s\\<down> sys; opt_r_ = None; x \\<noteq> mutator m;\n         x \\<noteq> sys; xa \\<in> ghost_honorary_grey (s\\<down> x)\\<rbrakk>\n        \\<Longrightarrow> xa \\<notin> sys_W s\\<down>\nA total of 25 subgoals...", "apply (auto simp: valid_W_distinct_simps valid_W_invD0(3) valid_W_invD(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>roots :=\n                 mut_roots s\\<down> \\<union> set_option opt_r_\\<rparr>,\n     sys := s'))\n\ngoal (14 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_ins_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {y}; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 9. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 10. \\<And>s s'.\n        \\<lbrakk>at (mutator m) hs_get_roots_done s;\n         at sys sys.sys_hs_mut_done s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>W := {},\n               ghost_hs_phase :=\n                 hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                      (m := False),\n               W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n               ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                 (m := True)\\<rparr>);\n         taken (mutator m) hs_get_roots_done s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>))\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_ins_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {y}; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 9. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 10. \\<And>s s'.\n        \\<lbrakk>at (mutator m) hs_get_roots_done s;\n         at sys sys.sys_hs_mut_done s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>W := {},\n               ghost_hs_phase :=\n                 hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                      (m := False),\n               W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n               ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                 (m := True)\\<rparr>);\n         taken (mutator m) hs_get_roots_done s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>))\nA total of 14 subgoals...", "case (store_ins_mo_co_W s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_ins_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) store_ins_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {y}\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  mut_new_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n\ngoal (14 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_ins_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {y}; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 9. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 10. \\<And>s s'.\n        \\<lbrakk>at (mutator m) hs_get_roots_done s;\n         at sys sys.sys_hs_mut_done s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>W := {},\n               ghost_hs_phase :=\n                 hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                      (m := False),\n               W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n               ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                 (m := True)\\<rparr>);\n         taken (mutator m) hs_get_roots_done s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>))\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_ins_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) store_ins_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {y}\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  mut_new_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_ins_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) store_ins_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {y}\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  mut_new_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>W := insert y (mut_W s\\<down>),\n            ghost_honorary_grey := {}\\<rparr>))", "by - (erule valid_W_inv_mo_co_W; blast+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>W := insert y (mut_W s\\<down>),\n          ghost_honorary_grey := {}\\<rparr>))\n\ngoal (13 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 9. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>W := insert y (mut_W s\\<down>),\n               ghost_honorary_grey := {}\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_W s';\n         \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_root s\\<down> = {};\n         mut_ghost_honorary_grey s\\<down> = {y};\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := insert y (mut_W s\\<down>),\n                                  ghost_honorary_grey := {}\\<rparr>))\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 9. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>W := insert y (mut_W s\\<down>),\n               ghost_honorary_grey := {}\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_W s';\n         \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_root s\\<down> = {};\n         mut_ghost_honorary_grey s\\<down> = {y};\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := insert y (mut_W s\\<down>),\n                                  ghost_honorary_grey := {}\\<rparr>))\nA total of 13 subgoals...", "case (store_ins_mo_co_unlock s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_ins_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) store_ins_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_new_ref s\\<down> = Some y\n  mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n  sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (13 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_ins_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_new_ref s\\<down> = Some y;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 9. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>W := insert y (mut_W s\\<down>),\n               ghost_honorary_grey := {}\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_W s';\n         \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_root s\\<down> = {};\n         mut_ghost_honorary_grey s\\<down> = {y};\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := insert y (mut_W s\\<down>),\n                                  ghost_honorary_grey := {}\\<rparr>))\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_ins_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) store_ins_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_new_ref s\\<down> = Some y\n  mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n  sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_ins_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) store_ins_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_new_ref s\\<down> = Some y\n  mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n  sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))", "by - (erule valid_W_inv_mo_co_unlock; simp split: if_splits)"], ["proof (state)\nthis:\n  valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))\n\ngoal (12 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n         at sys sys.tso_unlock s;\n         s'\\<down> = s\\<down>\n         (sys := mem_lock_update Map.empty (s\\<down> sys));\n         taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         sys_mem_store_buffers (mutator m) s\\<down> = [];\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> = Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n         if mut_cas_mark s\\<down> = mut_mark s\\<down>\n         then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n         else mut_ghost_honorary_grey s\\<down> = {};\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (sys :=\n                               mem_lock_update Map.empty (s\\<down> sys)))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n         at sys sys.tso_unlock s;\n         s'\\<down> = s\\<down>\n         (sys := mem_lock_update Map.empty (s\\<down> sys));\n         taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         sys_mem_store_buffers (mutator m) s\\<down> = [];\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> = Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n         if mut_cas_mark s\\<down> = mut_mark s\\<down>\n         then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n         else mut_ghost_honorary_grey s\\<down> = {};\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (sys :=\n                               mem_lock_update Map.empty (s\\<down> sys)))\nA total of 12 subgoals...", "case (store_ins_mo_co_mark s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_ins_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) store_ins_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  mut_new_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (12 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_ins_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; mut_new_ref s\\<down> = Some y;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 8. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n         at sys sys.tso_unlock s;\n         s'\\<down> = s\\<down>\n         (sys := mem_lock_update Map.empty (s\\<down> sys));\n         taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         sys_mem_store_buffers (mutator m) s\\<down> = [];\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> = Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n         if mut_cas_mark s\\<down> = mut_mark s\\<down>\n         then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n         else mut_ghost_honorary_grey s\\<down> = {};\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (sys :=\n                               mem_lock_update Map.empty (s\\<down> sys)))\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_ins_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) store_ins_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  mut_new_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_ins_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) store_ins_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  mut_new_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (mutator m :=\n                      sys_mem_store_buffers (mutator m) s\\<down> @\n                      [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))", "by - (erule valid_W_inv_mo_co_mark; blast+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (mutator m :=\n                    sys_mem_store_buffers (mutator m) s\\<down> @\n                    [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n\ngoal (11 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n         at sys sys.tso_store s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (mutator m :=\n                         sys_mem_store_buffers (mutator m) s\\<down> @\n                         [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> = Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {};\n         mut_cas_mark s\\<down> = mut_mark s\\<down>;\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n         filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n         []\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s\\<down> @\n      [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n         at sys sys.tso_store s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (mutator m :=\n                         sys_mem_store_buffers (mutator m) s\\<down> @\n                         [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> = Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {};\n         mut_cas_mark s\\<down> = mut_mark s\\<down>;\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n         filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n         []\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s\\<down> @\n      [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\nA total of 11 subgoals...", "case (store_ins_mo_co_lock s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_ins_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) store_ins_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_new_ref s\\<down> = Some y\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (11 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_ins_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_ins_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_new_ref s\\<down> = Some y; y \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 7. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n         at sys sys.tso_store s;\n         s'\\<down> = s\\<down>\n         (mutator m := s\\<down> (mutator m)\n            \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n          sys := s\\<down> sys\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (mutator m :=\n                         sys_mem_store_buffers (mutator m) s\\<down> @\n                         [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_mem_lock s\\<down> = Some (mutator m);\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {};\n         mut_cas_mark s\\<down> = mut_mark s\\<down>;\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n         filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n         []\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s\\<down> sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s\\<down> @\n      [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_ins_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) store_ins_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_new_ref s\\<down> = Some y\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_ins_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) store_ins_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_new_ref s\\<down> = Some y\n  y \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "by - (erule valid_W_inv_mo_co_lock; assumption+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n\ngoal (10 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n         at sys sys.tso_lock s;\n         s'\\<down> = s\\<down>\n         (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n         obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n          s\\<down> \\<or>\n         marked y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>;\n         filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n         []\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>mem_lock :=\n   Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n         at sys sys.tso_lock s;\n         s'\\<down> = s\\<down>\n         (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n         obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n          s\\<down> \\<or>\n         marked y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>;\n         filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n         []\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>mem_lock :=\n   Some (mutator m)\\<rparr>))", "case (store_del_mo_co_W s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_del_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) store_del_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {y}\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n\ngoal (10 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) store_del_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {y};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 6. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 10. \\<And>s s' y.\n        \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n         at sys sys.tso_lock s;\n         s'\\<down> = s\\<down>\n         (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n         taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n         \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n         sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n         sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n         valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n         sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n         mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n         mut_hs_pending s\\<down>;\n         filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n          (sys_mem_store_buffers (mutator m) s\\<down>) =\n         [];\n         mut_ghost_honorary_grey s\\<down> = {};\n         mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n         mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n         \\<forall>x.\n            x \\<in> mut_roots s\\<down> \\<and>\n            x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n            marked x s\\<down>;\n         obj_at (\\<lambda>obj. True) y s\\<down>;\n         mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n         obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n          s\\<down> \\<or>\n         marked y s\\<down>;\n         mut_fM s\\<down> = sys_fM s\\<down>;\n         filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n         []\\<rbrakk>\n        \\<Longrightarrow> valid_W_inv\n                           (s\\<down>\n                            (sys := s\\<down> sys\n                               \\<lparr>mem_lock :=\n   Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_del_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) store_del_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {y}\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_del_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) store_del_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {y}\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>W := insert y (mut_W s\\<down>),\n            ghost_honorary_grey := {}\\<rparr>))", "by - (erule valid_W_inv_mo_co_W; blast+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>W := insert y (mut_W s\\<down>),\n          ghost_honorary_grey := {}\\<rparr>))\n\ngoal (9 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "case (store_del_mo_co_unlock s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_del_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) store_del_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n  sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (9 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) store_del_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 9. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_del_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) store_del_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n  sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_del_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) store_del_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_Mark \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n  sys_phase s\\<down> \\<noteq> ph_Idle \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))", "by - (erule valid_W_inv_mo_co_unlock; simp split: if_splits)"], ["proof (state)\nthis:\n  valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))\n\ngoal (8 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "case (store_del_mo_co_mark s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_del_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) store_del_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (8 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) store_del_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 2. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 8. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_del_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) store_del_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_del_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) store_del_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (mutator m :=\n                      sys_mem_store_buffers (mutator m) s\\<down> @\n                      [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))", "by - (erule valid_W_inv_mo_co_mark; blast+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (mutator m :=\n                    sys_mem_store_buffers (mutator m) s\\<down> @\n                    [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n\ngoal (7 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "case (store_del_mo_co_lock s s' y)"], ["proof (state)\nthis:\n  at (mutator m) store_del_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) store_del_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (7 subgoals):\n 1. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) store_del_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) store_del_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        y \\<in> mut_ghost_honorary_root s\\<down>;\n        mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle;\n        mut_ghost_honorary_grey s\\<down> = {};\n        (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n         mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n         sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n        (\\<forall>opt_r'.\n            mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n            \\<notin> set (sys_mem_store_buffers (mutator m)\n                           s\\<down>)) \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>;\n        mut_ref s\\<down> = Some y;\n        (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n        the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>;\n        mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 7. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) store_del_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) store_del_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) store_del_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) store_del_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  y \\<in> mut_ghost_honorary_root s\\<down>\n  mut_ghost_hs_phase s\\<down> \\<noteq> hp_Idle\n  mut_ghost_honorary_grey s\\<down> = {}\n  (mut_ghost_hs_phase s\\<down> = hp_Mark \\<or>\n   mut_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n   sys_phase s\\<down> \\<noteq> ph_Idle) \\<and>\n  (\\<forall>opt_r'.\n      mw_Mutate (mut_tmp_ref s\\<down>) (mut_field s\\<down>) opt_r'\n      \\<notin> set (sys_mem_store_buffers (mutator m)\n                     s\\<down>)) \\<longrightarrow>\n  obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n   (mut_tmp_ref s\\<down>) (mut_field s\\<down>) s\\<down>\n  mut_ref s\\<down> = Some y\n  (\\<exists>y. mut_new_ref s\\<down> = Some y) \\<longrightarrow>\n  the (mut_new_ref s\\<down>) \\<in> mut_roots s\\<down>\n  mut_tmp_ref s\\<down> \\<in> mut_roots s\\<down>\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "by - (erule valid_W_inv_mo_co_lock; assumption+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n\ngoal (6 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "case (hs_get_roots_loop_mo_co_W s s' y)"], ["proof (state)\nthis:\n  at (mutator m) hs_get_roots_loop_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_ghost_honorary_grey s\\<down> = {y}\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (6 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_W s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := insert y (mut_W s\\<down>),\n              ghost_honorary_grey := {}\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_W s';\n        \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_ghost_honorary_grey s\\<down> = {y};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := insert y (mut_W s\\<down>),\n                                 ghost_honorary_grey := {}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 6. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_roots_loop_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_ghost_honorary_grey s\\<down> = {y}\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_roots_loop_mo_co_W s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := insert y (mut_W s\\<down>),\n        ghost_honorary_grey := {}\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_W s'\n  \\<forall>p''\\<in>- {mutator m}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_ghost_honorary_grey s\\<down> = {y}\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>W := insert y (mut_W s\\<down>),\n            ghost_honorary_grey := {}\\<rparr>))", "by - (erule valid_W_inv_mo_co_W; blast+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>W := insert y (mut_W s\\<down>),\n          ghost_honorary_grey := {}\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "case (hs_get_roots_loop_mo_co_unlock s s' y)"], ["proof (state)\nthis:\n  at (mutator m) hs_get_roots_loop_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) hs_get_roots_loop_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  mut_ghost_honorary_root s\\<down> = {}\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_unlock s;\n        at sys sys.tso_unlock s;\n        s'\\<down> = s\\<down>\n        (sys := mem_lock_update Map.empty (s\\<down> sys));\n        taken (mutator m) hs_get_roots_loop_mo_co_unlock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator m) s\\<down> = [];\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>; mut_ghost_honorary_root s\\<down> = {};\n        if mut_cas_mark s\\<down> = mut_mark s\\<down>\n        then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n        else mut_ghost_honorary_grey s\\<down> = {};\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; marked y s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys :=\n                              mem_lock_update Map.empty (s\\<down> sys)))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 5. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_roots_loop_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) hs_get_roots_loop_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  mut_ghost_honorary_root s\\<down> = {}\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_roots_loop_mo_co_unlock s\n  at sys sys.tso_unlock s\n  s'\\<down> = s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys))\n  taken (mutator m) hs_get_roots_loop_mo_co_unlock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_store_buffers (mutator m) s\\<down> = []\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  mut_ghost_honorary_root s\\<down> = {}\n  if mut_cas_mark s\\<down> = mut_mark s\\<down>\n  then mut_ghost_honorary_grey s\\<down> = {mut_the_ref s\\<down>}\n  else mut_ghost_honorary_grey s\\<down> = {}\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  marked y s\\<down>\n\ngoal (1 subgoal):\n 1. valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))", "by - (erule valid_W_inv_mo_co_unlock; simp split: if_splits)"], ["proof (state)\nthis:\n  valid_W_inv (s\\<down>(sys := mem_lock_update Map.empty (s\\<down> sys)))\n\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "case (hs_get_roots_loop_mo_co_mark s s' y)"], ["proof (state)\nthis:\n  at (mutator m) hs_get_roots_loop_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_mark s;\n        at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator m :=\n                        sys_mem_store_buffers (mutator m) s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> = Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {};\n        mut_cas_mark s\\<down> = mut_mark s\\<down>;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        mut_ref s\\<down> = Some y; obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>; white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))\n  (mutator m :=\n     sys_mem_store_buffers (mutator m) s\\<down> @\n     [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_roots_loop_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_roots_loop_mo_co_mark s\n  at sys sys.tso_store s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (mutator m :=\n                  sys_mem_store_buffers (mutator m) s\\<down> @\n                  [mw_Mark y (sys_fM s\\<down>)])\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_mark s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> = Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_cas_mark s\\<down> = mut_mark s\\<down>\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  mut_ref s\\<down> = Some y\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  white y s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (mutator m :=\n                      sys_mem_store_buffers (mutator m) s\\<down> @\n                      [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))", "by - (erule valid_W_inv_mo_co_mark; blast+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (mutator m :=\n                    sys_mem_store_buffers (mutator m) s\\<down> @\n                    [mw_Mark y (sys_fM s\\<down>)])\\<rparr>))\n\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "case (hs_get_roots_loop_mo_co_lock s s' y)"], ["proof (state)\nthis:\n  at (mutator m) hs_get_roots_loop_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_ref s\\<down> = Some y\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at (mutator m) hs_get_roots_loop_mo_co_lock s;\n        at sys sys.tso_lock s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>);\n        taken (mutator m) hs_get_roots_loop_mo_co_lock s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        sys_mem_lock s\\<down> = None; fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; y \\<in> mut_roots s\\<down>;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; mut_ref s\\<down> = Some y;\n        mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<and>\n           x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        obj_at (\\<lambda>obj. True) y s\\<down>;\n        mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n         s\\<down> \\<or>\n        marked y s\\<down>;\n        mut_fM s\\<down> = sys_fM s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) =\n        []\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_roots_loop_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_ref s\\<down> = Some y\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_roots_loop_mo_co_lock s\n  at sys sys.tso_lock s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>)\n  taken (mutator m) hs_get_roots_loop_mo_co_lock s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  sys_mem_lock s\\<down> = None\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_hs_type s\\<down> = ht_GetRoots\n  y \\<in> mut_roots s\\<down>\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n  mut_ref s\\<down> = Some y\n  mut_refs s\\<down> \\<subseteq> mut_roots s\\<down>\n  \\<forall>x.\n     x \\<in> mut_roots s\\<down> \\<and>\n     x \\<notin> mut_refs s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  obj_at (\\<lambda>obj. True) y s\\<down>\n  mut_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) y\n   s\\<down> \\<or>\n  marked y s\\<down>\n  mut_fM s\\<down> = sys_fM s\\<down>\n  filter is_mw_Mark (sys_mem_store_buffers (mutator m) s\\<down>) = []\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>))", "by - (erule valid_W_inv_mo_co_lock; assumption+)"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (sys := s\\<down> sys\\<lparr>mem_lock := Some (mutator m)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "case (hs_get_roots_done s s')"], ["proof (state)\nthis:\n  at (mutator m) hs_get_roots_done s\n  at sys sys.sys_hs_mut_done s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := {},\n        ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_roots_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  \\<forall>x. x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_roots_done s\n  at sys sys.sys_hs_mut_done s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := {},\n        ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_roots_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  \\<forall>x. x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_roots_done s\n  at sys sys.sys_hs_mut_done s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := {},\n        ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_roots_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  \\<forall>x. x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetRoots\n  mut_hs_type s\\<down> = ht_GetRoots\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>W := {},\n            ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                   (m := False),\n            W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n            ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n              (m := True)\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at (mutator m) hs_get_roots_done s;\n     at sys sys.sys_hs_mut_done s;\n     s'\\<down> = s\\<down>\n     (mutator m := s\\<down> (mutator m)\n        \\<lparr>W := {},\n           ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n      sys := s\\<down> sys\n        \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                  (m := False),\n           W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n           ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n             (m := True)\\<rparr>);\n     taken (mutator m) hs_get_roots_done s';\n     \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n     fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     \\<forall>x.\n        x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n     sys_hs_type s\\<down> = ht_GetRoots; mut_hs_type s\\<down> = ht_GetRoots;\n     sys_hs_pending m s\\<down>; mut_hs_pending s\\<down>;\n     filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n      (sys_mem_store_buffers (mutator m) s\\<down>) =\n     [];\n     mut_ghost_honorary_grey s\\<down> = {};\n     mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (mutator m := s\\<down> (mutator m)\n    \\<lparr>W := {},\n       ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n  sys := s\\<down> sys\n    \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n              (m := False),\n       W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n       ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n         (m := True)\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(mutator m := s\\<down> (mutator m)\n   \\<lparr>W := {},\n      ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n sys := s\\<down> sys\n   \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n             (m := False),\n      W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n      ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n        (m := True)\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (mutator m := s\\<down> (mutator m)\n                           \\<lparr>W := {},\n                              ghost_hs_phase :=\n                                hs_step\n                                 (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                         sys := s\\<down> sys\n                           \\<lparr>hs_pending :=\n                                     (local_state.hs_pending (s\\<down> sys))\n                                     (m := False),\n                              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n                              ghost_hs_in_sync :=\n                                (ghost_hs_in_sync (s\\<down> sys))\n                                (m := True)\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (mutator m := s\\<down> (mutator m)\n    \\<lparr>W := {},\n       ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n  sys := s\\<down> sys\n    \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n              (m := False),\n       W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n       ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n         (m := True)\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(mutator m := s\\<down> (mutator m)\n   \\<lparr>W := {},\n      ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n sys := s\\<down> sys\n   \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n             (m := False),\n      W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n      ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n        (m := True)\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {},\n                                  ghost_hs_phase :=\n                                    hs_step\n                                     (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (mutator m := s\\<down> (mutator m)\n                                 \\<lparr>W := {},\n                                    ghost_hs_phase :=\nhs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                               sys := s\\<down> sys\n                                 \\<lparr>hs_pending :=\n     (local_state.hs_pending (s\\<down> sys))(m := False),\n                                    W :=\nsys_W s\\<down> \\<union> mut_W s\\<down>,\n                                    ghost_hs_in_sync :=\n(ghost_hs_in_sync (s\\<down> sys))(m := True)\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (simp add: all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at (mutator m) hs_get_roots_done s;\n     at sys sys.sys_hs_mut_done s;\n     s'\\<down> = s\\<down>\n     (mutator m := s\\<down> (mutator m)\n        \\<lparr>W := {},\n           ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n      sys := s\\<down> sys\n        \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                  (m := False),\n           W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n           ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n             (m := True)\\<rparr>);\n     taken (mutator m) hs_get_roots_done s';\n     \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n     fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     \\<forall>x.\n        x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n     sys_hs_type s\\<down> = ht_GetRoots; mut_hs_type s\\<down> = ht_GetRoots;\n     sys_hs_pending m s\\<down>; mut_hs_pending s\\<down>;\n     filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n      (sys_mem_store_buffers (mutator m) s\\<down>) =\n     [];\n     mut_ghost_honorary_grey s\\<down> = {};\n     mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<in> mut_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          sys_mem_lock s\\<down> \\<noteq> Some sys \\<and>\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          (case x of\n                           mutator m' \\<Rightarrow>\n                             if m' = m then {} else WL (mutator m') s\\<down>\n                           | gc \\<Rightarrow> WL gc s\\<down>\n                           | sys \\<Rightarrow>\n                               WL sys s\\<down> \\<union>\n                               WL (mutator m) s\\<down>) \\<inter>\n                          (case xa of\n                           mutator m' \\<Rightarrow>\n                             if m' = m then {} else WL (mutator m') s\\<down>\n                           | gc \\<Rightarrow> WL gc s\\<down>\n                           | sys \\<Rightarrow>\n                               WL sys s\\<down> \\<union>\n                               WL (mutator m) s\\<down>) =\n                          {}) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          x \\<notin> sys_W s\\<down> \\<and>\n                          x \\<notin> mut_W s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> sys_ghost_honorary_grey\n  s\\<down> \\<longrightarrow>\n                              xa \\<notin> W (s\\<down> x))) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> sys_W s\\<down> \\<and>\n                              xa \\<notin> mut_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> mutator m \\<longrightarrow>\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xaa.\n                                  xaa\n                                  \\<in> ghost_honorary_grey\n   (s\\<down> x) \\<longrightarrow>\n                                  xaa \\<notin> W (s\\<down> xa)))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<in> set (sys_mem_store_buffers sys\ns\\<down>) \\<longrightarrow>\n                          xa = sys_fM s\\<down> \\<and>\n                          x \\<in> sys_ghost_honorary_grey s\\<down> \\<and>\n                          sys_mem_lock s\\<down> = Some sys \\<and>\n                          white x s\\<down> \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers sys s\\<down>) =\n                          [mw_Mark x xa]) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers (mutator m)\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa xaa.\n                              mw_Mark xa xaa\n                              \\<in> set (sys_mem_store_buffers x\n    s\\<down>) \\<longrightarrow>\n                              xaa = sys_fM s\\<down> \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<and>\n                              sys_mem_lock s\\<down> = Some x \\<and>\n                              white xa s\\<down> \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s\\<down>) =\n                              [mw_Mark xa xaa]))", "apply (intro allI conjI impI; clarsimp simp: valid_W_inv_sys_ghg_empty_iff valid_W_invD(2) valid_W_invD0(2,3) filter_empty_conv dest!: valid_W_invE(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetRoots;\n        mut_hs_type s\\<down> = ht_GetRoots; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        \\<forall>x\\<in>set (sys_mem_store_buffers (mutator m) s\\<down>).\n           (\\<forall>r f r'. x \\<noteq> mw_Mutate r f r') \\<and>\n           (\\<forall>r f pl. x \\<noteq> mw_Mutate_Payload r f pl);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          mutator m' \\<Rightarrow>\n                            if m' = m then {} else WL (mutator m') s\\<down>\n                          | gc \\<Rightarrow> WL gc s\\<down>\n                          | sys \\<Rightarrow>\n                              WL sys s\\<down> \\<union>\n                              WL (mutator m) s\\<down>) \\<inter>\n                         (case xa of\n                          mutator m' \\<Rightarrow>\n                            if m' = m then {} else WL (mutator m') s\\<down>\n                          | gc \\<Rightarrow> WL gc s\\<down>\n                          | sys \\<Rightarrow>\n                              WL sys s\\<down> \\<union>\n                              WL (mutator m) s\\<down>) =\n                         {}", "apply (fastforce simp: valid_W_distinct_simps split: process_name.splits if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>W := {},\n          ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                 (m := False),\n          W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n          ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n            (m := True)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "case (hs_get_work_done s s')"], ["proof (state)\nthis:\n  at (mutator m) hs_get_work_done s\n  at sys sys.sys_hs_mut_done s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_work_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetWork\n  mut_hs_type s\\<down> = ht_GetWork\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s\\<down>) =\n        [];\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_W_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_work_done s\n  at sys sys.sys_hs_mut_done s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_work_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetWork\n  mut_hs_type s\\<down> = ht_GetWork\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_work_done s\n  at sys sys.sys_hs_mut_done s\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_work_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_mem_lock s\\<down> \\<noteq> Some (mutator m)\n  sys_hs_type s\\<down> = ht_GetWork\n  mut_hs_type s\\<down> = ht_GetWork\n  sys_hs_pending m s\\<down>\n  mut_hs_pending s\\<down>\n  filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n   (sys_mem_store_buffers (mutator m) s\\<down>) =\n  []\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_W_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                   (m := False),\n            W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n            ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n              (m := True)\\<rparr>))", "apply (subst valid_W_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at (mutator m) hs_get_work_done s;\n     at sys sys.sys_hs_mut_done s;\n     s'\\<down> = s\\<down>\n     (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n      sys := s\\<down> sys\n        \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                  (m := False),\n           W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n           ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n             (m := True)\\<rparr>);\n     taken (mutator m) hs_get_work_done s';\n     \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n     fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n     sys_hs_type s\\<down> = ht_GetWork; mut_hs_type s\\<down> = ht_GetWork;\n     sys_hs_pending m s\\<down>; mut_hs_pending s\\<down>;\n     filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n      (sys_mem_store_buffers (mutator m) s\\<down>) =\n     [];\n     mut_ghost_honorary_grey s\\<down> = {};\n     mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x xa.\n                          xa \\<in> W ((s\\<down>\n (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n  sys := s\\<down> sys\n    \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n              (m := False),\n       W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n       ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n         (m := True)\\<rparr>))\n x) \\<or>\n                          sys_mem_lock\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<noteq>\n                          Some x \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n sys := s\\<down> sys\n   \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n             (m := False),\n      W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n      ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n        (m := True)\\<rparr>))\nx) \\<longrightarrow>\n                          marked xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>))) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          WL x\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<inter>\n                          WL xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) =\n                          {}) \\<and>\n                      (\\<forall>x xa xb.\n                          \\<not> (xb \\<in> ghost_honorary_grey\n      ((s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>))\n        x) \\<and>\n                                  xb \\<in> W\n      ((s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>))\n        xa))) \\<and>\n                      sys_ghost_honorary_grey\n                       (s\\<down>\n                        (mutator m := s\\<down> (mutator m)\n                           \\<lparr>W := {}\\<rparr>,\n                         sys := s\\<down> sys\n                           \\<lparr>hs_pending :=\n                                     (local_state.hs_pending (s\\<down> sys))\n                                     (m := False),\n                              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n                              ghost_hs_in_sync :=\n                                (ghost_hs_in_sync (s\\<down> sys))\n                                (m := True)\\<rparr>)) =\n                      {} \\<and>\n                      (\\<forall>x xa xb.\n                          mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x\n(s\\<down>\n (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n  sys := s\\<down> sys\n    \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n              (m := False),\n       W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n       ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n         (m := True)\\<rparr>))) \\<longrightarrow>\n                          xb =\n                          sys_fM\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<and>\n                          xa \\<in> ghost_honorary_grey\n                                    ((s\\<down>\n(mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n sys := s\\<down> sys\n   \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n             (m := False),\n      W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n      ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n        (m := True)\\<rparr>))\nx) \\<and>\n                          sys_mem_lock\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) =\n                          Some x \\<and>\n                          white xa\n                           (s\\<down>\n                            (mutator m := s\\<down> (mutator m)\n                               \\<lparr>W := {}\\<rparr>,\n                             sys := s\\<down> sys\n                               \\<lparr>hs_pending :=\n   (local_state.hs_pending (s\\<down> sys))(m := False),\n                                  W := sys_W s\\<down> \\<union>\n mut_W s\\<down>,\n                                  ghost_hs_in_sync :=\n                                    (ghost_hs_in_sync (s\\<down> sys))\n                                    (m := True)\\<rparr>)) \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers x\n                             (s\\<down>\n                              (mutator m := s\\<down> (mutator m)\n                                 \\<lparr>W := {}\\<rparr>,\n                               sys := s\\<down> sys\n                                 \\<lparr>hs_pending :=\n     (local_state.hs_pending (s\\<down> sys))(m := False),\n                                    W :=\nsys_W s\\<down> \\<union> mut_W s\\<down>,\n                                    ghost_hs_in_sync :=\n(ghost_hs_in_sync (s\\<down> sys))(m := True)\\<rparr>))) =\n                          [mw_Mark xa xb])", "apply (simp add: all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at (mutator m) hs_get_work_done s;\n     at sys sys.sys_hs_mut_done s;\n     s'\\<down> = s\\<down>\n     (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n      sys := s\\<down> sys\n        \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                  (m := False),\n           W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n           ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n             (m := True)\\<rparr>);\n     taken (mutator m) hs_get_work_done s';\n     \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n     fM_rel_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n     sys_hs_type s\\<down> = ht_GetWork; mut_hs_type s\\<down> = ht_GetWork;\n     sys_hs_pending m s\\<down>; mut_hs_pending s\\<down>;\n     filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n      (sys_mem_store_buffers (mutator m) s\\<down>) =\n     [];\n     mut_ghost_honorary_grey s\\<down> = {};\n     mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          x \\<in> sys_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<in> mut_W s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> W (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          sys_mem_lock s\\<down> \\<noteq> Some sys \\<and>\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          marked x s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              sys_mem_lock s\\<down> \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              marked xa s\\<down>)) \\<and>\n                      (\\<forall>x xa.\n                          x \\<noteq> xa \\<longrightarrow>\n                          (case x of\n                           mutator m' \\<Rightarrow>\n                             if m' = m then {} else WL (mutator m') s\\<down>\n                           | gc \\<Rightarrow> WL gc s\\<down>\n                           | sys \\<Rightarrow>\n                               WL sys s\\<down> \\<union>\n                               WL (mutator m) s\\<down>) \\<inter>\n                          (case xa of\n                           mutator m' \\<Rightarrow>\n                             if m' = m then {} else WL (mutator m') s\\<down>\n                           | gc \\<Rightarrow> WL gc s\\<down>\n                           | sys \\<Rightarrow>\n                               WL sys s\\<down> \\<union>\n                               WL (mutator m) s\\<down>) =\n                          {}) \\<and>\n                      (\\<forall>x.\n                          x \\<in> sys_ghost_honorary_grey\n                                   s\\<down> \\<longrightarrow>\n                          x \\<notin> sys_W s\\<down> \\<and>\n                          x \\<notin> mut_W s\\<down>) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> sys_ghost_honorary_grey\n  s\\<down> \\<longrightarrow>\n                              xa \\<notin> W (s\\<down> x))) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa.\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<longrightarrow>\n                              xa \\<notin> sys_W s\\<down> \\<and>\n                              xa \\<notin> mut_W s\\<down>) \\<and>\n                          (\\<forall>xa.\n                              xa \\<noteq> mutator m \\<longrightarrow>\n                              xa \\<noteq> sys \\<longrightarrow>\n                              (\\<forall>xaa.\n                                  xaa\n                                  \\<in> ghost_honorary_grey\n   (s\\<down> x) \\<longrightarrow>\n                                  xaa \\<notin> W (s\\<down> xa)))) \\<and>\n                      sys_ghost_honorary_grey s\\<down> = {} \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<in> set (sys_mem_store_buffers sys\ns\\<down>) \\<longrightarrow>\n                          xa = sys_fM s\\<down> \\<and>\n                          x \\<in> sys_ghost_honorary_grey s\\<down> \\<and>\n                          sys_mem_lock s\\<down> = Some sys \\<and>\n                          white x s\\<down> \\<and>\n                          filter is_mw_Mark\n                           (sys_mem_store_buffers sys s\\<down>) =\n                          [mw_Mark x xa]) \\<and>\n                      (\\<forall>x xa.\n                          mw_Mark x xa\n                          \\<notin> set (sys_mem_store_buffers (mutator m)\n   s\\<down>)) \\<and>\n                      (\\<forall>x.\n                          x \\<noteq> mutator m \\<longrightarrow>\n                          x \\<noteq> sys \\<longrightarrow>\n                          (\\<forall>xa xaa.\n                              mw_Mark xa xaa\n                              \\<in> set (sys_mem_store_buffers x\n    s\\<down>) \\<longrightarrow>\n                              xaa = sys_fM s\\<down> \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s\\<down> x) \\<and>\n                              sys_mem_lock s\\<down> = Some x \\<and>\n                              white xa s\\<down> \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s\\<down>) =\n                              [mw_Mark xa xaa]))", "apply (intro allI conjI impI; clarsimp simp: valid_W_inv_sys_ghg_empty_iff valid_W_invD(2) valid_W_invD0(2,3) filter_empty_conv dest!: valid_W_invE(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_mem_lock s\\<down> \\<noteq> Some (mutator m);\n        sys_hs_type s\\<down> = ht_GetWork;\n        mut_hs_type s\\<down> = ht_GetWork; sys_hs_pending m s\\<down>;\n        mut_hs_pending s\\<down>;\n        \\<forall>x\\<in>set (sys_mem_store_buffers (mutator m) s\\<down>).\n           (\\<forall>r f r'. x \\<noteq> mw_Mutate r f r') \\<and>\n           (\\<forall>r f pl. x \\<noteq> mw_Mutate_Payload r f pl);\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}; x \\<noteq> xa\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          mutator m' \\<Rightarrow>\n                            if m' = m then {} else WL (mutator m') s\\<down>\n                          | gc \\<Rightarrow> WL gc s\\<down>\n                          | sys \\<Rightarrow>\n                              WL sys s\\<down> \\<union>\n                              WL (mutator m) s\\<down>) \\<inter>\n                         (case xa of\n                          mutator m' \\<Rightarrow>\n                            if m' = m then {} else WL (mutator m') s\\<down>\n                          | gc \\<Rightarrow> WL gc s\\<down>\n                          | sys \\<Rightarrow>\n                              WL sys s\\<down> \\<union>\n                              WL (mutator m) s\\<down>) =\n                         {}", "apply (fastforce simp: valid_W_distinct_simps split: process_name.splits if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_W_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                 (m := False),\n          W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n          ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n            (m := True)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}