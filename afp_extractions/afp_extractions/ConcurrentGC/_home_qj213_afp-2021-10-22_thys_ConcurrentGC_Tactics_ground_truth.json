{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Tactics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma valid_pre:\n  assumes \"\\<lbrace>Q\\<rbrace> p \\<lbrace>R\\<rbrace>\"\n  assumes \"\\<And>s. P s \\<Longrightarrow> Q s\"\n  shows \"\\<lbrace>P\\<rbrace> p \\<lbrace>R\\<rbrace>\"", "lemma valid_conj_lift:\n  assumes x: \"\\<lbrace>P\\<rbrace> p \\<lbrace>Q\\<rbrace>\"\n  assumes y: \"\\<lbrace>P'\\<rbrace> p \\<lbrace>Q'\\<rbrace>\"\n  shows      \"\\<lbrace>P \\<^bold>\\<and> P'\\<rbrace> p \\<lbrace>Q \\<^bold>\\<and> Q'\\<rbrace>\"", "lemma valid_all_lift:\n  assumes \"\\<And>x. \\<lbrace>P x\\<rbrace> p \\<lbrace>Q x\\<rbrace>\"\n  shows \"\\<lbrace>\\<lambda>s. \\<forall>x. P x s\\<rbrace> p \\<lbrace>\\<lambda>s. \\<forall>x. Q x s\\<rbrace>\"", "lemma atS_dests:\n  \"\\<lbrakk> atS p ls s; atS p ls' s \\<rbrakk> \\<Longrightarrow> atS p (ls \\<union> ls') s\"\n  \"\\<lbrakk> \\<not>atS p ls s; \\<not>atS p ls' s \\<rbrakk> \\<Longrightarrow> \\<not>atS p (ls \\<union> ls') s\"\n  \"\\<lbrakk> \\<not>atS p ls s; atS p ls' s \\<rbrakk> \\<Longrightarrow> atS p (ls' - ls) s\"\n  \"\\<lbrakk> \\<not>atS p ls s; at p l s \\<rbrakk> \\<Longrightarrow> atS p ({l} - ls) s\"", "lemma schematic_prem: \"\\<lbrakk>Q \\<Longrightarrow> P; Q\\<rbrakk> \\<Longrightarrow> P\"", "lemma TrueE: \"\\<lbrakk>True; P\\<rbrakk> \\<Longrightarrow> P\"", "lemma thin_locs_pre_discardE:\n  \"\\<lbrakk>at p l' s \\<longrightarrow> P; at p l s; l' \\<noteq> l; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS p ls s \\<longrightarrow> P; at p l s; l \\<notin> ls; Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma thin_locs_pre_keep_atE:\n  \"\\<lbrakk>at p l s \\<longrightarrow> P; at p l s; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma thin_locs_pre_keep_atSE:\n  \"\\<lbrakk>atS p ls s \\<longrightarrow> P; at p l s; l \\<in> ls; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma thin_locs_post_discardE:\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn'); l' \\<notin> lfn; p \\<noteq> q\\<rbrakk> \\<Longrightarrow> at p l' s' \\<longrightarrow> P\"\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn); l' \\<notin> lfn\\<rbrakk> \\<Longrightarrow> at p l' s' \\<longrightarrow> P\"\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn'); \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls;  p \\<noteq> q\\<rbrakk> \\<Longrightarrow> atS p ls s' \\<longrightarrow> P\"\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn); \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls\\<rbrakk> \\<Longrightarrow> atS p ls s' \\<longrightarrow> P\"", "lemmas thin_locs_post_discard_conjE =\n  conjI[OF thin_locs_post_discardE(1)]\n  conjI[OF thin_locs_post_discardE(2)]\n  conjI[OF thin_locs_post_discardE(3)]\n  conjI[OF thin_locs_post_discardE(4)]", "lemma thin_locs_post_keep_locsE:\n  \"\\<lbrakk>(L \\<longrightarrow> P) \\<and> R; R \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> (L \\<longrightarrow> P) \\<and> Q\"\n  \"L \\<longrightarrow> P \\<Longrightarrow> L \\<longrightarrow> P\"", "lemma thin_locs_post_keepE:\n  \"\\<lbrakk>P \\<and> R; R \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> (L \\<longrightarrow> P) \\<and> Q\"\n  \"P \\<Longrightarrow> L \\<longrightarrow> P\"", "lemma ni_thin_locs_discardE:\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l \\<noteq> l'; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l' s'; l \\<noteq> l'; proc \\<noteq> p; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<notin> ls; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l' s'; l' \\<notin> ls; proc \\<noteq> p; Q\\<rbrakk> \\<Longrightarrow> Q\"\n\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); atS proc ls' s'; l \\<notin> ls'; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); atS proc ls' s'; l \\<notin> ls'; proc \\<noteq> p; Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma ni_thin_locs_keep_atE:\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l s'; proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l s'; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma ni_thin_locs_keep_atSE:\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<in> ls; proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l' s'; l' \\<in> ls; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); atS proc ls' s'; ls' \\<subseteq> ls; proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); atS proc ls' s'; ls' \\<subseteq> ls; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma loc_mem_tac_intros:\n  \"\\<lbrakk>c \\<notin> A; c \\<notin> B\\<rbrakk> \\<Longrightarrow> c \\<notin> A \\<union> B\"\n  \"c \\<noteq> d \\<Longrightarrow> c \\<notin> {d}\"\n  \"c \\<notin> A \\<Longrightarrow> c \\<in> - A\"\n  \"c \\<in> A \\<Longrightarrow> c \\<notin> - A\"\n  \"A \\<subseteq> A\"", "lemmas loc_mem_tac_elims =\n  singletonE\n  UnE", "lemmas loc_mem_tac_simps =\n  append.simps list.simps rev.simps \\<comment> \\<open>evaluate string equality\\<close>\n  char.inject cong_exp_iff_simps \\<comment> \\<open>evaluate character equality\\<close>\n  prefix_code suffix_to_prefix\n  simp_thms\n  Eq_FalseI\n  not_Cons_self", "lemmas vcg_fragments'_simps =\n  valid_proc_def gc_coms.simps vcg_fragments'.simps atC.simps\n  ball_Un bool_simps if_False if_True", "lemmas vcg_sem_simps =\n  lconst.simps\n  simp_thms\n  True_implies_equals\n  prod.simps fst_conv snd_conv\n  gc_phase.simps process_name.simps hs_type.simps hs_phase.simps\n  mem_store_action.simps mem_load_action.simps request_op.simps response.simps", "lemmas vcg_inv_simps =\n  simp_thms"], "translations": [["", "lemma valid_pre:\n  assumes \"\\<lbrace>Q\\<rbrace> p \\<lbrace>R\\<rbrace>\"\n  assumes \"\\<And>s. P s \\<Longrightarrow> Q s\"\n  shows \"\\<lbrace>P\\<rbrace> p \\<lbrace>R\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> p \\<lbrace>R\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrace>Q\\<rbrace> p \\<lbrace>R\\<rbrace>\n  P ?s \\<Longrightarrow> Q ?s\n\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> p \\<lbrace>R\\<rbrace>", "apply (clarsimp simp: valid_proc_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>x\\<in>vcg_fragments (gc_coms p).\n                   case x of\n                   (c, afts) \\<Rightarrow> valid_syn gc_coms p afts Q c R;\n        \\<And>s. P s \\<Longrightarrow> Q s;\n        (a, b) \\<in> vcg_fragments (gc_coms p)\\<rbrakk>\n       \\<Longrightarrow> valid_syn gc_coms p b P a R", "apply (drule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>s. P s \\<Longrightarrow> Q s;\n        (a, b) \\<in> vcg_fragments (gc_coms p);\n        case (a, b) of\n        (c, afts) \\<Rightarrow> valid_syn gc_coms p afts Q c R\\<rbrakk>\n       \\<Longrightarrow> valid_syn gc_coms p b P a R", "apply (auto elim: vcg_pre)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_conj_lift:\n  assumes x: \"\\<lbrace>P\\<rbrace> p \\<lbrace>Q\\<rbrace>\"\n  assumes y: \"\\<lbrace>P'\\<rbrace> p \\<lbrace>Q'\\<rbrace>\"\n  shows      \"\\<lbrace>P \\<^bold>\\<and> P'\\<rbrace> p \\<lbrace>Q \\<^bold>\\<and> Q'\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                P s \\<and>\n                P' s\\<rbrace> p \\<lbrace>\\<lambda>s.\n      Q s \\<and> Q' s\\<rbrace>", "apply (clarsimp simp: valid_proc_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> vcg_fragments (gc_coms p) \\<Longrightarrow>\n       valid_syn gc_coms p b (\\<lambda>s. P s \\<and> P' s) a\n        (\\<lambda>s. Q s \\<and> Q' s)", "apply (rule vcg_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> vcg_fragments (gc_coms p) \\<Longrightarrow>\n       valid_syn gc_coms p b (\\<lambda>s. P s \\<and> P' s) a Q\n 2. \\<And>a b.\n       (a, b) \\<in> vcg_fragments (gc_coms p) \\<Longrightarrow>\n       valid_syn gc_coms p b (\\<lambda>s. P s \\<and> P' s) a Q'", "apply (rule vcg_pre[OF spec[OF spec[OF x[unfolded Ball_def valid_proc_def split_paired_All]], simplified, rule_format]], simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> vcg_fragments (gc_coms p) \\<Longrightarrow>\n       valid_syn gc_coms p b (\\<lambda>s. P s \\<and> P' s) a Q'", "apply (rule vcg_pre[OF spec[OF spec[OF y[unfolded Ball_def valid_proc_def split_paired_All]], simplified, rule_format]], simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_all_lift:\n  assumes \"\\<And>x. \\<lbrace>P x\\<rbrace> p \\<lbrace>Q x\\<rbrace>\"\n  shows \"\\<lbrace>\\<lambda>s. \\<forall>x. P x s\\<rbrace> p \\<lbrace>\\<lambda>s. \\<forall>x. Q x s\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                \\<forall>x.\n                   P x s\\<rbrace> p \\<lbrace>\\<lambda>s.\n          \\<forall>x. Q x s\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrace>P ?x\\<rbrace> p \\<lbrace>Q ?x\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                \\<forall>x.\n                   P x s\\<rbrace> p \\<lbrace>\\<lambda>s.\n          \\<forall>x. Q x s\\<rbrace>", "by (fastforce simp: valid_proc_def intro: vcg_all_lift)"], ["", "subsection\\<open> Tactics \\<close>"], ["", "subsubsection\\<open> Model-specific \\<close>"], ["", "text\\<open>\n\nThe following is unfortunately overspecialised to the GC. One might\nhope for general tactics that work on all CIMP programs.\n\nThe system responds to all requests. The schematic variable is\ninstantiated with the semantics of the responses. Thanks to Thomas\nSewell for the hackery.\n\n\\<close>"], ["", "schematic_goal system_responds_actionE:\n  \"\\<lbrakk> (\\<lbrace>l\\<rbrace> Response action, afts) \\<in> fragments (gc_coms p) {}; v \\<in> action x s;\n     \\<lbrakk> p = sys; ?P \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lbrace>l\\<rbrace> Response action, afts)\n             \\<in> fragments (gc_coms p) {};\n     v \\<in> action x s;\n     \\<lbrakk>p = sys; ?P\\<rbrakk> \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (cases p)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>(\\<lbrace>l\\<rbrace> Response action, afts)\n                \\<in> fragments (gc_coms p) {};\n        v \\<in> action x s;\n        \\<lbrakk>p = sys; ?P\\<rbrakk> \\<Longrightarrow> Q;\n        p = mutator x1\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<lbrakk>(\\<lbrace>l\\<rbrace> Response action, afts)\n             \\<in> fragments (gc_coms p) {};\n     v \\<in> action x s; \\<lbrakk>p = sys; ?P\\<rbrakk> \\<Longrightarrow> Q;\n     p = gc\\<rbrakk>\n    \\<Longrightarrow> Q\n 3. \\<lbrakk>(\\<lbrace>l\\<rbrace> Response action, afts)\n             \\<in> fragments (gc_coms p) {};\n     v \\<in> action x s; \\<lbrakk>p = sys; ?P\\<rbrakk> \\<Longrightarrow> Q;\n     p = sys\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (simp_all add: all_com_interned_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = sys.sys_hs_mut_done \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n                       W := W s \\<union> W',\n                       ghost_hs_in_sync := (ghost_hs_in_sync s)\n                         (m := True)\\<rparr>,\n                   mv_Void) |\n                  m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_mut \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n                  (\\<exists>m.\n                      req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_mut_pending \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s, mv_Bool (hs_pending s m)) |m.\n                  req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_load_W \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n                  req = (gc, ro_hs_gc_load_W)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_done \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n                  req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_mut_reqs \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n                   mv_Void) |\n                  m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_set_type \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>hs_type := ht,\n                       ghost_hs_in_sync := \\<lambda>s. False,\n                       ghost_hs_phase :=\n                         hp_step ht (ghost_hs_phase s)\\<rparr>,\n                   mv_Void) |\n                  ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_free \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |\n                  r. snd req = ro_Free r}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = Proofs_Basis.sys.alloc \\<and>\n             action =\n             (\\<lambda>req s.\n                 if {a. \\<exists>y. heap s a = Some y} = UNIV\n                 then {uu_.\n                       \\<exists>_.\n                          uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n                 else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                                   \\<lparr>obj_mark = fA s,\nobj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                        mv_Ref (Some r)) |\n                       r. r \\<notin> dom (heap s) \\<and>\n                          snd req = ro_Alloc}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_unlock \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n                  (\\<exists>p.\n                      req = (p, ro_Unlock) \\<and>\n                      mem_lock s = Some p \\<and>\n                      mem_store_buffers s p = [])}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_lock \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n                  req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_mfence \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (s, mv_Void) \\<and>\n                  (\\<exists>p.\n                      req = (p, ro_MFENCE) \\<and>\n                      mem_store_buffers s p = [])}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_store \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                              (p := mem_store_buffers s p @ [w])\\<rparr>,\n                   mv_Void) |\n                  p w. req = (p, ro_Store w)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_load \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s, sys_load p mr s) |p mr.\n                  req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load};\n     v \\<in> action x s; ?P \\<Longrightarrow> Q; p = sys\\<rbrakk>\n    \\<Longrightarrow> Q", "apply atomize"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = sys.sys_hs_mut_done \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n                       W := W s \\<union> W',\n                       ghost_hs_in_sync := (ghost_hs_in_sync s)\n                         (m := True)\\<rparr>,\n                   mv_Void) |\n                  m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_mut \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n                  (\\<exists>m.\n                      req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_mut_pending \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s, mv_Bool (hs_pending s m)) |m.\n                  req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_load_W \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n                  req = (gc, ro_hs_gc_load_W)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_done \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n                  req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_mut_reqs \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n                   mv_Void) |\n                  m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_hs_gc_set_type \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>hs_type := ht,\n                       ghost_hs_in_sync := \\<lambda>s. False,\n                       ghost_hs_phase :=\n                         hp_step ht (ghost_hs_phase s)\\<rparr>,\n                   mv_Void) |\n                  ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.sys_free \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |\n                  r. snd req = ro_Free r}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = Proofs_Basis.sys.alloc \\<and>\n             action =\n             (\\<lambda>req s.\n                 if {a. \\<exists>y. heap s a = Some y} = UNIV\n                 then {uu_.\n                       \\<exists>_.\n                          uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n                 else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                                   \\<lparr>obj_mark = fA s,\nobj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                        mv_Ref (Some r)) |\n                       r. r \\<notin> dom (heap s) \\<and>\n                          snd req = ro_Alloc}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_unlock \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n                  (\\<exists>p.\n                      req = (p, ro_Unlock) \\<and>\n                      mem_lock s = Some p \\<and>\n                      mem_store_buffers s p = [])}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_lock \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n                  req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_mfence \\<and>\n             action =\n             (\\<lambda>req s.\n                 {uu_.\n                  uu_ = (s, mv_Void) \\<and>\n                  (\\<exists>p.\n                      req = (p, ro_MFENCE) \\<and>\n                      mem_store_buffers s p = [])}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_store \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                              (p := mem_store_buffers s p @ [w])\\<rparr>,\n                   mv_Void) |\n                  p w. req = (p, ro_Store w)}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load} \\<or>\n             l = sys.tso_load \\<and>\n             action =\n             (\\<lambda>req s.\n                 {(s, sys_load p mr s) |p mr.\n                  req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n             afts =\n             lconst\n              {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n               sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n               sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n               Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n               sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n               sys.tso_load};\n     v \\<in> action x s; ?P \\<longrightarrow> Q; p = sys\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (drule_tac P=\"x \\<or> y\" and Q=\"v \\<in> action p k\" for x y p k in conjI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> action x s; ?P \\<longrightarrow> Q; p = sys;\n     (l = sys.sys_hs_mut_done \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n                W := W s \\<union> W',\n                ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n            mv_Void) |\n           m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_mut \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n           (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_mut_pending \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s, mv_Bool (hs_pending s m)) |m.\n           req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_load_W \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n           req = (gc, ro_hs_gc_load_W)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_done \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n           req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_mut_reqs \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n            mv_Void) |\n           m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_set_type \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n                ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n            mv_Void) |\n           ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_free \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n           snd req = ro_Free r}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = Proofs_Basis.sys.alloc \\<and>\n      action =\n      (\\<lambda>req s.\n          if {a. \\<exists>y. heap s a = Some y} = UNIV\n          then {uu_.\n                \\<exists>_.\n                   uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n          else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                            \\<lparr>obj_mark = fA s, obj_fields = Map.empty,\n                               obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                 mv_Ref (Some r)) |\n                r. r \\<notin> dom (heap s) \\<and>\n                   snd req = ro_Alloc}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_unlock \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n           (\\<exists>p.\n               req = (p, ro_Unlock) \\<and>\n               mem_lock s = Some p \\<and>\n               mem_store_buffers s p = [])}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_lock \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n           req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_mfence \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (s, mv_Void) \\<and>\n           (\\<exists>p.\n               req = (p, ro_MFENCE) \\<and>\n               mem_store_buffers s p = [])}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_store \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                       (p := mem_store_buffers s p @ [w])\\<rparr>,\n            mv_Void) |\n           p w. req = (p, ro_Store w)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_load \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s, sys_load p mr s) |p mr.\n           req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load}) \\<and>\n     v \\<in> action x s\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (thin_tac \"v \\<in> action p k\" for p k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>?P \\<longrightarrow> Q; p = sys;\n     (l = sys.sys_hs_mut_done \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n                W := W s \\<union> W',\n                ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n            mv_Void) |\n           m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_mut \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n           (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_mut_pending \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s, mv_Bool (hs_pending s m)) |m.\n           req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_load_W \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n           req = (gc, ro_hs_gc_load_W)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_done \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n           req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_mut_reqs \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n            mv_Void) |\n           m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_hs_gc_set_type \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n                ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n            mv_Void) |\n           ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.sys_free \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n           snd req = ro_Free r}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = Proofs_Basis.sys.alloc \\<and>\n      action =\n      (\\<lambda>req s.\n          if {a. \\<exists>y. heap s a = Some y} = UNIV\n          then {uu_.\n                \\<exists>_.\n                   uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n          else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                            \\<lparr>obj_mark = fA s, obj_fields = Map.empty,\n                               obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                 mv_Ref (Some r)) |\n                r. r \\<notin> dom (heap s) \\<and>\n                   snd req = ro_Alloc}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_unlock \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n           (\\<exists>p.\n               req = (p, ro_Unlock) \\<and>\n               mem_lock s = Some p \\<and>\n               mem_store_buffers s p = [])}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_lock \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n           req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_mfence \\<and>\n      action =\n      (\\<lambda>req s.\n          {uu_.\n           uu_ = (s, mv_Void) \\<and>\n           (\\<exists>p.\n               req = (p, ro_MFENCE) \\<and>\n               mem_store_buffers s p = [])}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_store \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                       (p := mem_store_buffers s p @ [w])\\<rparr>,\n            mv_Void) |\n           p w. req = (p, ro_Store w)}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load} \\<or>\n      l = sys.tso_load \\<and>\n      action =\n      (\\<lambda>req s.\n          {(s, sys_load p mr s) |p mr.\n           req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n      afts =\n      lconst\n       {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n        sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n        sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n        sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n        sys.tso_mfence, sys.tso_store, sys.tso_load}) \\<and>\n     v \\<in> action x s\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (simp only: conj_disj_distribR conj_assoc mem_Collect_eq cong: conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>?P \\<longrightarrow> Q; p = sys;\n     l = sys.sys_hs_mut_done \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n               W := W s \\<union> W',\n               ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n           mv_Void) |\n          m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m W'.\n         v =\n         (s\\<lparr>hs_pending := (hs_pending s)(m := False),\n              W := W s \\<union> W',\n              ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n          mv_Void) \\<and>\n         x = (mutator m, ro_hs_mut_done W')) \\<or>\n     l = sys.sys_hs_mut \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n          (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s, mv_hs_type (hs_type s)) \\<and>\n     (\\<exists>m. x = (mutator m, ro_hs_mut_load_type)) \\<or>\n     l = sys.sys_hs_mut_pending \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, mv_Bool (hs_pending s m)) |m.\n          req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v = (s, mv_Bool (hs_pending s m)) \\<and>\n         x = (mutator m, ro_hs_mut_load_pending)) \\<or>\n     l = sys.sys_hs_gc_load_W \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n          req = (gc, ro_hs_gc_load_W)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n     x = (gc, ro_hs_gc_load_W) \\<or>\n     l = sys.sys_hs_gc_done \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n          req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v = (s, mv_Bool (\\<not> hs_pending s m)) \\<and>\n         x = (gc, ro_hs_gc_load_pending m)) \\<or>\n     l = sys.sys_hs_gc_mut_reqs \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n           mv_Void) |\n          m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v =\n         (s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n          mv_Void) \\<and>\n         x = (gc, ro_hs_gc_store_pending m)) \\<or>\n     l = sys.sys_hs_gc_set_type \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n               ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n           mv_Void) |\n          ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>ht.\n         v =\n         (s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n              ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n          mv_Void) \\<and>\n         x = (gc, ro_hs_gc_store_type ht)) \\<or>\n     l = sys.sys_free \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n          snd req = ro_Free r}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>r.\n         v = (s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) \\<and>\n         snd x = ro_Free r) \\<or>\n     l = Proofs_Basis.sys.alloc \\<and>\n     action =\n     (\\<lambda>req s.\n         if {a. \\<exists>y. heap s a = Some y} = UNIV\n         then {uu_.\n               \\<exists>_. uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n         else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                           \\<lparr>obj_mark = fA s, obj_fields = Map.empty,\n                              obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                mv_Ref (Some r)) |\n               r. r \\<notin> dom (heap s) \\<and> snd req = ro_Alloc}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v \\<in> (if {a. \\<exists>y. heap s a = Some y} = UNIV\n              then {uu_.\n                    \\<exists>_.\n                       uu_ = (s, mv_Ref None) \\<and> snd x = ro_Alloc}\n              else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fA s,\n                                   obj_fields = Map.empty,\n                                   obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                     mv_Ref (Some r)) |\n                    r. r \\<notin> dom (heap s) \\<and>\n                       snd x = ro_Alloc}) \\<or>\n     l = sys.tso_unlock \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_Unlock) \\<and>\n              mem_lock s = Some p \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (mem_lock_update Map.empty s, mv_Void) \\<and>\n     (\\<exists>p.\n         x = (p, ro_Unlock) \\<and>\n         mem_lock s = Some p \\<and> mem_store_buffers s p = []) \\<or>\n     l = sys.tso_lock \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n          req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p.\n         v = (s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) \\<and>\n         x = (p, ro_Lock) \\<and> mem_lock s = None) \\<or>\n     l = sys.tso_mfence \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_MFENCE) \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s, mv_Void) \\<and>\n     (\\<exists>p.\n         x = (p, ro_MFENCE) \\<and> mem_store_buffers s p = []) \\<or>\n     l = sys.tso_store \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                      (p := mem_store_buffers s p @ [w])\\<rparr>,\n           mv_Void) |\n          p w. req = (p, ro_Store w)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p w.\n         v =\n         (s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                     (p := mem_store_buffers s p @ [w])\\<rparr>,\n          mv_Void) \\<and>\n         x = (p, ro_Store w)) \\<or>\n     l = sys.tso_load \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, sys_load p mr s) |p mr.\n          req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p mr.\n         v = (s, sys_load p mr s) \\<and>\n         x = (p, ro_Load mr) \\<and> not_blocked s p)\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = sys;\n     l = sys.sys_hs_mut_done \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n               W := W s \\<union> W',\n               ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n           mv_Void) |\n          m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m W'.\n         v =\n         (s\\<lparr>hs_pending := (hs_pending s)(m := False),\n              W := W s \\<union> W',\n              ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n          mv_Void) \\<and>\n         x = (mutator m, ro_hs_mut_done W')) \\<or>\n     l = sys.sys_hs_mut \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n          (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s, mv_hs_type (hs_type s)) \\<and>\n     (\\<exists>m. x = (mutator m, ro_hs_mut_load_type)) \\<or>\n     l = sys.sys_hs_mut_pending \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, mv_Bool (hs_pending s m)) |m.\n          req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v = (s, mv_Bool (hs_pending s m)) \\<and>\n         x = (mutator m, ro_hs_mut_load_pending)) \\<or>\n     l = sys.sys_hs_gc_load_W \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n          req = (gc, ro_hs_gc_load_W)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n     x = (gc, ro_hs_gc_load_W) \\<or>\n     l = sys.sys_hs_gc_done \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n          req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v = (s, mv_Bool (\\<not> hs_pending s m)) \\<and>\n         x = (gc, ro_hs_gc_load_pending m)) \\<or>\n     l = sys.sys_hs_gc_mut_reqs \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n           mv_Void) |\n          m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v =\n         (s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n          mv_Void) \\<and>\n         x = (gc, ro_hs_gc_store_pending m)) \\<or>\n     l = sys.sys_hs_gc_set_type \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n               ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n           mv_Void) |\n          ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>ht.\n         v =\n         (s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n              ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n          mv_Void) \\<and>\n         x = (gc, ro_hs_gc_store_type ht)) \\<or>\n     l = sys.sys_free \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n          snd req = ro_Free r}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>r.\n         v = (s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) \\<and>\n         snd x = ro_Free r) \\<or>\n     l = Proofs_Basis.sys.alloc \\<and>\n     action =\n     (\\<lambda>req s.\n         if {a. \\<exists>y. heap s a = Some y} = UNIV\n         then {uu_.\n               \\<exists>_. uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n         else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                           \\<lparr>obj_mark = fA s, obj_fields = Map.empty,\n                              obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                mv_Ref (Some r)) |\n               r. r \\<notin> dom (heap s) \\<and> snd req = ro_Alloc}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v \\<in> (if {a. \\<exists>y. heap s a = Some y} = UNIV\n              then {uu_.\n                    \\<exists>_.\n                       uu_ = (s, mv_Ref None) \\<and> snd x = ro_Alloc}\n              else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fA s,\n                                   obj_fields = Map.empty,\n                                   obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                     mv_Ref (Some r)) |\n                    r. r \\<notin> dom (heap s) \\<and>\n                       snd x = ro_Alloc}) \\<or>\n     l = sys.tso_unlock \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_Unlock) \\<and>\n              mem_lock s = Some p \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (mem_lock_update Map.empty s, mv_Void) \\<and>\n     (\\<exists>p.\n         x = (p, ro_Unlock) \\<and>\n         mem_lock s = Some p \\<and> mem_store_buffers s p = []) \\<or>\n     l = sys.tso_lock \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n          req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p.\n         v = (s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) \\<and>\n         x = (p, ro_Lock) \\<and> mem_lock s = None) \\<or>\n     l = sys.tso_mfence \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_MFENCE) \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s, mv_Void) \\<and>\n     (\\<exists>p.\n         x = (p, ro_MFENCE) \\<and> mem_store_buffers s p = []) \\<or>\n     l = sys.tso_store \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                      (p := mem_store_buffers s p @ [w])\\<rparr>,\n           mv_Void) |\n          p w. req = (p, ro_Store w)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p w.\n         v =\n         (s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                     (p := mem_store_buffers s p @ [w])\\<rparr>,\n          mv_Void) \\<and>\n         x = (p, ro_Store w)) \\<or>\n     l = sys.tso_load \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, sys_load p mr s) |p mr.\n          req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p mr.\n         v = (s, sys_load p mr s) \\<and>\n         x = (p, ro_Load mr) \\<and> not_blocked s p)\\<rbrakk>\n    \\<Longrightarrow> ?P", "apply (thin_tac \"p = sys\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = sys.sys_hs_mut_done \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n              W := W s \\<union> W',\n              ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n          mv_Void) |\n         m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>m W'.\n        v =\n        (s\\<lparr>hs_pending := (hs_pending s)(m := False),\n             W := W s \\<union> W',\n             ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n         mv_Void) \\<and>\n        x = (mutator m, ro_hs_mut_done W')) \\<or>\n    l = sys.sys_hs_mut \\<and>\n    action =\n    (\\<lambda>req s.\n        {uu_.\n         uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n         (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    v = (s, mv_hs_type (hs_type s)) \\<and>\n    (\\<exists>m. x = (mutator m, ro_hs_mut_load_type)) \\<or>\n    l = sys.sys_hs_mut_pending \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s, mv_Bool (hs_pending s m)) |m.\n         req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>m.\n        v = (s, mv_Bool (hs_pending s m)) \\<and>\n        x = (mutator m, ro_hs_mut_load_pending)) \\<or>\n    l = sys.sys_hs_gc_load_W \\<and>\n    action =\n    (\\<lambda>req s.\n        {uu_.\n         uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n         req = (gc, ro_hs_gc_load_W)}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    v = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n    x = (gc, ro_hs_gc_load_W) \\<or>\n    l = sys.sys_hs_gc_done \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n         req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>m.\n        v = (s, mv_Bool (\\<not> hs_pending s m)) \\<and>\n        x = (gc, ro_hs_gc_load_pending m)) \\<or>\n    l = sys.sys_hs_gc_mut_reqs \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n          mv_Void) |\n         m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>m.\n        v =\n        (s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n         mv_Void) \\<and>\n        x = (gc, ro_hs_gc_store_pending m)) \\<or>\n    l = sys.sys_hs_gc_set_type \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n              ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n          mv_Void) |\n         ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>ht.\n        v =\n        (s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n             ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n         mv_Void) \\<and>\n        x = (gc, ro_hs_gc_store_type ht)) \\<or>\n    l = sys.sys_free \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n         snd req = ro_Free r}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>r.\n        v = (s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) \\<and>\n        snd x = ro_Free r) \\<or>\n    l = Proofs_Basis.sys.alloc \\<and>\n    action =\n    (\\<lambda>req s.\n        if {a. \\<exists>y. heap s a = Some y} = UNIV\n        then {uu_.\n              \\<exists>_. uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n        else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                          \\<lparr>obj_mark = fA s, obj_fields = Map.empty,\n                             obj_payload = Map.empty\\<rparr>)\\<rparr>,\n               mv_Ref (Some r)) |\n              r. r \\<notin> dom (heap s) \\<and> snd req = ro_Alloc}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    v \\<in> (if {a. \\<exists>y. heap s a = Some y} = UNIV\n             then {uu_.\n                   \\<exists>_.\n                      uu_ = (s, mv_Ref None) \\<and> snd x = ro_Alloc}\n             else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                               \\<lparr>obj_mark = fA s,\n                                  obj_fields = Map.empty,\n                                  obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                    mv_Ref (Some r)) |\n                   r. r \\<notin> dom (heap s) \\<and>\n                      snd x = ro_Alloc}) \\<or>\n    l = sys.tso_unlock \\<and>\n    action =\n    (\\<lambda>req s.\n        {uu_.\n         uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n         (\\<exists>p.\n             req = (p, ro_Unlock) \\<and>\n             mem_lock s = Some p \\<and> mem_store_buffers s p = [])}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    v = (mem_lock_update Map.empty s, mv_Void) \\<and>\n    (\\<exists>p.\n        x = (p, ro_Unlock) \\<and>\n        mem_lock s = Some p \\<and> mem_store_buffers s p = []) \\<or>\n    l = sys.tso_lock \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n         req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>p.\n        v = (s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) \\<and>\n        x = (p, ro_Lock) \\<and> mem_lock s = None) \\<or>\n    l = sys.tso_mfence \\<and>\n    action =\n    (\\<lambda>req s.\n        {uu_.\n         uu_ = (s, mv_Void) \\<and>\n         (\\<exists>p.\n             req = (p, ro_MFENCE) \\<and>\n             mem_store_buffers s p = [])}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    v = (s, mv_Void) \\<and>\n    (\\<exists>p. x = (p, ro_MFENCE) \\<and> mem_store_buffers s p = []) \\<or>\n    l = sys.tso_store \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                     (p := mem_store_buffers s p @ [w])\\<rparr>,\n          mv_Void) |\n         p w. req = (p, ro_Store w)}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>p w.\n        v =\n        (s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                    (p := mem_store_buffers s p @ [w])\\<rparr>,\n         mv_Void) \\<and>\n        x = (p, ro_Store w)) \\<or>\n    l = sys.tso_load \\<and>\n    action =\n    (\\<lambda>req s.\n        {(s, sys_load p mr s) |p mr.\n         req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n    afts =\n    lconst\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n    (\\<exists>p mr.\n        v = (s, sys_load p mr s) \\<and>\n        x = (p, ro_Load mr) \\<and> not_blocked s p) \\<Longrightarrow>\n    ?P", "apply (assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal system_responds_action_caseE:\n  \"\\<lbrakk> (\\<lbrace>l\\<rbrace> Response action, afts) \\<in> fragments (gc_coms p) {}; v \\<in> action (pname, req) s;\n     \\<lbrakk> p = sys; case_request_op ?P1 ?P2 ?P3 ?P4 ?P5 ?P6 ?P7 ?P8 ?P9 ?P10 ?P11 ?P12 ?P13 ?P14 req \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lbrace>l\\<rbrace> Response action, afts)\n             \\<in> fragments (gc_coms p) {};\n     v \\<in> action (pname, req) s;\n     \\<lbrakk>p = sys;\n      case req of ro_MFENCE \\<Rightarrow> ?P1\n      | ro_Load x \\<Rightarrow> ?P2 x | ro_Store x \\<Rightarrow> ?P3 x\n      | ro_Lock \\<Rightarrow> ?P4 | ro_Unlock \\<Rightarrow> ?P5\n      | ro_Alloc \\<Rightarrow> ?P6 | ro_Free x \\<Rightarrow> ?P7 x\n      | ro_hs_gc_load_pending x \\<Rightarrow> ?P8 x\n      | ro_hs_gc_store_type x \\<Rightarrow> ?P9 x\n      | ro_hs_gc_store_pending x \\<Rightarrow> ?P10 x\n      | ro_hs_gc_load_W \\<Rightarrow> ?P11\n      | ro_hs_mut_load_pending \\<Rightarrow> ?P12\n      | ro_hs_mut_load_type \\<Rightarrow> ?P13\n      | ro_hs_mut_done x \\<Rightarrow> ?P14 x\\<rbrakk>\n     \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (erule(1) system_responds_actionE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> action (pname, req) s;\n     \\<lbrakk>p = sys;\n      case req of ro_MFENCE \\<Rightarrow> ?P1\n      | ro_Load x \\<Rightarrow> ?P2 x | ro_Store x \\<Rightarrow> ?P3 x\n      | ro_Lock \\<Rightarrow> ?P4 | ro_Unlock \\<Rightarrow> ?P5\n      | ro_Alloc \\<Rightarrow> ?P6 | ro_Free x \\<Rightarrow> ?P7 x\n      | ro_hs_gc_load_pending x \\<Rightarrow> ?P8 x\n      | ro_hs_gc_store_type x \\<Rightarrow> ?P9 x\n      | ro_hs_gc_store_pending x \\<Rightarrow> ?P10 x\n      | ro_hs_gc_load_W \\<Rightarrow> ?P11\n      | ro_hs_mut_load_pending \\<Rightarrow> ?P12\n      | ro_hs_mut_load_type \\<Rightarrow> ?P13\n      | ro_hs_mut_done x \\<Rightarrow> ?P14 x\\<rbrakk>\n     \\<Longrightarrow> Q;\n     p = sys;\n     l = sys.sys_hs_mut_done \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n               W := W s \\<union> W',\n               ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n           mv_Void) |\n          m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m W'.\n         v =\n         (s\\<lparr>hs_pending := (hs_pending s)(m := False),\n              W := W s \\<union> W',\n              ghost_hs_in_sync := (ghost_hs_in_sync s)(m := True)\\<rparr>,\n          mv_Void) \\<and>\n         (pname, req) = (mutator m, ro_hs_mut_done W')) \\<or>\n     l = sys.sys_hs_mut \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n          (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s, mv_hs_type (hs_type s)) \\<and>\n     (\\<exists>m. (pname, req) = (mutator m, ro_hs_mut_load_type)) \\<or>\n     l = sys.sys_hs_mut_pending \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, mv_Bool (hs_pending s m)) |m.\n          req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v = (s, mv_Bool (hs_pending s m)) \\<and>\n         (pname, req) = (mutator m, ro_hs_mut_load_pending)) \\<or>\n     l = sys.sys_hs_gc_load_W \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n          req = (gc, ro_hs_gc_load_W)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n     (pname, req) = (gc, ro_hs_gc_load_W) \\<or>\n     l = sys.sys_hs_gc_done \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n          req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v = (s, mv_Bool (\\<not> hs_pending s m)) \\<and>\n         (pname, req) = (gc, ro_hs_gc_load_pending m)) \\<or>\n     l = sys.sys_hs_gc_mut_reqs \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n           mv_Void) |\n          m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>m.\n         v =\n         (s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n          mv_Void) \\<and>\n         (pname, req) = (gc, ro_hs_gc_store_pending m)) \\<or>\n     l = sys.sys_hs_gc_set_type \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n               ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n           mv_Void) |\n          ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>ht.\n         v =\n         (s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n              ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n          mv_Void) \\<and>\n         (pname, req) = (gc, ro_hs_gc_store_type ht)) \\<or>\n     l = sys.sys_free \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n          snd req = ro_Free r}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>r.\n         v = (s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) \\<and>\n         snd (pname, req) = ro_Free r) \\<or>\n     l = Proofs_Basis.sys.alloc \\<and>\n     action =\n     (\\<lambda>req s.\n         if {a. \\<exists>y. heap s a = Some y} = UNIV\n         then {uu_.\n               \\<exists>_. uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n         else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                           \\<lparr>obj_mark = fA s, obj_fields = Map.empty,\n                              obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                mv_Ref (Some r)) |\n               r. r \\<notin> dom (heap s) \\<and> snd req = ro_Alloc}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v \\<in> (if {a. \\<exists>y. heap s a = Some y} = UNIV\n              then {uu_.\n                    \\<exists>_.\n                       uu_ = (s, mv_Ref None) \\<and>\n                       snd (pname, req) = ro_Alloc}\n              else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fA s,\n                                   obj_fields = Map.empty,\n                                   obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                     mv_Ref (Some r)) |\n                    r. r \\<notin> dom (heap s) \\<and>\n                       snd (pname, req) = ro_Alloc}) \\<or>\n     l = sys.tso_unlock \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_Unlock) \\<and>\n              mem_lock s = Some p \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (mem_lock_update Map.empty s, mv_Void) \\<and>\n     (\\<exists>p.\n         (pname, req) = (p, ro_Unlock) \\<and>\n         mem_lock s = Some p \\<and> mem_store_buffers s p = []) \\<or>\n     l = sys.tso_lock \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n          req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p.\n         v = (s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) \\<and>\n         (pname, req) = (p, ro_Lock) \\<and> mem_lock s = None) \\<or>\n     l = sys.tso_mfence \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_MFENCE) \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s, mv_Void) \\<and>\n     (\\<exists>p.\n         (pname, req) = (p, ro_MFENCE) \\<and>\n         mem_store_buffers s p = []) \\<or>\n     l = sys.tso_store \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                      (p := mem_store_buffers s p @ [w])\\<rparr>,\n           mv_Void) |\n          p w. req = (p, ro_Store w)}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p w.\n         v =\n         (s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                     (p := mem_store_buffers s p @ [w])\\<rparr>,\n          mv_Void) \\<and>\n         (pname, req) = (p, ro_Store w)) \\<or>\n     l = sys.tso_load \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s, sys_load p mr s) |p mr.\n          req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p mr.\n         v = (s, sys_load p mr s) \\<and>\n         (pname, req) = (p, ro_Load mr) \\<and> not_blocked s p)\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (cases req; simp only: request_op.simps prod.inject simp_thms fst_conv snd_conv if_cancel empty_def[symmetric] empty_iff)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<lbrakk>(s, mv_Void) \\<in> {uu_. uu_ = (s, mv_Void)};\n     \\<lbrakk>True; ?P1\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n     l = sys.tso_mfence \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_MFENCE) \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (s, mv_Void) \\<and> mem_store_buffers s pname = [];\n     req = ro_MFENCE\\<rbrakk>\n    \\<Longrightarrow> Q\n 2. \\<And>x2.\n       \\<lbrakk>v \\<in> {(s, sys_load p mr s) |p mr.\n                         (pname = p \\<and> x2 = mr) \\<and> not_blocked s p};\n        \\<lbrakk>True; ?P2 x2\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n        l = sys.tso_load \\<and>\n        action =\n        (\\<lambda>req s.\n            {(s, sys_load p mr s) |p mr.\n             req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n        afts =\n        lconst\n         {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n          sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n          sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n          sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n          sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n        (\\<exists>p mr.\n            v = (s, sys_load p mr s) \\<and>\n            (pname = p \\<and> x2 = mr) \\<and> not_blocked s p);\n        req = ro_Load x2\\<rbrakk>\n       \\<Longrightarrow> Q\n 3. \\<And>x3.\n       \\<lbrakk>v \\<in> {(s\\<lparr>mem_store_buffers :=\n                                     (mem_store_buffers s)\n                                     (p :=\n  mem_store_buffers s p @ [w])\\<rparr>,\n                          mv_Void) |\n                         p w. pname = p \\<and> x3 = w};\n        \\<lbrakk>True; ?P3 x3\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n        l = sys.tso_store \\<and>\n        action =\n        (\\<lambda>req s.\n            {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                         (p := mem_store_buffers s p @ [w])\\<rparr>,\n              mv_Void) |\n             p w. req = (p, ro_Store w)}) \\<and>\n        afts =\n        lconst\n         {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n          sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n          sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n          sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n          sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n        (\\<exists>p w.\n            v =\n            (s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                        (p := mem_store_buffers s p @ [w])\\<rparr>,\n             mv_Void) \\<and>\n            pname = p \\<and> x3 = w);\n        req = ro_Store x3\\<rbrakk>\n       \\<Longrightarrow> Q\n 4. \\<lbrakk>v \\<in> {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n                      pname = p \\<and> mem_lock s = None};\n     \\<lbrakk>True; ?P4\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n     l = sys.tso_lock \\<and>\n     action =\n     (\\<lambda>req s.\n         {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n          req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     (\\<exists>p.\n         v = (s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) \\<and>\n         pname = p \\<and> mem_lock s = None);\n     req = ro_Lock\\<rbrakk>\n    \\<Longrightarrow> Q\n 5. \\<lbrakk>(mem_lock_update Map.empty s, mv_Void)\n             \\<in> {uu_. uu_ = (mem_lock_update Map.empty s, mv_Void)};\n     \\<lbrakk>True; ?P5\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n     l = sys.tso_unlock \\<and>\n     action =\n     (\\<lambda>req s.\n         {uu_.\n          uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n          (\\<exists>p.\n              req = (p, ro_Unlock) \\<and>\n              mem_lock s = Some p \\<and>\n              mem_store_buffers s p = [])}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v = (mem_lock_update Map.empty s, mv_Void) \\<and>\n     mem_lock s = Some pname \\<and> mem_store_buffers s pname = [];\n     req = ro_Unlock\\<rbrakk>\n    \\<Longrightarrow> Q\n 6. \\<lbrakk>True; \\<lbrakk>True; ?P6\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n     l = Proofs_Basis.sys.alloc \\<and>\n     action =\n     (\\<lambda>req s.\n         if {a. \\<exists>y. heap s a = Some y} = UNIV\n         then {uu_. uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n         else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                           \\<lparr>obj_mark = fA s, obj_fields = Map.empty,\n                              obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                mv_Ref (Some r)) |\n               r. r \\<notin> dom (heap s) \\<and> snd req = ro_Alloc}) \\<and>\n     afts =\n     lconst\n      {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n       sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n       sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n       sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n       sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n     v \\<in> (if {a. \\<exists>y. heap s a = Some y} = UNIV\n              then {uu_. uu_ = (s, mv_Ref None)}\n              else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fA s,\n                                   obj_fields = Map.empty,\n                                   obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                     mv_Ref (Some r)) |\n                    r. r \\<notin> dom (heap s)});\n     req = ro_Alloc\\<rbrakk>\n    \\<Longrightarrow> Q\n 7. \\<And>x7.\n       \\<lbrakk>v \\<in> {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>,\n                          mv_Void) |\n                         r. x7 = r};\n        \\<lbrakk>True; ?P7 x7\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n        l = sys.sys_free \\<and>\n        action =\n        (\\<lambda>req s.\n            {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n             snd req = ro_Free r}) \\<and>\n        afts =\n        lconst\n         {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n          sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n          sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n          sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n          sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n        (\\<exists>r.\n            v =\n            (s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) \\<and>\n            x7 = r);\n        req = ro_Free x7\\<rbrakk>\n       \\<Longrightarrow> Q\n 8. \\<And>x8.\n       \\<lbrakk>v \\<in> {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n                         pname = gc \\<and> x8 = m};\n        \\<lbrakk>True; ?P8 x8\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n        l = sys.sys_hs_gc_done \\<and>\n        action =\n        (\\<lambda>req s.\n            {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n             req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n        afts =\n        lconst\n         {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n          sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n          sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n          sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n          sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n        (\\<exists>m.\n            v = (s, mv_Bool (\\<not> hs_pending s m)) \\<and>\n            pname = gc \\<and> x8 = m);\n        req = ro_hs_gc_load_pending x8\\<rbrakk>\n       \\<Longrightarrow> Q\n 9. \\<And>x9.\n       \\<lbrakk>v \\<in> {(s\\<lparr>hs_type := ht,\n                              ghost_hs_in_sync := \\<lambda>s. False,\n                              ghost_hs_phase :=\n                                hp_step ht (ghost_hs_phase s)\\<rparr>,\n                          mv_Void) |\n                         ht. pname = gc \\<and> x9 = ht};\n        \\<lbrakk>True; ?P9 x9\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n        l = sys.sys_hs_gc_set_type \\<and>\n        action =\n        (\\<lambda>req s.\n            {(s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n                  ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n              mv_Void) |\n             ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n        afts =\n        lconst\n         {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n          sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n          sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n          sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n          sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n        (\\<exists>ht.\n            v =\n            (s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n                 ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n             mv_Void) \\<and>\n            pname = gc \\<and> x9 = ht);\n        req = ro_hs_gc_store_type x9\\<rbrakk>\n       \\<Longrightarrow> Q\n 10. \\<And>x10.\n        \\<lbrakk>v \\<in> {(s\\<lparr>hs_pending := (hs_pending s)\n(m := True)\\<rparr>,\n                           mv_Void) |\n                          m. pname = gc \\<and> x10 = m};\n         \\<lbrakk>True; ?P10 x10\\<rbrakk> \\<Longrightarrow> Q; p = sys;\n         l = sys.sys_hs_gc_mut_reqs \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n               mv_Void) |\n              m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m.\n             v =\n             (s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n              mv_Void) \\<and>\n             pname = gc \\<and> x10 = m);\n         req = ro_hs_gc_store_pending x10\\<rbrakk>\n        \\<Longrightarrow> Q\nA total of 14 subgoals...", "apply (drule meta_mp[OF _ TrueI], erule meta_mp, erule_tac P=\"A \\<and> B\" for A B in triv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal system_responds_action_specE:\n  \"\\<lbrakk> (\\<lbrace>l\\<rbrace> Response action, afts) \\<in> fragments (gc_coms p) {}; v \\<in> action x s;\n     \\<lbrakk> p = sys; case_request_op ?P1 ?P2 ?P3 ?P4 ?P5 ?P6 ?P7 ?P8 ?P9 ?P10 ?P11 ?P12 ?P13 ?P14 (snd x) \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lbrace>l\\<rbrace> Response action, afts)\n             \\<in> fragments (gc_coms p) {};\n     v \\<in> action x s;\n     \\<lbrakk>p = sys;\n      case snd x of ro_MFENCE \\<Rightarrow> ?P1\n      | ro_Load x \\<Rightarrow> ?P2 x | ro_Store x \\<Rightarrow> ?P3 x\n      | ro_Lock \\<Rightarrow> ?P4 | ro_Unlock \\<Rightarrow> ?P5\n      | ro_Alloc \\<Rightarrow> ?P6 | ro_Free x \\<Rightarrow> ?P7 x\n      | ro_hs_gc_load_pending x \\<Rightarrow> ?P8 x\n      | ro_hs_gc_store_type x \\<Rightarrow> ?P9 x\n      | ro_hs_gc_store_pending x \\<Rightarrow> ?P10 x\n      | ro_hs_gc_load_W \\<Rightarrow> ?P11\n      | ro_hs_mut_load_pending \\<Rightarrow> ?P12\n      | ro_hs_mut_load_type \\<Rightarrow> ?P13\n      | ro_hs_mut_done x \\<Rightarrow> ?P14 x\\<rbrakk>\n     \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "apply (erule system_responds_action_caseE[where pname=\"fst x\" and req=\"snd x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> action x s;\n     \\<lbrakk>p = sys;\n      case snd x of ro_MFENCE \\<Rightarrow> ?P1\n      | ro_Load x \\<Rightarrow> ?P2 x | ro_Store x \\<Rightarrow> ?P3 x\n      | ro_Lock \\<Rightarrow> ?P4 | ro_Unlock \\<Rightarrow> ?P5\n      | ro_Alloc \\<Rightarrow> ?P6 | ro_Free x \\<Rightarrow> ?P7 x\n      | ro_hs_gc_load_pending x \\<Rightarrow> ?P8 x\n      | ro_hs_gc_store_type x \\<Rightarrow> ?P9 x\n      | ro_hs_gc_store_pending x \\<Rightarrow> ?P10 x\n      | ro_hs_gc_load_W \\<Rightarrow> ?P11\n      | ro_hs_mut_load_pending \\<Rightarrow> ?P12\n      | ro_hs_mut_load_type \\<Rightarrow> ?P13\n      | ro_hs_mut_done x \\<Rightarrow> ?P14 x\\<rbrakk>\n     \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> ?v30 \\<in> action (fst x, snd x) ?s30\n 2. \\<lbrakk>v \\<in> action x s;\n     \\<lbrakk>p = sys;\n      case snd x of ro_MFENCE \\<Rightarrow> ?P1\n      | ro_Load x \\<Rightarrow> ?P2 x | ro_Store x \\<Rightarrow> ?P3 x\n      | ro_Lock \\<Rightarrow> ?P4 | ro_Unlock \\<Rightarrow> ?P5\n      | ro_Alloc \\<Rightarrow> ?P6 | ro_Free x \\<Rightarrow> ?P7 x\n      | ro_hs_gc_load_pending x \\<Rightarrow> ?P8 x\n      | ro_hs_gc_store_type x \\<Rightarrow> ?P9 x\n      | ro_hs_gc_store_pending x \\<Rightarrow> ?P10 x\n      | ro_hs_gc_load_W \\<Rightarrow> ?P11\n      | ro_hs_mut_load_pending \\<Rightarrow> ?P12\n      | ro_hs_mut_load_type \\<Rightarrow> ?P13\n      | ro_hs_mut_done x \\<Rightarrow> ?P14 x\\<rbrakk>\n     \\<Longrightarrow> Q;\n     p = sys;\n     case snd x of\n     ro_MFENCE \\<Rightarrow>\n       l = sys.tso_mfence \\<and>\n       action =\n       (\\<lambda>req s.\n           {uu_.\n            uu_ = (s, mv_Void) \\<and>\n            (\\<exists>p.\n                req = (p, ro_MFENCE) \\<and>\n                mem_store_buffers s p = [])}) \\<and>\n       afts =\n       lconst\n        {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n         sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n         sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n         sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n         sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n       ?v30 = (?s30, mv_Void) \\<and> mem_store_buffers ?s30 (fst x) = []\n     | ro_Load x2 \\<Rightarrow>\n         l = sys.tso_load \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s, sys_load p mr s) |p mr.\n              req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>p mr.\n             ?v30 = (?s30, sys_load p mr ?s30) \\<and>\n             (fst x = p \\<and> x2 = mr) \\<and> not_blocked ?s30 p)\n     | ro_Store x3 \\<Rightarrow>\n         l = sys.tso_store \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                          (p := mem_store_buffers s p @ [w])\\<rparr>,\n               mv_Void) |\n              p w. req = (p, ro_Store w)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>p w.\n             ?v30 =\n             (?s30\n              \\<lparr>mem_store_buffers := (mem_store_buffers ?s30)\n                        (p := mem_store_buffers ?s30 p @ [w])\\<rparr>,\n              mv_Void) \\<and>\n             fst x = p \\<and> x3 = w)\n     | ro_Lock \\<Rightarrow>\n         l = sys.tso_lock \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n              req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>p.\n             ?v30 = (?s30\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) \\<and>\n             fst x = p \\<and> mem_lock ?s30 = None)\n     | ro_Unlock \\<Rightarrow>\n         l = sys.tso_unlock \\<and>\n         action =\n         (\\<lambda>req s.\n             {uu_.\n              uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n              (\\<exists>p.\n                  req = (p, ro_Unlock) \\<and>\n                  mem_lock s = Some p \\<and>\n                  mem_store_buffers s p = [])}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         ?v30 = (mem_lock_update Map.empty ?s30, mv_Void) \\<and>\n         mem_lock ?s30 = Some (fst x) \\<and>\n         mem_store_buffers ?s30 (fst x) = []\n     | ro_Alloc \\<Rightarrow>\n         l = Proofs_Basis.sys.alloc \\<and>\n         action =\n         (\\<lambda>req s.\n             if {a. \\<exists>y. heap s a = Some y} = UNIV\n             then {uu_. uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n             else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                               \\<lparr>obj_mark = fA s,\n                                  obj_fields = Map.empty,\n                                  obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                    mv_Ref (Some r)) |\n                   r. r \\<notin> dom (heap s) \\<and>\n                      snd req = ro_Alloc}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         ?v30\n         \\<in> (if {a. \\<exists>y. heap ?s30 a = Some y} = UNIV\n                then {uu_. uu_ = (?s30, mv_Ref None)}\n                else {(?s30\n                       \\<lparr>heap := heap ?s30(r \\<mapsto>\n                                 \\<lparr>obj_mark = fA ?s30,\n                                    obj_fields = Map.empty,\n                                    obj_payload =\nMap.empty\\<rparr>)\\<rparr>,\n                       mv_Ref (Some r)) |\n                      r. r \\<notin> dom (heap ?s30)})\n     | ro_Free x7 \\<Rightarrow>\n         l = sys.sys_free \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n              snd req = ro_Free r}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>r.\n             ?v30 =\n             (?s30\\<lparr>heap := (heap ?s30)(r := None)\\<rparr>,\n              mv_Void) \\<and>\n             x7 = r)\n     | ro_hs_gc_load_pending x8 \\<Rightarrow>\n         l = sys.sys_hs_gc_done \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n              req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m.\n             ?v30 = (?s30, mv_Bool (\\<not> hs_pending ?s30 m)) \\<and>\n             fst x = gc \\<and> x8 = m)\n     | ro_hs_gc_store_type x9 \\<Rightarrow>\n         l = sys.sys_hs_gc_set_type \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>hs_type := ht,\n                   ghost_hs_in_sync := \\<lambda>s. False,\n                   ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n               mv_Void) |\n              ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>ht.\n             ?v30 =\n             (?s30\n              \\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n                 ghost_hs_phase := hp_step ht (ghost_hs_phase ?s30)\\<rparr>,\n              mv_Void) \\<and>\n             fst x = gc \\<and> x9 = ht)\n     | ro_hs_gc_store_pending x10 \\<Rightarrow>\n         l = sys.sys_hs_gc_mut_reqs \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n               mv_Void) |\n              m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m.\n             ?v30 =\n             (?s30\n              \\<lparr>hs_pending := (hs_pending ?s30)(m := True)\\<rparr>,\n              mv_Void) \\<and>\n             fst x = gc \\<and> x10 = m)\n     | ro_hs_gc_load_W \\<Rightarrow>\n         l = sys.sys_hs_gc_load_W \\<and>\n         action =\n         (\\<lambda>req s.\n             {uu_.\n              uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n              req = (gc, ro_hs_gc_load_W)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         ?v30 = (?s30\\<lparr>W := {}\\<rparr>, mv_Refs (W ?s30)) \\<and>\n         fst x = gc\n     | ro_hs_mut_load_pending \\<Rightarrow>\n         l = sys.sys_hs_mut_pending \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s, mv_Bool (hs_pending s m)) |m.\n              req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m.\n             ?v30 = (?s30, mv_Bool (hs_pending ?s30 m)) \\<and>\n             fst x = mutator m)\n     | ro_hs_mut_load_type \\<Rightarrow>\n         l = sys.sys_hs_mut \\<and>\n         action =\n         (\\<lambda>req s.\n             {uu_.\n              uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n              (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         ?v30 = (?s30, mv_hs_type (hs_type ?s30)) \\<and>\n         (\\<exists>m. fst x = mutator m)\n     | ro_hs_mut_done x14 \\<Rightarrow>\n         l = sys.sys_hs_mut_done \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n                   W := W s \\<union> W',\n                   ghost_hs_in_sync := (ghost_hs_in_sync s)\n                     (m := True)\\<rparr>,\n               mv_Void) |\n              m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m W'.\n             ?v30 =\n             (?s30\n              \\<lparr>hs_pending := (hs_pending ?s30)(m := False),\n                 W := W ?s30 \\<union> W',\n                 ghost_hs_in_sync := (ghost_hs_in_sync ?s30)\n                   (m := True)\\<rparr>,\n              mv_Void) \\<and>\n             fst x = mutator m \\<and> x14 = W')\\<rbrakk>\n    \\<Longrightarrow> Q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> action x s;\n     \\<lbrakk>p = sys;\n      case snd x of ro_MFENCE \\<Rightarrow> ?P1\n      | ro_Load x \\<Rightarrow> ?P2 x | ro_Store x \\<Rightarrow> ?P3 x\n      | ro_Lock \\<Rightarrow> ?P4 | ro_Unlock \\<Rightarrow> ?P5\n      | ro_Alloc \\<Rightarrow> ?P6 | ro_Free x \\<Rightarrow> ?P7 x\n      | ro_hs_gc_load_pending x \\<Rightarrow> ?P8 x\n      | ro_hs_gc_store_type x \\<Rightarrow> ?P9 x\n      | ro_hs_gc_store_pending x \\<Rightarrow> ?P10 x\n      | ro_hs_gc_load_W \\<Rightarrow> ?P11\n      | ro_hs_mut_load_pending \\<Rightarrow> ?P12\n      | ro_hs_mut_load_type \\<Rightarrow> ?P13\n      | ro_hs_mut_done x \\<Rightarrow> ?P14 x\\<rbrakk>\n     \\<Longrightarrow> Q;\n     p = sys;\n     case snd x of\n     ro_MFENCE \\<Rightarrow>\n       l = sys.tso_mfence \\<and>\n       action =\n       (\\<lambda>req s.\n           {uu_.\n            uu_ = (s, mv_Void) \\<and>\n            (\\<exists>p.\n                req = (p, ro_MFENCE) \\<and>\n                mem_store_buffers s p = [])}) \\<and>\n       afts =\n       lconst\n        {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n         sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n         sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n         sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n         sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n       v = (s, mv_Void) \\<and> mem_store_buffers s (fst x) = []\n     | ro_Load x2 \\<Rightarrow>\n         l = sys.tso_load \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s, sys_load p mr s) |p mr.\n              req = (p, ro_Load mr) \\<and> not_blocked s p}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>p mr.\n             v = (s, sys_load p mr s) \\<and>\n             (fst x = p \\<and> x2 = mr) \\<and> not_blocked s p)\n     | ro_Store x3 \\<Rightarrow>\n         l = sys.tso_store \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                          (p := mem_store_buffers s p @ [w])\\<rparr>,\n               mv_Void) |\n              p w. req = (p, ro_Store w)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>p w.\n             v =\n             (s\\<lparr>mem_store_buffers := (mem_store_buffers s)\n                         (p := mem_store_buffers s p @ [w])\\<rparr>,\n              mv_Void) \\<and>\n             fst x = p \\<and> x3 = w)\n     | ro_Lock \\<Rightarrow>\n         l = sys.tso_lock \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) |p.\n              req = (p, ro_Lock) \\<and> mem_lock s = None}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>p.\n             v = (s\\<lparr>mem_lock := Some p\\<rparr>, mv_Void) \\<and>\n             fst x = p \\<and> mem_lock s = None)\n     | ro_Unlock \\<Rightarrow>\n         l = sys.tso_unlock \\<and>\n         action =\n         (\\<lambda>req s.\n             {uu_.\n              uu_ = (mem_lock_update Map.empty s, mv_Void) \\<and>\n              (\\<exists>p.\n                  req = (p, ro_Unlock) \\<and>\n                  mem_lock s = Some p \\<and>\n                  mem_store_buffers s p = [])}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         v = (mem_lock_update Map.empty s, mv_Void) \\<and>\n         mem_lock s = Some (fst x) \\<and> mem_store_buffers s (fst x) = []\n     | ro_Alloc \\<Rightarrow>\n         l = Proofs_Basis.sys.alloc \\<and>\n         action =\n         (\\<lambda>req s.\n             if {a. \\<exists>y. heap s a = Some y} = UNIV\n             then {uu_. uu_ = (s, mv_Ref None) \\<and> snd req = ro_Alloc}\n             else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                               \\<lparr>obj_mark = fA s,\n                                  obj_fields = Map.empty,\n                                  obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                    mv_Ref (Some r)) |\n                   r. r \\<notin> dom (heap s) \\<and>\n                      snd req = ro_Alloc}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         v \\<in> (if {a. \\<exists>y. heap s a = Some y} = UNIV\n                  then {uu_. uu_ = (s, mv_Ref None)}\n                  else {(s\\<lparr>heap := heap s(r \\<mapsto>\n                                    \\<lparr>obj_mark = fA s,\n obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>,\n                         mv_Ref (Some r)) |\n                        r. r \\<notin> dom (heap s)})\n     | ro_Free x7 \\<Rightarrow>\n         l = sys.sys_free \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) |r.\n              snd req = ro_Free r}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>r.\n             v =\n             (s\\<lparr>heap := (heap s)(r := None)\\<rparr>, mv_Void) \\<and>\n             x7 = r)\n     | ro_hs_gc_load_pending x8 \\<Rightarrow>\n         l = sys.sys_hs_gc_done \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s, mv_Bool (\\<not> hs_pending s m)) |m.\n              req = (gc, ro_hs_gc_load_pending m)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m.\n             v = (s, mv_Bool (\\<not> hs_pending s m)) \\<and>\n             fst x = gc \\<and> x8 = m)\n     | ro_hs_gc_store_type x9 \\<Rightarrow>\n         l = sys.sys_hs_gc_set_type \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>hs_type := ht,\n                   ghost_hs_in_sync := \\<lambda>s. False,\n                   ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n               mv_Void) |\n              ht. req = (gc, ro_hs_gc_store_type ht)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>ht.\n             v =\n             (s\\<lparr>hs_type := ht, ghost_hs_in_sync := \\<lambda>s. False,\n                  ghost_hs_phase := hp_step ht (ghost_hs_phase s)\\<rparr>,\n              mv_Void) \\<and>\n             fst x = gc \\<and> x9 = ht)\n     | ro_hs_gc_store_pending x10 \\<Rightarrow>\n         l = sys.sys_hs_gc_mut_reqs \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n               mv_Void) |\n              m. req = (gc, ro_hs_gc_store_pending m)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m.\n             v =\n             (s\\<lparr>hs_pending := (hs_pending s)(m := True)\\<rparr>,\n              mv_Void) \\<and>\n             fst x = gc \\<and> x10 = m)\n     | ro_hs_gc_load_W \\<Rightarrow>\n         l = sys.sys_hs_gc_load_W \\<and>\n         action =\n         (\\<lambda>req s.\n             {uu_.\n              uu_ = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and>\n              req = (gc, ro_hs_gc_load_W)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         v = (s\\<lparr>W := {}\\<rparr>, mv_Refs (W s)) \\<and> fst x = gc\n     | ro_hs_mut_load_pending \\<Rightarrow>\n         l = sys.sys_hs_mut_pending \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s, mv_Bool (hs_pending s m)) |m.\n              req = (mutator m, ro_hs_mut_load_pending)}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m.\n             v = (s, mv_Bool (hs_pending s m)) \\<and> fst x = mutator m)\n     | ro_hs_mut_load_type \\<Rightarrow>\n         l = sys.sys_hs_mut \\<and>\n         action =\n         (\\<lambda>req s.\n             {uu_.\n              uu_ = (s, mv_hs_type (hs_type s)) \\<and>\n              (\\<exists>m. req = (mutator m, ro_hs_mut_load_type))}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         v = (s, mv_hs_type (hs_type s)) \\<and>\n         (\\<exists>m. fst x = mutator m)\n     | ro_hs_mut_done x14 \\<Rightarrow>\n         l = sys.sys_hs_mut_done \\<and>\n         action =\n         (\\<lambda>req s.\n             {(s\\<lparr>hs_pending := (hs_pending s)(m := False),\n                   W := W s \\<union> W',\n                   ghost_hs_in_sync := (ghost_hs_in_sync s)\n                     (m := True)\\<rparr>,\n               mv_Void) |\n              m W'. req = (mutator m, ro_hs_mut_done W')}) \\<and>\n         afts =\n         lconst\n          {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n           sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n           sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n           sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n           sys.tso_mfence, sys.tso_store, sys.tso_load} \\<and>\n         (\\<exists>m W'.\n             v =\n             (s\\<lparr>hs_pending := (hs_pending s)(m := False),\n                  W := W s \\<union> W',\n                  ghost_hs_in_sync := (ghost_hs_in_sync s)\n                    (m := True)\\<rparr>,\n              mv_Void) \\<and>\n             fst x = mutator m \\<and> x14 = W')\\<rbrakk>\n    \\<Longrightarrow> Q", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open> Locations\\<close>"], ["", "(* FIXME not automation friendly but used in some non-interference proofs *)"], ["", "lemma atS_dests:\n  \"\\<lbrakk> atS p ls s; atS p ls' s \\<rbrakk> \\<Longrightarrow> atS p (ls \\<union> ls') s\"\n  \"\\<lbrakk> \\<not>atS p ls s; \\<not>atS p ls' s \\<rbrakk> \\<Longrightarrow> \\<not>atS p (ls \\<union> ls') s\"\n  \"\\<lbrakk> \\<not>atS p ls s; atS p ls' s \\<rbrakk> \\<Longrightarrow> atS p (ls' - ls) s\"\n  \"\\<lbrakk> \\<not>atS p ls s; at p l s \\<rbrakk> \\<Longrightarrow> atS p ({l} - ls) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>atS p ls s; atS p ls' s\\<rbrakk>\n      \\<Longrightarrow> atS p (ls \\<union> ls') s) &&&\n     (\\<lbrakk>\\<not> atS p ls s; \\<not> atS p ls' s\\<rbrakk>\n      \\<Longrightarrow> \\<not> atS p (ls \\<union> ls') s)) &&&\n    (\\<lbrakk>\\<not> atS p ls s; atS p ls' s\\<rbrakk>\n     \\<Longrightarrow> atS p (ls' - ls) s) &&&\n    (\\<lbrakk>\\<not> atS p ls s; at p l s\\<rbrakk>\n     \\<Longrightarrow> atS p ({l} - ls) s)", "by (auto simp: atS_def)"], ["", "lemma schematic_prem: \"\\<lbrakk>Q \\<Longrightarrow> P; Q\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<Longrightarrow> P; Q\\<rbrakk> \\<Longrightarrow> P", "by blast"], ["", "(* One way of instantiating a schematic prem. *)"], ["", "lemma TrueE: \"\\<lbrakk>True; P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>True; P\\<rbrakk> \\<Longrightarrow> P", "by blast"], ["", "lemma thin_locs_pre_discardE:\n  \"\\<lbrakk>at p l' s \\<longrightarrow> P; at p l s; l' \\<noteq> l; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS p ls s \\<longrightarrow> P; at p l s; l \\<notin> ls; Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>at p l' s \\<longrightarrow> P; at p l s; l' \\<noteq> l;\n      Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>atS p ls s \\<longrightarrow> P; at p l s; l \\<notin> ls;\n      Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "unfolding atS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>at p l' s \\<longrightarrow> P; at p l s; l' \\<noteq> l;\n      Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>(\\<exists>l\\<in>ls. at p l s) \\<longrightarrow> P; at p l s;\n      l \\<notin> ls; Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "by blast+"], ["", "lemma thin_locs_pre_keep_atE:\n  \"\\<lbrakk>at p l s \\<longrightarrow> P; at p l s; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at p l s \\<longrightarrow> P; at p l s;\n     P \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by blast"], ["", "lemma thin_locs_pre_keep_atSE:\n  \"\\<lbrakk>atS p ls s \\<longrightarrow> P; at p l s; l \\<in> ls; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atS p ls s \\<longrightarrow> P; at p l s; l \\<in> ls;\n     P \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "unfolding atS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>l\\<in>ls. at p l s) \\<longrightarrow> P; at p l s;\n     l \\<in> ls; P \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by blast"], ["", "(* FIXME complete with symmetric rules on process names -- but probably not needed here *)"], ["", "lemma thin_locs_post_discardE:\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn'); l' \\<notin> lfn; p \\<noteq> q\\<rbrakk> \\<Longrightarrow> at p l' s' \\<longrightarrow> P\"\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn); l' \\<notin> lfn\\<rbrakk> \\<Longrightarrow> at p l' s' \\<longrightarrow> P\"\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn'); \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls;  p \\<noteq> q\\<rbrakk> \\<Longrightarrow> atS p ls s' \\<longrightarrow> P\"\n  \"\\<lbrakk>AT s' = (AT s)(p := lfn); \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls\\<rbrakk> \\<Longrightarrow> atS p ls s' \\<longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn'); l' \\<notin> lfn;\n       p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> at p l' s' \\<longrightarrow> P) &&&\n     (\\<lbrakk>AT s' = (AT s)(p := lfn); l' \\<notin> lfn\\<rbrakk>\n      \\<Longrightarrow> at p l' s' \\<longrightarrow> P)) &&&\n    (\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn');\n      \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls;\n      p \\<noteq> q\\<rbrakk>\n     \\<Longrightarrow> atS p ls s' \\<longrightarrow> P) &&&\n    (\\<lbrakk>AT s' = (AT s)(p := lfn);\n      \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls\\<rbrakk>\n     \\<Longrightarrow> atS p ls s' \\<longrightarrow> P)", "unfolding atS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn'); l' \\<notin> lfn;\n       p \\<noteq> q\\<rbrakk>\n      \\<Longrightarrow> at p l' s' \\<longrightarrow> P) &&&\n     (\\<lbrakk>AT s' = (AT s)(p := lfn); l' \\<notin> lfn\\<rbrakk>\n      \\<Longrightarrow> at p l' s' \\<longrightarrow> P)) &&&\n    (\\<lbrakk>AT s' = (AT s)(p := lfn, q := lfn');\n      \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls;\n      p \\<noteq> q\\<rbrakk>\n     \\<Longrightarrow> (\\<exists>l\\<in>ls. at p l s') \\<longrightarrow>\n                       P) &&&\n    (\\<lbrakk>AT s' = (AT s)(p := lfn);\n      \\<And>l. l \\<in> lfn \\<Longrightarrow> l \\<notin> ls\\<rbrakk>\n     \\<Longrightarrow> (\\<exists>l\\<in>ls. at p l s') \\<longrightarrow> P)", "by (auto simp: fun_upd_apply)"], ["", "lemmas thin_locs_post_discard_conjE =\n  conjI[OF thin_locs_post_discardE(1)]\n  conjI[OF thin_locs_post_discardE(2)]\n  conjI[OF thin_locs_post_discardE(3)]\n  conjI[OF thin_locs_post_discardE(4)]"], ["", "lemma thin_locs_post_keep_locsE:\n  \"\\<lbrakk>(L \\<longrightarrow> P) \\<and> R; R \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> (L \\<longrightarrow> P) \\<and> Q\"\n  \"L \\<longrightarrow> P \\<Longrightarrow> L \\<longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(L \\<longrightarrow> P) \\<and> R;\n      R \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> (L \\<longrightarrow> P) \\<and> Q) &&&\n    (L \\<longrightarrow> P \\<Longrightarrow> L \\<longrightarrow> P)", "by blast+"], ["", "lemma thin_locs_post_keepE:\n  \"\\<lbrakk>P \\<and> R; R \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> (L \\<longrightarrow> P) \\<and> Q\"\n  \"P \\<Longrightarrow> L \\<longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P \\<and> R; R \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> (L \\<longrightarrow> P) \\<and> Q) &&&\n    (P \\<Longrightarrow> L \\<longrightarrow> P)", "by blast+"], ["", "(* FIXME checking the fun_upds are irrelevant is not necessary, but ensures the keep rule applies. *)\n(* FIXME consider atS (mutator m) mut_hs_get_roots_loop_locs s' -- same again but replace at proc l s' with atS proc ls s' *)\n(* FIXME in general we'd need to consider intersections *)"], ["", "lemma ni_thin_locs_discardE:\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l \\<noteq> l'; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l' s'; l \\<noteq> l'; proc \\<noteq> p; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<notin> ls; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l' s'; l' \\<notin> ls; proc \\<noteq> p; Q\\<rbrakk> \\<Longrightarrow> Q\"\n\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); atS proc ls' s'; l \\<notin> ls'; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); atS proc ls' s'; l \\<notin> ls'; proc \\<noteq> p; Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>at proc l s \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l \\<noteq> l';\n       proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n       at proc l' s'; l \\<noteq> l'; proc \\<noteq> p; Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>atS proc ls s \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<notin> ls;\n       proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n      \\<Longrightarrow> Q)) &&&\n    (\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n      at proc l' s'; l' \\<notin> ls; proc \\<noteq> p; Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>at proc l s \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn, q := lfn'); atS proc ls' s'; l \\<notin> ls';\n      proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n      atS proc ls' s'; l \\<notin> ls'; proc \\<noteq> p; Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "(*\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); atS proc l s'; l \\<notin> ls; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); atS proc ls' s'; l \\<notin> ls; proc \\<noteq> p; Q\\<rbrakk> \\<Longrightarrow> Q\"\n*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>at proc l s \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l \\<noteq> l';\n       proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n       at proc l' s'; l \\<noteq> l'; proc \\<noteq> p; Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>atS proc ls s \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<notin> ls;\n       proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n      \\<Longrightarrow> Q)) &&&\n    (\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n      at proc l' s'; l' \\<notin> ls; proc \\<noteq> p; Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>at proc l s \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn, q := lfn'); atS proc ls' s'; l \\<notin> ls';\n      proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n      atS proc ls' s'; l \\<notin> ls'; proc \\<noteq> p; Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "unfolding atS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>at proc l s \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l \\<noteq> l';\n       proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n       at proc l' s'; l \\<noteq> l'; proc \\<noteq> p; Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>(\\<exists>l\\<in>ls. at proc l s) \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<notin> ls;\n       proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n      \\<Longrightarrow> Q)) &&&\n    (\\<lbrakk>(\\<exists>l\\<in>ls. at proc l s) \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn); at proc l' s'; l' \\<notin> ls;\n      proc \\<noteq> p; Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>at proc l s \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn, q := lfn'); \\<exists>l\\<in>ls'. at proc l s';\n      l \\<notin> ls'; proc \\<noteq> p; proc \\<noteq> q; Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n      \\<exists>l\\<in>ls'. at proc l s'; l \\<notin> ls'; proc \\<noteq> p;\n      Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "by auto"], ["", "lemma ni_thin_locs_keep_atE:\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l s'; proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l s'; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>at proc l s \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn, q := lfn'); at proc l s'; proc \\<noteq> p;\n      proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>at proc l s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n      at proc l s'; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "by (auto simp: fun_upd_apply)"], ["", "lemma ni_thin_locs_keep_atSE:\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<in> ls; proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); at proc l' s'; l' \\<in> ls; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn, q := lfn'); atS proc ls' s'; ls' \\<subseteq> ls; proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn); atS proc ls' s'; ls' \\<subseteq> ls; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>atS proc ls s \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<in> ls;\n       proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n       at proc l' s'; l' \\<in> ls; proc \\<noteq> p;\n       P \\<Longrightarrow> Q\\<rbrakk>\n      \\<Longrightarrow> Q)) &&&\n    (\\<lbrakk>atS proc ls s \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn, q := lfn'); atS proc ls' s';\n      ls' \\<subseteq> ls; proc \\<noteq> p; proc \\<noteq> q;\n      P \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>atS proc ls s \\<longrightarrow> P; AT s' = (AT s)(p := lfn);\n      atS proc ls' s'; ls' \\<subseteq> ls; proc \\<noteq> p;\n      P \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "unfolding atS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>(\\<exists>l\\<in>ls. at proc l s) \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn, q := lfn'); at proc l' s'; l' \\<in> ls;\n       proc \\<noteq> p; proc \\<noteq> q; P \\<Longrightarrow> Q\\<rbrakk>\n      \\<Longrightarrow> Q) &&&\n     (\\<lbrakk>(\\<exists>l\\<in>ls. at proc l s) \\<longrightarrow> P;\n       AT s' = (AT s)(p := lfn); at proc l' s'; l' \\<in> ls;\n       proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk>\n      \\<Longrightarrow> Q)) &&&\n    (\\<lbrakk>(\\<exists>l\\<in>ls. at proc l s) \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn, q := lfn'); \\<exists>l\\<in>ls'. at proc l s';\n      ls' \\<subseteq> ls; proc \\<noteq> p; proc \\<noteq> q;\n      P \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>(\\<exists>l\\<in>ls. at proc l s) \\<longrightarrow> P;\n      AT s' = (AT s)(p := lfn); \\<exists>l\\<in>ls'. at proc l s';\n      ls' \\<subseteq> ls; proc \\<noteq> p; P \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "by (auto simp: fun_upd_apply)"], ["", "lemma loc_mem_tac_intros:\n  \"\\<lbrakk>c \\<notin> A; c \\<notin> B\\<rbrakk> \\<Longrightarrow> c \\<notin> A \\<union> B\"\n  \"c \\<noteq> d \\<Longrightarrow> c \\<notin> {d}\"\n  \"c \\<notin> A \\<Longrightarrow> c \\<in> - A\"\n  \"c \\<in> A \\<Longrightarrow> c \\<notin> - A\"\n  \"A \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>c \\<notin> A; c \\<notin> B\\<rbrakk>\n      \\<Longrightarrow> c \\<notin> A \\<union> B) &&&\n     (c \\<noteq> d \\<Longrightarrow> c \\<notin> {d})) &&&\n    (c \\<notin> A \\<Longrightarrow> c \\<in> - A) &&&\n    (c \\<in> A \\<Longrightarrow> c \\<notin> - A) &&& A \\<subseteq> A", "by blast+"], ["", "(* FIXME these rules are dangerous if any other sets are lying around. Specialise the types? *)"], ["", "lemmas loc_mem_tac_elims =\n  singletonE\n  UnE"], ["", "lemmas loc_mem_tac_simps =\n  append.simps list.simps rev.simps \\<comment> \\<open>evaluate string equality\\<close>\n  char.inject cong_exp_iff_simps \\<comment> \\<open>evaluate character equality\\<close>\n  prefix_code suffix_to_prefix\n  simp_thms\n  Eq_FalseI\n  not_Cons_self"], ["", "lemmas vcg_fragments'_simps =\n  valid_proc_def gc_coms.simps vcg_fragments'.simps atC.simps\n  ball_Un bool_simps if_False if_True"], ["", "lemmas vcg_sem_simps =\n  lconst.simps\n  simp_thms\n  True_implies_equals\n  prod.simps fst_conv snd_conv\n  gc_phase.simps process_name.simps hs_type.simps hs_phase.simps\n  mem_store_action.simps mem_load_action.simps request_op.simps response.simps"], ["", "lemmas vcg_inv_simps =\n  simp_thms"], ["", "ML \\<open>\n\nsignature GC_VCG =\nsig\n  (* Internals *)\n  val nuke_schematic_prems : Proof.context -> int -> tactic\n  val loc_mem_tac : Proof.context -> int -> tactic\n  val vcg_fragments_tac : Proof.context -> int -> tactic\n  val vcg_sem_tac : Proof.context -> int -> tactic\n  val thin_pre_inv_tac : Proof.context -> int -> tactic\n  val thin_post_inv_tac : bool -> Proof.context -> int -> tactic\n  val vcg_inv_tac : bool -> bool -> Proof.context -> int -> tactic\n  (* End-user tactics *)\n  val vcg_jackhammer_tac : bool -> bool -> Proof.context -> int -> tactic\n  val vcg_chainsaw_tac : bool -> thm list -> Proof.context -> int -> tactic\n  val vcg_name_cases_tac : term list -> thm list -> context_tactic\nend\n\nstructure GC_VCG : GC_VCG =\nstruct\n\n(* Identify and remove schematic premises. FIXME reverses the prems *)\nfun nuke_schematic_prems ctxt =\n  let\n    fun is_schematic_prem t =\n      case t of\n        Const (\"HOL.Trueprop\", _) $ t => is_schematic_prem t\n      | t $ _ => is_schematic_prem t\n      | Var _ => true\n      | _ => false\n  in\n    DETERM o filter_prems_tac ctxt (not o is_schematic_prem)\n  end;\n\n(* FIXME Want to unify only with a non-schematic prem. might get there with first order matching or some existing variant of assume. *)\nfun assume_non_schematic_prem_tac ctxt =\n  (TRY o nuke_schematic_prems ctxt) THEN' assume_tac ctxt\n\nfun vcg_fragments_tac ctxt =\n  SELECT_GOAL (HEADGOAL (safe_simp_tac (ss_only (@{thms vcg_fragments'_simps} @ @{thms all_com_interned_defs}) ctxt)\n                  THEN' SELECT_GOAL (safe_tac ctxt))); (* FIXME split the goal, simplify the sets away. FIXME try to nuke safe_tac *)\n\nfun vcg_sem_tac ctxt =\n  SELECT_GOAL (HEADGOAL (match_tac ctxt @{thms CIMP_vcg.vcg.intros}\n                  THEN' (TRY o (ematch_tac ctxt @{thms system_responds_action_specE} THEN' assume_tac ctxt))\n                  THEN' Rule_Insts.thin_tac ctxt \"HST s = h\" [(@{binding s}, NONE, NoSyn), (@{binding h}, NONE, NoSyn)] (* discard history: we don't use it here *)\n                  THEN' clarsimp_tac (ss_only @{thms vcg_sem_simps} ctxt)\n           THEN_ALL_NEW asm_simp_tac ctxt)); (* remove unused meta-bound vars FIXME subgoaler in HOL's usual simplifier setup, somehow lost by ss_only *)\n\n(* FIXME gingerly settle location set membership and (dis-)equalities *)\nfun loc_mem_tac ctxt =\n  let\n    val loc_defs = Proof_Context.get_fact ctxt (Facts.named \"loc_defs\")\n  in\n    SELECT_GOAL (HEADGOAL ( (TRY o REPEAT_ALL_NEW (ematch_tac ctxt @{thms loc_mem_tac_elims}))\n               THEN_ALL_NEW (TRY o hyp_subst_tac ctxt)\n               THEN_ALL_NEW (TRY o REPEAT_ALL_NEW (match_tac ctxt @{thms loc_mem_tac_intros}))\n               THEN_ALL_NEW ( SOLVED' (match_tac ctxt (Named_Theorems.get ctxt \\<^named_theorems>\\<open>locset_cache\\<close>)\n                               ORELSE' safe_simp_tac (HOL_ss_only (@{thms loc_mem_tac_simps} @ loc_defs) ctxt) ) )))\n  end;\n\nfun thin_pre_inv_tac ctxt =\n    SELECT_GOAL (HEADGOAL ( (* FIXME trying to scope the REPEAT_DETERM ala [1] *)\n            (REPEAT_DETERM o ematch_tac ctxt @{thms conjE})\n      THEN' (REPEAT_DETERM o ( (ematch_tac ctxt @{thms thin_locs_pre_discardE}  THEN' assume_tac ctxt THEN' loc_mem_tac ctxt)\n                       ORELSE' (ematch_tac ctxt @{thms thin_locs_pre_keep_atE}  THEN' assume_tac ctxt)\n                       ORELSE' (ematch_tac ctxt @{thms thin_locs_pre_keep_atSE} THEN' assume_tac ctxt THEN' loc_mem_tac ctxt) ))));\n\n(* FIXME redo keep_postE: if at loc is provable, discard the at antecedent, otherwise keep it *)\n(* if the post inv is an LSTP then the present fix is to say (no_thin_post_inv) -- would be good to automate that *)\nfun thin_post_inv_tac keep_locs ctxt =\n  let\n    val keep_postE_thms = if keep_locs then @{thms thin_locs_post_keep_locsE} else @{thms thin_locs_post_keepE}\n    fun nail_discard_prems_tac ctxt = assume_non_schematic_prem_tac ctxt THEN' loc_mem_tac ctxt THEN' (TRY o match_tac ctxt @{thms process_name.simps})\n  in\n    SELECT_GOAL (HEADGOAL ( (* FIXME trying to scope the REPEAT_DETERM ala [1] *)\n            resolve_tac ctxt @{thms schematic_prem}\n      THEN' REPEAT_DETERM o CHANGED o (* FIXME CHANGED? also check what happens for non-invL post invs -- aim to fail the ^^^ resolve_tac too *)\n              ( (                                      match_tac ctxt @{thms thin_locs_post_discard_conjE} THEN' nail_discard_prems_tac ctxt)\n        ORELSE' (eresolve_tac ctxt @{thms TrueE} THEN' match_tac ctxt @{thms thin_locs_post_discardE}      THEN' nail_discard_prems_tac ctxt)\n        ORELSE' eresolve_tac ctxt keep_postE_thms )\n  ))\n  end;\n\nfun vcg_inv_tac keep_locs no_thin_post_inv ctxt =\n  let\n    val invs = Named_Theorems.get ctxt \\<^named_theorems>\\<open>inv\\<close>\n  in\n          SELECT_GOAL (Local_Defs.unfold_tac ctxt invs) (* FIXME trying to say unfold in [1] only *)\n    THEN' thin_pre_inv_tac ctxt\n    THEN' ( if no_thin_post_inv\n            then SELECT_GOAL all_tac (* full_simp_tac (ss_only @{thms vcg_inv_simps} ctxt) (* FIXME maybe not? *) *)\n            else full_simp_tac (Splitter.add_split @{thm lcond_split_asm} (ss_only @{thms vcg_inv_simps} ctxt))\n    THEN_ALL_NEW thin_post_inv_tac keep_locs ctxt )\n  end;\n\n(* For showing local invariants. FIXME tack on (no_thin_post_inv) for universal/LSTP ones *)\nfun vcg_jackhammer_tac keep_locs no_thin_post_inv ctxt =\n    SELECT_GOAL (HEADGOAL (vcg_fragments_tac ctxt)\n    THEN PARALLEL_ALLGOALS (\n                   vcg_sem_tac ctxt\n      THEN_ALL_NEW vcg_inv_tac keep_locs no_thin_post_inv ctxt\n      THEN_ALL_NEW (if keep_locs then SELECT_GOAL all_tac else Rule_Insts.thin_tac ctxt \"AT _ = _\" [])\n      THEN_ALL_NEW TRY o clarsimp_tac ctxt (* limply try to solve the remaining goals *)\n    ));\n\n(* For showing noninterference *)\nfun vcg_chainsaw_tac no_thin unfold_foreign_inv_thms ctxt =\n  let\n    fun specialize_foreign_invs_tac ctxt =\n                   (* FIXME split goal: makes sense because local procs control locs have changed? *)\n                       REPEAT_ALL_NEW (match_tac ctxt @{thms conjI})\n          THEN_ALL_NEW TRY o ( match_tac ctxt @{thms impI} (* FIXME could tweak rules vvvv *)\n                          (* thin out the invariant we're showing non-interference for *)\n(* FIXME look for reasons to retain the invariant, then do a big thin_tac at the end.\nIntuitively we don't have enough info to settle atS v atS questions and it's too hard/not informative enough to try.\nLet the user do it.\nMaybe add an info thing that tells what was thinned.\n\nFIXME location-sensitive predicates are not amenable to\nsimplification: this is the cost of using projections on\npred_state. Instead use elimination rules \\<open>nie\\<close>.\n\n *)\n                         THEN' ( REPEAT_DETERM o ( ( ematch_tac ctxt @{thms ni_thin_locs_discardE}  THEN' assume_tac ctxt THEN' assume_tac ctxt THEN' loc_mem_tac ctxt THEN' match_tac ctxt @{thms process_name.simps} THEN' TRY o match_tac ctxt @{thms process_name.simps} )\n                                           ORELSE' ( ematch_tac ctxt @{thms ni_thin_locs_keep_atE}  THEN' assume_tac ctxt THEN' assume_tac ctxt THEN' match_tac ctxt @{thms process_name.simps} THEN' TRY o match_tac ctxt @{thms process_name.simps} )\n                                           ORELSE' ( ematch_tac ctxt @{thms ni_thin_locs_keep_atSE} THEN' assume_tac ctxt THEN' assume_tac ctxt THEN' loc_mem_tac ctxt THEN' match_tac ctxt @{thms process_name.simps} THEN' TRY o match_tac ctxt @{thms process_name.simps} ) ) ) )\n  in\n    SELECT_GOAL (HEADGOAL (vcg_fragments_tac ctxt)\n    THEN PARALLEL_ALLGOALS (\n                   vcg_sem_tac ctxt\n                   (* nail cheaply with an nie fact + ambient clarsimp *)\n      THEN_ALL_NEW ( SOLVED' (ematch_tac ctxt (Named_Theorems.get ctxt @{named_theorems nie}) THEN_ALL_NEW clarsimp_tac ctxt)\n             ORELSE' ( (* do it the hard way: specialise any process-specific invariants. Similar to vcg_jackhammer but not the same *)\n                       vcg_inv_tac false true ctxt\n                       (* unfold the foreign inv *)\n                 THEN' SELECT_GOAL (Local_Defs.unfold_tac ctxt unfold_foreign_inv_thms) (* FIXME trying to say [1] *)\n                 THEN' (REPEAT_DETERM o ematch_tac ctxt @{thms conjE})\n                 THEN' specialize_foreign_invs_tac ctxt\n                       (* limply try to solve the remaining goals; FIXME turn s' into s as much as easily possible *)\n          THEN_ALL_NEW (TRY o clarsimp_tac ctxt)\n                       (* FIXME discard loc info. It is useful, this is a stopgap *)\n          THEN_ALL_NEW (if no_thin then SELECT_GOAL all_tac\n                        else (Rule_Insts.thin_tac ctxt \"AT _ = _\" []\n                THEN_ALL_NEW (REPEAT_DETERM o Rule_Insts.thin_tac ctxt \"at _ _ _ \\<longrightarrow> _\" [])\n                THEN_ALL_NEW (REPEAT_DETERM o Rule_Insts.thin_tac ctxt \"atS _ _ _ \\<longrightarrow> _\" []) ))\n    ))))\n  end;\n\n(*\n\nScrutinise the goal state for an `AT` fact that tells us which label the process is at.\n\nIt seems this is not kosher:\n - for reasons unknown (Eisbach?) this tactic gets called with a bogus \"TERM _\" and then the real goal state.\n - this tactic (sometimes) does not work if used with THEN_ALL_NEW ';' --\n   chk_label does not manage to uniquify labels -- so be sure to\n   combine with ','.\n - if two goals have the same `at` location then we disambiguate, but\n   perhaps not stably. Could imagine creating subcases, but\n   `Method.goal_cases_tac` is not yet capable of that.\n - at communication steps we could get unlucky and choose the label from the other process.\n\nThe user can supply a list of process names to somewhat address these issues.\n\nSee Pure/Tools/rule_insts.ML for structurally similar tactics (\"dynamic instantiation\").\n\nLimitations:\n - only works with `Const` labels\n - brittle: assumes things are very well-formed\n\n*)\nfun vcg_name_cases_tac (proc_names: term list) _(*facts*) (ctxt, st) =\n  if Thm.nprems_of st = 0\n  then Seq.empty (* no_tac *)\n  else\n    let\n      fun fst_ord ord ((x, _), (x', _)) = ord (x, x')\n      fun snd_ord ord ((_, y), (_, y')) = ord (y, y')\n\n      (* FIXME this search is drecky *)\n      fun find_AT (t: term) : (term * string) option =\n            ( (* tracing (\"scruting: \" ^ Syntax.string_of_term ctxt t) ; *)\n              case t of Const (\"HOL.Trueprop\", _) $ (Const (@{const_name \"Set.member\"}, _) $ Const (l, _) $ (Const (@{const_name \"CIMP_lang.AT\"},  _) $ _ $ p)) => ((* tracing \"HIT\"; *) SOME (p, Long_Name.base_name l))\n                      | Const (\"HOL.Trueprop\", _) $ (Const (@{const_name \"CIMP_lang.atS\"}, _) $ p $ Const (ls, _) $ _) => ((* tracing \"HIT\"; *) SOME (p, Long_Name.base_name ls))\n                      | _ => NONE )\n\n      (* FIXME Isabelle makes it awkward to use polymorphic process names; paper over that crack here *)\n      val rec terms_eq_ignoring_types =\n          fn (Const (c0, _), Const (c1, _)) => fast_string_ord (c0, c1) = EQUAL\n           | (Free (f0, _),  Free (f1, _))  => fast_string_ord (f0, f1) = EQUAL\n           | (Var (v0, _) , Var (v1, _)) => prod_ord fast_string_ord int_ord (v0, v1) = EQUAL\n           | (Bound i0, Bound i1) => i0 = i1\n           | (Abs (b0, _, t0), Abs (b1, _, t1)) => fast_string_ord (b0, b1) = EQUAL andalso terms_eq_ignoring_types (t0, t1)\n           | (t0 $ u0, t1 $ u1) => terms_eq_ignoring_types (t0, t1) andalso terms_eq_ignoring_types (u0, u1)\n           | _ => false\n\n      fun mk_label (default: string) (ats : (term * string) list) : string =\n            case (ats, proc_names) of\n              ((_, l)::_, []) => ((* tracing (\"No proc_names, Using label: \" ^ l); *) l)\n            | _ =>\n              let\n                val ls = List.mapPartial (fn p => List.find (fn (p', _) => terms_eq_ignoring_types (p, p')) ats) proc_names\n              in\n                case ls of\n                  [] => (warning (\"vcg_name_cases: using the default name: \" ^ default); default)\n                | _  => ls |> List.map snd |> String.concatWith \"_\"\n              end\n\n      fun labels_for_cases (i: int) (acc: (int * string) list) : (int * string) list =\n            case i of\n              0 => acc\n            | i => Thm.cprem_of st i |> Thm.term_of |> Logic.strip_assums_hyp\n                   |> List.mapPartial find_AT |> mk_label (Int.toString i)\n                   |> (fn l => labels_for_cases (i - 1) ((i, l) :: acc))\n\n        (* Make the labels unique if need be *)\n      fun uniquify (i: int) (ls: (int * string) list) : (int * string) list =\n        case ls of\n          [] => []\n        | [l] => [l]\n        | l :: l' :: ls => (case fast_string_ord (snd l, snd l') of\n                             EQUAL => (fst l, snd l ^ Int.toString i) :: uniquify (i + 1) (l' :: ls)\n                           | _     => l :: uniquify 0 (l' :: ls))\n      val labels = labels_for_cases (Thm.nprems_of st) []\n      val labels = labels\n                |> sort (snd_ord fast_string_ord) |> uniquify 0 |> sort (fst_ord int_ord)\n                |> List.map (fn (_, l) => ((* tracing (\"label: \" ^ l); *) l))\n    in\n      Method.goal_cases_tac labels (ctxt, st)\n    end;\n\nend\n\nval _ =\n  Theory.setup (Method.setup @{binding loc_mem}\n    (Scan.succeed (SIMPLE_METHOD' o GC_VCG.loc_mem_tac))\n    \"solve location membership goals\")\n\nval _ =\n  Theory.setup (Method.setup @{binding vcg_fragments}\n    (Scan.succeed (SIMPLE_METHOD' o GC_VCG.vcg_fragments_tac))\n    \"unfold com defs, execute vcg_fragments' and split goals\")\n\nval _ =\n  Theory.setup (Method.setup @{binding vcg_sem}\n    (Scan.succeed (SIMPLE_METHOD' o GC_VCG.vcg_sem_tac))\n    \"reduce VCG goal to semantics and clarsimp\")\n\nval _ =\n  Theory.setup (Method.setup @{binding vcg_inv}\n    (Scan.lift (Args.mode \"keep_locs\" -- Args.mode \"no_thin_post_inv\") >> (fn (keep_locs, no_thin_post_inv) => SIMPLE_METHOD' o GC_VCG.vcg_inv_tac keep_locs no_thin_post_inv))\n    \"specialise the invariants to the goal. (keep_locs) retains locs in post conds\")\n\nval _ =\n  Theory.setup (Method.setup @{binding vcg_jackhammer}\n    (Scan.lift (Args.mode \"keep_locs\" -- Args.mode \"no_thin_post_inv\") >> (fn (keep_locs, no_thin_post_inv) => SIMPLE_METHOD' o GC_VCG.vcg_jackhammer_tac keep_locs no_thin_post_inv))\n    \"VCG tactic. (keep_locs) retains locs in post conds. (no_thin_post_inv) does not attempt to specalise the post condition.\")\n\nval _ =\n  Theory.setup (Method.setup @{binding vcg_chainsaw}\n    (Scan.lift (Args.mode \"no_thin\") -- Attrib.thms >> (fn (no_thin, thms) => SIMPLE_METHOD' o GC_VCG.vcg_chainsaw_tac no_thin thms))\n    \"VCG non-interference tactic. Tell it how to unfold the foreign local invs.\")\n\nval _ =\n  Theory.setup (Method.setup @{binding vcg_name_cases}\n    (Scan.repeat Args.term >> (fn proc_names => fn _ => CONTEXT_METHOD (GC_VCG.vcg_name_cases_tac proc_names)))\n    \"divine canonical case names for outstanding VCG goals\")\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}