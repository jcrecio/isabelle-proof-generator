{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Global_Invariants_Lemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma tso_store_inv_eq_imp:\n  \"eq_imp (\\<lambda>p s. mem_store_buffers (s sys) p)\n          tso_store_inv\"", "lemmas tso_store_inv_fun_upd[simp] = eq_imp_fun_upd[OF tso_store_inv_eq_imp, simplified eq_imp_simps, rule_format]", "lemma tso_store_invD[simp]:\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers gc s = mw_Mutate r f r' # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers gc s = mw_Mutate_Payload r f pl # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers (mutator m) s = mw_fA fl # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers (mutator m) s = mw_fM fl # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers (mutator m) s = mw_Phase ph # ws\"", "lemma mut_do_store_action[simp]:\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = w # ws; tso_store_inv s \\<rbrakk> \\<Longrightarrow> fA (do_store_action w (s sys)) = sys_fA s\"\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = w # ws; tso_store_inv s \\<rbrakk> \\<Longrightarrow> fM (do_store_action w (s sys)) = sys_fM s\"\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = w # ws; tso_store_inv s \\<rbrakk> \\<Longrightarrow> phase (do_store_action w (s sys)) = sys_phase s\"", "lemma tso_store_inv_sys_load_Mut[simp]:\n  assumes \"tso_store_inv s\"\n  assumes \"(ract, v) \\<in> { (mr_fM, mv_Mark (Some (sys_fM s))), (mr_fA, mv_Mark (Some (sys_fA s))), (mr_Phase, mv_Phase (sys_phase s)) }\"\n  shows \"sys_load (mutator m) ract (s sys) = v\"", "lemma tso_store_inv_sys_load_GC[simp]:\n  assumes \"tso_store_inv s\"\n  shows \"sys_load gc (mr_Ref r f) (s sys) = mv_Ref (Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f))\" (is \"?lhs = mv_Ref ?rhs\")", "lemma tso_no_pending_marksD[simp]:\n  assumes \"tso_pending_mark p s = []\"\n  shows \"sys_load p (mr_Mark r) (s sys) = mv_Mark (map_option obj_mark (sys_heap s r))\"", "lemma no_pending_phase_sys_load[simp]:\n  assumes \"tso_pending_phase p s = []\"\n  shows \"sys_load p mr_Phase (s sys) = mv_Phase (sys_phase s)\"", "lemma gc_no_pending_fM_write[simp]:\n  assumes \"tso_pending_fM gc s = []\"\n  shows \"sys_load gc mr_fM (s sys) = mv_Mark (Some (sys_fM s))\"", "lemma tso_store_refs_simps[simp]:\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>roots := roots'\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := sys_mem_store_buffers (mutator m') s @ [mw_Mutate r f opt_r'])\\<rparr>))\n = mut_m.tso_store_refs m s \\<union> (if m' = m then store_refs (mw_Mutate r f opt_r') else {})\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := sys_mem_store_buffers (mutator m') s @ [mw_Mutate_Payload r f pl])\\<rparr>))\n = mut_m.tso_store_refs m s \\<union> (if m' = m then store_refs (mw_Mutate_Payload r f pl) else {})\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r \\<mapsto> obj)\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>ghost_honorary_root := Option.set_option opt_r', ref := opt_r'\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                          mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\n = (if p = mutator m then \\<Union>w \\<in> set ws. store_refs w else mut_m.tso_store_refs m s)\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>) (sys_heap s r)),\n                                          mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\n = (if p = mutator m then \\<Union>w \\<in> set ws. store_refs w else mut_m.tso_store_refs m s)\"\n  \"sys_mem_store_buffers p s = mw_Mark r fl # ws\n\\<Longrightarrow> mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\n = mut_m.tso_store_refs m s\"", "lemma fold_stores_points_to[rule_format, simplified conj_explode]:\n  \"heap (fold_stores ws (s sys)) r = Some obj \\<and> obj_fields obj f = Some r'\n     \\<longrightarrow> (r points_to r') s \\<or> (\\<exists>w \\<in> set ws. r' \\<in> store_refs w)\" (is \"?P (fold_stores ws) obj\")", "lemma points_to_Mutate:\n  \"(x points_to y)\n         (s(sys := (s sys)\\<lparr> heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                            mem_store_buffers := (mem_store_buffers (s sys))(p := ws) \\<rparr>))\n  \\<longleftrightarrow> (r \\<noteq> x \\<and> (x points_to y) s) \\<or> (r = x \\<and> valid_ref r s \\<and> (opt_r' = Some y \\<or> ( (x points_to y) s \\<and> obj_at (\\<lambda>obj. \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f') r s)))\"", "lemma \\<comment> \\<open>Sanity\\<close>\n  \"hp' = hs_step hp \\<Longrightarrow> \\<exists>in' ht. (in', ht, hp', hp) \\<in> hp_step_rel\"", "lemma \\<comment> \\<open>Sanity\\<close>\n  \"(False, ht, hp', hp) \\<in> hp_step_rel \\<Longrightarrow> hp' = hp_step ht hp\"", "lemma (in mut_m) handshake_phase_invD:\n  assumes \"handshake_phase_inv s\"\n  shows \"(sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s, mut_ghost_hs_phase s) \\<in> hp_step_rel\n       \\<and> (sys_hs_pending m s \\<longrightarrow> \\<not>sys_ghost_hs_in_sync m s)\"", "lemma handshake_in_syncD:\n  \"\\<lbrakk> All (ghost_hs_in_sync (s sys)); handshake_phase_inv s \\<rbrakk>\n     \\<Longrightarrow> \\<forall>m'. mut_m.mut_ghost_hs_phase m' s = sys_ghost_hs_phase s\"", "lemmas fM_rel_invD = iffD1[OF fun_cong[OF fM_rel_inv_def[simplified atomize_eq]]]", "lemma phase_rel_invD:\n  assumes \"phase_rel_inv s\"\n  shows \"(\\<forall>m. sys_ghost_hs_in_sync m s, sys_ghost_hs_phase s, gc_phase s, sys_phase s, tso_pending_phase gc s) \\<in> phase_rel\"", "lemma mut_m_not_idle_no_fM_write:\n  \"\\<lbrakk> ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s; handshake_phase_inv s; tso_store_inv s; p \\<noteq> sys \\<rbrakk>\n     \\<Longrightarrow> \\<not>sys_mem_store_buffers p s = mw_fM fl # ws\"", "lemma (in mut_m) mut_ghost_handshake_phase_idle:\n  \"\\<lbrakk> mut_ghost_hs_phase s = hp_Idle; handshake_phase_inv s; phase_rel_inv s \\<rbrakk>\n     \\<Longrightarrow> sys_phase s = ph_Idle\"", "lemma mut_m_not_idle_no_fM_writeD:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_fM fl # ws; ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s; handshake_phase_inv s; tso_store_inv s; p \\<noteq> sys \\<rbrakk>\n     \\<Longrightarrow> False\"", "lemma (in mut_m) reachable_eq_imp:\n  \"eq_imp (\\<lambda>r'. mut_roots \\<^bold>\\<otimes> mut_ghost_honorary_root \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r')))\n              \\<^bold>\\<otimes> tso_pending_mutate (mutator m))\n          (reachable r)\"", "lemmas reachable_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.reachable_eq_imp, simplified eq_imp_simps, rule_format]", "lemma reachableI[intro]:\n  \"x \\<in> mut_m.mut_roots m s \\<Longrightarrow> mut_m.reachable m x s\"\n  \"x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow> mut_m.reachable m x s\"", "lemma reachable_points_to[elim]:\n  \"\\<lbrakk> (x points_to y) s; mut_m.reachable m x s \\<rbrakk> \\<Longrightarrow> mut_m.reachable m y s\"", "lemma (in mut_m) mut_reachableE[consumes 1, case_names mut_root tso_store_refs]:\n  \"\\<lbrakk> reachable y s;\n     \\<And>x. \\<lbrakk> (x reaches y) s; x \\<in> mut_roots s \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>x. \\<lbrakk> (x reaches y) s; x \\<in> mut_ghost_honorary_root s \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>x. \\<lbrakk> (x reaches y) s; x \\<in> tso_store_refs s \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemma reachable_induct[consumes 1, case_names root ghost_honorary_root tso_root reaches]:\n  assumes r: \"mut_m.reachable m y s\"\n  assumes root: \"\\<And>x. \\<lbrakk> x \\<in> mut_m.mut_roots m s \\<rbrakk> \\<Longrightarrow> P x\"\n  assumes ghost_honorary_root: \"\\<And>x. \\<lbrakk> x \\<in> mut_m.mut_ghost_honorary_root m s \\<rbrakk> \\<Longrightarrow> P x\"\n  assumes tso_root: \"\\<And>x. x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow> P x\"\n  assumes reaches: \"\\<And>x y. \\<lbrakk> mut_m.reachable m x s; (x points_to y) s; P x \\<rbrakk> \\<Longrightarrow> P y\"\n  shows \"P y\"", "lemma mutator_reachable_tso:\n  \"sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n    \\<Longrightarrow> mut_m.reachable m r s \\<and> (\\<forall>r'. opt_r' = Some r' \\<longrightarrow> mut_m.reachable m r' s)\"\n  \"sys_mem_store_buffers (mutator m) s = mw_Mutate_Payload r f pl # ws\n    \\<Longrightarrow> mut_m.reachable m r s\"", "lemma greyI[intro]:\n  \"r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> grey r s\"\n  \"r \\<in> W (s p) \\<Longrightarrow> grey r s\"\n  \"r \\<in> WL p s \\<Longrightarrow> grey r s\"", "lemma blackD[dest]:\n  \"black r s \\<Longrightarrow> marked r s\"\n  \"black r s \\<Longrightarrow> r \\<notin> WL p s\"", "lemma whiteI[intro]: (* FIXME simp normal form of def *)\n  \"obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) r s \\<Longrightarrow> white r s\"", "lemma marked_not_white[dest]:\n  \"white r s \\<Longrightarrow> \\<not>marked r s\"", "lemma white_valid_ref[elim!]:\n  \"white r s \\<Longrightarrow> valid_ref r s\"", "lemma not_white_marked[elim!]:\n  \"\\<lbrakk>\\<not> white r s; valid_ref r s\\<rbrakk> \\<Longrightarrow> marked r s\"", "lemma black_eq_imp:\n  \"eq_imp (\\<lambda>_::unit. (\\<lambda>s. r \\<in> (\\<Union>p. WL p s)) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r)))\n          (black r)\"", "lemma grey_eq_imp:\n  \"eq_imp (\\<lambda>_::unit. (\\<lambda>s. r \\<in> (\\<Union>p. WL p s)))\n          (grey r)\"", "lemma white_eq_imp:\n  \"eq_imp (\\<lambda>_::unit. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r)))\n          (white r)\"", "lemmas black_fun_upd[simp] = eq_imp_fun_upd[OF black_eq_imp, simplified eq_imp_simps, rule_format]", "lemmas grey_fun_upd[simp] = eq_imp_fun_upd[OF grey_eq_imp, simplified eq_imp_simps, rule_format]", "lemmas white_fun_upd[simp] = eq_imp_fun_upd[OF white_eq_imp, simplified eq_imp_simps, rule_format]", "lemma black_heap_eq_imp:\n  \"eq_imp (\\<lambda>r'. (\\<lambda>s. \\<Union>p. WL p s) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          black_heap\"", "lemma white_heap_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          white_heap\"", "lemma no_black_refs_eq_imp:\n  \"eq_imp (\\<lambda>r'. (\\<lambda>s. (\\<Union>p. WL p s)) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          no_black_refs\"", "lemmas black_heap_fun_upd[simp] = eq_imp_fun_upd[OF black_heap_eq_imp, simplified eq_imp_simps, rule_format]", "lemmas white_heap_fun_upd[simp] = eq_imp_fun_upd[OF white_heap_eq_imp, simplified eq_imp_simps, rule_format]", "lemmas no_black_refs_fun_upd[simp] = eq_imp_fun_upd[OF no_black_refs_eq_imp, simplified eq_imp_simps, rule_format]", "lemma white_heap_imp_no_black_refs[elim!]:\n  \"white_heap s \\<Longrightarrow> no_black_refs s\"", "lemma black_heap_no_greys[elim]:\n  \"\\<lbrakk> no_grey_refs s; \\<forall>r. marked r s \\<or> \\<not>valid_ref r s \\<rbrakk> \\<Longrightarrow> black_heap s\"", "lemma heap_colours_colours:\n  \"black_heap s \\<Longrightarrow> \\<not>white r s\"\n  \"white_heap s \\<Longrightarrow> \\<not>black r s\"", "lemma strong_tricolour_invD:\n  \"\\<lbrakk> black x s; (x points_to y) s; valid_ref y s; strong_tricolour_inv s \\<rbrakk>\n     \\<Longrightarrow> marked y s\"", "lemma no_black_refsD:\n  \"no_black_refs s \\<Longrightarrow> \\<not>black r s\"", "lemma has_white_path_to_induct[consumes 1, case_names refl step, induct set: has_white_path_to]:\n  assumes \"(x has_white_path_to y) s\"\n  assumes \"\\<And>x. P x x\"\n  assumes \"\\<And>x y z. \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s; white z s\\<rbrakk> \\<Longrightarrow> P x z\"\n  shows \"P x y\"", "lemma has_white_path_toD[dest]:\n  \"(x has_white_path_to y) s \\<Longrightarrow> white y s \\<or> x = y\"", "lemma has_white_path_to_refl[iff]:\n  \"(x has_white_path_to x) s\"", "lemma has_white_path_to_step[intro]:\n  \"\\<lbrakk>(x has_white_path_to y) s; (y points_to z) s; white z s\\<rbrakk> \\<Longrightarrow> (x has_white_path_to z) s\"\n  \"\\<lbrakk>(y has_white_path_to z) s; (x points_to y) s; white y s\\<rbrakk> \\<Longrightarrow> (x has_white_path_to z) s\"", "lemma has_white_path_toE[elim!]:\n  \"\\<lbrakk> (x points_to y) s; white y s \\<rbrakk> \\<Longrightarrow> (x has_white_path_to y) s\"", "lemma has_white_path_to_reaches[elim]:\n  \"(x has_white_path_to y) s \\<Longrightarrow> (x reaches y) s\"", "lemma has_white_path_to_blacken[simp]:\n  \"(x has_white_path_to w) (s(gc := s gc\\<lparr> W := gc_W s - rs \\<rparr>)) \\<longleftrightarrow> (x has_white_path_to w) s\"", "lemma has_white_path_to_eq_imp': \\<comment> \\<open>Complicated condition takes care of \\<open>alloc\\<close>: collapses no object and object with no fields\\<close>\n  assumes \"(x has_white_path_to y) s'\"\n  assumes \"\\<forall>r'. \\<Union>(ran ` obj_fields ` set_option (sys_heap s' r')) = \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))\"\n  assumes \"\\<forall>r'. map_option obj_mark (sys_heap s' r') = map_option obj_mark (sys_heap s r')\"\n  assumes \"sys_fM s' = sys_fM s\"\n  shows \"(x has_white_path_to y) s\"", "lemma has_white_path_to_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          (x has_white_path_to y)\"", "lemmas has_white_path_to_fun_upd[simp] = eq_imp_fun_upd[OF has_white_path_to_eq_imp, simplified eq_imp_simps, rule_format]", "lemma grey_protects_whiteD[dest]:\n  \"(g grey_protects_white w) s \\<Longrightarrow> grey g s \\<and> (g = w \\<or> white w s)\"", "lemma grey_protects_whiteI[iff]:\n  \"grey g s \\<Longrightarrow> (g grey_protects_white g) s\"", "lemma grey_protects_whiteE[elim!]:\n  \"\\<lbrakk> (g points_to w) s; grey g s; white w s \\<rbrakk> \\<Longrightarrow> (g grey_protects_white w) s\"\n  \"\\<lbrakk> (g grey_protects_white y) s; (y points_to w) s; white w s \\<rbrakk> \\<Longrightarrow> (g grey_protects_white w) s\"", "lemma grey_protects_white_reaches[elim]:\n  \"(g grey_protects_white w) s \\<Longrightarrow> (g reaches w) s\"", "lemma grey_protects_white_induct[consumes 1, case_names refl step, induct set: grey_protects_white]:\n  assumes \"(g grey_protects_white w) s\"\n  assumes \"\\<And>x. grey x s \\<Longrightarrow> P x x\"\n  assumes \"\\<And>x y z. \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s; white z s\\<rbrakk> \\<Longrightarrow> P x z\"\n  shows \"P g w\"", "lemma valid_W_inv_sys_ghg_empty_iff[elim!]:\n  \"valid_W_inv s \\<Longrightarrow> sys_ghost_honorary_grey s = {}\"", "lemma WLI[intro]:\n  \"r \\<in> W (s p) \\<Longrightarrow> r \\<in> WL p s\"\n  \"r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> r \\<in> WL p s\"", "lemma WL_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. (ghost_honorary_grey (s p), W (s p)))\n          (WL p)\"", "lemmas WL_fun_upd[simp] = eq_imp_fun_upd[OF WL_eq_imp, simplified eq_imp_simps, rule_format]", "lemma valid_W_inv_eq_imp:\n  \"eq_imp (\\<lambda>(p, r). (\\<lambda>s. W (s p)) \\<^bold>\\<otimes> (\\<lambda>s. ghost_honorary_grey (s p)) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r)) \\<^bold>\\<otimes> sys_mem_lock \\<^bold>\\<otimes> tso_pending_mark p)\n          valid_W_inv\"", "lemmas valid_W_inv_fun_upd[simp] = eq_imp_fun_upd[OF valid_W_inv_eq_imp, simplified eq_imp_simps, rule_format]", "lemma valid_W_invE[elim!]:\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> marked r s\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk> \\<Longrightarrow> marked r s\"\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> valid_ref r s\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk> \\<Longrightarrow> valid_ref r s\"\n  \"\\<lbrakk> mw_Mark r fl \\<in> set (sys_mem_store_buffers p s); valid_W_inv s \\<rbrakk> \\<Longrightarrow> r \\<in> ghost_honorary_grey (s p)\"", "lemma valid_W_invD:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = []\"\n  \"\\<lbrakk> mw_Mark r fl \\<in> set (sys_mem_store_buffers p s); valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark (sys_mem_store_buffers p s) = [mw_Mark r fl]\"", "lemma valid_W_inv_colours:\n  \"\\<lbrakk>white x s; valid_W_inv s\\<rbrakk> \\<Longrightarrow> x \\<notin> W (s p)\"", "lemma valid_W_inv_no_mark_stores_invD:\n  \"\\<lbrakk> sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> tso_pending p is_mw_Mark s = []\"", "lemma valid_W_inv_sys_load[simp]:\n  \"\\<lbrakk> sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> sys_load p (mr_Mark r) (s sys) = mv_Mark (map_option obj_mark (sys_heap s r))\"", "lemma grey_reachable_eq_imp:\n  \"eq_imp (\\<lambda>r'. (\\<lambda>s. \\<Union>p. WL p s) \\<^bold>\\<otimes> (\\<lambda>s. Set.bind (Option.set_option (sys_heap s r')) (ran \\<circ> obj_fields)))\n          (grey_reachable r)\"", "lemmas grey_reachable_fun_upd[simp] = eq_imp_fun_upd[OF grey_reachable_eq_imp, simplified eq_imp_simps, rule_format]", "lemma grey_reachableI[intro]:\n  \"grey g s \\<Longrightarrow> grey_reachable g s\"", "lemma grey_reachableE:\n  \"\\<lbrakk> (g points_to y) s; grey_reachable g s \\<rbrakk> \\<Longrightarrow> grey_reachable y s\"", "lemma valid_refs_invI:\n  \"\\<lbrakk> \\<And>m x y. \\<lbrakk> (x reaches y) s; mut_m.root m x s \\<or> grey x s \\<rbrakk> \\<Longrightarrow> valid_ref y s\n   \\<rbrakk> \\<Longrightarrow> valid_refs_inv s\"", "lemma valid_refs_inv_eq_imp:\n  \"eq_imp (\\<lambda>(m', r'). (\\<lambda>s. roots (s (mutator m'))) \\<^bold>\\<otimes> (\\<lambda>s. ghost_honorary_root (s (mutator m'))) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_fields (sys_heap s r')) \\<^bold>\\<otimes> tso_pending_mutate (mutator m') \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>p. WL p s))\n          valid_refs_inv\"", "lemmas valid_refs_inv_fun_upd[simp] = eq_imp_fun_upd[OF valid_refs_inv_eq_imp, simplified eq_imp_simps, rule_format]", "lemma valid_refs_invD[elim]:\n  \"\\<lbrakk> x \\<in> mut_m.mut_roots m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> x \\<in> mut_m.mut_roots m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\"\n  \"\\<lbrakk> x \\<in> mut_m.tso_store_refs m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> x \\<in> mut_m.tso_store_refs m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\"\n  \"\\<lbrakk> w \\<in> set (sys_mem_store_buffers (mutator m) s); x \\<in> store_refs w; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> w \\<in> set (sys_mem_store_buffers (mutator m) s); x \\<in> store_refs w; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\"\n  \"\\<lbrakk> grey x s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> mut_m.reachable m x s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref x s\"\n  \"\\<lbrakk> mut_m.reachable m x s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s x = Some obj\"\n  \"\\<lbrakk> x \\<in> mut_m.mut_ghost_honorary_root m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> x \\<in> mut_m.mut_ghost_honorary_root m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\"", "lemma reachable_snapshot_invI[intro]:\n  \"(\\<And>y. reachable y s \\<Longrightarrow> in_snapshot y s) \\<Longrightarrow> reachable_snapshot_inv s\"", "lemma reachable_snapshot_inv_eq_imp:\n  \"eq_imp (\\<lambda>r'. mut_roots \\<^bold>\\<otimes> mut_ghost_honorary_root \\<^bold>\\<otimes> (\\<lambda>s. r' \\<in> (\\<Union>p. WL p s)) \\<^bold>\\<otimes> sys_fM\n            \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r'))\n            \\<^bold>\\<otimes> tso_pending_mutate (mutator m))\n          reachable_snapshot_inv\"", "lemmas reachable_snapshot_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.reachable_snapshot_inv_eq_imp, simplified eq_imp_simps, rule_format]", "lemma in_snapshotI[intro]:\n  \"black r s \\<Longrightarrow> in_snapshot r s\"\n  \"grey r s \\<Longrightarrow> in_snapshot r s\"\n  \"\\<lbrakk> white w s; (g grey_protects_white w) s \\<rbrakk> \\<Longrightarrow> in_snapshot w s\"", "lemma \\<comment> \\<open>Sanity\\<close>\n  \"in_snapshot r s \\<Longrightarrow> black r s \\<or> grey r s \\<or> white r s\"", "lemma in_snapshot_valid_ref:\n  \"\\<lbrakk> in_snapshot r s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref r s\"", "lemma reachableI2[intro]:\n  \"x \\<in> mut_m.mut_ghost_honorary_root m s \\<Longrightarrow> mut_m.reachable m x s\"", "lemma tso_pending_mw_mutate_cong:\n  \"\\<lbrakk> filter is_mw_Mutate (sys_mem_store_buffers p s) = filter is_mw_Mutate (sys_mem_store_buffers p s');\n     \\<And>r f r'. P r f r' \\<longleftrightarrow> Q r f r' \\<rbrakk>\n     \\<Longrightarrow> (\\<forall>r f r'. mw_Mutate r f r' \\<in> set (sys_mem_store_buffers p s)  \\<longrightarrow> P r f r')\n     \\<longleftrightarrow> (\\<forall>r f r'. mw_Mutate r f r' \\<in> set (sys_mem_store_buffers p s') \\<longrightarrow> Q r f r')\"", "lemma (in mut_m) marked_insertions_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')) \\<^bold>\\<otimes> tso_pending_mw_mutate (mutator m))\n          marked_insertions\"", "lemmas marked_insertions_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.marked_insertions_eq_imp, simplified eq_imp_simps, rule_format]", "lemma marked_insertionD[elim!]:\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = mw_Mutate r f (Some r') # ws; mut_m.marked_insertions m s \\<rbrakk>\n     \\<Longrightarrow> marked r' s\"", "lemma marked_insertions_store_buffer_empty[intro]:\n  \"tso_pending_mutate (mutator m) s = [] \\<Longrightarrow> mut_m.marked_insertions m s\"", "lemma (in mut_m) marked_deletions_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_fields (sys_heap s r')) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')) \\<^bold>\\<otimes> tso_pending_mw_mutate (mutator m))\n          marked_deletions\"", "lemmas marked_deletions_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.marked_deletions_eq_imp, simplified eq_imp_simps, rule_format]", "lemma marked_deletions_store_buffer_empty[intro]:\n  \"tso_pending_mutate (mutator m) s = [] \\<Longrightarrow> mut_m.marked_deletions m s\"", "lemma obj_at_ref_sweep_loop_free[simp]:\n  \"obj_at P r (s(sys := (s sys)\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) \\<longleftrightarrow> obj_at P r s \\<and> r \\<noteq> r'\"", "lemma obj_at_alloc[simp]:\n  \"sys_heap s r' = None\n  \\<Longrightarrow> obj_at P r (s(m := mut_m_s', sys := (s sys)\\<lparr> heap := sys_heap s(r' \\<mapsto> obj) \\<rparr>))\n  \\<longleftrightarrow> (obj_at P r s \\<or> (r = r' \\<and> P obj))\"", "lemma valid_ref_valid_null_ref_simps[simp]:\n  \"valid_ref r (s(sys := do_store_action w (s sys)\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<longleftrightarrow> valid_ref r s\"\n  \"valid_null_ref r' (s(sys := do_store_action w (s sys)\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<longleftrightarrow> valid_null_ref r' s\"\n  \"valid_null_ref r' (s(mutator m := mut_s', sys := (s sys)\\<lparr> heap := (heap (s sys))(r'' \\<mapsto> obj) \\<rparr>)) \\<longleftrightarrow> valid_null_ref r' s \\<or> r' = Some r''\"", "lemma reachable_load[simp]:\n  assumes \"sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'\"\n  assumes \"r \\<in> mut_roots s\"\n  shows \"mut_m.reachable m' y (s(mutator m := s (mutator m)\\<lparr> roots := mut_roots s \\<union> Option.set_option r' \\<rparr>)) \\<longleftrightarrow> mut_m.reachable m' y s\" (is \"?lhs = ?rhs\")", "lemma WL_blacken[simp]:\n  \"gc_ghost_honorary_grey s = {}\n    \\<Longrightarrow> WL p (s(gc := s gc\\<lparr> W := gc_W s - rs \\<rparr>)) = WL p s - { r |r. p = gc \\<and> r \\<in> rs }\"", "lemma WL_hs_done[simp]:\n  \"ghost_honorary_grey (s (mutator m)) = {}\n     \\<Longrightarrow> WL p (s(mutator m := s (mutator m)\\<lparr> W := {}, ghost_hs_phase := hp' \\<rparr>,\n                 sys   := s sys\\<lparr> hs_pending := hsp', W := sys_W s \\<union> W (s (mutator m)),\n                                 ghost_hs_in_sync := in' \\<rparr>))\n      = (case p of gc \\<Rightarrow> WL gc s | mutator m' \\<Rightarrow> (if m' = m then {} else WL (mutator m') s) | sys \\<Rightarrow> WL sys s \\<union> WL (mutator m) s)\"\n  \"ghost_honorary_grey (s (mutator m)) = {}\n     \\<Longrightarrow> WL p (s(mutator m := s (mutator m)\\<lparr> W := {} \\<rparr>,\n                 sys   := s sys\\<lparr> hs_pending := hsp', W := sys_W s \\<union> W (s (mutator m)),\n                                 ghost_hs_in_sync := in' \\<rparr>))\n      = (case p of gc \\<Rightarrow> WL gc s | mutator m' \\<Rightarrow> (if m' = m then {} else WL (mutator m') s) | sys \\<Rightarrow> WL sys s \\<union> WL (mutator m) s)\"", "lemma colours_load_W[iff]:\n  \"gc_W s = {} \\<Longrightarrow> black r (s(gc := (s gc)\\<lparr>W := W (s sys)\\<rparr>, sys := (s sys)\\<lparr>W := {}\\<rparr>)) \\<longleftrightarrow> black r s\"\n  \"gc_W s = {} \\<Longrightarrow> grey r (s(gc := (s gc)\\<lparr>W := W (s sys)\\<rparr>, sys := (s sys)\\<lparr>W := {}\\<rparr>)) \\<longleftrightarrow> grey r s\"", "lemma WL_load_W[simp]:\n  \"gc_W s = {}\n    \\<Longrightarrow> (WL p (s(gc := (s gc)\\<lparr>W := sys_W s\\<rparr>, sys := (s sys)\\<lparr>W := {}\\<rparr>)))\n     = (case p of gc \\<Rightarrow> WL gc s \\<union> sys_W s | mutator m \\<Rightarrow> WL (mutator m) s | sys \\<Rightarrow> sys_ghost_honorary_grey s)\"", "lemma no_grey_refs_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit). (\\<lambda>s. \\<Union>p. WL p s))\n          no_grey_refs\"", "lemmas no_grey_refs_fun_upd[simp] = eq_imp_fun_upd[OF no_grey_refs_eq_imp, simplified eq_imp_simps, rule_format]", "lemma no_grey_refs_no_pending_marks:\n  \"\\<lbrakk> no_grey_refs s; valid_W_inv s \\<rbrakk> \\<Longrightarrow> tso_no_pending_marks s\"", "lemma no_grey_refs_not_grey_reachableD:\n  \"no_grey_refs s \\<Longrightarrow> \\<not>grey_reachable x s\"", "lemma no_grey_refsD:\n  \"no_grey_refs s \\<Longrightarrow> r \\<notin> W (s p)\"\n  \"no_grey_refs s \\<Longrightarrow> r \\<notin> WL p s\"\n  \"no_grey_refs s \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s p)\"", "lemma no_grey_refs_marked[dest]:\n  \"\\<lbrakk> marked r s; no_grey_refs s \\<rbrakk> \\<Longrightarrow> black r s\"", "lemma no_grey_refs_bwD[dest]:\n  \"\\<lbrakk> heap (s sys) r = Some obj; no_grey_refs s \\<rbrakk> \\<Longrightarrow> black r s \\<or> white r s\"", "lemma reachable_blackD:\n  \"\\<lbrakk> no_grey_refs s; reachable_snapshot_inv s; reachable r s \\<rbrakk> \\<Longrightarrow> black r s\"", "lemma no_grey_refs_not_reachable:\n  \"\\<lbrakk> no_grey_refs s; reachable_snapshot_inv s; white r s \\<rbrakk> \\<Longrightarrow> \\<not>reachable r s\"", "lemma no_grey_refs_not_rootD:\n  \"\\<lbrakk> no_grey_refs s; reachable_snapshot_inv s; white r s \\<rbrakk>\n     \\<Longrightarrow> r \\<notin> mut_roots s \\<and> r \\<notin> mut_ghost_honorary_root s \\<and> r \\<notin> tso_store_refs s\"", "lemma reachable_snapshot_inv_white_root:\n  \"\\<lbrakk> white w s; w \\<in> mut_roots s \\<or> w \\<in> mut_ghost_honorary_root s; reachable_snapshot_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>g. (g grey_protects_white w) s\"", "lemma black_dequeue_Mark[simp]:\n  \"black b (s(sys := (s sys)\\<lparr> heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws) \\<rparr>))\n\\<longleftrightarrow> (black b s \\<and> b \\<noteq> r) \\<or> (b = r \\<and> fl = sys_fM s \\<and> valid_ref r s \\<and> \\<not>grey r s)\"", "lemma colours_sweep_loop_free[iff]:\n  \"black r (s(sys := s sys\\<lparr>heap := (heap (s sys))(r' := None)\\<rparr>)) \\<longleftrightarrow> (black r s \\<and> r \\<noteq> r')\"\n  \"grey r (s(sys := s sys\\<lparr>heap := (heap (s sys))(r' := None)\\<rparr>)) \\<longleftrightarrow> (grey r s)\"\n  \"white r (s(sys := s sys\\<lparr>heap := (heap (s sys))(r' := None)\\<rparr>)) \\<longleftrightarrow> (white r s \\<and> r \\<noteq> r')\"", "lemma colours_get_work_done[simp]:\n  \"black r (s(mutator m := (s (mutator m))\\<lparr>W := {}\\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> black r s\"\n  \"grey r (s(mutator m := (s (mutator m))\\<lparr>W := {}\\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> grey r s\"\n  \"white r (s(mutator m := (s (mutator m))\\<lparr>W := {}\\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> white r s\"", "lemma colours_get_roots_done[simp]:\n  \"black r (s(mutator m := (s (mutator m))\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> black r s\"\n  \"grey r (s(mutator m := (s (mutator m))\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> grey r s\"\n  \"white r (s(mutator m := (s (mutator m))\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> white r s\"", "lemma colours_flip_fM[simp]:\n  \"fl \\<noteq> sys_fM s \\<Longrightarrow> black b (s(sys := (s sys)\\<lparr>fM := fl, mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<longleftrightarrow> white b s \\<and> \\<not>grey b s\"", "lemma colours_alloc[simp]:\n  \"heap (s sys) r' = None\n     \\<Longrightarrow> black r (s(mutator m := (s (mutator m))\\<lparr> roots := roots' \\<rparr>, sys := (s sys)\\<lparr>heap := heap (s sys)(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> black r s \\<or> (r' = r \\<and> fl = sys_fM s \\<and> \\<not>grey r' s)\"\n  \"grey r (s(mutator m := (s (mutator m))\\<lparr> roots := roots' \\<rparr>, sys := (s sys)\\<lparr>heap := heap (s sys)(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> grey r s\"\n  \"heap (s sys) r' = None\n     \\<Longrightarrow> white r (s(mutator m := (s (mutator m))\\<lparr> roots := roots' \\<rparr>, sys := (s sys)\\<lparr>heap := heap (s sys)(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> white r s \\<or> (r' = r \\<and> fl \\<noteq> sys_fM s)\"", "lemma heap_colours_alloc[simp]:\n  \"\\<lbrakk> heap (s sys) r' = None; valid_refs_inv s \\<rbrakk>\n  \\<Longrightarrow> black_heap (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  \\<longleftrightarrow> black_heap s \\<and> fl = sys_fM s\"\n  \"heap (s sys) r' = None\n  \\<Longrightarrow> white_heap (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  \\<longleftrightarrow> white_heap s \\<and> fl \\<noteq> sys_fM s\"", "lemma grey_protects_white_hs_done[simp]:\n  \"(g grey_protects_white w) (s(mutator m := s (mutator m)\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n                              sys := s sys\\<lparr> hs_pending := hp', W := sys_W s \\<union> W (s (mutator m)),\n                                            ghost_hs_in_sync := his' \\<rparr>))\n  \\<longleftrightarrow> (g grey_protects_white w) s\"", "lemma grey_protects_white_alloc[simp]:\n  \"\\<lbrakk> fl = sys_fM s; sys_heap s r = None \\<rbrakk>\n     \\<Longrightarrow> (g grey_protects_white w) (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> (g grey_protects_white w) s\"", "lemma (in mut_m) reachable_snapshot_inv_sweep_loop_free:\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes nmr: \"white r s\"\n  assumes ngs: \"no_grey_refs s\"\n  assumes rsi: \"reachable_snapshot_inv s\"\n  shows \"reachable_snapshot_inv (s(sys := (s sys)\\<lparr>heap := (heap (s sys))(r := None)\\<rparr>))\" (is \"reachable_snapshot_inv ?s'\")", "lemma reachable_alloc[simp]:\n  assumes rn: \"sys_heap s r = None\"\n  shows \"mut_m.reachable m r' (s(mutator m' := (s (mutator m'))\\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>, sys := (s sys)\\<lparr>heap := (sys_heap s)(r \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> mut_m.reachable m r' s \\<or> (m' = m \\<and> r' = r)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma reachable_snapshot_inv_alloc[simp, elim!]:\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes rsi: \"reachable_snapshot_inv s\"\n  assumes rn: \"sys_heap s r = None\"\n  assumes fl: \"fl = sys_fM s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"reachable_snapshot_inv (s(mutator m' := (s (mutator m'))\\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>, sys := (s sys)\\<lparr>heap := (sys_heap s)(r \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\"\n(is \"reachable_snapshot_inv ?s'\")", "lemma reachable_snapshot_inv_discard_roots[simp]:\n  \"\\<lbrakk> reachable_snapshot_inv s; roots' \\<subseteq> roots (s (mutator m)) \\<rbrakk>\n     \\<Longrightarrow> reachable_snapshot_inv (s(mutator m := (s (mutator m))\\<lparr>roots := roots'\\<rparr>))\"", "lemma reachable_snapshot_inv_load[simp]:\n  \"\\<lbrakk> reachable_snapshot_inv s; sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'; r \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> reachable_snapshot_inv (s(mutator m := s (mutator m)\\<lparr> roots := mut_roots s \\<union> Option.set_option r' \\<rparr>))\"", "lemma reachable_snapshot_inv_store_ins[simp]:\n  \"\\<lbrakk> reachable_snapshot_inv s; r \\<in> mut_roots s; (\\<exists>r'. opt_r' = Some r') \\<longrightarrow> the opt_r' \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> reachable_snapshot_inv (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_root := {}\\<rparr>,\n                                  sys := s sys\\<lparr>  mem_store_buffers := (mem_store_buffers (s sys))(mutator m := sys_mem_store_buffers (mutator m) s @ [mw_Mutate r f opt_r']) \\<rparr>))\"", "lemma WL_mo_co_mark[simp]:\n  \"ghost_honorary_grey (s p) = {}\n     \\<Longrightarrow> WL p' (s(p := s p\\<lparr> ghost_honorary_grey := rs \\<rparr>)) = WL p' s \\<union> { r |r. p' = p \\<and> r \\<in> rs}\"", "lemma ghost_honorary_grey_mo_co_mark[simp]:\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {} \\<rbrakk> \\<Longrightarrow> black b (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<longleftrightarrow> black b s \\<and> b \\<noteq> r\"\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {} \\<rbrakk> \\<Longrightarrow> grey g (s(p := (s p)\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<longleftrightarrow> grey g s \\<or> g = r\"\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {} \\<rbrakk> \\<Longrightarrow> white w (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))  \\<longleftrightarrow> white w s\"", "lemma ghost_honorary_grey_mo_co_W[simp]:\n  \"ghost_honorary_grey (s p') = {r}\n     \\<Longrightarrow> (WL p (s(p' := (s p')\\<lparr>W := insert r (W (s p')), ghost_honorary_grey := {}\\<rparr>))) = (WL p s)\"\n  \"ghost_honorary_grey (s p') = {r}\n     \\<Longrightarrow> grey g (s(p' := (s p')\\<lparr>W := insert r (W (s p')), ghost_honorary_grey := {}\\<rparr>)) \\<longleftrightarrow> grey g s\"", "lemma reachable_sweep_loop_free:\n  \"mut_m.reachable m r (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\n   \\<Longrightarrow> mut_m.reachable m r s\"", "lemma reachable_deref_del[simp]:\n  \"\\<lbrakk> sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; r \\<in> mut_m.mut_roots m s; mut_m.mut_ghost_honorary_root m s = {} \\<rbrakk>\n   \\<Longrightarrow> mut_m.reachable m' y (s(mutator m := s (mutator m)\\<lparr> ghost_honorary_root := Option.set_option opt_r', ref := opt_r' \\<rparr>))\n   \\<longleftrightarrow> mut_m.reachable m' y s\"", "lemma no_black_refs_dequeue[simp]:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; no_black_refs s; valid_W_inv s \\<rbrakk>\n   \\<Longrightarrow> no_black_refs (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mutate r f r' # ws; no_black_refs s \\<rbrakk>\n     \\<Longrightarrow> no_black_refs (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>) (sys_heap s r)),\n                                      mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\"", "lemma colours_blacken[simp]:\n  \"valid_W_inv s \\<Longrightarrow> black b (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) \\<longleftrightarrow> black b s \\<or> (r \\<in> gc_W s \\<and> b = r)\"\n  \"\\<lbrakk> r \\<in> gc_W s; valid_W_inv s \\<rbrakk> \\<Longrightarrow> grey g (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) \\<longleftrightarrow> (grey g s \\<and> g \\<noteq> r)\"", "lemma no_black_refs_alloc[simp]:\n  \"\\<lbrakk> heap (s sys) r' = None; no_black_refs s \\<rbrakk>\n     \\<Longrightarrow> no_black_refs (s(mutator m' := s (mutator m')\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> fl \\<noteq> sys_fM s \\<or> grey r' s\"", "lemma no_black_refs_mo_co_mark[simp]:\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {}; white r s \\<rbrakk>\n     \\<Longrightarrow> no_black_refs (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<longleftrightarrow> no_black_refs s\"", "lemma grey_protects_white_mark[simp]:\n  assumes ghg: \"ghost_honorary_grey (s p) = {}\"\n  shows \"(\\<exists>g. (g grey_protects_white w) (s(p := s p\\<lparr> ghost_honorary_grey := {r} \\<rparr>)))\n      \\<longleftrightarrow> (\\<exists>g'. (g' grey_protects_white w) s) \\<or> (r has_white_path_to w) s\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma valid_refs_inv_dequeue_Mutate:\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes vri: \"valid_refs_inv s\"\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\"\n  shows \"valid_refs_inv (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>))\" (is \"valid_refs_inv ?s'\")", "lemma valid_refs_inv_dequeue_Mutate_Payload:\n  notes if_split_asm[split del]\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes vri: \"valid_refs_inv s\"\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate_Payload r f pl # ws\"\n  shows \"valid_refs_inv (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>) (sys_heap s r)),\n                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))\" (is \"valid_refs_inv ?s'\")"], "translations": [["", "lemma tso_store_inv_eq_imp:\n  \"eq_imp (\\<lambda>p s. mem_store_buffers (s sys) p)\n          tso_store_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp sys_mem_store_buffers tso_store_inv", "by (simp add: eq_imp_def tso_store_inv_def)"], ["", "lemmas tso_store_inv_fun_upd[simp] = eq_imp_fun_upd[OF tso_store_inv_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma tso_store_invD[simp]:\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers gc s = mw_Mutate r f r' # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers gc s = mw_Mutate_Payload r f pl # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers (mutator m) s = mw_fA fl # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers (mutator m) s = mw_fM fl # ws\"\n  \"tso_store_inv s \\<Longrightarrow> \\<not>sys_mem_store_buffers (mutator m) s = mw_Phase ph # ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((tso_store_inv s \\<Longrightarrow>\n      sys_mem_store_buffers gc s \\<noteq> mw_Mutate r f r' # ws) &&&\n     (tso_store_inv s \\<Longrightarrow>\n      sys_mem_store_buffers gc s \\<noteq>\n      mw_Mutate_Payload r f pl # ws)) &&&\n    (tso_store_inv s \\<Longrightarrow>\n     sys_mem_store_buffers (mutator m) s \\<noteq> mw_fA fl # ws) &&&\n    (tso_store_inv s \\<Longrightarrow>\n     sys_mem_store_buffers (mutator m) s \\<noteq> mw_fM fl # ws) &&&\n    (tso_store_inv s \\<Longrightarrow>\n     sys_mem_store_buffers (mutator m) s \\<noteq> mw_Phase ph # ws)", "by (auto simp: tso_store_inv_def dest!: spec[where x=m])"], ["", "lemma mut_do_store_action[simp]:\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = w # ws; tso_store_inv s \\<rbrakk> \\<Longrightarrow> fA (do_store_action w (s sys)) = sys_fA s\"\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = w # ws; tso_store_inv s \\<rbrakk> \\<Longrightarrow> fM (do_store_action w (s sys)) = sys_fM s\"\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = w # ws; tso_store_inv s \\<rbrakk> \\<Longrightarrow> phase (do_store_action w (s sys)) = sys_phase s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sys_mem_store_buffers (mutator m) s = w # ws;\n      tso_store_inv s\\<rbrakk>\n     \\<Longrightarrow> fA (do_store_action w (s sys)) = sys_fA s) &&&\n    (\\<lbrakk>sys_mem_store_buffers (mutator m) s = w # ws;\n      tso_store_inv s\\<rbrakk>\n     \\<Longrightarrow> fM (do_store_action w (s sys)) = sys_fM s) &&&\n    (\\<lbrakk>sys_mem_store_buffers (mutator m) s = w # ws;\n      tso_store_inv s\\<rbrakk>\n     \\<Longrightarrow> phase (do_store_action w (s sys)) = sys_phase s)", "by (auto simp: do_store_action_def split: mem_store_action.splits)"], ["", "lemma tso_store_inv_sys_load_Mut[simp]:\n  assumes \"tso_store_inv s\"\n  assumes \"(ract, v) \\<in> { (mr_fM, mv_Mark (Some (sys_fM s))), (mr_fA, mv_Mark (Some (sys_fA s))), (mr_Phase, mv_Phase (sys_phase s)) }\"\n  shows \"sys_load (mutator m) ract (s sys) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_load (mutator m) ract (s sys) = v", "using assms"], ["proof (prove)\nusing this:\n  tso_store_inv s\n  (ract, v)\n  \\<in> {(mr_fM, mv_Mark (Some (sys_fM s))),\n         (mr_fA, mv_Mark (Some (sys_fA s))),\n         (mr_Phase, mv_Phase (sys_phase s))}\n\ngoal (1 subgoal):\n 1. sys_load (mutator m) ract (s sys) = v", "apply (clarsimp simp: sys_load_def fold_stores_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tso_store_inv s;\n     ract = mr_fM \\<and> v = mv_Mark (Some (sys_fM s)) \\<or>\n     ract = mr_fA \\<and> v = mv_Mark (Some (sys_fA s)) \\<or>\n     ract = mr_Phase \\<and> v = mv_Phase (sys_phase s)\\<rbrakk>\n    \\<Longrightarrow> do_load_action ract\n                       (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                         (sys_mem_store_buffers (mutator m) s) id (s sys)) =\n                      v", "apply (rule fold_invariant[where P=\"\\<lambda>fr. do_load_action ract (fr (s sys)) = v\" and Q=\"mut_writes\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>tso_store_inv s;\n        ract = mr_fM \\<and> v = mv_Mark (Some (sys_fM s)) \\<or>\n        ract = mr_fA \\<and> v = mv_Mark (Some (sys_fA s)) \\<or>\n        ract = mr_Phase \\<and> v = mv_Phase (sys_phase s);\n        x \\<in> set (sys_mem_store_buffers (mutator m) s)\\<rbrakk>\n       \\<Longrightarrow> mut_writes x\n 2. \\<lbrakk>tso_store_inv s;\n     ract = mr_fM \\<and> v = mv_Mark (Some (sys_fM s)) \\<or>\n     ract = mr_fA \\<and> v = mv_Mark (Some (sys_fA s)) \\<or>\n     ract = mr_Phase \\<and> v = mv_Phase (sys_phase s)\\<rbrakk>\n    \\<Longrightarrow> do_load_action ract (id (s sys)) = v\n 3. \\<And>x sa.\n       \\<lbrakk>tso_store_inv s;\n        ract = mr_fM \\<and> v = mv_Mark (Some (sys_fM s)) \\<or>\n        ract = mr_fA \\<and> v = mv_Mark (Some (sys_fA s)) \\<or>\n        ract = mr_Phase \\<and> v = mv_Phase (sys_phase s);\n        mut_writes x; do_load_action ract (sa (s sys)) = v\\<rbrakk>\n       \\<Longrightarrow> do_load_action ract\n                          ((do_store_action x \\<circ> sa) (s sys)) =\n                         v", "apply (fastforce simp: tso_store_inv_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tso_store_inv s;\n     ract = mr_fM \\<and> v = mv_Mark (Some (sys_fM s)) \\<or>\n     ract = mr_fA \\<and> v = mv_Mark (Some (sys_fA s)) \\<or>\n     ract = mr_Phase \\<and> v = mv_Phase (sys_phase s)\\<rbrakk>\n    \\<Longrightarrow> do_load_action ract (id (s sys)) = v\n 2. \\<And>x sa.\n       \\<lbrakk>tso_store_inv s;\n        ract = mr_fM \\<and> v = mv_Mark (Some (sys_fM s)) \\<or>\n        ract = mr_fA \\<and> v = mv_Mark (Some (sys_fA s)) \\<or>\n        ract = mr_Phase \\<and> v = mv_Phase (sys_phase s);\n        mut_writes x; do_load_action ract (sa (s sys)) = v\\<rbrakk>\n       \\<Longrightarrow> do_load_action ract\n                          ((do_store_action x \\<circ> sa) (s sys)) =\n                         v", "apply (auto simp: do_load_action_def split: mem_store_action.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tso_store_inv_sys_load_GC[simp]:\n  assumes \"tso_store_inv s\"\n  shows \"sys_load gc (mr_Ref r f) (s sys) = mv_Ref (Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f))\" (is \"?lhs = mv_Ref ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_load gc (mr_Ref r f) (s sys) =\n    mv_Ref (Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f))", "using assms"], ["proof (prove)\nusing this:\n  tso_store_inv s\n\ngoal (1 subgoal):\n 1. sys_load gc (mr_Ref r f) (s sys) =\n    mv_Ref (Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f))", "unfolding sys_load_def fold_stores_def"], ["proof (prove)\nusing this:\n  tso_store_inv s\n\ngoal (1 subgoal):\n 1. (do_load_action (mr_Ref r f) \\<circ>\n     (\\<lambda>s.\n         fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n          (mem_store_buffers s gc) id s))\n     (s sys) =\n    mv_Ref (Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. tso_store_inv s \\<Longrightarrow>\n    Option.bind\n     (heap\n       (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n         (sys_mem_store_buffers gc s) id (s sys))\n       r)\n     (\\<lambda>obj. obj_fields obj f) =\n    Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f)", "apply (rule fold_invariant[where P=\"\\<lambda>fr. Option.bind (heap (fr (s sys)) r) (\\<lambda>obj. obj_fields obj f) = ?rhs\"\n                             and Q=\"\\<lambda>w. \\<forall>r f r'. w \\<noteq> mw_Mutate r f r'\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>tso_store_inv s;\n        x \\<in> set (sys_mem_store_buffers gc s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r f r'. x \\<noteq> mw_Mutate r f r'\n 2. tso_store_inv s \\<Longrightarrow>\n    Option.bind (heap (id (s sys)) r) (\\<lambda>obj. obj_fields obj f) =\n    Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f)\n 3. \\<And>x sa.\n       \\<lbrakk>tso_store_inv s;\n        \\<forall>r f r'. x \\<noteq> mw_Mutate r f r';\n        Option.bind (heap (sa (s sys)) r) (\\<lambda>obj. obj_fields obj f) =\n        Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f)\\<rbrakk>\n       \\<Longrightarrow> Option.bind\n                          (heap ((do_store_action x \\<circ> sa) (s sys)) r)\n                          (\\<lambda>obj. obj_fields obj f) =\n                         Option.bind (sys_heap s r)\n                          (\\<lambda>obj. obj_fields obj f)", "apply (fastforce simp: tso_store_inv_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. tso_store_inv s \\<Longrightarrow>\n    Option.bind (heap (id (s sys)) r) (\\<lambda>obj. obj_fields obj f) =\n    Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f)\n 2. \\<And>x sa.\n       \\<lbrakk>tso_store_inv s;\n        \\<forall>r f r'. x \\<noteq> mw_Mutate r f r';\n        Option.bind (heap (sa (s sys)) r) (\\<lambda>obj. obj_fields obj f) =\n        Option.bind (sys_heap s r) (\\<lambda>obj. obj_fields obj f)\\<rbrakk>\n       \\<Longrightarrow> Option.bind\n                          (heap ((do_store_action x \\<circ> sa) (s sys)) r)\n                          (\\<lambda>obj. obj_fields obj f) =\n                         Option.bind (sys_heap s r)\n                          (\\<lambda>obj. obj_fields obj f)", "apply (auto simp: do_store_action_def map_option_case fun_upd_apply\n            split: mem_store_action.splits option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tso_no_pending_marksD[simp]:\n  assumes \"tso_pending_mark p s = []\"\n  shows \"sys_load p (mr_Mark r) (s sys) = mv_Mark (map_option obj_mark (sys_heap s r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_load p (mr_Mark r) (s sys) =\n    mv_Mark (map_option obj_mark (sys_heap s r))", "using assms"], ["proof (prove)\nusing this:\n  filter is_mw_Mark (sys_mem_store_buffers p s) = []\n\ngoal (1 subgoal):\n 1. sys_load p (mr_Mark r) (s sys) =\n    mv_Mark (map_option obj_mark (sys_heap s r))", "unfolding sys_load_def fold_stores_def"], ["proof (prove)\nusing this:\n  filter is_mw_Mark (sys_mem_store_buffers p s) = []\n\ngoal (1 subgoal):\n 1. (do_load_action (mr_Mark r) \\<circ>\n     (\\<lambda>s.\n         fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n          (mem_store_buffers s p) id s))\n     (s sys) =\n    mv_Mark (map_option obj_mark (sys_heap s r))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter is_mw_Mark (sys_mem_store_buffers p s) = [] \\<Longrightarrow>\n    map_option obj_mark\n     (heap\n       (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n         (sys_mem_store_buffers p s) id (s sys))\n       r) =\n    map_option obj_mark (sys_heap s r)", "apply (rule fold_invariant[where P=\"\\<lambda>fr. map_option obj_mark (heap (fr (s sys)) r) = map_option obj_mark (sys_heap s r)\"\n                             and Q=\"\\<lambda>w. \\<forall>fl. w \\<noteq> mw_Mark r fl\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>filter is_mw_Mark (sys_mem_store_buffers p s) = [];\n        x \\<in> set (sys_mem_store_buffers p s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>fl. x \\<noteq> mw_Mark r fl\n 2. filter is_mw_Mark (sys_mem_store_buffers p s) = [] \\<Longrightarrow>\n    map_option obj_mark (heap (id (s sys)) r) =\n    map_option obj_mark (sys_heap s r)\n 3. \\<And>x sa.\n       \\<lbrakk>filter is_mw_Mark (sys_mem_store_buffers p s) = [];\n        \\<forall>fl. x \\<noteq> mw_Mark r fl;\n        map_option obj_mark (heap (sa (s sys)) r) =\n        map_option obj_mark (sys_heap s r)\\<rbrakk>\n       \\<Longrightarrow> map_option obj_mark\n                          (heap ((do_store_action x \\<circ> sa) (s sys))\n                            r) =\n                         map_option obj_mark (sys_heap s r)", "apply (auto simp: map_option_case do_store_action_def filter_empty_conv fun_upd_apply\n             split: mem_store_action.splits option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_pending_phase_sys_load[simp]:\n  assumes \"tso_pending_phase p s = []\"\n  shows \"sys_load p mr_Phase (s sys) = mv_Phase (sys_phase s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_load p mr_Phase (s sys) = mv_Phase (sys_phase s)", "using assms"], ["proof (prove)\nusing this:\n  filter is_mw_Phase (sys_mem_store_buffers p s) = []\n\ngoal (1 subgoal):\n 1. sys_load p mr_Phase (s sys) = mv_Phase (sys_phase s)", "apply (clarsimp simp: sys_load_def fold_stores_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter is_mw_Phase (sys_mem_store_buffers p s) = [] \\<Longrightarrow>\n    phase\n     (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n       (sys_mem_store_buffers p s) id (s sys)) =\n    sys_phase s", "apply (rule fold_invariant[where P=\"\\<lambda>fr. phase (fr (s sys)) = sys_phase s\" and Q=\"\\<lambda>w. \\<forall>ph. w \\<noteq> mw_Phase ph\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>filter is_mw_Phase (sys_mem_store_buffers p s) = [];\n        x \\<in> set (sys_mem_store_buffers p s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ph. x \\<noteq> mw_Phase ph\n 2. filter is_mw_Phase (sys_mem_store_buffers p s) = [] \\<Longrightarrow>\n    phase (id (s sys)) = sys_phase s\n 3. \\<And>x sa.\n       \\<lbrakk>filter is_mw_Phase (sys_mem_store_buffers p s) = [];\n        \\<forall>ph. x \\<noteq> mw_Phase ph;\n        phase (sa (s sys)) = sys_phase s\\<rbrakk>\n       \\<Longrightarrow> phase ((do_store_action x \\<circ> sa) (s sys)) =\n                         sys_phase s", "apply (auto simp: do_store_action_def filter_empty_conv\n             split: mem_store_action.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gc_no_pending_fM_write[simp]:\n  assumes \"tso_pending_fM gc s = []\"\n  shows \"sys_load gc mr_fM (s sys) = mv_Mark (Some (sys_fM s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_load gc mr_fM (s sys) = mv_Mark (Some (sys_fM s))", "using assms"], ["proof (prove)\nusing this:\n  filter is_mw_fM (sys_mem_store_buffers gc s) = []\n\ngoal (1 subgoal):\n 1. sys_load gc mr_fM (s sys) = mv_Mark (Some (sys_fM s))", "apply (clarsimp simp: sys_load_def fold_stores_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter is_mw_fM (sys_mem_store_buffers gc s) = [] \\<Longrightarrow>\n    fM (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n         (sys_mem_store_buffers gc s) id (s sys)) =\n    sys_fM s", "apply (rule fold_invariant[where P=\"\\<lambda>fr. fM (fr (s sys)) = sys_fM s\" and Q=\"\\<lambda>w. \\<forall>fl. w \\<noteq> mw_fM fl\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>filter is_mw_fM (sys_mem_store_buffers gc s) = [];\n        x \\<in> set (sys_mem_store_buffers gc s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>fl. x \\<noteq> mw_fM fl\n 2. filter is_mw_fM (sys_mem_store_buffers gc s) = [] \\<Longrightarrow>\n    fM (id (s sys)) = sys_fM s\n 3. \\<And>x sa.\n       \\<lbrakk>filter is_mw_fM (sys_mem_store_buffers gc s) = [];\n        \\<forall>fl. x \\<noteq> mw_fM fl;\n        fM (sa (s sys)) = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> fM ((do_store_action x \\<circ> sa) (s sys)) =\n                         sys_fM s", "apply (auto simp: do_store_action_def filter_empty_conv\n             split: mem_store_action.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tso_store_refs_simps[simp]:\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>roots := roots'\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := sys_mem_store_buffers (mutator m') s @ [mw_Mutate r f opt_r'])\\<rparr>))\n = mut_m.tso_store_refs m s \\<union> (if m' = m then store_refs (mw_Mutate r f opt_r') else {})\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := sys_mem_store_buffers (mutator m') s @ [mw_Mutate_Payload r f pl])\\<rparr>))\n = mut_m.tso_store_refs m s \\<union> (if m' = m then store_refs (mw_Mutate_Payload r f pl) else {})\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r \\<mapsto> obj)\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(mutator m' := s (mutator m')\\<lparr>ghost_honorary_root := Option.set_option opt_r', ref := opt_r'\\<rparr>))\n = mut_m.tso_store_refs m s\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                          mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\n = (if p = mutator m then \\<Union>w \\<in> set ws. store_refs w else mut_m.tso_store_refs m s)\"\n  \"mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>) (sys_heap s r)),\n                                          mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\n = (if p = mutator m then \\<Union>w \\<in> set ws. store_refs w else mut_m.tso_store_refs m s)\"\n  \"sys_mem_store_buffers p s = mw_Mark r fl # ws\n\\<Longrightarrow> mut_m.tso_store_refs m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\n = mut_m.tso_store_refs m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((mut_m.tso_store_refs m\n       (s(mutator m' := s (mutator m')\\<lparr>roots := roots'\\<rparr>)) =\n      mut_m.tso_store_refs m s &&&\n      mut_m.tso_store_refs m\n       (s(mutator m' := s (mutator m')\n            \\<lparr>ghost_honorary_root := {}\\<rparr>,\n          sys := s sys\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' :=\n                         sys_mem_store_buffers (mutator m') s @\n                         [mw_Mutate r f opt_r'])\\<rparr>)) =\n      mut_m.tso_store_refs m s \\<union>\n      (if m' = m then store_refs (mw_Mutate r f opt_r') else {})) &&&\n     mut_m.tso_store_refs m\n      (s(sys := s sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m' :=\n                        sys_mem_store_buffers (mutator m') s @\n                        [mw_Mutate_Payload r f pl])\\<rparr>)) =\n     mut_m.tso_store_refs m s \\<union>\n     (if m' = m then store_refs (mw_Mutate_Payload r f pl) else {}) &&&\n     mut_m.tso_store_refs m\n      (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) =\n     mut_m.tso_store_refs m s) &&&\n    (mut_m.tso_store_refs m\n      (s(mutator m' := s (mutator m')\n           \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n         sys := s sys\\<lparr>heap := sys_heap s(r \\<mapsto> obj)\\<rparr>)) =\n     mut_m.tso_store_refs m s &&&\n     mut_m.tso_store_refs m\n      (s(mutator m' := s (mutator m')\n           \\<lparr>ghost_honorary_root := set_option opt_r',\n              ref := opt_r'\\<rparr>)) =\n     mut_m.tso_store_refs m s) &&&\n    mut_m.tso_store_refs m\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (p := ws)\\<rparr>)) =\n    (if p = mutator m then \\<Union> (store_refs ` set ws)\n     else mut_m.tso_store_refs m s) &&&\n    mut_m.tso_store_refs m\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_payload := (obj_payload obj)\n   (f := pl)\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (p := ws)\\<rparr>)) =\n    (if p = mutator m then \\<Union> (store_refs ` set ws)\n     else mut_m.tso_store_refs m s) &&&\n    (sys_mem_store_buffers p s = mw_Mark r fl # ws \\<Longrightarrow>\n     mut_m.tso_store_refs m\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (p := ws)\\<rparr>)) =\n     mut_m.tso_store_refs m s)", "unfolding mut_m.tso_store_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Union>\n       (store_refs `\n        set (sys_mem_store_buffers (mutator m)\n              (s(mutator m' := s (mutator m')\n                   \\<lparr>roots := roots'\\<rparr>)))) =\n      \\<Union> (store_refs ` set (sys_mem_store_buffers (mutator m) s)) &&&\n      \\<Union>\n       (store_refs `\n        set (sys_mem_store_buffers (mutator m)\n              (s(mutator m' := s (mutator m')\n                   \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                 sys := s sys\n                   \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                             (mutator m' :=\n                                sys_mem_store_buffers (mutator m') s @\n                                [mw_Mutate r f opt_r'])\\<rparr>)))) =\n      \\<Union>\n       (store_refs ` set (sys_mem_store_buffers (mutator m) s)) \\<union>\n      (if m' = m then store_refs (mw_Mutate r f opt_r') else {})) &&&\n     \\<Union>\n      (store_refs `\n       set (sys_mem_store_buffers (mutator m)\n             (s(sys := s sys\n                  \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' :=\n                               sys_mem_store_buffers (mutator m') s @\n                               [mw_Mutate_Payload r f pl])\\<rparr>)))) =\n     \\<Union>\n      (store_refs ` set (sys_mem_store_buffers (mutator m) s)) \\<union>\n     (if m' = m then store_refs (mw_Mutate_Payload r f pl) else {}) &&&\n     \\<Union>\n      (store_refs `\n       set (sys_mem_store_buffers (mutator m)\n             (s(sys := s sys\n                  \\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)))) =\n     \\<Union> (store_refs ` set (sys_mem_store_buffers (mutator m) s))) &&&\n    (\\<Union>\n      (store_refs `\n       set (sys_mem_store_buffers (mutator m)\n             (s(mutator m' := s (mutator m')\n                  \\<lparr>roots :=\n                            insert r (roots (s (mutator m')))\\<rparr>,\n                sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj)\\<rparr>)))) =\n     \\<Union> (store_refs ` set (sys_mem_store_buffers (mutator m) s)) &&&\n     \\<Union>\n      (store_refs `\n       set (sys_mem_store_buffers (mutator m)\n             (s(mutator m' := s (mutator m')\n                  \\<lparr>ghost_honorary_root := set_option opt_r',\n                     ref := opt_r'\\<rparr>)))) =\n     \\<Union> (store_refs ` set (sys_mem_store_buffers (mutator m) s))) &&&\n    \\<Union>\n     (store_refs `\n      set (sys_mem_store_buffers (mutator m)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (p := ws)\\<rparr>)))) =\n    (if p = mutator m then \\<Union> (store_refs ` set ws)\n     else \\<Union>\n           (store_refs ` set (sys_mem_store_buffers (mutator m) s))) &&&\n    \\<Union>\n     (store_refs `\n      set (sys_mem_store_buffers (mutator m)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (p := ws)\\<rparr>)))) =\n    (if p = mutator m then \\<Union> (store_refs ` set ws)\n     else \\<Union>\n           (store_refs ` set (sys_mem_store_buffers (mutator m) s))) &&&\n    (sys_mem_store_buffers p s = mw_Mark r fl # ws \\<Longrightarrow>\n     \\<Union>\n      (store_refs `\n       set (sys_mem_store_buffers (mutator m)\n             (s(sys := s sys\n                  \\<lparr>heap := (sys_heap s)\n                            (r := map_option\n                                   (obj_mark_update (\\<lambda>_. fl))\n                                   (sys_heap s r)),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (p := ws)\\<rparr>)))) =\n     \\<Union> (store_refs ` set (sys_mem_store_buffers (mutator m) s)))", "by (auto simp: fun_upd_apply)"], ["", "lemma fold_stores_points_to[rule_format, simplified conj_explode]:\n  \"heap (fold_stores ws (s sys)) r = Some obj \\<and> obj_fields obj f = Some r'\n     \\<longrightarrow> (r points_to r') s \\<or> (\\<exists>w \\<in> set ws. r' \\<in> store_refs w)\" (is \"?P (fold_stores ws) obj\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (fold_stores ws (s sys)) r = Some obj \\<and>\n    obj_fields obj f = Some r' \\<longrightarrow>\n    (r points_to r') s \\<or> (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)", "unfolding fold_stores_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (fold (\\<lambda>w. (\\<circ>) (do_store_action w)) ws id (s sys))\n     r =\n    Some obj \\<and>\n    obj_fields obj f = Some r' \\<longrightarrow>\n    (r points_to r') s \\<or> (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)", "apply (rule spec[OF fold_invariant[where P=\"\\<lambda>fr. \\<forall>obj. ?P fr obj\" and Q=\"\\<lambda>w. w \\<in> set ws\"]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> set ws \\<Longrightarrow> x \\<in> set ws\n 2. \\<forall>x.\n       heap (id (s sys)) r = Some x \\<and>\n       obj_fields x f = Some r' \\<longrightarrow>\n       (r points_to r') s \\<or>\n       (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)\n 3. \\<And>x sa.\n       \\<lbrakk>x \\<in> set ws;\n        \\<forall>x.\n           heap (sa (s sys)) r = Some x \\<and>\n           obj_fields x f = Some r' \\<longrightarrow>\n           (r points_to r') s \\<or>\n           (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            heap ((do_store_action x \\<circ> sa) (s sys))\n                             r =\n                            Some xa \\<and>\n                            obj_fields xa f = Some r' \\<longrightarrow>\n                            (r points_to r') s \\<or>\n                            (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       heap (id (s sys)) r = Some x \\<and>\n       obj_fields x f = Some r' \\<longrightarrow>\n       (r points_to r') s \\<or>\n       (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)\n 2. \\<And>x sa.\n       \\<lbrakk>x \\<in> set ws;\n        \\<forall>x.\n           heap (sa (s sys)) r = Some x \\<and>\n           obj_fields x f = Some r' \\<longrightarrow>\n           (r points_to r') s \\<or>\n           (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            heap ((do_store_action x \\<circ> sa) (s sys))\n                             r =\n                            Some xa \\<and>\n                            obj_fields xa f = Some r' \\<longrightarrow>\n                            (r points_to r') s \\<or>\n                            (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)", "apply (fastforce simp: ran_def split: obj_at_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x sa.\n       \\<lbrakk>x \\<in> set ws;\n        \\<forall>x.\n           heap (sa (s sys)) r = Some x \\<and>\n           obj_fields x f = Some r' \\<longrightarrow>\n           (r points_to r') s \\<or>\n           (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            heap ((do_store_action x \\<circ> sa) (s sys))\n                             r =\n                            Some xa \\<and>\n                            obj_fields xa f = Some r' \\<longrightarrow>\n                            (r points_to r') s \\<or>\n                            (\\<exists>w\\<in>set ws. r' \\<in> store_refs w)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x sa xa.\n       \\<lbrakk>x \\<in> set ws;\n        heap (do_store_action x (sa (s sys))) r = Some xa;\n        obj_fields xa f = Some r';\n        \\<forall>w\\<in>set ws.\n           r' \\<notin> (case w of\n                        mw_Mutate r f r' \\<Rightarrow>\n                          insert r (set_option r')\n                        | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                        | _ \\<Rightarrow> {});\n        \\<forall>x.\n           heap (sa (s sys)) r = Some x \\<longrightarrow>\n           obj_fields x f \\<noteq> Some r'\\<rbrakk>\n       \\<Longrightarrow> (r points_to r') s", "apply (drule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x sa xa.\n       \\<lbrakk>x \\<in> set ws;\n        heap (do_store_action x (sa (s sys))) r = Some xa;\n        obj_fields xa f = Some r';\n        \\<forall>x.\n           heap (sa (s sys)) r = Some x \\<longrightarrow>\n           obj_fields x f \\<noteq> Some r';\n        r' \\<notin> (case x of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> (r points_to r') s", "apply (clarsimp simp: fun_upd_apply split: mem_store_action.split_asm if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma points_to_Mutate:\n  \"(x points_to y)\n         (s(sys := (s sys)\\<lparr> heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                            mem_store_buffers := (mem_store_buffers (s sys))(p := ws) \\<rparr>))\n  \\<longleftrightarrow> (r \\<noteq> x \\<and> (x points_to y) s) \\<or> (r = x \\<and> valid_ref r s \\<and> (opt_r' = Some y \\<or> ( (x points_to y) s \\<and> obj_at (\\<lambda>obj. \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f') r s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x points_to y)\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (p := ws)\\<rparr>)) =\n    (r \\<noteq> x \\<and> (x points_to y) s \\<or>\n     r = x \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (opt_r' = Some y \\<or>\n      (x points_to y) s \\<and>\n      obj_at\n       (\\<lambda>obj.\n           \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n       r s))", "unfolding ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at\n     (\\<lambda>obj. y \\<in> {b. \\<exists>a. obj_fields obj a = Some b}) x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (p := ws)\\<rparr>)) =\n    (r \\<noteq> x \\<and>\n     obj_at\n      (\\<lambda>obj. y \\<in> {b. \\<exists>a. obj_fields obj a = Some b}) x\n      s \\<or>\n     r = x \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (opt_r' = Some y \\<or>\n      obj_at\n       (\\<lambda>obj. y \\<in> {b. \\<exists>a. obj_fields obj a = Some b}) x\n       s \\<and>\n      obj_at\n       (\\<lambda>obj.\n           \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n       r s))", "by (auto simp: fun_upd_apply split: obj_at_splits)"], ["", "subsection\\<open> FIXME mutator handshake facts \\<close>"], ["", "lemma \\<comment> \\<open>Sanity\\<close>\n  \"hp' = hs_step hp \\<Longrightarrow> \\<exists>in' ht. (in', ht, hp', hp) \\<in> hp_step_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hp' = hs_step hp \\<Longrightarrow>\n    \\<exists>in' ht. (in', ht, hp', hp) \\<in> hp_step_rel", "by (cases hp) (auto simp: hp_step_rel_def)"], ["", "lemma \\<comment> \\<open>Sanity\\<close>\n  \"(False, ht, hp', hp) \\<in> hp_step_rel \\<Longrightarrow> hp' = hp_step ht hp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (False, ht, hp', hp) \\<in> hp_step_rel \\<Longrightarrow>\n    hp' = hp_step ht hp", "by (cases ht) (auto simp: hp_step_rel_def)"], ["", "lemma (in mut_m) handshake_phase_invD:\n  assumes \"handshake_phase_inv s\"\n  shows \"(sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s, mut_ghost_hs_phase s) \\<in> hp_step_rel\n       \\<and> (sys_hs_pending m s \\<longrightarrow> \\<not>sys_ghost_hs_in_sync m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n     mut_ghost_hs_phase s)\n    \\<in> hp_step_rel \\<and>\n    (sys_hs_pending m s \\<longrightarrow> \\<not> sys_ghost_hs_in_sync m s)", "using assms"], ["proof (prove)\nusing this:\n  handshake_phase_inv s\n\ngoal (1 subgoal):\n 1. (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n     mut_ghost_hs_phase s)\n    \\<in> hp_step_rel \\<and>\n    (sys_hs_pending m s \\<longrightarrow> \\<not> sys_ghost_hs_in_sync m s)", "unfolding handshake_phase_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (sys_ghost_hs_in_sync x s, sys_hs_type s, sys_ghost_hs_phase s,\n      ghost_hs_phase (s (mutator x)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending x s \\<longrightarrow> \\<not> sys_ghost_hs_in_sync x s)\n\ngoal (1 subgoal):\n 1. (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n     mut_ghost_hs_phase s)\n    \\<in> hp_step_rel \\<and>\n    (sys_hs_pending m s \\<longrightarrow> \\<not> sys_ghost_hs_in_sync m s)", "by simp"], ["", "lemma handshake_in_syncD:\n  \"\\<lbrakk> All (ghost_hs_in_sync (s sys)); handshake_phase_inv s \\<rbrakk>\n     \\<Longrightarrow> \\<forall>m'. mut_m.mut_ghost_hs_phase m' s = sys_ghost_hs_phase s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>All (ghost_hs_in_sync (s sys)); handshake_phase_inv s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m'.\n                         ghost_hs_phase (s (mutator m')) =\n                         sys_ghost_hs_phase s", "by clarsimp (auto simp: hp_step_rel_def dest!: mut_m.handshake_phase_invD)"], ["", "lemmas fM_rel_invD = iffD1[OF fun_cong[OF fM_rel_inv_def[simplified atomize_eq]]]"], ["", "text\\<open>\n\nRelate @{const \"sys_ghost_hs_phase\"}, @{const \"gc_phase\"},\n@{const \"sys_phase\"} and writes to the phase in the GC's TSO buffer.\n\n\\<close>"], ["", "simps_of_case handshake_phase_rel_simps[simp]: handshake_phase_rel_def (splits: hs_phase.split)"], ["", "lemma phase_rel_invD:\n  assumes \"phase_rel_inv s\"\n  shows \"(\\<forall>m. sys_ghost_hs_in_sync m s, sys_ghost_hs_phase s, gc_phase s, sys_phase s, tso_pending_phase gc s) \\<in> phase_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m. sys_ghost_hs_in_sync m s, sys_ghost_hs_phase s, gc_phase s,\n     sys_phase s, filter is_mw_Phase (sys_mem_store_buffers gc s))\n    \\<in> phase_rel", "using assms"], ["proof (prove)\nusing this:\n  phase_rel_inv s\n\ngoal (1 subgoal):\n 1. (\\<forall>m. sys_ghost_hs_in_sync m s, sys_ghost_hs_phase s, gc_phase s,\n     sys_phase s, filter is_mw_Phase (sys_mem_store_buffers gc s))\n    \\<in> phase_rel", "unfolding phase_rel_inv_def"], ["proof (prove)\nusing this:\n  (All (ghost_hs_in_sync (s sys)), sys_ghost_hs_phase s, gc_phase s,\n   sys_phase s, filter is_mw_Phase (sys_mem_store_buffers gc s))\n  \\<in> phase_rel\n\ngoal (1 subgoal):\n 1. (\\<forall>m. sys_ghost_hs_in_sync m s, sys_ghost_hs_phase s, gc_phase s,\n     sys_phase s, filter is_mw_Phase (sys_mem_store_buffers gc s))\n    \\<in> phase_rel", "by simp"], ["", "lemma mut_m_not_idle_no_fM_write:\n  \"\\<lbrakk> ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s; handshake_phase_inv s; tso_store_inv s; p \\<noteq> sys \\<rbrakk>\n     \\<Longrightarrow> \\<not>sys_mem_store_buffers p s = mw_fM fl # ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s;\n     handshake_phase_inv s; tso_store_inv s; p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> sys_mem_store_buffers p s \\<noteq> mw_fM fl # ws", "apply (drule mut_m.handshake_phase_invD[where m=m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s;\n     tso_store_inv s; p \\<noteq> sys;\n     (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n      ghost_hs_phase (s (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s)\\<rbrakk>\n    \\<Longrightarrow> sys_mem_store_buffers p s \\<noteq> mw_fM fl # ws", "apply (drule fM_rel_invD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle;\n     tso_store_inv s; p \\<noteq> sys;\n     (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n      ghost_hs_phase (s (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s \\<longrightarrow> \\<not> sys_ghost_hs_in_sync m s);\n     (\\<forall>x. sys_ghost_hs_in_sync x s, sys_ghost_hs_phase s, gc_fM s,\n      sys_fM s, filter is_mw_fM (sys_mem_store_buffers gc s),\n      sys_mem_lock s = Some gc)\n     \\<in> fM_rel\\<rbrakk>\n    \\<Longrightarrow> sys_mem_store_buffers p s \\<noteq> mw_fM fl # ws", "apply (clarsimp simp: hp_step_rel_def fM_rel_def filter_empty_conv p_not_sys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle;\n     tso_store_inv s; p = gc \\<or> (\\<exists>m. p = mutator m);\n     sys_fM s = gc_fM s \\<and>\n     (\\<forall>x\\<in>set (sys_mem_store_buffers gc s).\n         \\<forall>fl. x \\<noteq> mw_fM fl) \\<and>\n     (sys_ghost_hs_phase s = hp_Idle \\<longrightarrow>\n      (\\<exists>x. \\<not> sys_ghost_hs_in_sync x s)) \\<or>\n     sys_ghost_hs_phase s = hp_Idle \\<and>\n     (\\<forall>x\\<in>set (sys_mem_store_buffers gc s).\n         \\<forall>fl. x \\<noteq> mw_fM fl) \\<and>\n     All (ghost_hs_in_sync (s sys)) \\<or>\n     sys_ghost_hs_phase s = hp_Idle \\<and>\n     gc_fM s = (\\<not> sys_fM s) \\<and>\n     filter is_mw_fM (sys_mem_store_buffers gc s) =\n     [mw_fM (\\<not> sys_fM s)] \\<and>\n     sys_mem_lock s \\<noteq> Some gc \\<and> All (ghost_hs_in_sync (s sys));\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     sys_ghost_hs_phase s = hp_Idle \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     sys_ghost_hs_phase s = hp_InitMark \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleInit \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     sys_ghost_hs_phase s = hp_Mark \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_InitMark \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetRoots \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_Mark \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetWork \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetRoots \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetWork \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     ghost_hs_phase (s (mutator m)) = sys_ghost_hs_phase s \\<and>\n     (sys_ghost_hs_phase s = hp_Idle \\<or>\n      sys_ghost_hs_phase s = hp_IdleInit \\<or>\n      sys_ghost_hs_phase s = hp_InitMark \\<or>\n      sys_ghost_hs_phase s = hp_Mark);\n     sys_hs_pending m s \\<longrightarrow> \\<not> sys_ghost_hs_in_sync m s;\n     sys_mem_store_buffers p s = mw_fM fl # ws\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis list.set_intros(1) tso_store_invD(4))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in mut_m) mut_ghost_handshake_phase_idle:\n  \"\\<lbrakk> mut_ghost_hs_phase s = hp_Idle; handshake_phase_inv s; phase_rel_inv s \\<rbrakk>\n     \\<Longrightarrow> sys_phase s = ph_Idle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_ghost_hs_phase s = hp_Idle; handshake_phase_inv s;\n     phase_rel_inv s\\<rbrakk>\n    \\<Longrightarrow> sys_phase s = ph_Idle", "apply (drule phase_rel_invD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_ghost_hs_phase s = hp_Idle; handshake_phase_inv s;\n     (\\<forall>m. sys_ghost_hs_in_sync m s, sys_ghost_hs_phase s,\n      gc_phase s, sys_phase s,\n      filter is_mw_Phase (sys_mem_store_buffers gc s))\n     \\<in> phase_rel\\<rbrakk>\n    \\<Longrightarrow> sys_phase s = ph_Idle", "apply (drule handshake_phase_invD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_ghost_hs_phase s = hp_Idle;\n     (\\<forall>m. sys_ghost_hs_in_sync m s, sys_ghost_hs_phase s,\n      gc_phase s, sys_phase s,\n      filter is_mw_Phase (sys_mem_store_buffers gc s))\n     \\<in> phase_rel;\n     (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n      mut_ghost_hs_phase s)\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s)\\<rbrakk>\n    \\<Longrightarrow> sys_phase s = ph_Idle", "apply (auto simp: phase_rel_def hp_step_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mut_m_not_idle_no_fM_writeD:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_fM fl # ws; ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s; handshake_phase_inv s; tso_store_inv s; p \\<noteq> sys \\<rbrakk>\n     \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_fM fl # ws;\n     ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s;\n     handshake_phase_inv s; tso_store_inv s; p \\<noteq> sys\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule mut_m.handshake_phase_invD[where m=m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_fM fl # ws;\n     ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; fM_rel_inv s;\n     tso_store_inv s; p \\<noteq> sys;\n     (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n      ghost_hs_phase (s (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule fM_rel_invD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_fM fl # ws;\n     ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; tso_store_inv s;\n     p \\<noteq> sys;\n     (sys_ghost_hs_in_sync m s, sys_hs_type s, sys_ghost_hs_phase s,\n      ghost_hs_phase (s (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s \\<longrightarrow> \\<not> sys_ghost_hs_in_sync m s);\n     (\\<forall>x. sys_ghost_hs_in_sync x s, sys_ghost_hs_phase s, gc_fM s,\n      sys_fM s, filter is_mw_fM (sys_mem_store_buffers gc s),\n      sys_mem_lock s = Some gc)\n     \\<in> fM_rel\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: hp_step_rel_def fM_rel_def filter_empty_conv p_not_sys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_fM fl # ws;\n     ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle; tso_store_inv s;\n     p = gc \\<or> (\\<exists>m. p = mutator m);\n     sys_fM s = gc_fM s \\<and>\n     (\\<forall>x\\<in>set (sys_mem_store_buffers gc s).\n         \\<forall>fl. x \\<noteq> mw_fM fl) \\<and>\n     (sys_ghost_hs_phase s = hp_Idle \\<longrightarrow>\n      (\\<exists>x. \\<not> sys_ghost_hs_in_sync x s)) \\<or>\n     sys_ghost_hs_phase s = hp_Idle \\<and>\n     (\\<forall>x\\<in>set (sys_mem_store_buffers gc s).\n         \\<forall>fl. x \\<noteq> mw_fM fl) \\<and>\n     All (ghost_hs_in_sync (s sys)) \\<or>\n     sys_ghost_hs_phase s = hp_Idle \\<and>\n     gc_fM s = (\\<not> sys_fM s) \\<and>\n     filter is_mw_fM (sys_mem_store_buffers gc s) =\n     [mw_fM (\\<not> sys_fM s)] \\<and>\n     sys_mem_lock s \\<noteq> Some gc \\<and> All (ghost_hs_in_sync (s sys));\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     sys_ghost_hs_phase s = hp_Idle \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     sys_ghost_hs_phase s = hp_InitMark \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleInit \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     sys_ghost_hs_phase s = hp_Mark \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_InitMark \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetRoots \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_Mark \\<or>\n     \\<not> sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetWork \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetRoots \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_GetWork \\<and>\n     sys_ghost_hs_phase s = hp_IdleMarkSweep \\<and>\n     ghost_hs_phase (s (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s \\<and>\n     sys_hs_type s = ht_NOOP \\<and>\n     ghost_hs_phase (s (mutator m)) = sys_ghost_hs_phase s \\<and>\n     (sys_ghost_hs_phase s = hp_Idle \\<or>\n      sys_ghost_hs_phase s = hp_IdleInit \\<or>\n      sys_ghost_hs_phase s = hp_InitMark \\<or>\n      sys_ghost_hs_phase s = hp_Mark);\n     sys_hs_pending m s \\<longrightarrow>\n     \\<not> sys_ghost_hs_in_sync m s\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis list.set_intros(1) tso_store_invD(4))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>points to, reaches, reachable mut\\<close>"], ["", "lemma (in mut_m) reachable_eq_imp:\n  \"eq_imp (\\<lambda>r'. mut_roots \\<^bold>\\<otimes> mut_ghost_honorary_root \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r')))\n              \\<^bold>\\<otimes> tso_pending_mutate (mutator m))\n          (reachable r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (mut_roots s, mut_ghost_honorary_root s,\n          \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')),\n          filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n           (sys_mem_store_buffers (mutator m) s)))\n     (reachable r)", "unfolding eq_imp_def reachable_def tso_store_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (mut_roots s, mut_ghost_honorary_root s,\n            \\<Union> (ran ` obj_fields ` set_option (sys_heap s x)),\n            filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n             (sys_mem_store_buffers (mutator m) s)) =\n           (mut_roots s', mut_ghost_honorary_root s',\n            \\<Union> (ran ` obj_fields ` set_option (sys_heap s' x)),\n            filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n             (sys_mem_store_buffers (mutator m) s'))) \\<longrightarrow>\n       (\\<exists>x.\n           x \\<in> mut_roots s \\<union> mut_ghost_honorary_root s \\<union>\n                   \\<Union>\n                    (store_refs `\n                     set (sys_mem_store_buffers (mutator m) s)) \\<and>\n           (x reaches r) s) =\n       (\\<exists>x.\n           x \\<in> mut_roots s' \\<union> mut_ghost_honorary_root s' \\<union>\n                   \\<Union>\n                    (store_refs `\n                     set (sys_mem_store_buffers (mutator m) s')) \\<and>\n           (x reaches r) s')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s) =\n                         (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s').\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s')", "apply (rename_tac s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s) =\n                         (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s').\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s')", "apply (subgoal_tac \"\\<forall>r'. (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s). r' \\<in> store_refs w) \\<longleftrightarrow> (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s'). r' \\<in> store_refs w)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s');\n        \\<forall>r'.\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n               r' \\<in> store_refs w) =\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n               r' \\<in> store_refs w)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s) =\n                         (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s').\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s')\n 2. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s).\n                                r' \\<in> store_refs w) =\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s').\n                                r' \\<in> store_refs w)", "apply (subgoal_tac \"\\<forall>x. (x reaches r) s \\<longleftrightarrow> (x reaches r) s'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s');\n        \\<forall>r'.\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n               r' \\<in> store_refs w) =\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n               r' \\<in> store_refs w);\n        \\<forall>x. (x reaches r) s = (x reaches r) s'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s) =\n                         (\\<exists>x.\n                             (x \\<in> mut_roots s' \\<or>\n                              x \\<in> mut_ghost_honorary_root s' \\<or>\n                              (\\<exists>xa\n  \\<in>set (sys_mem_store_buffers (mutator m) s').\n                                  x \\<in> (case xa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {}))) \\<and>\n                             (x reaches r) s')\n 2. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s');\n        \\<forall>r'.\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n               r' \\<in> store_refs w) =\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n               r' \\<in> store_refs w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. (x reaches r) s = (x reaches r) s'\n 3. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s).\n                                r' \\<in> store_refs w) =\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s').\n                                r' \\<in> store_refs w)", "apply (clarsimp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s');\n        \\<forall>r'.\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n               r' \\<in> store_refs w) =\n           (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n               r' \\<in> store_refs w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. (x reaches r) s = (x reaches r) s'\n 2. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s).\n                                r' \\<in> store_refs w) =\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s').\n                                r' \\<in> store_refs w)", "apply (auto simp: reaches_fields; fail)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s).\n                                r' \\<in> store_refs w) =\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s').\n                                r' \\<in> store_refs w)", "apply (drule arg_cong[where f=set])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        set (filter\n              (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n              (sys_mem_store_buffers (mutator m) s)) =\n        set (filter\n              (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n              (sys_mem_store_buffers (mutator m) s'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s).\n                                r' \\<in> store_refs w) =\n                            (\\<exists>w\n\\<in>set (sys_mem_store_buffers (mutator m) s').\n                                r' \\<in> store_refs w)", "apply (clarsimp simp: set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>w\\<in>set\n    (sys_mem_store_buffers (mutator m) s).\n                             r' \\<in> (case w of\n mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n | mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})) =\n                         (\\<exists>w\\<in>set\n    (sys_mem_store_buffers (mutator m) s').\n                             r' \\<in> (case w of\n mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n | mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {}))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s').\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})\n 2. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s').\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})\n 2. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (rename_tac s s' r' w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s').\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})\n 2. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (drule_tac x=w in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s').\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})\n 2. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (rule_tac x=w in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> r' \\<in> (case w of\n                                   mw_Mutate r f r' \\<Rightarrow>\n                                     insert r (set_option r')\n                                   | mw_Mutate_Payload r f pl \\<Rightarrow>\n {r}\n                                   | _ \\<Rightarrow> {})\n 2. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> w \\<in> set (sys_mem_store_buffers (mutator m) s')\n 3. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (clarsimp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> w \\<in> set (sys_mem_store_buffers (mutator m) s')\n 2. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (clarsimp split: mem_store_action.splits; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s').\n           r' \\<in> (case w of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s');\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (rename_tac s s' r' w)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        \\<forall>x.\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x)) =\n           (x \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n            (is_mw_Mutate x \\<or> is_mw_Mutate_Payload x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s');\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (drule_tac x=w in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s');\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w\\<in>set\n   (sys_mem_store_buffers (mutator m) s).\n                            r' \\<in> (case w of\nmw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n| mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {})", "apply (rule_tac x=w in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s');\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> r' \\<in> (case w of\n                                   mw_Mutate r f r' \\<Rightarrow>\n                                     insert r (set_option r')\n                                   | mw_Mutate_Payload r f pl \\<Rightarrow>\n {r}\n                                   | _ \\<Rightarrow> {})\n 2. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s');\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> w \\<in> set (sys_mem_store_buffers (mutator m) s)", "apply (clarsimp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' r' w.\n       \\<lbrakk>\\<forall>x. (x \\<in> mut_roots s) = (x \\<in> mut_roots s');\n        \\<forall>x.\n           (x \\<in> mut_ghost_honorary_root s) =\n           (x \\<in> mut_ghost_honorary_root s');\n        \\<forall>x xa.\n           (\\<exists>x\\<in>set_option (sys_heap s x).\n               xa \\<in> ran (obj_fields x)) =\n           (\\<exists>x\\<in>set_option (sys_heap s' x).\n               xa \\<in> ran (obj_fields x));\n        w \\<in> set (sys_mem_store_buffers (mutator m) s');\n        r' \\<in> (case w of\n                  mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                  | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                  | _ \\<Rightarrow> {});\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s) \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w)) =\n        (w \\<in> set (sys_mem_store_buffers (mutator m) s') \\<and>\n         (is_mw_Mutate w \\<or> is_mw_Mutate_Payload w))\\<rbrakk>\n       \\<Longrightarrow> w \\<in> set (sys_mem_store_buffers (mutator m) s)", "apply (clarsimp split: mem_store_action.splits; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas reachable_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.reachable_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma reachableI[intro]:\n  \"x \\<in> mut_m.mut_roots m s \\<Longrightarrow> mut_m.reachable m x s\"\n  \"x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow> mut_m.reachable m x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> roots (s (mutator m)) \\<Longrightarrow>\n     mut_m.reachable m x s) &&&\n    (x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow>\n     mut_m.reachable m x s)", "by (auto simp: mut_m.reachable_def reaches_def)"], ["", "lemma reachable_points_to[elim]:\n  \"\\<lbrakk> (x points_to y) s; mut_m.reachable m x s \\<rbrakk> \\<Longrightarrow> mut_m.reachable m y s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x points_to y) s; mut_m.reachable m x s\\<rbrakk>\n    \\<Longrightarrow> mut_m.reachable m y s", "by (auto simp: mut_m.reachable_def reaches_def elim: rtranclp.intros(2))"], ["", "lemma (in mut_m) mut_reachableE[consumes 1, case_names mut_root tso_store_refs]:\n  \"\\<lbrakk> reachable y s;\n     \\<And>x. \\<lbrakk> (x reaches y) s; x \\<in> mut_roots s \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>x. \\<lbrakk> (x reaches y) s; x \\<in> mut_ghost_honorary_root s \\<rbrakk> \\<Longrightarrow> Q;\n     \\<And>x. \\<lbrakk> (x reaches y) s; x \\<in> tso_store_refs s \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable y s;\n     \\<And>x.\n        \\<lbrakk>(x reaches y) s; x \\<in> mut_roots s\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>x.\n        \\<lbrakk>(x reaches y) s; x \\<in> mut_ghost_honorary_root s\\<rbrakk>\n        \\<Longrightarrow> Q;\n     \\<And>x.\n        \\<lbrakk>(x reaches y) s; x \\<in> tso_store_refs s\\<rbrakk>\n        \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (auto simp: reachable_def)"], ["", "lemma reachable_induct[consumes 1, case_names root ghost_honorary_root tso_root reaches]:\n  assumes r: \"mut_m.reachable m y s\"\n  assumes root: \"\\<And>x. \\<lbrakk> x \\<in> mut_m.mut_roots m s \\<rbrakk> \\<Longrightarrow> P x\"\n  assumes ghost_honorary_root: \"\\<And>x. \\<lbrakk> x \\<in> mut_m.mut_ghost_honorary_root m s \\<rbrakk> \\<Longrightarrow> P x\"\n  assumes tso_root: \"\\<And>x. x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow> P x\"\n  assumes reaches: \"\\<And>x y. \\<lbrakk> mut_m.reachable m x s; (x points_to y) s; P x \\<rbrakk> \\<Longrightarrow> P y\"\n  shows \"P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P y", "using r"], ["proof (prove)\nusing this:\n  mut_m.reachable m y s\n\ngoal (1 subgoal):\n 1. P y", "unfolding mut_m.reachable_def"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> roots (s (mutator m)) \\<union>\n             ghost_honorary_root (s (mutator m)) \\<union>\n             mut_m.tso_store_refs m s \\<and>\n     (x reaches y) s\n\ngoal (1 subgoal):\n 1. P y", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> roots (s (mutator m)) \\<union>\n                        ghost_honorary_root (s (mutator m)) \\<union>\n                        mut_m.tso_store_refs m s;\n        (x reaches y) s\\<rbrakk>\n       \\<Longrightarrow> P y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> roots (s (mutator m)) \\<union>\n                        ghost_honorary_root (s (mutator m)) \\<union>\n                        mut_m.tso_store_refs m s;\n        (x reaches y) s\\<rbrakk>\n       \\<Longrightarrow> P y", "assume \"(x reaches y) s\" and \"x \\<in> mut_m.mut_roots m s \\<union> mut_m.mut_ghost_honorary_root m s \\<union> mut_m.tso_store_refs m s\""], ["proof (state)\nthis:\n  (x reaches y) s\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> roots (s (mutator m)) \\<union>\n                        ghost_honorary_root (s (mutator m)) \\<union>\n                        mut_m.tso_store_refs m s;\n        (x reaches y) s\\<rbrakk>\n       \\<Longrightarrow> P y", "then"], ["proof (chain)\npicking this:\n  (x reaches y) s\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s", "show \"P y\""], ["proof (prove)\nusing this:\n  (x reaches y) s\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. P y", "unfolding reaches_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. P y", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> roots (s (mutator m)) \\<union>\n            ghost_honorary_root (s (mutator m)) \\<union>\n            mut_m.tso_store_refs m s \\<Longrightarrow>\n    P x\n 2. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        (y points_to z) s;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<Longrightarrow>\n        P y;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> P z", "case base"], ["proof (state)\nthis:\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (2 subgoals):\n 1. x \\<in> roots (s (mutator m)) \\<union>\n            ghost_honorary_root (s (mutator m)) \\<union>\n            mut_m.tso_store_refs m s \\<Longrightarrow>\n    P x\n 2. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        (y points_to z) s;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<Longrightarrow>\n        P y;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> P z", "with root ghost_honorary_root tso_root"], ["proof (chain)\npicking this:\n  ?x \\<in> roots (s (mutator m)) \\<Longrightarrow> P ?x\n  ?x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow> P ?x\n  ?x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow> P ?x\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> roots (s (mutator m)) \\<Longrightarrow> P ?x\n  ?x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow> P ?x\n  ?x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow> P ?x\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. P x", "by blast"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        (y points_to z) s;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<Longrightarrow>\n        P y;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> P z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        (y points_to z) s;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<Longrightarrow>\n        P y;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> P z", "case (step y z)"], ["proof (state)\nthis:\n  (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\n  (y points_to z) s\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s \\<Longrightarrow>\n  P y\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        (y points_to z) s;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<Longrightarrow>\n        P y;\n        x \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> P z", "with reaches"], ["proof (chain)\npicking this:\n  \\<lbrakk>mut_m.reachable m ?x s; (?x points_to ?y) s; P ?x\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\n  (y points_to z) s\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s \\<Longrightarrow>\n  P y\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>mut_m.reachable m ?x s; (?x points_to ?y) s; P ?x\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\n  (y points_to z) s\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s \\<Longrightarrow>\n  P y\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. P z", "unfolding mut_m.reachable_def reaches_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>x.\n              x \\<in> roots (s (mutator m)) \\<union>\n                      ghost_honorary_root (s (mutator m)) \\<union>\n                      mut_m.tso_store_refs m s \\<and>\n              (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x ?x;\n   (?x points_to ?y) s; P ?x\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\n  (y points_to z) s\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s \\<Longrightarrow>\n  P y\n  x \\<in> roots (s (mutator m)) \\<union>\n          ghost_honorary_root (s (mutator m)) \\<union>\n          mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. P z", "by meson"], ["proof (state)\nthis:\n  P z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mutator_reachable_tso:\n  \"sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n    \\<Longrightarrow> mut_m.reachable m r s \\<and> (\\<forall>r'. opt_r' = Some r' \\<longrightarrow> mut_m.reachable m r' s)\"\n  \"sys_mem_store_buffers (mutator m) s = mw_Mutate_Payload r f pl # ws\n    \\<Longrightarrow> mut_m.reachable m r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sys_mem_store_buffers (mutator m) s =\n     mw_Mutate r f opt_r' # ws \\<Longrightarrow>\n     mut_m.reachable m r s \\<and>\n     (\\<forall>r'.\n         opt_r' = Some r' \\<longrightarrow> mut_m.reachable m r' s)) &&&\n    (sys_mem_store_buffers (mutator m) s =\n     mw_Mutate_Payload r f pl # ws \\<Longrightarrow>\n     mut_m.reachable m r s)", "by (auto simp: mut_m.tso_store_refs_def)"], ["", "subsection\\<open> Colours \\<close>"], ["", "lemma greyI[intro]:\n  \"r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> grey r s\"\n  \"r \\<in> W (s p) \\<Longrightarrow> grey r s\"\n  \"r \\<in> WL p s \\<Longrightarrow> grey r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> grey r s) &&&\n    (r \\<in> W (s p) \\<Longrightarrow> grey r s) &&&\n    (r \\<in> WL p s \\<Longrightarrow> grey r s)", "unfolding grey_def WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow>\n     \\<exists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x)) &&&\n    (r \\<in> W (s p) \\<Longrightarrow>\n     \\<exists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x)) &&&\n    (r \\<in> W (s p) \\<union> ghost_honorary_grey (s p) \\<Longrightarrow>\n     \\<exists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x))", "by (case_tac [!] p) auto"], ["", "lemma blackD[dest]:\n  \"black r s \\<Longrightarrow> marked r s\"\n  \"black r s \\<Longrightarrow> r \\<notin> WL p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (black r s \\<Longrightarrow> marked r s) &&&\n    (black r s \\<Longrightarrow> r \\<notin> WL p s)", "unfolding black_def grey_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (marked r s \\<and> (\\<nexists>x. r \\<in> WL x s) \\<Longrightarrow>\n     marked r s) &&&\n    (marked r s \\<and> (\\<nexists>x. r \\<in> WL x s) \\<Longrightarrow>\n     r \\<notin> WL p s)", "by simp_all"], ["", "lemma whiteI[intro]: (* FIXME simp normal form of def *)\n  \"obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) r s \\<Longrightarrow> white r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) r\n     s \\<Longrightarrow>\n    white r s", "unfolding white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) r\n     s \\<Longrightarrow>\n    obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r s", "by simp"], ["", "lemma marked_not_white[dest]:\n  \"white r s \\<Longrightarrow> \\<not>marked r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. white r s \\<Longrightarrow> \\<not> marked r s", "unfolding white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r\n     s \\<Longrightarrow>\n    \\<not> marked r s", "by (simp_all split: obj_at_splits)"], ["", "lemma white_valid_ref[elim!]:\n  \"white r s \\<Longrightarrow> valid_ref r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. white r s \\<Longrightarrow> obj_at (\\<lambda>s. True) r s", "unfolding white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r\n     s \\<Longrightarrow>\n    obj_at (\\<lambda>s. True) r s", "by (simp_all split: obj_at_splits)"], ["", "lemma not_white_marked[elim!]:\n  \"\\<lbrakk>\\<not> white r s; valid_ref r s\\<rbrakk> \\<Longrightarrow> marked r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> white r s; obj_at (\\<lambda>s. True) r s\\<rbrakk>\n    \\<Longrightarrow> marked r s", "unfolding white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r\n                     s;\n     obj_at (\\<lambda>s. True) r s\\<rbrakk>\n    \\<Longrightarrow> marked r s", "by (simp split: obj_at_splits)"], ["", "lemma black_eq_imp:\n  \"eq_imp (\\<lambda>_::unit. (\\<lambda>s. r \\<in> (\\<Union>p. WL p s)) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r)))\n          (black r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>_ s.\n         (r \\<in> (\\<Union>p. WL p s), sys_fM s,\n          map_option obj_mark (sys_heap s r)))\n     (black r)", "unfolding eq_imp_def black_def grey_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (r \\<in> (\\<Union>p. WL p s), sys_fM s,\n            map_option obj_mark (sys_heap s r)) =\n           (r \\<in> (\\<Union>p. WL p s'), sys_fM s',\n            map_option obj_mark (sys_heap s' r))) \\<longrightarrow>\n       (marked r s \\<and> (\\<nexists>x. r \\<in> WL x s)) =\n       (marked r s' \\<and> (\\<nexists>x. r \\<in> WL x s'))", "by (auto split: obj_at_splits)"], ["", "lemma grey_eq_imp:\n  \"eq_imp (\\<lambda>_::unit. (\\<lambda>s. r \\<in> (\\<Union>p. WL p s)))\n          (grey r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp (\\<lambda>_ s. r \\<in> (\\<Union>p. WL p s)) (grey r)", "unfolding eq_imp_def grey_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (r \\<in> (\\<Union>p. WL p s)) =\n           (r \\<in> (\\<Union>p. WL p s'))) \\<longrightarrow>\n       (\\<exists>x. r \\<in> WL x s) = (\\<exists>x. r \\<in> WL x s')", "by auto"], ["", "lemma white_eq_imp:\n  \"eq_imp (\\<lambda>_::unit. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r)))\n          (white r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp (\\<lambda>_ s. (sys_fM s, map_option obj_mark (sys_heap s r)))\n     (white r)", "unfolding eq_imp_def white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (sys_fM s, map_option obj_mark (sys_heap s r)) =\n           (sys_fM s',\n            map_option obj_mark (sys_heap s' r))) \\<longrightarrow>\n       obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r s =\n       obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s') r s'", "by (auto split: obj_at_splits)"], ["", "lemmas black_fun_upd[simp] = eq_imp_fun_upd[OF black_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemmas grey_fun_upd[simp] = eq_imp_fun_upd[OF grey_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemmas white_fun_upd[simp] = eq_imp_fun_upd[OF white_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "text\\<open>coloured heaps\\<close>"], ["", "lemma black_heap_eq_imp:\n  \"eq_imp (\\<lambda>r'. (\\<lambda>s. \\<Union>p. WL p s) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          black_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (\\<Union>p. WL p s, sys_fM s, map_option obj_mark (sys_heap s r')))\n     black_heap", "apply (clarsimp simp: eq_imp_def black_heap_def black_def grey_def all_conj_distrib fun_eq_iff split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s)) =\n                         (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x\n                              s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s'))", "apply (rename_tac s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s)) =\n                         (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x\n                              s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s'))", "apply (subgoal_tac \"\\<forall>x. marked x s \\<longleftrightarrow> marked x s'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s)) =\n                         (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x\n                              s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (subgoal_tac \"\\<forall>x. valid_ref x s \\<longleftrightarrow> valid_ref x s'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>s. True) x s =\n           obj_at (\\<lambda>s. True) x s'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s)) =\n                         (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x\n                              s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>s. True) x s =\n                            obj_at (\\<lambda>s. True) x s'\n 3. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (subgoal_tac \"\\<forall>x. (\\<forall>p. x \\<notin> WL p s) \\<longleftrightarrow> (\\<forall>p. x \\<notin> WL p s')\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>s. True) x s = obj_at (\\<lambda>s. True) x s';\n        \\<forall>x.\n           (\\<forall>p. x \\<notin> WL p s) =\n           (\\<forall>p. x \\<notin> WL p s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s)) =\n                         (\\<forall>x.\n                             obj_at (\\<lambda>s. True) x\n                              s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s'))\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>s. True) x s =\n           obj_at (\\<lambda>s. True) x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<forall>p. x \\<notin> WL p s) =\n                            (\\<forall>p. x \\<notin> WL p s')\n 3. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>s. True) x s =\n                            obj_at (\\<lambda>s. True) x s'\n 4. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>s. True) x s =\n           obj_at (\\<lambda>s. True) x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<forall>p. x \\<notin> WL p s) =\n                            (\\<forall>p. x \\<notin> WL p s')\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>s. True) x s =\n                            obj_at (\\<lambda>s. True) x s'\n 3. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (auto simp: set_eq_iff)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>s. True) x s =\n                            obj_at (\\<lambda>s. True) x s'\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s'\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) x s =\n                         obj_at (\\<lambda>s. True) x s'\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s'\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) x s =\n                         obj_at (\\<lambda>s. True) x s'\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (rule eq_impD[OF obj_at_eq_imp])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            map_option (\\<lambda>s. True) (sys_heap s x) =\n                            map_option (\\<lambda>s. True) (sys_heap s' x)\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s';\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            map_option (\\<lambda>s. True) (sys_heap s x) =\n                            map_option (\\<lambda>s. True) (sys_heap s' x)\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (drule_tac f=\"map_option \\<langle>True\\<rangle>\" in arg_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s';\n        map_option (\\<lambda>s. True) (map_option obj_mark (sys_heap s x)) =\n        map_option (\\<lambda>s. True)\n         (map_option obj_mark (sys_heap s' x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            map_option (\\<lambda>s. True) (sys_heap s x) =\n                            map_option (\\<lambda>s. True) (sys_heap s' x)\n 2. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x\n                          s =\n                         marked x s'", "apply (rule eq_impD[OF obj_at_eq_imp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            map_option\n                             (\\<lambda>obj. obj_mark obj = sys_fM s')\n                             (sys_heap s x) =\n                            map_option\n                             (\\<lambda>obj. obj_mark obj = sys_fM s')\n                             (sys_heap s' x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s x) =\n                         map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s' x)", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s x) =\n                         map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s' x)", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s x) =\n                         map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s' x)", "apply (drule_tac f=\"map_option (\\<lambda>fl. fl = sys_fM s)\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>(\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        sys_fM s = sys_fM s';\n        map_option (\\<lambda>fl. fl = sys_fM s)\n         (map_option obj_mark (sys_heap s x)) =\n        map_option (\\<lambda>fl. fl = sys_fM s)\n         (map_option obj_mark (sys_heap s' x))\\<rbrakk>\n       \\<Longrightarrow> map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s x) =\n                         map_option (\\<lambda>obj. obj_mark obj = sys_fM s')\n                          (sys_heap s' x)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma white_heap_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          white_heap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp (\\<lambda>r' s. (sys_fM s, map_option obj_mark (sys_heap s r')))\n     white_heap", "apply (clarsimp simp: all_conj_distrib eq_imp_def white_def white_heap_def obj_at_def fun_eq_iff\n               split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x x2.\n                             sys_heap s x = Some x2 \\<longrightarrow>\n                             obj_mark x2 = (\\<not> sys_fM s')) =\n                         (\\<forall>x x2.\n                             sys_heap s' x = Some x2 \\<longrightarrow>\n                             obj_mark x2 = (\\<not> sys_fM s'))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x x2.\n           sys_heap s x = Some x2 \\<longrightarrow>\n           obj_mark x2 = (\\<not> sys_fM s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x2.\n                            sys_heap s' x = Some x2 \\<longrightarrow>\n                            obj_mark x2 = (\\<not> sys_fM s')\n 2. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x x2.\n           sys_heap s' x = Some x2 \\<longrightarrow>\n           obj_mark x2 = (\\<not> sys_fM s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x2.\n                            sys_heap s x = Some x2 \\<longrightarrow>\n                            obj_mark x2 = (\\<not> sys_fM s')", "apply (metis (hide_lams, no_types) map_option_eq_Some)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_black_refs_eq_imp:\n  \"eq_imp (\\<lambda>r'. (\\<lambda>s. (\\<Union>p. WL p s)) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          no_black_refs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (\\<Union>p. WL p s, sys_fM s, map_option obj_mark (sys_heap s r')))\n     no_black_refs", "apply (clarsimp simp add: eq_imp_def no_black_refs_def black_def grey_def all_conj_distrib fun_eq_iff set_eq_iff split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa. x \\<in> WL xa s) =\n                   (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<longrightarrow>\n                             (\\<exists>xa. x \\<in> WL xa s')) =\n                         (\\<forall>x.\n                             marked x s' \\<longrightarrow>\n                             (\\<exists>xa. x \\<in> WL xa s'))", "apply (rename_tac s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa. x \\<in> WL xa s) =\n                   (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<longrightarrow>\n                             (\\<exists>xa. x \\<in> WL xa s')) =\n                         (\\<forall>x.\n                             marked x s' \\<longrightarrow>\n                             (\\<exists>xa. x \\<in> WL xa s'))", "apply (subgoal_tac \"\\<forall>x. marked x s \\<longleftrightarrow> marked x s'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa. x \\<in> WL xa s) =\n                   (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<longrightarrow>\n                             (\\<exists>xa. x \\<in> WL xa s')) =\n                         (\\<forall>x.\n                             marked x s' \\<longrightarrow>\n                             (\\<exists>xa. x \\<in> WL xa s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa. x \\<in> WL xa s) =\n                   (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa. x \\<in> WL xa s) =\n                   (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (clarsimp split: obj_at_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa. x \\<in> WL xa s) =\n                   (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa. x \\<in> WL xa s) =\n                   (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))", "apply (drule_tac x=x in spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))", "apply (auto split: obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas black_heap_fun_upd[simp] = eq_imp_fun_upd[OF black_heap_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemmas white_heap_fun_upd[simp] = eq_imp_fun_upd[OF white_heap_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemmas no_black_refs_fun_upd[simp] = eq_imp_fun_upd[OF no_black_refs_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma white_heap_imp_no_black_refs[elim!]:\n  \"white_heap s \\<Longrightarrow> no_black_refs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. white_heap s \\<Longrightarrow> no_black_refs s", "apply (clarsimp simp: white_def white_heap_def no_black_refs_def black_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                   obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) x\n                    s;\n        marked x s\\<rbrakk>\n       \\<Longrightarrow> grey x s", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                   obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) x\n                    s;\n        marked x s\\<rbrakk>\n       \\<Longrightarrow> grey x s", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>marked x s;\n        obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) x s\\<rbrakk>\n       \\<Longrightarrow> grey x s", "apply (clarsimp split: obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma black_heap_no_greys[elim]:\n  \"\\<lbrakk> no_grey_refs s; \\<forall>r. marked r s \\<or> \\<not>valid_ref r s \\<rbrakk> \\<Longrightarrow> black_heap s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_grey_refs s;\n     \\<forall>r.\n        marked r s \\<or> \\<not> obj_at (\\<lambda>s. True) r s\\<rbrakk>\n    \\<Longrightarrow> black_heap s", "unfolding black_def black_heap_def no_grey_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. \\<not> grey x s;\n     \\<forall>r.\n        marked r s \\<or> \\<not> obj_at (\\<lambda>s. True) r s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                         marked x s \\<and> \\<not> grey x s", "by fastforce"], ["", "lemma heap_colours_colours:\n  \"black_heap s \\<Longrightarrow> \\<not>white r s\"\n  \"white_heap s \\<Longrightarrow> \\<not>black r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (black_heap s \\<Longrightarrow> \\<not> white r s) &&&\n    (white_heap s \\<Longrightarrow> \\<not> black r s)", "by (auto simp: black_heap_def white_def white_heap_def\n        dest!: spec[where x=r]\n        split: obj_at_splits)"], ["", "text\\<open>The strong-tricolour invariant \\<close>"], ["", "lemma strong_tricolour_invD:\n  \"\\<lbrakk> black x s; (x points_to y) s; valid_ref y s; strong_tricolour_inv s \\<rbrakk>\n     \\<Longrightarrow> marked y s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>black x s; (x points_to y) s; obj_at (\\<lambda>s. True) y s;\n     strong_tricolour_inv s\\<rbrakk>\n    \\<Longrightarrow> marked y s", "unfolding strong_tricolour_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>black x s; (x points_to y) s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x xa.\n        black x s \\<longrightarrow>\n        \\<not> ((x points_to xa) s \\<and> white xa s)\\<rbrakk>\n    \\<Longrightarrow> marked y s", "by fastforce"], ["", "lemma no_black_refsD:\n  \"no_black_refs s \\<Longrightarrow> \\<not>black r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_black_refs s \\<Longrightarrow> \\<not> black r s", "unfolding no_black_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<not> black x s \\<Longrightarrow> \\<not> black r s", "by simp"], ["", "lemma has_white_path_to_induct[consumes 1, case_names refl step, induct set: has_white_path_to]:\n  assumes \"(x has_white_path_to y) s\"\n  assumes \"\\<And>x. P x x\"\n  assumes \"\\<And>x y z. \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s; white z s\\<rbrakk> \\<Longrightarrow> P x z\"\n  shows \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y", "using assms"], ["proof (prove)\nusing this:\n  (x has_white_path_to y) s\n  P ?x ?x\n  \\<lbrakk>(?x has_white_path_to ?y) s; P ?x ?y; (?y points_to ?z) s;\n   white ?z s\\<rbrakk>\n  \\<Longrightarrow> P ?x ?z\n\ngoal (1 subgoal):\n 1. P x y", "unfolding has_white_path_to_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x y\n  P ?x ?x\n  \\<lbrakk>(\\<lambda>x y.\n               (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>*\n            ?x ?y;\n   P ?x ?y; (?y points_to ?z) s; white ?z s\\<rbrakk>\n  \\<Longrightarrow> P ?x ?z\n\ngoal (1 subgoal):\n 1. P x y", "by (rule rtranclp.induct; blast)"], ["", "lemma has_white_path_toD[dest]:\n  \"(x has_white_path_to y) s \\<Longrightarrow> white y s \\<or> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x has_white_path_to y) s \\<Longrightarrow> white y s \\<or> x = y", "unfolding has_white_path_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n     y \\<Longrightarrow>\n    white y s \\<or> x = y", "by (fastforce elim: rtranclp.cases)"], ["", "lemma has_white_path_to_refl[iff]:\n  \"(x has_white_path_to x) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x has_white_path_to x) s", "unfolding has_white_path_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x x", "by simp"], ["", "lemma has_white_path_to_step[intro]:\n  \"\\<lbrakk>(x has_white_path_to y) s; (y points_to z) s; white z s\\<rbrakk> \\<Longrightarrow> (x has_white_path_to z) s\"\n  \"\\<lbrakk>(y has_white_path_to z) s; (x points_to y) s; white y s\\<rbrakk> \\<Longrightarrow> (x has_white_path_to z) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(x has_white_path_to y) s; (y points_to z) s;\n      white z s\\<rbrakk>\n     \\<Longrightarrow> (x has_white_path_to z) s) &&&\n    (\\<lbrakk>(y has_white_path_to z) s; (x points_to y) s;\n      white y s\\<rbrakk>\n     \\<Longrightarrow> (x has_white_path_to z) s)", "unfolding has_white_path_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(\\<lambda>x y.\n                  (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>*\n               x y;\n      (y points_to z) s; white z s\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>x y.\n                           (x points_to y) s \\<and>\n                           white y s)\\<^sup>*\\<^sup>*\n                        x z) &&&\n    (\\<lbrakk>(\\<lambda>x y.\n                  (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>*\n               y z;\n      (x points_to y) s; white y s\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>x y.\n                           (x points_to y) s \\<and>\n                           white y s)\\<^sup>*\\<^sup>*\n                        x z)", "apply (simp add: rtranclp.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x y.\n                 (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>*\n              y z;\n     (x points_to y) s; white y s\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x y.\n                          (x points_to y) s \\<and>\n                          white y s)\\<^sup>*\\<^sup>*\n                       x z", "apply (simp add: converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma has_white_path_toE[elim!]:\n  \"\\<lbrakk> (x points_to y) s; white y s \\<rbrakk> \\<Longrightarrow> (x has_white_path_to y) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x points_to y) s; white y s\\<rbrakk>\n    \\<Longrightarrow> (x has_white_path_to y) s", "unfolding has_white_path_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x points_to y) s; white y s\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x y.\n                          (x points_to y) s \\<and>\n                          white y s)\\<^sup>*\\<^sup>*\n                       x y", "by (auto elim: rtranclp.intros(2))"], ["", "lemma has_white_path_to_reaches[elim]:\n  \"(x has_white_path_to y) s \\<Longrightarrow> (x reaches y) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x has_white_path_to y) s \\<Longrightarrow> (x reaches y) s", "unfolding has_white_path_to_def reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n     y \\<Longrightarrow>\n    (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y", "by (induct rule: rtranclp.induct) (auto intro: rtranclp.intros(2))"], ["", "lemma has_white_path_to_blacken[simp]:\n  \"(x has_white_path_to w) (s(gc := s gc\\<lparr> W := gc_W s - rs \\<rparr>)) \\<longleftrightarrow> (x has_white_path_to w) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x has_white_path_to w)\n     (s(gc := s gc\\<lparr>W := gc_W s - rs\\<rparr>)) =\n    (x has_white_path_to w) s", "unfolding has_white_path_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y.\n        (x points_to y)\n         (s(gc := s gc\\<lparr>W := gc_W s - rs\\<rparr>)) \\<and>\n        white y\n         (s(gc := s gc\\<lparr>W := gc_W s - rs\\<rparr>)))\\<^sup>*\\<^sup>*\n     x w =\n    (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x w", "by (simp add: fun_upd_apply)"], ["", "lemma has_white_path_to_eq_imp': \\<comment> \\<open>Complicated condition takes care of \\<open>alloc\\<close>: collapses no object and object with no fields\\<close>\n  assumes \"(x has_white_path_to y) s'\"\n  assumes \"\\<forall>r'. \\<Union>(ran ` obj_fields ` set_option (sys_heap s' r')) = \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))\"\n  assumes \"\\<forall>r'. map_option obj_mark (sys_heap s' r') = map_option obj_mark (sys_heap s r')\"\n  assumes \"sys_fM s' = sys_fM s\"\n  shows \"(x has_white_path_to y) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x has_white_path_to y) s", "using assms"], ["proof (prove)\nusing this:\n  (x has_white_path_to y) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  \\<forall>r'.\n     map_option obj_mark (sys_heap s' r') =\n     map_option obj_mark (sys_heap s r')\n  sys_fM s' = sys_fM s\n\ngoal (1 subgoal):\n 1. (x has_white_path_to y) s", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>r'.\n                   \\<Union>\n                    (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                   \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s';\n        \\<lbrakk>\\<forall>r'.\n                    \\<Union>\n                     (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                    \\<Union>\n                     (ran ` obj_fields ` set_option (sys_heap s r'));\n         \\<forall>r'.\n            map_option obj_mark (sys_heap s' r') =\n            map_option obj_mark (sys_heap s r');\n         sys_fM s' = sys_fM s\\<rbrakk>\n        \\<Longrightarrow> (x has_white_path_to y) s;\n        (y points_to z) s'; white z s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to z) s", "case (step x y z)"], ["proof (state)\nthis:\n  (x has_white_path_to y) s'\n  \\<lbrakk>\\<forall>r'.\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n   \\<forall>r'.\n      map_option obj_mark (sys_heap s' r') =\n      map_option obj_mark (sys_heap s r');\n   sys_fM s' = sys_fM s\\<rbrakk>\n  \\<Longrightarrow> (x has_white_path_to y) s\n  (y points_to z) s'\n  white z s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  \\<forall>r'.\n     map_option obj_mark (sys_heap s' r') =\n     map_option obj_mark (sys_heap s r')\n  sys_fM s' = sys_fM s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>r'.\n                   \\<Union>\n                    (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                   \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s';\n        \\<lbrakk>\\<forall>r'.\n                    \\<Union>\n                     (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                    \\<Union>\n                     (ran ` obj_fields ` set_option (sys_heap s r'));\n         \\<forall>r'.\n            map_option obj_mark (sys_heap s' r') =\n            map_option obj_mark (sys_heap s r');\n         sys_fM s' = sys_fM s\\<rbrakk>\n        \\<Longrightarrow> (x has_white_path_to y) s;\n        (y points_to z) s'; white z s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to z) s", "then"], ["proof (chain)\npicking this:\n  (x has_white_path_to y) s'\n  \\<lbrakk>\\<forall>r'.\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n   \\<forall>r'.\n      map_option obj_mark (sys_heap s' r') =\n      map_option obj_mark (sys_heap s r');\n   sys_fM s' = sys_fM s\\<rbrakk>\n  \\<Longrightarrow> (x has_white_path_to y) s\n  (y points_to z) s'\n  white z s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  \\<forall>r'.\n     map_option obj_mark (sys_heap s' r') =\n     map_option obj_mark (sys_heap s r')\n  sys_fM s' = sys_fM s", "have \"(y points_to z) s\""], ["proof (prove)\nusing this:\n  (x has_white_path_to y) s'\n  \\<lbrakk>\\<forall>r'.\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n   \\<forall>r'.\n      map_option obj_mark (sys_heap s' r') =\n      map_option obj_mark (sys_heap s r');\n   sys_fM s' = sys_fM s\\<rbrakk>\n  \\<Longrightarrow> (x has_white_path_to y) s\n  (y points_to z) s'\n  white z s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  \\<forall>r'.\n     map_option obj_mark (sys_heap s' r') =\n     map_option obj_mark (sys_heap s r')\n  sys_fM s' = sys_fM s\n\ngoal (1 subgoal):\n 1. (y points_to z) s", "by (cases \"sys_heap s y\")\n       (auto 10 10 simp: ran_def obj_at_def split: option.splits dest!: spec[where x=y])"], ["proof (state)\nthis:\n  (y points_to z) s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>r'.\n                   \\<Union>\n                    (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                   \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s';\n        \\<lbrakk>\\<forall>r'.\n                    \\<Union>\n                     (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                    \\<Union>\n                     (ran ` obj_fields ` set_option (sys_heap s r'));\n         \\<forall>r'.\n            map_option obj_mark (sys_heap s' r') =\n            map_option obj_mark (sys_heap s r');\n         sys_fM s' = sys_fM s\\<rbrakk>\n        \\<Longrightarrow> (x has_white_path_to y) s;\n        (y points_to z) s'; white z s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to z) s", "with step"], ["proof (chain)\npicking this:\n  (x has_white_path_to y) s'\n  \\<lbrakk>\\<forall>r'.\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n   \\<forall>r'.\n      map_option obj_mark (sys_heap s' r') =\n      map_option obj_mark (sys_heap s r');\n   sys_fM s' = sys_fM s\\<rbrakk>\n  \\<Longrightarrow> (x has_white_path_to y) s\n  (y points_to z) s'\n  white z s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  \\<forall>r'.\n     map_option obj_mark (sys_heap s' r') =\n     map_option obj_mark (sys_heap s r')\n  sys_fM s' = sys_fM s\n  (y points_to z) s", "show ?case"], ["proof (prove)\nusing this:\n  (x has_white_path_to y) s'\n  \\<lbrakk>\\<forall>r'.\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n              \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n   \\<forall>r'.\n      map_option obj_mark (sys_heap s' r') =\n      map_option obj_mark (sys_heap s r');\n   sys_fM s' = sys_fM s\\<rbrakk>\n  \\<Longrightarrow> (x has_white_path_to y) s\n  (y points_to z) s'\n  white z s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  \\<forall>r'.\n     map_option obj_mark (sys_heap s' r') =\n     map_option obj_mark (sys_heap s r')\n  sys_fM s' = sys_fM s\n  (y points_to z) s\n\ngoal (1 subgoal):\n 1. (x has_white_path_to z) s", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x has_white_path_to y) s';\n     \\<lbrakk>\\<forall>r'.\n                 \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                 \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n      \\<forall>r'.\n         map_option obj_mark (sys_heap s' r') =\n         map_option obj_mark (sys_heap s r');\n      sys_fM s' = sys_fM s\\<rbrakk>\n     \\<Longrightarrow> (x has_white_path_to y) s;\n     (y points_to z) s'; white z s';\n     \\<forall>r'.\n        \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n        \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n     \\<forall>r'.\n        map_option obj_mark (sys_heap s' r') =\n        map_option obj_mark (sys_heap s r');\n     sys_fM s' = sys_fM s; (y points_to z) s\\<rbrakk>\n    \\<Longrightarrow> (x has_white_path_to z) s", "apply (rule has_white_path_to_step, assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x has_white_path_to y) s';\n     \\<lbrakk>\\<forall>r'.\n                 \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                 \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n      \\<forall>r'.\n         map_option obj_mark (sys_heap s' r') =\n         map_option obj_mark (sys_heap s r');\n      sys_fM s' = sys_fM s\\<rbrakk>\n     \\<Longrightarrow> (x has_white_path_to y) s;\n     (y points_to z) s'; white z s';\n     \\<forall>r'.\n        \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n        \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n     \\<forall>r'.\n        map_option obj_mark (sys_heap s' r') =\n        map_option obj_mark (sys_heap s r');\n     sys_fM s' = sys_fM s; (y points_to z) s\\<rbrakk>\n    \\<Longrightarrow> white z s", "apply (clarsimp simp: white_def split: obj_at_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>obj obja objb.\n       \\<lbrakk>(x has_white_path_to y) s'; (x has_white_path_to y) s;\n        sys_heap s' y = Some obj; z \\<in> ran (obj_fields obj);\n        sys_heap s' z = Some obja; obj_mark obja = (\\<not> sys_fM s);\n        \\<forall>r'.\n           (\\<Union>a\\<in>set_option (sys_heap s' r'). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s r'). ran (obj_fields a));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s; sys_heap s y = Some objb;\n        z \\<in> ran (obj_fields objb)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y. sys_heap s z = Some y) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s z = Some obj \\<longrightarrow>\n                             obj_mark obj = (\\<not> sys_fM s))", "apply (metis map_option_eq_Some option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (x has_white_path_to z) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>r'.\n                   \\<Union>\n                    (ran ` obj_fields ` set_option (sys_heap s' r')) =\n                   \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'));\n        \\<forall>r'.\n           map_option obj_mark (sys_heap s' r') =\n           map_option obj_mark (sys_heap s r');\n        sys_fM s' = sys_fM s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to x) s", "qed simp"], ["", "lemma has_white_path_to_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')))\n          (x has_white_path_to y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (sys_fM s,\n          \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')),\n          map_option obj_mark (sys_heap s r')))\n     (x has_white_path_to y)", "unfolding eq_imp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (sys_fM s,\n            \\<Union> (ran ` obj_fields ` set_option (sys_heap s x)),\n            map_option obj_mark (sys_heap s x)) =\n           (sys_fM s',\n            \\<Union> (ran ` obj_fields ` set_option (sys_heap s' x)),\n            map_option obj_mark (sys_heap s' x))) \\<longrightarrow>\n       (x has_white_path_to y) s = (x has_white_path_to y) s'", "apply (clarsimp simp: all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to y) s =\n                         (x has_white_path_to y) s'", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        (x has_white_path_to y) s\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to y) s'\n 2. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        (x has_white_path_to y) s'\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to y) s", "apply (erule has_white_path_to_eq_imp'; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        (x has_white_path_to y) s'\\<rbrakk>\n       \\<Longrightarrow> (x has_white_path_to y) s", "apply (erule has_white_path_to_eq_imp'; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas has_white_path_to_fun_upd[simp] = eq_imp_fun_upd[OF has_white_path_to_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "text\\<open>grey protects white\\<close>"], ["", "lemma grey_protects_whiteD[dest]:\n  \"(g grey_protects_white w) s \\<Longrightarrow> grey g s \\<and> (g = w \\<or> white w s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g grey_protects_white w) s \\<Longrightarrow>\n    grey g s \\<and> (g = w \\<or> white w s)", "by (auto simp: grey_protects_white_def)"], ["", "lemma grey_protects_whiteI[iff]:\n  \"grey g s \\<Longrightarrow> (g grey_protects_white g) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grey g s \\<Longrightarrow> (g grey_protects_white g) s", "by (simp add: grey_protects_white_def)"], ["", "lemma grey_protects_whiteE[elim!]:\n  \"\\<lbrakk> (g points_to w) s; grey g s; white w s \\<rbrakk> \\<Longrightarrow> (g grey_protects_white w) s\"\n  \"\\<lbrakk> (g grey_protects_white y) s; (y points_to w) s; white w s \\<rbrakk> \\<Longrightarrow> (g grey_protects_white w) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(g points_to w) s; grey g s; white w s\\<rbrakk>\n     \\<Longrightarrow> (g grey_protects_white w) s) &&&\n    (\\<lbrakk>(g grey_protects_white y) s; (y points_to w) s;\n      white w s\\<rbrakk>\n     \\<Longrightarrow> (g grey_protects_white w) s)", "by (auto simp: grey_protects_white_def)"], ["", "lemma grey_protects_white_reaches[elim]:\n  \"(g grey_protects_white w) s \\<Longrightarrow> (g reaches w) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g grey_protects_white w) s \\<Longrightarrow> (g reaches w) s", "by (auto simp: grey_protects_white_def)"], ["", "lemma grey_protects_white_induct[consumes 1, case_names refl step, induct set: grey_protects_white]:\n  assumes \"(g grey_protects_white w) s\"\n  assumes \"\\<And>x. grey x s \\<Longrightarrow> P x x\"\n  assumes \"\\<And>x y z. \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s; white z s\\<rbrakk> \\<Longrightarrow> P x z\"\n  shows \"P g w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P g w", "using assms"], ["proof (prove)\nusing this:\n  (g grey_protects_white w) s\n  grey ?x s \\<Longrightarrow> P ?x ?x\n  \\<lbrakk>(?x has_white_path_to ?y) s; P ?x ?y; (?y points_to ?z) s;\n   white ?z s\\<rbrakk>\n  \\<Longrightarrow> P ?x ?z\n\ngoal (1 subgoal):\n 1. P g w", "unfolding grey_protects_white_def"], ["proof (prove)\nusing this:\n  grey g s \\<and> (g has_white_path_to w) s\n  grey ?x s \\<Longrightarrow> P ?x ?x\n  \\<lbrakk>(?x has_white_path_to ?y) s; P ?x ?y; (?y points_to ?z) s;\n   white ?z s\\<rbrakk>\n  \\<Longrightarrow> P ?x ?z\n\ngoal (1 subgoal):\n 1. P g w", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>grey g s \\<and> (g has_white_path_to w) s;\n     \\<And>x. grey x s \\<Longrightarrow> P x x;\n     \\<And>x y z.\n        \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s;\n         white z s\\<rbrakk>\n        \\<Longrightarrow> P x z\\<rbrakk>\n    \\<Longrightarrow> P g w", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. grey x s \\<Longrightarrow> P x x;\n     \\<And>x y z.\n        \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s;\n         white z s\\<rbrakk>\n        \\<Longrightarrow> P x z;\n     grey g s; (g has_white_path_to w) s\\<rbrakk>\n    \\<Longrightarrow> P g w", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(g has_white_path_to w) s;\n     \\<And>x. grey x s \\<Longrightarrow> P x x;\n     \\<And>x y z.\n        \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s;\n         white z s\\<rbrakk>\n        \\<Longrightarrow> P x z;\n     grey g s\\<rbrakk>\n    \\<Longrightarrow> P g w", "apply (induct rule: has_white_path_to_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x. grey x s \\<Longrightarrow> P x x;\n        \\<And>x y z.\n           \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s;\n            white z s\\<rbrakk>\n           \\<Longrightarrow> P x z;\n        grey x s\\<rbrakk>\n       \\<Longrightarrow> P x x\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<lbrakk>\\<And>x. grey x s \\<Longrightarrow> P x x;\n         \\<And>x y z.\n            \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s;\n             white z s\\<rbrakk>\n            \\<Longrightarrow> P x z;\n         grey x s\\<rbrakk>\n        \\<Longrightarrow> P x y;\n        (y points_to z) s; white z s;\n        \\<And>x. grey x s \\<Longrightarrow> P x x;\n        \\<And>x y z.\n           \\<lbrakk>(x has_white_path_to y) s; P x y; (y points_to z) s;\n            white z s\\<rbrakk>\n           \\<Longrightarrow> P x z;\n        grey x s\\<rbrakk>\n       \\<Longrightarrow> P x z", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> @{term \"valid_W_inv\"} \\<close>"], ["", "lemma valid_W_inv_sys_ghg_empty_iff[elim!]:\n  \"valid_W_inv s \\<Longrightarrow> sys_ghost_honorary_grey s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_W_inv s \\<Longrightarrow> sys_ghost_honorary_grey s = {}", "unfolding valid_W_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x xa.\n        xa \\<in> W (s x) \\<or>\n        sys_mem_lock s \\<noteq> Some x \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        marked xa s) \\<and>\n    (\\<forall>x xa.\n        x \\<noteq> xa \\<longrightarrow> WL x s \\<inter> WL xa s = {}) \\<and>\n    (\\<forall>x xa xb.\n        \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                xb \\<in> W (s xa))) \\<and>\n    sys_ghost_honorary_grey s = {} \\<and>\n    (\\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) =\n        [mw_Mark xa xb]) \\<Longrightarrow>\n    sys_ghost_honorary_grey s = {}", "by simp"], ["", "lemma WLI[intro]:\n  \"r \\<in> W (s p) \\<Longrightarrow> r \\<in> WL p s\"\n  \"r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> r \\<in> WL p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<in> W (s p) \\<Longrightarrow> r \\<in> WL p s) &&&\n    (r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow> r \\<in> WL p s)", "unfolding WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<in> W (s p) \\<Longrightarrow>\n     r \\<in> W (s p) \\<union> ghost_honorary_grey (s p)) &&&\n    (r \\<in> ghost_honorary_grey (s p) \\<Longrightarrow>\n     r \\<in> W (s p) \\<union> ghost_honorary_grey (s p))", "by simp_all"], ["", "lemma WL_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. (ghost_honorary_grey (s p), W (s p)))\n          (WL p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp (\\<lambda>_ s. (ghost_honorary_grey (s p), W (s p))) (WL p)", "unfolding eq_imp_def WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (ghost_honorary_grey (s p), W (s p)) =\n           (ghost_honorary_grey (s' p), W (s' p))) \\<longrightarrow>\n       W (s p) \\<union> ghost_honorary_grey (s p) =\n       W (s' p) \\<union> ghost_honorary_grey (s' p)", "by simp"], ["", "lemmas WL_fun_upd[simp] = eq_imp_fun_upd[OF WL_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma valid_W_inv_eq_imp:\n  \"eq_imp (\\<lambda>(p, r). (\\<lambda>s. W (s p)) \\<^bold>\\<otimes> (\\<lambda>s. ghost_honorary_grey (s p)) \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r)) \\<^bold>\\<otimes> sys_mem_lock \\<^bold>\\<otimes> tso_pending_mark p)\n          valid_W_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>(p, r) s.\n         (W (s p), ghost_honorary_grey (s p), sys_fM s,\n          map_option obj_mark (sys_heap s r), sys_mem_lock s,\n          filter is_mw_Mark (sys_mem_store_buffers p s)))\n     valid_W_inv", "apply (clarsimp simp: eq_imp_def valid_W_inv_def fun_eq_iff all_conj_distrib white_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s \\<inter> WL xa s = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s) \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb])) =\n                         ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s' \\<inter> WL xa s' = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s') \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s' \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb]))", "apply (rename_tac s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s \\<inter> WL xa s = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s) \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb])) =\n                         ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s' \\<inter> WL xa s' = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s') \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s' \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb]))", "apply (subgoal_tac \"\\<forall>p. WL p s = WL p s'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s \\<inter> WL xa s = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s) \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb])) =\n                         ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s' \\<inter> WL xa s' = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s') \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s' \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb]))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (subgoal_tac \"\\<forall>x. marked x s \\<longleftrightarrow> marked x s'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s \\<inter> WL xa s = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s) \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb])) =\n                         ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s' \\<inter> WL xa s' = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s') \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s' \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb]))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (subgoal_tac \"\\<forall>x. obj_at (\\<lambda>obj. obj_mark obj = (\\<not>sys_fM s')) x s \\<longleftrightarrow> obj_at (\\<lambda>obj. obj_mark obj = (\\<not>sys_fM s')) x s'\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'; \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x s =\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x\n            s'\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s \\<inter> WL xa s = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s) \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb])) =\n                         ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s' \\<inter> WL xa s' = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s') \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s' \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb]))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s =\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (subgoal_tac \"\\<forall>x xa xb. mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s) \\<longleftrightarrow> mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s')\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'; \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x s =\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x s';\n        \\<forall>x xa xb.\n           (mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s)) =\n           (mw_Mark xa xb \\<in> set (sys_mem_store_buffers x s'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              obj_at\n                               (\\<lambda>obj. obj_mark obj = sys_fM s') xa\n                               s) \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s \\<inter> WL xa s = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s) \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb])) =\n                         ((\\<forall>x xa.\n                              xa \\<in> W (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              sys_mem_lock s' \\<noteq> Some x \\<and>\n                              xa \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              marked xa s') \\<and>\n                          (\\<forall>x xa.\n                              x \\<noteq> xa \\<longrightarrow>\n                              WL x s' \\<inter> WL xa s' = {}) \\<and>\n                          (\\<forall>x xa xb.\n                              xb \\<in> ghost_honorary_grey\n  (s' x) \\<longrightarrow>\n                              xb \\<notin> W (s' xa)) \\<and>\n                          sys_ghost_honorary_grey s' = {} \\<and>\n                          (\\<forall>x xa xb.\n                              mw_Mark xa xb\n                              \\<in> set (sys_mem_store_buffers x\n    s') \\<longrightarrow>\n                              xb = sys_fM s' \\<and>\n                              xa \\<in> ghost_honorary_grey (s' x) \\<and>\n                              sys_mem_lock s' = Some x \\<and>\n                              obj_at\n                               (\\<lambda>obj.\n                                   obj_mark obj = (\\<not> sys_fM s'))\n                               xa s' \\<and>\n                              filter is_mw_Mark\n                               (sys_mem_store_buffers x s') =\n                              [mw_Mark xa xb]))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'; \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x s =\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x\n            s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x xa xb.\n                            (mw_Mark xa xb\n                             \\<in> set (sys_mem_store_buffers x s)) =\n                            (mw_Mark xa xb\n                             \\<in> set (sys_mem_store_buffers x s'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s =\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s'\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 5. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (simp; fail)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'; \\<forall>x. marked x s = marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x s =\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x\n            s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x xa xb.\n                            (mw_Mark xa xb\n                             \\<in> set (sys_mem_store_buffers x s)) =\n                            (mw_Mark xa xb\n                             \\<in> set (sys_mem_store_buffers x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s =\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s' x xa xb.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x s =\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x\n            s'\\<rbrakk>\n       \\<Longrightarrow> (mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x s)) =\n                         (mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s =\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (rename_tac x xa xb)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s' x xa xb.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s';\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x s =\n           obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s')) x\n            s'\\<rbrakk>\n       \\<Longrightarrow> (mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x s)) =\n                         (mw_Mark xa xb\n                          \\<in> set (sys_mem_store_buffers x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s =\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (drule_tac x=x in spec, drule arg_cong[where f=set], fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s =\n                            obj_at\n                             (\\<lambda>obj.\n                                 obj_mark obj = (\\<not> sys_fM s'))\n                             x s'\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (clarsimp split: obj_at_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. sys_heap s x = Some y) \\<or>\n                    (\\<forall>obj.\n                        sys_heap s' x = Some obj \\<longrightarrow>\n                        obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                   (\\<forall>obj.\n                       sys_heap s x = Some obj \\<longrightarrow>\n                       ((\\<exists>y. sys_heap s' x = Some y) \\<or>\n                        obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                       (\\<forall>obja.\n                           sys_heap s' x = Some obja \\<longrightarrow>\n                           (obj_mark obj = sys_fM s') =\n                           (obj_mark obja = sys_fM s')));\n        \\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = sys_fM s')) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = sys_fM s') \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = (\\<not> sys_fM s')) =\n                                 (obj_mark obja = (\\<not> sys_fM s'))))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (rename_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. sys_heap s x = Some y) \\<or>\n                    (\\<forall>obj.\n                        sys_heap s' x = Some obj \\<longrightarrow>\n                        obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                   (\\<forall>obj.\n                       sys_heap s x = Some obj \\<longrightarrow>\n                       ((\\<exists>y. sys_heap s' x = Some y) \\<or>\n                        obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                       (\\<forall>obja.\n                           sys_heap s' x = Some obja \\<longrightarrow>\n                           (obj_mark obj = sys_fM s') =\n                           (obj_mark obja = sys_fM s')));\n        \\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = sys_fM s')) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = sys_fM s') \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = (\\<not> sys_fM s')) =\n                                 (obj_mark obja = (\\<not> sys_fM s'))))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply ( (drule_tac x=x in spec)+ )[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s'; sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        ((\\<exists>y. sys_heap s x = Some y) \\<or>\n         (\\<forall>obj.\n             sys_heap s' x = Some obj \\<longrightarrow>\n             obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            ((\\<exists>y. sys_heap s' x = Some y) \\<or>\n             obj_mark obj = (\\<not> sys_fM s')) \\<and>\n            (\\<forall>obja.\n                sys_heap s' x = Some obja \\<longrightarrow>\n                (obj_mark obj = sys_fM s') = (obj_mark obja = sys_fM s')));\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = sys_fM s')) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = sys_fM s') \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = (\\<not> sys_fM s')) =\n                                 (obj_mark obja = (\\<not> sys_fM s'))))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (case_tac \"sys_heap s x\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s' x a.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s'; sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        ((\\<exists>y. sys_heap s' x = Some y) \\<or>\n         obj_mark a = (\\<not> sys_fM s')) \\<and>\n        (\\<forall>obj.\n            sys_heap s' x = Some obj \\<longrightarrow>\n            (obj_mark a = sys_fM s') = (obj_mark obj = sys_fM s'));\n        Some (obj_mark a) = map_option obj_mark (sys_heap s' x);\n        sys_heap s x = Some a\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s' x = None \\<longrightarrow>\n                          obj_mark a = sys_fM s') \\<and>\n                         (\\<forall>obj.\n                             sys_heap s' x = Some obj \\<longrightarrow>\n                             (obj_mark a = (\\<not> sys_fM s')) =\n                             (obj_mark obj = (\\<not> sys_fM s')))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                             x s =\n                            marked x s'\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (case_tac \"sys_heap s' x\", auto)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                             x s =\n                            marked x s'\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (clarsimp split: obj_at_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s'\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s'; sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (case_tac \"sys_heap s x\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x a.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s'; sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s');\n        \\<forall>p. WL p s = WL p s';\n        Some (obj_mark a) = map_option obj_mark (sys_heap s' x);\n        sys_heap s x = Some a\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s' x = None \\<longrightarrow>\n                          obj_mark a = (\\<not> sys_fM s')) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s' x = Some obj \\<longrightarrow>\n                             (obj_mark a = sys_fM s') =\n                             (obj_mark obj = sys_fM s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (case_tac \"sys_heap s' x\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. W (s a) = W (s' a);\n        \\<forall>a. ghost_honorary_grey (s a) = ghost_honorary_grey (s' a);\n        sys_fM s = sys_fM s';\n        \\<forall>b.\n           map_option obj_mark (sys_heap s b) =\n           map_option obj_mark (sys_heap s' b);\n        sys_mem_lock s = sys_mem_lock s';\n        \\<forall>a.\n           filter is_mw_Mark (sys_mem_store_buffers a s) =\n           filter is_mw_Mark (sys_mem_store_buffers a s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p. WL p s = WL p s'", "apply (simp add: WL_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas valid_W_inv_fun_upd[simp] = eq_imp_fun_upd[OF valid_W_inv_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma valid_W_invE[elim!]:\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> marked r s\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk> \\<Longrightarrow> marked r s\"\n  \"\\<lbrakk> r \\<in> W (s p); valid_W_inv s \\<rbrakk> \\<Longrightarrow> valid_ref r s\"\n  \"\\<lbrakk> r \\<in> ghost_honorary_grey (s p); sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk> \\<Longrightarrow> valid_ref r s\"\n  \"\\<lbrakk> mw_Mark r fl \\<in> set (sys_mem_store_buffers p s); valid_W_inv s \\<rbrakk> \\<Longrightarrow> r \\<in> ghost_honorary_grey (s p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n      \\<Longrightarrow> marked r s) &&&\n     (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n       sys_mem_lock s \\<noteq> Some p; valid_W_inv s\\<rbrakk>\n      \\<Longrightarrow> marked r s)) &&&\n    (\\<lbrakk>r \\<in> W (s p); valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> obj_at (\\<lambda>s. True) r s) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n      sys_mem_lock s \\<noteq> Some p; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> obj_at (\\<lambda>s. True) r s) &&&\n    (\\<lbrakk>mw_Mark r fl \\<in> set (sys_mem_store_buffers p s);\n      valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> r \\<in> ghost_honorary_grey (s p))", "unfolding valid_W_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>r \\<in> W (s p);\n       (\\<forall>x xa.\n           xa \\<in> W (s x) \\<or>\n           sys_mem_lock s \\<noteq> Some x \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           marked xa s) \\<and>\n       (\\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           WL x s \\<inter> WL xa s = {}) \\<and>\n       (\\<forall>x xa xb.\n           \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                   xb \\<in> W (s xa))) \\<and>\n       sys_ghost_honorary_grey s = {} \\<and>\n       (\\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) =\n           [mw_Mark xa xb])\\<rbrakk>\n      \\<Longrightarrow> marked r s) &&&\n     (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n       sys_mem_lock s \\<noteq> Some p;\n       (\\<forall>x xa.\n           xa \\<in> W (s x) \\<or>\n           sys_mem_lock s \\<noteq> Some x \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           marked xa s) \\<and>\n       (\\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           WL x s \\<inter> WL xa s = {}) \\<and>\n       (\\<forall>x xa xb.\n           \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                   xb \\<in> W (s xa))) \\<and>\n       sys_ghost_honorary_grey s = {} \\<and>\n       (\\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) =\n           [mw_Mark xa xb])\\<rbrakk>\n      \\<Longrightarrow> marked r s)) &&&\n    (\\<lbrakk>r \\<in> W (s p);\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> obj_at (\\<lambda>s. True) r s) &&&\n    (\\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n      sys_mem_lock s \\<noteq> Some p;\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> obj_at (\\<lambda>s. True) r s) &&&\n    (\\<lbrakk>mw_Mark r fl \\<in> set (sys_mem_store_buffers p s);\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> r \\<in> ghost_honorary_grey (s p))", "apply (simp_all add:  split: obj_at_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<in> W (s p);\n     \\<forall>x xa.\n        ((\\<exists>y. sys_heap s xa = Some y) \\<or>\n         xa \\<notin> W (s x) \\<and>\n         (sys_mem_lock s = Some x \\<or>\n          xa \\<notin> ghost_honorary_grey (s x))) \\<and>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            (xa \\<in> W (s x) \\<longrightarrow>\n             obj_mark obj = sys_fM s) \\<and>\n            (xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n             sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s));\n     \\<forall>x xa.\n        x \\<noteq> xa \\<longrightarrow> WL x s \\<inter> WL xa s = {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) =\n        [mw_Mark xa xb]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. sys_heap s r = Some y\n 2. \\<lbrakk>r \\<in> ghost_honorary_grey (s p);\n     sys_mem_lock s \\<noteq> Some p;\n     \\<forall>x xa.\n        ((\\<exists>y. sys_heap s xa = Some y) \\<or>\n         xa \\<notin> W (s x) \\<and>\n         (sys_mem_lock s = Some x \\<or>\n          xa \\<notin> ghost_honorary_grey (s x))) \\<and>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            (xa \\<in> W (s x) \\<longrightarrow>\n             obj_mark obj = sys_fM s) \\<and>\n            (xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n             sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s));\n     \\<forall>x xa.\n        x \\<noteq> xa \\<longrightarrow> WL x s \\<inter> WL xa s = {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) =\n        [mw_Mark xa xb]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. sys_heap s r = Some y", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_W_invD:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark ws = []\"\n  \"\\<lbrakk> mw_Mark r fl \\<in> set (sys_mem_store_buffers p s); valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and> r \\<in> ghost_honorary_grey (s p) \\<and> tso_locked_by p s \\<and> white r s \\<and> filter is_mw_Mark (sys_mem_store_buffers p s) = [mw_Mark r fl]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n      valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       white r s \\<and> filter is_mw_Mark ws = []) &&&\n    (\\<lbrakk>mw_Mark r fl \\<in> set (sys_mem_store_buffers p s);\n      valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       white r s \\<and>\n                       filter is_mw_Mark (sys_mem_store_buffers p s) =\n                       [mw_Mark r fl])", "unfolding valid_W_inv_def white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s)\n                        r s \\<and>\n                       filter is_mw_Mark ws = []) &&&\n    (\\<lbrakk>mw_Mark r fl \\<in> set (sys_mem_store_buffers p s);\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> fl = sys_fM s \\<and>\n                       r \\<in> ghost_honorary_grey (s p) \\<and>\n                       sys_mem_lock s = Some p \\<and>\n                       obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s)\n                        r s \\<and>\n                       filter is_mw_Mark (sys_mem_store_buffers p s) =\n                       [mw_Mark r fl])", "by (clarsimp dest!: spec[where x=p], blast)+"], ["", "lemma valid_W_inv_colours:\n  \"\\<lbrakk>white x s; valid_W_inv s\\<rbrakk> \\<Longrightarrow> x \\<notin> W (s p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>white x s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> W (s p)", "using marked_not_white valid_W_invE(1)"], ["proof (prove)\nusing this:\n  white ?r ?s \\<Longrightarrow> \\<not> marked ?r ?s\n  \\<lbrakk>?r \\<in> W (?s ?p); valid_W_inv ?s\\<rbrakk>\n  \\<Longrightarrow> marked ?r ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>white x s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> W (s p)", "by force"], ["", "lemma valid_W_inv_no_mark_stores_invD:\n  \"\\<lbrakk> sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> tso_pending p is_mw_Mark s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_lock s \\<noteq> Some p; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> filter is_mw_Mark (sys_mem_store_buffers p s) = []", "by (auto dest: valid_W_invD(2) intro!: filter_False)"], ["", "lemma valid_W_inv_sys_load[simp]:\n  \"\\<lbrakk> sys_mem_lock s \\<noteq> Some p; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> sys_load p (mr_Mark r) (s sys) = mv_Mark (map_option obj_mark (sys_heap s r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_lock s \\<noteq> Some p; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> sys_load p (mr_Mark r) (s sys) =\n                      mv_Mark (map_option obj_mark (sys_heap s r))", "unfolding sys_load_def fold_stores_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_lock s \\<noteq> Some p; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> (do_load_action (mr_Mark r) \\<circ>\n                       (\\<lambda>s.\n                           fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                            (mem_store_buffers s p) id s))\n                       (s sys) =\n                      mv_Mark (map_option obj_mark (sys_heap s r))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_lock s \\<noteq> Some p; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> map_option obj_mark\n                       (heap\n                         (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                           (sys_mem_store_buffers p s) id (s sys))\n                         r) =\n                      map_option obj_mark (sys_heap s r)", "apply (rule fold_invariant[where P=\"\\<lambda>fr. map_option obj_mark (heap (fr (s sys)) r) = map_option obj_mark (sys_heap s r)\"\n                             and Q=\"\\<lambda>w. \\<forall>r fl. w \\<noteq> mw_Mark r fl\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_lock s \\<noteq> Some p; valid_W_inv s;\n        x \\<in> set (sys_mem_store_buffers p s)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r fl. x \\<noteq> mw_Mark r fl\n 2. \\<lbrakk>sys_mem_lock s \\<noteq> Some p; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> map_option obj_mark (heap (id (s sys)) r) =\n                      map_option obj_mark (sys_heap s r)\n 3. \\<And>x sa.\n       \\<lbrakk>sys_mem_lock s \\<noteq> Some p; valid_W_inv s;\n        \\<forall>r fl. x \\<noteq> mw_Mark r fl;\n        map_option obj_mark (heap (sa (s sys)) r) =\n        map_option obj_mark (sys_heap s r)\\<rbrakk>\n       \\<Longrightarrow> map_option obj_mark\n                          (heap ((do_store_action x \\<circ> sa) (s sys))\n                            r) =\n                         map_option obj_mark (sys_heap s r)", "apply (auto simp: map_option_case do_store_action_def filter_empty_conv fun_upd_apply\n              dest: valid_W_invD(2)\n             split: mem_store_action.splits option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open> \\<open>grey_reachable\\<close> \\<close>"], ["", "lemma grey_reachable_eq_imp:\n  \"eq_imp (\\<lambda>r'. (\\<lambda>s. \\<Union>p. WL p s) \\<^bold>\\<otimes> (\\<lambda>s. Set.bind (Option.set_option (sys_heap s r')) (ran \\<circ> obj_fields)))\n          (grey_reachable r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (\\<Union>p. WL p s,\n          Set.bind (set_option (sys_heap s r')) (ran \\<circ> obj_fields)))\n     (grey_reachable r)", "by (auto simp: eq_imp_def grey_reachable_def grey_def set_eq_iff reaches_fields)"], ["", "lemmas grey_reachable_fun_upd[simp] = eq_imp_fun_upd[OF grey_reachable_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma grey_reachableI[intro]:\n  \"grey g s \\<Longrightarrow> grey_reachable g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grey g s \\<Longrightarrow> grey_reachable g s", "unfolding grey_reachable_def reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. grey g s \\<Longrightarrow>\n    \\<exists>x.\n       grey x s \\<and> (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x g", "by blast"], ["", "lemma grey_reachableE:\n  \"\\<lbrakk> (g points_to y) s; grey_reachable g s \\<rbrakk> \\<Longrightarrow> grey_reachable y s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(g points_to y) s; grey_reachable g s\\<rbrakk>\n    \\<Longrightarrow> grey_reachable y s", "unfolding grey_reachable_def reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(g points_to y) s;\n     \\<exists>x.\n        grey x s \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         grey x s \\<and>\n                         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                          y", "by (auto elim: rtranclp.intros(2))"], ["", "subsection\\<open>valid refs inv\\<close>"], ["", "lemma valid_refs_invI:\n  \"\\<lbrakk> \\<And>m x y. \\<lbrakk> (x reaches y) s; mut_m.root m x s \\<or> grey x s \\<rbrakk> \\<Longrightarrow> valid_ref y s\n   \\<rbrakk> \\<Longrightarrow> valid_refs_inv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m x y.\n        \\<lbrakk>(x reaches y) s;\n         x \\<in> roots (s (mutator m)) \\<union>\n                 ghost_honorary_root (s (mutator m)) \\<union>\n                 mut_m.tso_store_refs m s \\<or>\n         grey x s\\<rbrakk>\n        \\<Longrightarrow> obj_at (\\<lambda>s. True) y s) \\<Longrightarrow>\n    valid_refs_inv s", "by (auto simp: valid_refs_inv_def mut_m.reachable_def grey_reachable_def)"], ["", "lemma valid_refs_inv_eq_imp:\n  \"eq_imp (\\<lambda>(m', r'). (\\<lambda>s. roots (s (mutator m'))) \\<^bold>\\<otimes> (\\<lambda>s. ghost_honorary_root (s (mutator m'))) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_fields (sys_heap s r')) \\<^bold>\\<otimes> tso_pending_mutate (mutator m') \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>p. WL p s))\n          valid_refs_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>(m', r') s.\n         (roots (s (mutator m')), ghost_honorary_root (s (mutator m')),\n          map_option obj_fields (sys_heap s r'),\n          filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n           (sys_mem_store_buffers (mutator m') s),\n          \\<Union>p. WL p s))\n     valid_refs_inv", "apply (clarsimp simp: eq_imp_def valid_refs_inv_def grey_reachable_def all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa s \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))", "apply (rename_tac s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa s \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))", "apply (subgoal_tac \"\\<forall>r'. valid_ref r' s \\<longleftrightarrow> valid_ref r' s'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa s \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'", "apply (subgoal_tac \"\\<forall>r'. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r')) = \\<Union>(ran ` obj_fields ` set_option (sys_heap s' r'))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa s \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'", "apply (subst eq_impD[OF mut_m.reachable_eq_imp])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (?s'15 s s' (mutator x)),\n                             ghost_honorary_root (?s'15 s s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'15 s s') xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x)\n                                (?s'15 s s')))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa\n                               (?s'15 s s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa\n                               (?s'15 s s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'\n 4. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (?s'15 s s' (mutator x)),\n                             ghost_honorary_root (?s'15 s s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'15 s s') xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x)\n                                (?s'15 s s')))", "apply (subst eq_impD[OF grey_eq_imp])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p (?s'18 s s')))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa\n                               (?s'a18 s s' s s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa (?s'18 s s') \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'\n 5. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (?s'a18 s s' s s' (mutator x)),\n                             ghost_honorary_root\n                              (?s'a18 s s' s s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'a18 s s' s s') xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x)\n                                (?s'a18 s s' s s')))", "defer"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa\n                               (?s'a18 s s' s s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa (?s'18 s s') \\<and>\n                                  (xa reaches x) s) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'\n 4. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (?s'a18 s s' s s' (mutator x)),\n                             ghost_honorary_root\n                              (?s'a18 s s' s s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'a18 s s' s s') xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x)\n                                (?s'a18 s s' s s')))\n 5. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p (?s'18 s s')))", "apply (subst eq_impD[OF reaches_eq_imp])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran `\n                              obj_fields `\n                              set_option (sys_heap (?s'23 s s') x))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa\n                               (?s'aa23 s s' s s' s s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa (?s'a23 s s' s s') \\<and>\n                                  (xa reaches x)\n                                   (?s'23 s s')) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 4. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'\n 5. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (?s'a18 s s' s s' (mutator x)),\n                             ghost_honorary_root\n                              (?s'a18 s s' s s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'a18 s s' s s') xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x)\n                                (?s'a18 s s' s s')))\n 6. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p (?s'a23 s s' s s')))\nflex-flex pairs:\n  \\<lambda>s s'. ?s'aa23 s s' s s' s s' \\<equiv>\\<^sup>?\n    \\<lambda>s s'. ?s'a18 s s' s s'", "defer"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>x xa.\n                              mut_m.reachable x xa\n                               (?s'aa23 s s' s s' s s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s) \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa (?s'a23 s s' s s') \\<and>\n                                  (xa reaches x)\n                                   (?s'23 s s')) \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s)) =\n                         ((\\<forall>x xa.\n                              mut_m.reachable x xa s' \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) xa s') \\<and>\n                          (\\<forall>x.\n                              (\\<exists>xa.\n                                  grey xa s' \\<and>\n                                  (xa reaches x) s') \\<longrightarrow>\n                              obj_at (\\<lambda>s. True) x s'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 3. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'\n 4. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (?s'a18 s s' s s' (mutator x)),\n                             ghost_honorary_root\n                              (?s'a18 s s' s s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'a18 s s' s s') xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x)\n                                (?s'a18 s s' s s')))\n 5. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p (?s'a23 s s' s s')))\n 6. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran `\n                              obj_fields `\n                              set_option (sys_heap (?s'23 s s') x))\nflex-flex pairs:\n  \\<lambda>s s'. ?s'aa23 s s' s s' s s' \\<equiv>\\<^sup>?\n    \\<lambda>s s'. ?s'a18 s s' s s'", "apply force"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s =\n           obj_at (\\<lambda>s. True) r' s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s r')) =\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s' r'))\n 2. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'\n 3. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (s' (mutator x)),\n                             ghost_honorary_root (s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s' xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s'))\n 4. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p s'))\n 5. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran ` obj_fields ` set_option (sys_heap s' x))", "apply (metis option.set_map)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r'.\n                            obj_at (\\<lambda>s. True) r' s =\n                            obj_at (\\<lambda>s. True) r' s'\n 2. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (s' (mutator x)),\n                             ghost_honorary_root (s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s' xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s'))\n 3. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p s'))\n 4. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran ` obj_fields ` set_option (sys_heap s' x))", "apply (clarsimp split: obj_at_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s' r'.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s')\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s r' = None \\<longrightarrow>\n                          sys_heap s' r' = None) \\<and>\n                         ((\\<exists>obj.\n                              sys_heap s r' = Some obj) \\<longrightarrow>\n                          (\\<exists>y. sys_heap s' r' = Some y))\n 2. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (s' (mutator x)),\n                             ghost_honorary_root (s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s' xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s'))\n 3. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p s'))\n 4. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran ` obj_fields ` set_option (sys_heap s' x))", "apply (metis (no_types, hide_lams) None_eq_map_option_iff option.exhaust)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            (roots (s (mutator x)),\n                             ghost_honorary_root (s (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s)) =\n                            (roots (s' (mutator x)),\n                             ghost_honorary_root (s' (mutator x)),\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s' xa)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator x) s'))\n 2. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p s'))\n 3. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran ` obj_fields ` set_option (sys_heap s' x))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (xa \\<in> (\\<Union>p. WL p s)) =\n                            (xa \\<in> (\\<Union>p. WL p s'))\n 2. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran ` obj_fields ` set_option (sys_heap s' x))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' xa x.\n       \\<lbrakk>\\<forall>a. roots (s (mutator a)) = roots (s' (mutator a));\n        \\<forall>a.\n           ghost_honorary_root (s (mutator a)) =\n           ghost_honorary_root (s' (mutator a));\n        \\<forall>b.\n           map_option obj_fields (sys_heap s b) =\n           map_option obj_fields (sys_heap s' b);\n        \\<forall>a.\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s) =\n           filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n            (sys_mem_store_buffers (mutator a) s');\n        (\\<Union>p. WL p s) = (\\<Union>p. WL p s');\n        \\<forall>r'.\n           obj_at (\\<lambda>s. True) r' s = obj_at (\\<lambda>s. True) r' s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')) =\n           \\<Union>\n            (ran ` obj_fields ` set_option (sys_heap s' r'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<Union>\n                             (ran `\n                              obj_fields ` set_option (sys_heap s x)) =\n                            \\<Union>\n                             (ran ` obj_fields ` set_option (sys_heap s' x))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas valid_refs_inv_fun_upd[simp] = eq_imp_fun_upd[OF valid_refs_inv_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma valid_refs_invD[elim]:\n  \"\\<lbrakk> x \\<in> mut_m.mut_roots m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> x \\<in> mut_m.mut_roots m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\"\n  \"\\<lbrakk> x \\<in> mut_m.tso_store_refs m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> x \\<in> mut_m.tso_store_refs m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\"\n  \"\\<lbrakk> w \\<in> set (sys_mem_store_buffers (mutator m) s); x \\<in> store_refs w; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> w \\<in> set (sys_mem_store_buffers (mutator m) s); x \\<in> store_refs w; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\"\n  \"\\<lbrakk> grey x s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> mut_m.reachable m x s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref x s\"\n  \"\\<lbrakk> mut_m.reachable m x s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s x = Some obj\"\n  \"\\<lbrakk> x \\<in> mut_m.mut_ghost_honorary_root m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref y s\"\n  \"\\<lbrakk> x \\<in> mut_m.mut_ghost_honorary_root m s; (x reaches y) s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lbrakk>x \\<in> roots (s (mutator m)); (x reaches y) s;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y s) &&&\n      (\\<lbrakk>x \\<in> roots (s (mutator m)); (x reaches y) s;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj)) &&&\n     (\\<lbrakk>x \\<in> mut_m.tso_store_refs m s; (x reaches y) s;\n       valid_refs_inv s\\<rbrakk>\n      \\<Longrightarrow> obj_at (\\<lambda>s. True) y s) &&&\n     (\\<lbrakk>x \\<in> mut_m.tso_store_refs m s; (x reaches y) s;\n       valid_refs_inv s\\<rbrakk>\n      \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj) &&&\n     (\\<lbrakk>w \\<in> set (sys_mem_store_buffers (mutator m) s);\n       x \\<in> store_refs w; (x reaches y) s; valid_refs_inv s\\<rbrakk>\n      \\<Longrightarrow> obj_at (\\<lambda>s. True) y s)) &&&\n    ((\\<lbrakk>w \\<in> set (sys_mem_store_buffers (mutator m) s);\n       x \\<in> store_refs w; (x reaches y) s; valid_refs_inv s\\<rbrakk>\n      \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj) &&&\n     (\\<lbrakk>grey x s; (x reaches y) s; valid_refs_inv s\\<rbrakk>\n      \\<Longrightarrow> obj_at (\\<lambda>s. True) y s) &&&\n     (\\<lbrakk>mut_m.reachable m x s; valid_refs_inv s\\<rbrakk>\n      \\<Longrightarrow> obj_at (\\<lambda>s. True) x s)) &&&\n    (\\<lbrakk>mut_m.reachable m x s; valid_refs_inv s\\<rbrakk>\n     \\<Longrightarrow> \\<exists>obj. sys_heap s x = Some obj) &&&\n    (\\<lbrakk>x \\<in> ghost_honorary_root (s (mutator m)); (x reaches y) s;\n      valid_refs_inv s\\<rbrakk>\n     \\<Longrightarrow> obj_at (\\<lambda>s. True) y s) &&&\n    (\\<lbrakk>x \\<in> ghost_honorary_root (s (mutator m)); (x reaches y) s;\n      valid_refs_inv s\\<rbrakk>\n     \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj)", "apply (simp_all add: valid_refs_inv_def grey_reachable_def mut_m.reachable_def mut_m.tso_store_refs_def\n              split: obj_at_splits)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     x \\<in> roots (s (mutator m)); (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya\n 2. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     x \\<in> roots (s (mutator m)); (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\n 3. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     \\<exists>xa\\<in>set (sys_mem_store_buffers (mutator m) s).\n        x \\<in> (case xa of\n                 mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                 | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                 | _ \\<Rightarrow> {});\n     (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya\n 4. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     \\<exists>xa\\<in>set (sys_mem_store_buffers (mutator m) s).\n        x \\<in> (case xa of\n                 mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                 | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                 | _ \\<Rightarrow> {});\n     (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\n 5. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     w \\<in> set (sys_mem_store_buffers (mutator m) s);\n     x \\<in> (case w of\n              mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n              | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n              | _ \\<Rightarrow> {});\n     (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya\n 6. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     w \\<in> set (sys_mem_store_buffers (mutator m) s);\n     x \\<in> (case w of\n              mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n              | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n              | _ \\<Rightarrow> {});\n     (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj\n 7. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     grey x s; (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya\n 8. \\<And>xa.\n       \\<lbrakk>\\<forall>x xa.\n                   (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                   (\\<forall>xaa.\n                       xaa \\<notin> roots (s (mutator x)) \\<and>\n                       xaa\n                       \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                       (\\<forall>x\\<in>set\n  (sys_mem_store_buffers (mutator x) s).\n                           xaa\n                           \\<notin> (case x of\n                                     mw_Mutate r f r' \\<Rightarrow>\n insert r (set_option r')\n                                     | mw_Mutate_Payload r f\n  pl \\<Rightarrow>\n   {r}\n                                     | _ \\<Rightarrow> {})) \\<or>\n                       \\<not> (xaa reaches xa) s) \\<and>\n                   (\\<forall>x.\n                       grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n        xa \\<in> roots (s (mutator m)) \\<or>\n        xa \\<in> ghost_honorary_root (s (mutator m)) \\<or>\n        (\\<exists>x\\<in>set (sys_mem_store_buffers (mutator m) s).\n            xa \\<in> (case x of\n                      mw_Mutate r f r' \\<Rightarrow>\n                        insert r (set_option r')\n                      | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                      | _ \\<Rightarrow> {}));\n        (xa reaches x) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>obj. sys_heap s x = Some obj\n 9. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                (\\<forall>xaa.\n                    xaa \\<notin> roots (s (mutator x)) \\<and>\n                    xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                    (\\<forall>x\\<in>set (sys_mem_store_buffers (mutator x)\n    s).\n                        xaa\n                        \\<notin> (case x of\n                                  mw_Mutate r f r' \\<Rightarrow>\n                                    insert r (set_option r')\n                                  | mw_Mutate_Payload r f pl \\<Rightarrow>\n{r}\n                                  | _ \\<Rightarrow> {})) \\<or>\n                    \\<not> (xaa reaches xa) s) \\<and>\n                (\\<forall>x.\n                    grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n     x \\<in> ghost_honorary_root (s (mutator m)); (x reaches y) s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya\n 10. \\<lbrakk>\\<forall>x xa.\n                 (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                 (\\<forall>xaa.\n                     xaa \\<notin> roots (s (mutator x)) \\<and>\n                     xaa \\<notin> ghost_honorary_root (s (mutator x)) \\<and>\n                     (\\<forall>x\\<in>set\n(sys_mem_store_buffers (mutator x) s).\n                         xaa\n                         \\<notin> (case x of\n                                   mw_Mutate r f r' \\<Rightarrow>\n                                     insert r (set_option r')\n                                   | mw_Mutate_Payload r f pl \\<Rightarrow>\n {r}\n                                   | _ \\<Rightarrow> {})) \\<or>\n                     \\<not> (xaa reaches xa) s) \\<and>\n                 (\\<forall>x.\n                     grey x s \\<longrightarrow> \\<not> (x reaches xa) s);\n      x \\<in> ghost_honorary_root (s (mutator m)); (x reaches y) s\\<rbrakk>\n     \\<Longrightarrow> \\<exists>obj. sys_heap s y = Some obj", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>reachable snapshot inv\\<close>"], ["", "context mut_m\nbegin"], ["", "lemma reachable_snapshot_invI[intro]:\n  \"(\\<And>y. reachable y s \\<Longrightarrow> in_snapshot y s) \\<Longrightarrow> reachable_snapshot_inv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        reachable y s \\<Longrightarrow> in_snapshot y s) \\<Longrightarrow>\n    reachable_snapshot_inv s", "by (simp add: reachable_snapshot_inv_def)"], ["", "lemma reachable_snapshot_inv_eq_imp:\n  \"eq_imp (\\<lambda>r'. mut_roots \\<^bold>\\<otimes> mut_ghost_honorary_root \\<^bold>\\<otimes> (\\<lambda>s. r' \\<in> (\\<Union>p. WL p s)) \\<^bold>\\<otimes> sys_fM\n            \\<^bold>\\<otimes> (\\<lambda>s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r'))\n            \\<^bold>\\<otimes> tso_pending_mutate (mutator m))\n          reachable_snapshot_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (mut_roots s, mut_ghost_honorary_root s,\n          r' \\<in> (\\<Union>p. WL p s), sys_fM s,\n          \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')),\n          map_option obj_mark (sys_heap s r'),\n          filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n           (sys_mem_store_buffers (mutator m) s)))\n     reachable_snapshot_inv", "unfolding eq_imp_def mut_m.reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def black_def grey_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (mut_roots s, mut_ghost_honorary_root s,\n            x \\<in> (\\<Union>p. WL p s), sys_fM s,\n            \\<Union> (ran ` obj_fields ` set_option (sys_heap s x)),\n            map_option obj_mark (sys_heap s x),\n            filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n             (sys_mem_store_buffers (mutator m) s)) =\n           (mut_roots s', mut_ghost_honorary_root s',\n            x \\<in> (\\<Union>p. WL p s'), sys_fM s',\n            \\<Union> (ran ` obj_fields ` set_option (sys_heap s' x)),\n            map_option obj_mark (sys_heap s' x),\n            filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n             (sys_mem_store_buffers (mutator m) s'))) \\<longrightarrow>\n       (\\<forall>x.\n           reachable x s \\<longrightarrow>\n           marked x s \\<and> (\\<nexists>xa. x \\<in> WL xa s) \\<or>\n           (\\<exists>xa.\n               (\\<exists>x. xa \\<in> WL x s) \\<and>\n               (xa has_white_path_to x) s)) =\n       (\\<forall>x.\n           reachable x s' \\<longrightarrow>\n           marked x s' \\<and> (\\<nexists>xa. x \\<in> WL xa s') \\<or>\n           (\\<exists>xa.\n               (\\<exists>x. xa \\<in> WL x s') \\<and>\n               (xa has_white_path_to x) s'))", "apply (clarsimp simp: all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             reachable x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s)) =\n                         (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s'))", "apply (rename_tac s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             reachable x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s)) =\n                         (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s'))", "apply (subst (1) eq_impD[OF has_white_path_to_eq_imp])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' xa x.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (sys_fM s,\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s x)),\n                             map_option obj_mark (sys_heap s x)) =\n                            (sys_fM (?s'22 s s'),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'22 s s') x)),\n                             map_option obj_mark (sys_heap (?s'22 s s') x))\n 2. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             reachable x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) (?s'22 s s'))) =\n                         (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s'))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             reachable x s \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s')) =\n                         (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s'))", "apply (subst eq_impD[OF reachable_eq_imp])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' x.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (mut_roots s, mut_ghost_honorary_root s,\n                             \\<Union>\n                              (ran `\n                               obj_fields ` set_option (sys_heap s x)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator m) s)) =\n                            (mut_roots (?s'40 s s'),\n                             mut_ghost_honorary_root (?s'40 s s'),\n                             \\<Union>\n                              (ran `\n                               obj_fields `\n                               set_option (sys_heap (?s'40 s s') x)),\n                             filter\n                              (\\<lambda>s.\n                                  is_mw_Mutate s \\<or>\n                                  is_mw_Mutate_Payload s)\n                              (sys_mem_store_buffers (mutator m)\n                                (?s'40 s s')))\n 2. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             reachable x (?s'40 s s') \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s')) =\n                         (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s'))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s')) =\n                         (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s'))", "apply (subgoal_tac \"\\<forall>x. obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s \\<longleftrightarrow> obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s');\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                              x s \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s')) =\n                         (\\<forall>x.\n                             reachable x s' \\<longrightarrow>\n                             marked x s' \\<and>\n                             (\\<forall>xa. x \\<notin> WL xa s') \\<or>\n                             (\\<exists>xa.\n                                 (\\<exists>x. xa \\<in> WL x s') \\<and>\n                                 (xa has_white_path_to x) s'))\n 2. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                             x s =\n                            marked x s'", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            obj_at (\\<lambda>obj. obj_mark obj = sys_fM s')\n                             x s =\n                            marked x s'", "apply (clarsimp split: obj_at_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        \\<forall>x.\n           (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        sys_fM s = sys_fM s';\n        \\<forall>x.\n           (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n           (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))", "apply (drule_tac x=x in spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        sys_fM s = sys_fM s';\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s');\n        (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        (\\<Union>a\\<in>set_option (sys_heap s x). ran (obj_fields a)) =\n        (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>obj.\n                              sys_heap s' x = Some obj \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              obj_mark obj = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>obja.\n                                 sys_heap s' x = Some obja \\<longrightarrow>\n                                 (obj_mark obj = sys_fM s') =\n                                 (obj_mark obja = sys_fM s')))", "apply (case_tac \"sys_heap s x\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x a.\n       \\<lbrakk>mut_roots s = mut_roots s';\n        mut_ghost_honorary_root s = mut_ghost_honorary_root s';\n        sys_fM s = sys_fM s';\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s) =\n        filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n         (sys_mem_store_buffers (mutator m) s');\n        (\\<exists>xa. x \\<in> WL xa s) = (\\<exists>xa. x \\<in> WL xa s');\n        ran (obj_fields a) =\n        (\\<Union>a\\<in>set_option (sys_heap s' x). ran (obj_fields a));\n        Some (obj_mark a) = map_option obj_mark (sys_heap s' x);\n        sys_heap s x = Some a\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s' x = None \\<longrightarrow>\n                          obj_mark a = (\\<not> sys_fM s')) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s' x = Some obj \\<longrightarrow>\n                             (obj_mark a = sys_fM s') =\n                             (obj_mark obj = sys_fM s'))", "apply (case_tac \"sys_heap s' x\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemmas reachable_snapshot_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.reachable_snapshot_inv_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma in_snapshotI[intro]:\n  \"black r s \\<Longrightarrow> in_snapshot r s\"\n  \"grey r s \\<Longrightarrow> in_snapshot r s\"\n  \"\\<lbrakk> white w s; (g grey_protects_white w) s \\<rbrakk> \\<Longrightarrow> in_snapshot w s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (black r s \\<Longrightarrow> in_snapshot r s) &&&\n    (grey r s \\<Longrightarrow> in_snapshot r s) &&&\n    (\\<lbrakk>white w s; (g grey_protects_white w) s\\<rbrakk>\n     \\<Longrightarrow> in_snapshot w s)", "by (auto simp: in_snapshot_def)"], ["", "lemma \\<comment> \\<open>Sanity\\<close>\n  \"in_snapshot r s \\<Longrightarrow> black r s \\<or> grey r s \\<or> white r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_snapshot r s \\<Longrightarrow>\n    black r s \\<or> grey r s \\<or> white r s", "by (auto simp: in_snapshot_def)"], ["", "lemma in_snapshot_valid_ref:\n  \"\\<lbrakk> in_snapshot r s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> valid_ref r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_snapshot r s; valid_refs_inv s\\<rbrakk>\n    \\<Longrightarrow> obj_at (\\<lambda>s. True) r s", "by (metis blackD(1) grey_protects_whiteD grey_protects_white_reaches in_snapshot_def obj_at_cong obj_at_def option.case(2) valid_refs_invD(7))"], ["", "lemma reachableI2[intro]:\n  \"x \\<in> mut_m.mut_ghost_honorary_root m s \\<Longrightarrow> mut_m.reachable m x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n    mut_m.reachable m x s", "unfolding mut_m.reachable_def reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n    \\<exists>xa.\n       xa \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<and>\n       (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x", "by blast"], ["", "lemma tso_pending_mw_mutate_cong:\n  \"\\<lbrakk> filter is_mw_Mutate (sys_mem_store_buffers p s) = filter is_mw_Mutate (sys_mem_store_buffers p s');\n     \\<And>r f r'. P r f r' \\<longleftrightarrow> Q r f r' \\<rbrakk>\n     \\<Longrightarrow> (\\<forall>r f r'. mw_Mutate r f r' \\<in> set (sys_mem_store_buffers p s)  \\<longrightarrow> P r f r')\n     \\<longleftrightarrow> (\\<forall>r f r'. mw_Mutate r f r' \\<in> set (sys_mem_store_buffers p s') \\<longrightarrow> Q r f r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter is_mw_Mutate (sys_mem_store_buffers p s) =\n             filter is_mw_Mutate (sys_mem_store_buffers p s');\n     \\<And>r f r'. P r f r' = Q r f r'\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>r f r'.\n                          mw_Mutate r f r'\n                          \\<in> set (sys_mem_store_buffers p\ns) \\<longrightarrow>\n                          P r f r') =\n                      (\\<forall>r f r'.\n                          mw_Mutate r f r'\n                          \\<in> set (sys_mem_store_buffers p\ns') \\<longrightarrow>\n                          Q r f r')", "by (intro iff_allI) (auto dest!: arg_cong[where f=set])"], ["", "lemma (in mut_m) marked_insertions_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')) \\<^bold>\\<otimes> tso_pending_mw_mutate (mutator m))\n          marked_insertions\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (sys_fM s, map_option obj_mark (sys_heap s r'),\n          filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)))\n     marked_insertions", "unfolding eq_imp_def marked_insertions_def obj_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (sys_fM s, map_option obj_mark (sys_heap s x),\n            filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)) =\n           (sys_fM s', map_option obj_mark (sys_heap s' x),\n            filter is_mw_Mutate\n             (sys_mem_store_buffers (mutator m) s'))) \\<longrightarrow>\n       (\\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           (case x of mw_Mutate r f None \\<Rightarrow> True\n            | mw_Mutate r f (Some r') \\<Rightarrow>\n                case sys_heap s r' of None \\<Rightarrow> False\n                | Some obj \\<Rightarrow> obj_mark obj = sys_fM s\n            | _ \\<Rightarrow> True)) =\n       (\\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s') \\<longrightarrow>\n           (case x of mw_Mutate r f None \\<Rightarrow> True\n            | mw_Mutate r f (Some r') \\<Rightarrow>\n                case sys_heap s' r' of None \\<Rightarrow> False\n                | Some obj \\<Rightarrow> obj_mark obj = sys_fM s'\n            | _ \\<Rightarrow> True))", "apply (clarsimp split: mem_store_action.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s) =\n        filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x21 x22 x23.\n                             mw_Mutate x21 x22 x23\n                             \\<in> set (sys_mem_store_buffers (mutator m)\n   s) \\<longrightarrow>\n                             (case x23 of None \\<Rightarrow> True\n                              | Some r' \\<Rightarrow>\n                                  case sys_heap s r' of\n                                  None \\<Rightarrow> False\n                                  | Some obj \\<Rightarrow>\nobj_mark obj = sys_fM s)) =\n                         (\\<forall>x21 x22 x23.\n                             mw_Mutate x21 x22 x23\n                             \\<in> set (sys_mem_store_buffers (mutator m)\n   s') \\<longrightarrow>\n                             (case x23 of None \\<Rightarrow> True\n                              | Some r' \\<Rightarrow>\n                                  case sys_heap s' r' of\n                                  None \\<Rightarrow> False\n                                  | Some obj \\<Rightarrow>\nobj_mark obj = sys_fM s'))", "apply (erule tso_pending_mw_mutate_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x21 x22 x23.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (case x23 of None \\<Rightarrow> True\n                          | Some r' \\<Rightarrow>\n                              case sys_heap s r' of None \\<Rightarrow> False\n                              | Some obj \\<Rightarrow>\n                                  obj_mark obj = sys_fM s) =\n                         (case x23 of None \\<Rightarrow> True\n                          | Some r' \\<Rightarrow>\n                              case sys_heap s' r' of\n                              None \\<Rightarrow> False\n                              | Some obj \\<Rightarrow>\n                                  obj_mark obj = sys_fM s')", "apply (clarsimp split: option.splits obj_at_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x23 x2.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x2 = None \\<longrightarrow>\n                          (\\<forall>x2a.\n                              sys_heap s' x2 = Some x2a \\<longrightarrow>\n                              x23 = Some x2 \\<longrightarrow>\n                              obj_mark x2a = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>x2a.\n                             sys_heap s x2 = Some x2a \\<longrightarrow>\n                             (sys_heap s' x2 = None \\<longrightarrow>\n                              x23 = Some x2 \\<longrightarrow>\n                              obj_mark x2a = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>x2b.\n                                 sys_heap s' x2 = Some x2b \\<longrightarrow>\n                                 x23 = Some x2 \\<longrightarrow>\n                                 (obj_mark x2a = sys_fM s') =\n                                 (obj_mark x2b = sys_fM s')))", "apply (rename_tac s s' opt x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' opt x.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>x2.\n                              sys_heap s' x = Some x2 \\<longrightarrow>\n                              opt = Some x \\<longrightarrow>\n                              obj_mark x2 = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>x2.\n                             sys_heap s x = Some x2 \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              opt = Some x \\<longrightarrow>\n                              obj_mark x2 = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>x2a.\n                                 sys_heap s' x = Some x2a \\<longrightarrow>\n                                 opt = Some x \\<longrightarrow>\n                                 (obj_mark x2 = sys_fM s') =\n                                 (obj_mark x2a = sys_fM s')))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' opt x.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> (sys_heap s x = None \\<longrightarrow>\n                          (\\<forall>x2.\n                              sys_heap s' x = Some x2 \\<longrightarrow>\n                              opt = Some x \\<longrightarrow>\n                              obj_mark x2 = (\\<not> sys_fM s'))) \\<and>\n                         (\\<forall>x2.\n                             sys_heap s x = Some x2 \\<longrightarrow>\n                             (sys_heap s' x = None \\<longrightarrow>\n                              opt = Some x \\<longrightarrow>\n                              obj_mark x2 = (\\<not> sys_fM s')) \\<and>\n                             (\\<forall>x2a.\n                                 sys_heap s' x = Some x2a \\<longrightarrow>\n                                 opt = Some x \\<longrightarrow>\n                                 (obj_mark x2 = sys_fM s') =\n                                 (obj_mark x2a = sys_fM s')))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas marked_insertions_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.marked_insertions_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma marked_insertionD[elim!]:\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m) s = mw_Mutate r f (Some r') # ws; mut_m.marked_insertions m s \\<rbrakk>\n     \\<Longrightarrow> marked r' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers (mutator m) s =\n             mw_Mutate r f (Some r') # ws;\n     mut_m.marked_insertions m s\\<rbrakk>\n    \\<Longrightarrow> marked r' s", "by (auto simp: mut_m.marked_insertions_def)"], ["", "lemma marked_insertions_store_buffer_empty[intro]:\n  \"tso_pending_mutate (mutator m) s = [] \\<Longrightarrow> mut_m.marked_insertions m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n     (sys_mem_store_buffers (mutator m) s) =\n    [] \\<Longrightarrow>\n    mut_m.marked_insertions m s", "unfolding mut_m.marked_insertions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n     (sys_mem_store_buffers (mutator m) s) =\n    [] \\<Longrightarrow>\n    \\<forall>x.\n       x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n       marked_insertion x s", "by (auto simp: filter_empty_conv split: mem_store_action.splits)"], ["", "(* marked_deletions *)"], ["", "lemma (in mut_m) marked_deletions_eq_imp:\n  \"eq_imp (\\<lambda>r'. sys_fM \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_fields (sys_heap s r')) \\<^bold>\\<otimes> (\\<lambda>s. map_option obj_mark (sys_heap s r')) \\<^bold>\\<otimes> tso_pending_mw_mutate (mutator m))\n          marked_deletions\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         (sys_fM s, map_option obj_fields (sys_heap s r'),\n          map_option obj_mark (sys_heap s r'),\n          filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)))\n     marked_deletions", "unfolding eq_imp_def marked_deletions_def obj_at_field_on_heap_def ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           (sys_fM s, map_option obj_fields (sys_heap s x),\n            map_option obj_mark (sys_heap s x),\n            filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)) =\n           (sys_fM s', map_option obj_fields (sys_heap s' x),\n            map_option obj_mark (sys_heap s' x),\n            filter is_mw_Mutate\n             (sys_mem_store_buffers (mutator m) s'))) \\<longrightarrow>\n       (\\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           (case x of\n            mw_Mutate r f opt_r' \\<Rightarrow>\n              case map_option obj_fields (sys_heap s r) of\n              None \\<Rightarrow> False\n              | Some fs \\<Rightarrow>\n                  case fs f of None \\<Rightarrow> True\n                  | Some r' \\<Rightarrow> marked r' s\n            | _ \\<Rightarrow> True)) =\n       (\\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s') \\<longrightarrow>\n           (case x of\n            mw_Mutate r f opt_r' \\<Rightarrow>\n              case map_option obj_fields (sys_heap s' r) of\n              None \\<Rightarrow> False\n              | Some fs \\<Rightarrow>\n                  case fs f of None \\<Rightarrow> True\n                  | Some r' \\<Rightarrow> marked r' s'\n            | _ \\<Rightarrow> True))", "apply (clarsimp simp: all_conj_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s) =\n        filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s')\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x \\<Rightarrow>\n                                    ((\\<lambda>fs.\n   case fs f of None \\<Rightarrow> True\n   | Some r' \\<Rightarrow> marked r' s) \\<circ>\n                                     obj_fields)\n                                     x\n                              | _ \\<Rightarrow> True)) =\n                         (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s') \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x \\<Rightarrow>\n                                    ((\\<lambda>fs.\n   case fs f of None \\<Rightarrow> True\n   | Some r' \\<Rightarrow> marked r' s') \\<circ>\n                                     obj_fields)\n                                     x\n                              | _ \\<Rightarrow> True))", "apply (drule arg_cong[where f=set])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        set (filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)) =\n        set (filter is_mw_Mutate\n              (sys_mem_store_buffers (mutator m) s'))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x \\<Rightarrow>\n                                    ((\\<lambda>fs.\n   case fs f of None \\<Rightarrow> True\n   | Some r' \\<Rightarrow> marked r' s) \\<circ>\n                                     obj_fields)\n                                     x\n                              | _ \\<Rightarrow> True)) =\n                         (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s') \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x \\<Rightarrow>\n                                    ((\\<lambda>fs.\n   case fs f of None \\<Rightarrow> True\n   | Some r' \\<Rightarrow> marked r' s') \\<circ>\n                                     obj_fields)\n                                     x\n                              | _ \\<Rightarrow> True))", "apply (subgoal_tac \"\\<forall>x. marked x s \\<longleftrightarrow> marked x s'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        set (filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)) =\n        set (filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s'));\n        \\<forall>x. marked x s = marked x s'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x \\<Rightarrow>\n                                    ((\\<lambda>fs.\n   case fs f of None \\<Rightarrow> True\n   | Some r' \\<Rightarrow> marked r' s) \\<circ>\n                                     obj_fields)\n                                     x\n                              | _ \\<Rightarrow> True)) =\n                         (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s') \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x \\<Rightarrow>\n                                    ((\\<lambda>fs.\n   case fs f of None \\<Rightarrow> True\n   | Some r' \\<Rightarrow> marked r' s') \\<circ>\n                                     obj_fields)\n                                     x\n                              | _ \\<Rightarrow> True))\n 2. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        set (filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)) =\n        set (filter is_mw_Mutate\n              (sys_mem_store_buffers (mutator m) s'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (clarsimp cong: option.case_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s).\n         is_mw_Mutate x} =\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s').\n         is_mw_Mutate x};\n        \\<forall>x.\n           obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x s =\n           marked x s'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x2 \\<Rightarrow>\n                                    case obj_fields x2 f of\n                                    None \\<Rightarrow> True\n                                    | Some r' \\<Rightarrow> marked r' s'\n                              | _ \\<Rightarrow> True)) =\n                         (\\<forall>x.\n                             x \\<in> set\n(sys_mem_store_buffers (mutator m) s') \\<longrightarrow>\n                             (case x of\n                              mw_Mutate r f opt_r' \\<Rightarrow>\n                                case sys_heap s' r of\n                                None \\<Rightarrow> False\n                                | Some x2 \\<Rightarrow>\n                                    case obj_fields x2 f of\n                                    None \\<Rightarrow> True\n                                    | Some r' \\<Rightarrow> marked r' s'\n                              | _ \\<Rightarrow> True))\n 2. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        set (filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)) =\n        set (filter is_mw_Mutate\n              (sys_mem_store_buffers (mutator m) s'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply (rule iffI; clarsimp simp: set_eq_iff split: option.splits mem_store_action.splits; blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        set (filter is_mw_Mutate (sys_mem_store_buffers (mutator m) s)) =\n        set (filter is_mw_Mutate\n              (sys_mem_store_buffers (mutator m) s'))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x. marked x s = marked x s'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s).\n         is_mw_Mutate x} =\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s').\n         is_mw_Mutate x}\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x\n                          s =\n                         marked x s'", "apply (rename_tac s s' x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        \\<forall>x.\n           map_option obj_fields (sys_heap s x) =\n           map_option obj_fields (sys_heap s' x);\n        \\<forall>x.\n           map_option obj_mark (sys_heap s x) =\n           map_option obj_mark (sys_heap s' x);\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s).\n         is_mw_Mutate x} =\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s').\n         is_mw_Mutate x}\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x\n                          s =\n                         marked x s'", "apply (drule_tac x=x in spec)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' x.\n       \\<lbrakk>sys_fM s = sys_fM s';\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s).\n         is_mw_Mutate x} =\n        {x \\<in> set (sys_mem_store_buffers (mutator m) s').\n         is_mw_Mutate x};\n        map_option obj_fields (sys_heap s x) =\n        map_option obj_fields (sys_heap s' x);\n        map_option obj_mark (sys_heap s x) =\n        map_option obj_mark (sys_heap s' x)\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>obj. obj_mark obj = sys_fM s') x\n                          s =\n                         marked x s'", "apply (force split: obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas marked_deletions_fun_upd[simp] = eq_imp_fun_upd[OF mut_m.marked_deletions_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma marked_deletions_store_buffer_empty[intro]:\n  \"tso_pending_mutate (mutator m) s = [] \\<Longrightarrow> mut_m.marked_deletions m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n     (sys_mem_store_buffers (mutator m) s) =\n    [] \\<Longrightarrow>\n    mut_m.marked_deletions m s", "unfolding mut_m.marked_deletions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>s. is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n     (sys_mem_store_buffers (mutator m) s) =\n    [] \\<Longrightarrow>\n    \\<forall>x.\n       x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n       marked_deletion x s", "by (auto simp: filter_empty_conv split: mem_store_action.splits)"], ["", "subsection\\<open>Location-specific simplification rules\\<close>"], ["", "lemma obj_at_ref_sweep_loop_free[simp]:\n  \"obj_at P r (s(sys := (s sys)\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) \\<longleftrightarrow> obj_at P r s \\<and> r \\<noteq> r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at P r\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) =\n    (obj_at P r s \\<and> r \\<noteq> r')", "by (clarsimp simp: fun_upd_apply split: obj_at_splits)"], ["", "lemma obj_at_alloc[simp]:\n  \"sys_heap s r' = None\n  \\<Longrightarrow> obj_at P r (s(m := mut_m_s', sys := (s sys)\\<lparr> heap := sys_heap s(r' \\<mapsto> obj) \\<rparr>))\n  \\<longleftrightarrow> (obj_at P r s \\<or> (r = r' \\<and> P obj))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_heap s r' = None \\<Longrightarrow>\n    obj_at P r\n     (s(m := mut_m_s',\n        sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> obj)\\<rparr>)) =\n    (obj_at P r s \\<or> r = r' \\<and> P obj)", "unfolding ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_heap s r' = None \\<Longrightarrow>\n    obj_at P r\n     (s(m := mut_m_s',\n        sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> obj)\\<rparr>)) =\n    (obj_at P r s \\<or> r = r' \\<and> P obj)", "by (simp add: fun_upd_apply split: obj_at_splits)"], ["", "lemma valid_ref_valid_null_ref_simps[simp]:\n  \"valid_ref r (s(sys := do_store_action w (s sys)\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<longleftrightarrow> valid_ref r s\"\n  \"valid_null_ref r' (s(sys := do_store_action w (s sys)\\<lparr>mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<longleftrightarrow> valid_null_ref r' s\"\n  \"valid_null_ref r' (s(mutator m := mut_s', sys := (s sys)\\<lparr> heap := (heap (s sys))(r'' \\<mapsto> obj) \\<rparr>)) \\<longleftrightarrow> valid_null_ref r' s \\<or> r' = Some r''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>s. True) r\n     (s(sys := do_store_action w (s sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                    (p := ws)\\<rparr>)) =\n    obj_at (\\<lambda>s. True) r s &&&\n    valid_null_ref r'\n     (s(sys := do_store_action w (s sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                    (p := ws)\\<rparr>)) =\n    valid_null_ref r' s &&&\n    valid_null_ref r'\n     (s(mutator m := mut_s',\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r'' \\<mapsto> obj)\\<rparr>)) =\n    (valid_null_ref r' s \\<or> r' = Some r'')", "unfolding do_store_action_def valid_null_ref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>s. True) r\n     (s(sys :=\n          (case w of\n           mw_Mark r gc_mark \\<Rightarrow> s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (obj_mark_update (\\<lambda>_. gc_mark))\n                              (sys_heap s r))\\<rparr>\n           | mw_Mutate r f new_r \\<Rightarrow> s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_fields := (obj_fields obj)\n        (f := new_r)\\<rparr>)\n                                (sys_heap s r))\\<rparr>\n           | mw_Mutate_Payload r f pl \\<Rightarrow> s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_payload := (obj_payload obj)\n        (f := pl)\\<rparr>)\n                                (sys_heap s r))\\<rparr>\n           | mw_fA gc_mark \\<Rightarrow> s sys\\<lparr>fA := gc_mark\\<rparr>\n           | mw_fM gc_mark \\<Rightarrow> s sys\\<lparr>fM := gc_mark\\<rparr>\n           | mw_Phase gc_phase \\<Rightarrow> s sys\n               \\<lparr>phase := gc_phase\\<rparr>)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                    (p := ws)\\<rparr>)) =\n    obj_at (\\<lambda>s. True) r s &&&\n    (case r' of None \\<Rightarrow> \\<lambda>s. True\n     | Some r' \\<Rightarrow> obj_at (\\<lambda>s. True) r')\n     (s(sys :=\n          (case w of\n           mw_Mark r gc_mark \\<Rightarrow> s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (obj_mark_update (\\<lambda>_. gc_mark))\n                              (sys_heap s r))\\<rparr>\n           | mw_Mutate r f new_r \\<Rightarrow> s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_fields := (obj_fields obj)\n        (f := new_r)\\<rparr>)\n                                (sys_heap s r))\\<rparr>\n           | mw_Mutate_Payload r f pl \\<Rightarrow> s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_payload := (obj_payload obj)\n        (f := pl)\\<rparr>)\n                                (sys_heap s r))\\<rparr>\n           | mw_fA gc_mark \\<Rightarrow> s sys\\<lparr>fA := gc_mark\\<rparr>\n           | mw_fM gc_mark \\<Rightarrow> s sys\\<lparr>fM := gc_mark\\<rparr>\n           | mw_Phase gc_phase \\<Rightarrow> s sys\n               \\<lparr>phase := gc_phase\\<rparr>)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                    (p := ws)\\<rparr>)) =\n    (case r' of None \\<Rightarrow> \\<lambda>s. True\n     | Some r' \\<Rightarrow> obj_at (\\<lambda>s. True) r')\n     s &&&\n    (case r' of None \\<Rightarrow> \\<lambda>s. True\n     | Some r' \\<Rightarrow> obj_at (\\<lambda>s. True) r')\n     (s(mutator m := mut_s',\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r'' \\<mapsto> obj)\\<rparr>)) =\n    ((case r' of None \\<Rightarrow> \\<lambda>s. True\n      | Some r' \\<Rightarrow> obj_at (\\<lambda>s. True) r')\n      s \\<or>\n     r' = Some r'')", "by (auto simp: fun_upd_apply\n        split: mem_store_action.splits obj_at_splits option.splits)"], ["", "context mut_m\nbegin"], ["", "lemma reachable_load[simp]:\n  assumes \"sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'\"\n  assumes \"r \\<in> mut_roots s\"\n  shows \"mut_m.reachable m' y (s(mutator m := s (mutator m)\\<lparr> roots := mut_roots s \\<union> Option.set_option r' \\<rparr>)) \\<longleftrightarrow> mut_m.reachable m' y s\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n    mut_m.reachable m' y s", "proof(cases \"m' = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m' = m \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n    mut_m.reachable m' y s\n 2. m' \\<noteq> m \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n    mut_m.reachable m' y s", "case True"], ["proof (state)\nthis:\n  m' = m\n\ngoal (2 subgoals):\n 1. m' = m \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n    mut_m.reachable m' y s\n 2. m' \\<noteq> m \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n    mut_m.reachable m' y s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n    mut_m.reachable m' y s", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots :=\n                    mut_roots s \\<union>\n                    set_option r'\\<rparr>)) \\<Longrightarrow>\n    mut_m.reachable m' y s\n 2. mut_m.reachable m' y s \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "assume ?lhs"], ["proof (state)\nthis:\n  mut_m.reachable m' y\n   (s(mutator m := s (mutator m)\n        \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))\n\ngoal (2 subgoals):\n 1. mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots :=\n                    mut_roots s \\<union>\n                    set_option r'\\<rparr>)) \\<Longrightarrow>\n    mut_m.reachable m' y s\n 2. mut_m.reachable m' y s \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "with assms True"], ["proof (chain)\npicking this:\n  sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'\n  r \\<in> mut_roots s\n  m' = m\n  mut_m.reachable m' y\n   (s(mutator m := s (mutator m)\n        \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "show ?rhs"], ["proof (prove)\nusing this:\n  sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'\n  r \\<in> mut_roots s\n  m' = m\n  mut_m.reachable m' y\n   (s(mutator m := s (mutator m)\n        \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))\n\ngoal (1 subgoal):\n 1. mut_m.reachable m' y s", "unfolding sys_load_def"], ["proof (prove)\nusing this:\n  (do_load_action (mr_Ref r f) \\<circ>\n   processors_view_of_memory (mutator m))\n   (s sys) =\n  mv_Ref r'\n  r \\<in> mut_roots s\n  m' = m\n  mut_m.reachable m' y\n   (s(mutator m := s (mutator m)\n        \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))\n\ngoal (1 subgoal):\n 1. mut_m.reachable m' y s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> mut_roots s; m' = m;\n     reachable y\n      (s(mutator m := s (mutator m)\n           \\<lparr>roots :=\n                     mut_roots s \\<union>\n                     (\\<Union>x\\<in>set_option\n                                     (heap\n (processors_view_of_memory (mutator m) (s sys)) r).\n                         set_option (obj_fields x f))\\<rparr>));\n     r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f)\\<rbrakk>\n    \\<Longrightarrow> reachable y s", "apply (clarsimp simp: reachable_def reaches_def tso_store_refs_def sys_load_def fold_stores_def fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        x \\<in> mut_roots s \\<or>\n        (\\<exists>xa\\<in>set_option\n                          (heap\n                            (fold\n                              (\\<lambda>w. (\\<circ>) (do_store_action w))\n                              (sys_mem_store_buffers (mutator m) s) id\n                              (s sys))\n                            r).\n            obj_fields xa f = Some x) \\<or>\n        x \\<in> mut_ghost_honorary_root s \\<or>\n        (\\<exists>xa\\<in>set (sys_mem_store_buffers (mutator m) s).\n            x \\<in> (case xa of\n                     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                     | _ \\<Rightarrow> {}));\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply (elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> mut_roots s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set_option\n                         (heap\n                           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                             (sys_mem_store_buffers (mutator m) s) id\n                             (s sys))\n                           r).\n           obj_fields xa f = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 3. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> mut_ghost_honorary_root s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 4. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set (sys_mem_store_buffers (mutator m) s).\n           x \\<in> (case xa of\n                    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                    | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set_option\n                         (heap\n                           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                             (sys_mem_store_buffers (mutator m) s) id\n                             (s sys))\n                           r).\n           obj_fields xa f = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> mut_ghost_honorary_root s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 3. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set (sys_mem_store_buffers (mutator m) s).\n           x \\<in> (case xa of\n                    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                    | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> mut_ghost_honorary_root s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set (sys_mem_store_buffers (mutator m) s).\n           x \\<in> (case xa of\n                    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                    | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 3. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set_option\n                         (heap\n                           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                             (sys_mem_store_buffers (mutator m) s) id\n                             (s sys))\n                           r).\n           obj_fields xa f = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set (sys_mem_store_buffers (mutator m) s).\n           x \\<in> (case xa of\n                    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                    | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set_option\n                         (heap\n                           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                             (sys_mem_store_buffers (mutator m) s) id\n                             (s sys))\n                           r).\n           obj_fields xa f = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set_option\n                         (heap\n                           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                             (sys_mem_store_buffers (mutator m) s) id\n                             (s sys))\n                           r).\n           obj_fields xa f = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply (fold fold_stores_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m;\n        r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        \\<exists>xa\\<in>set_option\n                         (heap\n                           (processors_view_of_memory (mutator m) (s sys))\n                           r).\n           obj_fields xa f = Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m; r' = Some x;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields xa f = Some x;\n        heap (processors_view_of_memory (mutator m) (s sys)) r =\n        Some xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply (drule (1) fold_stores_points_to)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m; r' = Some x;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields xa f = Some x;\n        (r points_to x) s \\<or>\n        (\\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n            x \\<in> store_refs w)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m; r' = Some x;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields xa f = Some x; (r points_to x) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m; r' = Some x;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields xa f = Some x;\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n           x \\<in> store_refs w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply (fastforce elim!: converse_rtranclp_into_rtranclp[rotated] split: obj_at_splits intro!: ranI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m; r' = Some x;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields xa f = Some x;\n        \\<exists>w\\<in>set (sys_mem_store_buffers (mutator m) s).\n           x \\<in> store_refs w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 x \\<in> (case xa of\n    mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n    | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n    | _ \\<Rightarrow> {}))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply (clarsimp split: mem_store_action.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa w.\n       \\<lbrakk>r \\<in> mut_roots s; m' = m; r' = Some x;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields xa f = Some x;\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        \\<forall>x11 x12. w \\<noteq> mw_Mark x11 x12;\n        \\<forall>x21 x22 x23.\n           w = mw_Mutate x21 x22 x23 \\<longrightarrow>\n           x = x21 \\<or> x23 = Some x;\n        \\<forall>x31.\n           (\\<forall>x32 x33.\n               w \\<noteq> mw_Mutate_Payload x31 x32 x33) \\<or>\n           x = x31;\n        \\<forall>x4. w \\<noteq> mw_fA x4; \\<forall>x5. w \\<noteq> mw_fM x5;\n        \\<forall>x6. w \\<noteq> mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             (\\<exists>xa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 (\\<forall>x11 x12.\n                                     xa \\<noteq> mw_Mark x11 x12) \\<and>\n                                 (\\<forall>x21 x22 x23.\n                                     xa =\n                                     mw_Mutate x21 x22 x23 \\<longrightarrow>\n                                     x = x21 \\<or> x23 = Some x) \\<and>\n                                 (\\<forall>x31.\n                                     (\\<exists>x32 x33.\n   xa = mw_Mutate_Payload x31 x32 x33) \\<longrightarrow>\n                                     x = x31) \\<and>\n                                 (\\<forall>x4. xa \\<noteq> mw_fA x4) \\<and>\n                                 (\\<forall>x5. xa \\<noteq> mw_fM x5) \\<and>\n                                 (\\<forall>x6.\n                                     xa \\<noteq> mw_Phase x6))) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y", "apply meson"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mut_m.reachable m' y s\n\ngoal (1 subgoal):\n 1. mut_m.reachable m' y s \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mut_m.reachable m' y s \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "assume ?rhs"], ["proof (state)\nthis:\n  mut_m.reachable m' y s\n\ngoal (1 subgoal):\n 1. mut_m.reachable m' y s \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "with True"], ["proof (chain)\npicking this:\n  m' = m\n  mut_m.reachable m' y s", "show ?lhs"], ["proof (prove)\nusing this:\n  m' = m\n  mut_m.reachable m' y s\n\ngoal (1 subgoal):\n 1. mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "unfolding mut_m.reachable_def"], ["proof (prove)\nusing this:\n  m' = m\n  \\<exists>x.\n     x \\<in> roots (s (mutator m')) \\<union>\n             ghost_honorary_root (s (mutator m')) \\<union>\n             mut_m.tso_store_refs m' s \\<and>\n     (x reaches y) s\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> roots\n                ((s(mutator m := s (mutator m)\n                      \\<lparr>roots :=\n                                mut_roots s \\<union> set_option r'\\<rparr>))\n                  (mutator m')) \\<union>\n               ghost_honorary_root\n                ((s(mutator m := s (mutator m)\n                      \\<lparr>roots :=\n                                mut_roots s \\<union> set_option r'\\<rparr>))\n                  (mutator m')) \\<union>\n               mut_m.tso_store_refs m'\n                (s(mutator m := s (mutator m)\n                     \\<lparr>roots :=\n                               mut_roots s \\<union>\n                               set_option r'\\<rparr>)) \\<and>\n       (x reaches y)\n        (s(mutator m := s (mutator m)\n             \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))", "by (fastforce simp: fun_upd_apply)"], ["proof (state)\nthis:\n  mut_m.reachable m' y\n   (s(mutator m := s (mutator m)\n        \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mut_m.reachable m' y\n   (s(mutator m := s (mutator m)\n        \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n  mut_m.reachable m' y s\n\ngoal (1 subgoal):\n 1. m' \\<noteq> m \\<Longrightarrow>\n    mut_m.reachable m' y\n     (s(mutator m := s (mutator m)\n          \\<lparr>roots := mut_roots s \\<union> set_option r'\\<rparr>)) =\n    mut_m.reachable m' y s", "qed (simp add: fun_upd_apply)"], ["", "end"], ["", "text\\<open>WL\\<close>"], ["", "lemma WL_blacken[simp]:\n  \"gc_ghost_honorary_grey s = {}\n    \\<Longrightarrow> WL p (s(gc := s gc\\<lparr> W := gc_W s - rs \\<rparr>)) = WL p s - { r |r. p = gc \\<and> r \\<in> rs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gc_ghost_honorary_grey s = {} \\<Longrightarrow>\n    WL p (s(gc := s gc\\<lparr>W := gc_W s - rs\\<rparr>)) =\n    WL p s - {r |r. p = gc \\<and> r \\<in> rs}", "unfolding WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gc_ghost_honorary_grey s = {} \\<Longrightarrow>\n    W ((s(gc := s gc\\<lparr>W := gc_W s - rs\\<rparr>)) p) \\<union>\n    ghost_honorary_grey\n     ((s(gc := s gc\\<lparr>W := gc_W s - rs\\<rparr>)) p) =\n    W (s p) \\<union> ghost_honorary_grey (s p) -\n    {r |r. p = gc \\<and> r \\<in> rs}", "by (auto simp: fun_upd_apply)"], ["", "lemma WL_hs_done[simp]:\n  \"ghost_honorary_grey (s (mutator m)) = {}\n     \\<Longrightarrow> WL p (s(mutator m := s (mutator m)\\<lparr> W := {}, ghost_hs_phase := hp' \\<rparr>,\n                 sys   := s sys\\<lparr> hs_pending := hsp', W := sys_W s \\<union> W (s (mutator m)),\n                                 ghost_hs_in_sync := in' \\<rparr>))\n      = (case p of gc \\<Rightarrow> WL gc s | mutator m' \\<Rightarrow> (if m' = m then {} else WL (mutator m') s) | sys \\<Rightarrow> WL sys s \\<union> WL (mutator m) s)\"\n  \"ghost_honorary_grey (s (mutator m)) = {}\n     \\<Longrightarrow> WL p (s(mutator m := s (mutator m)\\<lparr> W := {} \\<rparr>,\n                 sys   := s sys\\<lparr> hs_pending := hsp', W := sys_W s \\<union> W (s (mutator m)),\n                                 ghost_hs_in_sync := in' \\<rparr>))\n      = (case p of gc \\<Rightarrow> WL gc s | mutator m' \\<Rightarrow> (if m' = m then {} else WL (mutator m') s) | sys \\<Rightarrow> WL sys s \\<union> WL (mutator m) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ghost_honorary_grey (s (mutator m)) = {} \\<Longrightarrow>\n     WL p\n      (s(mutator m := s (mutator m)\n           \\<lparr>W := {}, ghost_hs_phase := hp'\\<rparr>,\n         sys := s sys\n           \\<lparr>hs_pending := hsp',\n              W := sys_W s \\<union> W (s (mutator m)),\n              ghost_hs_in_sync := in'\\<rparr>)) =\n     (case p of\n      mutator m' \\<Rightarrow> if m' = m then {} else WL (mutator m') s\n      | gc \\<Rightarrow> WL gc s\n      | sys \\<Rightarrow> WL sys s \\<union> WL (mutator m) s)) &&&\n    (ghost_honorary_grey (s (mutator m)) = {} \\<Longrightarrow>\n     WL p\n      (s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s sys\n           \\<lparr>hs_pending := hsp',\n              W := sys_W s \\<union> W (s (mutator m)),\n              ghost_hs_in_sync := in'\\<rparr>)) =\n     (case p of\n      mutator m' \\<Rightarrow> if m' = m then {} else WL (mutator m') s\n      | gc \\<Rightarrow> WL gc s\n      | sys \\<Rightarrow> WL sys s \\<union> WL (mutator m) s))", "unfolding WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ghost_honorary_grey (s (mutator m)) = {} \\<Longrightarrow>\n     W ((s(mutator m := s (mutator m)\n             \\<lparr>W := {}, ghost_hs_phase := hp'\\<rparr>,\n           sys := s sys\n             \\<lparr>hs_pending := hsp',\n                W := sys_W s \\<union> W (s (mutator m)),\n                ghost_hs_in_sync := in'\\<rparr>))\n         p) \\<union>\n     ghost_honorary_grey\n      ((s(mutator m := s (mutator m)\n            \\<lparr>W := {}, ghost_hs_phase := hp'\\<rparr>,\n          sys := s sys\n            \\<lparr>hs_pending := hsp',\n               W := sys_W s \\<union> W (s (mutator m)),\n               ghost_hs_in_sync := in'\\<rparr>))\n        p) =\n     (case p of\n      mutator m' \\<Rightarrow>\n        if m' = m then {}\n        else W (s (mutator m')) \\<union>\n             ghost_honorary_grey (s (mutator m'))\n      | gc \\<Rightarrow> gc_W s \\<union> gc_ghost_honorary_grey s\n      | sys \\<Rightarrow>\n          sys_W s \\<union> sys_ghost_honorary_grey s \\<union>\n          (W (s (mutator m)) \\<union>\n           ghost_honorary_grey (s (mutator m))))) &&&\n    (ghost_honorary_grey (s (mutator m)) = {} \\<Longrightarrow>\n     W ((s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n           sys := s sys\n             \\<lparr>hs_pending := hsp',\n                W := sys_W s \\<union> W (s (mutator m)),\n                ghost_hs_in_sync := in'\\<rparr>))\n         p) \\<union>\n     ghost_honorary_grey\n      ((s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n          sys := s sys\n            \\<lparr>hs_pending := hsp',\n               W := sys_W s \\<union> W (s (mutator m)),\n               ghost_hs_in_sync := in'\\<rparr>))\n        p) =\n     (case p of\n      mutator m' \\<Rightarrow>\n        if m' = m then {}\n        else W (s (mutator m')) \\<union>\n             ghost_honorary_grey (s (mutator m'))\n      | gc \\<Rightarrow> gc_W s \\<union> gc_ghost_honorary_grey s\n      | sys \\<Rightarrow>\n          sys_W s \\<union> sys_ghost_honorary_grey s \\<union>\n          (W (s (mutator m)) \\<union> ghost_honorary_grey (s (mutator m)))))", "by (auto simp: fun_upd_apply split: process_name.splits)"], ["", "lemma colours_load_W[iff]:\n  \"gc_W s = {} \\<Longrightarrow> black r (s(gc := (s gc)\\<lparr>W := W (s sys)\\<rparr>, sys := (s sys)\\<lparr>W := {}\\<rparr>)) \\<longleftrightarrow> black r s\"\n  \"gc_W s = {} \\<Longrightarrow> grey r (s(gc := (s gc)\\<lparr>W := W (s sys)\\<rparr>, sys := (s sys)\\<lparr>W := {}\\<rparr>)) \\<longleftrightarrow> grey r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gc_W s = {} \\<Longrightarrow>\n     black r\n      (s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n         sys := s sys\\<lparr>W := {}\\<rparr>)) =\n     black r s) &&&\n    (gc_W s = {} \\<Longrightarrow>\n     grey r\n      (s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n         sys := s sys\\<lparr>W := {}\\<rparr>)) =\n     grey r s)", "unfolding black_def grey_def WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gc_W s = {} \\<Longrightarrow>\n     (marked r\n       (s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n          sys := s sys\\<lparr>W := {}\\<rparr>)) \\<and>\n      (\\<nexists>x.\n          r \\<in> W ((s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n                        sys := s sys\\<lparr>W := {}\\<rparr>))\n                      x) \\<union>\n                  ghost_honorary_grey\n                   ((s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n                       sys := s sys\\<lparr>W := {}\\<rparr>))\n                     x))) =\n     (marked r s \\<and>\n      (\\<nexists>x.\n          r \\<in> W (s x) \\<union> ghost_honorary_grey (s x)))) &&&\n    (gc_W s = {} \\<Longrightarrow>\n     (\\<exists>x.\n         r \\<in> W ((s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n                       sys := s sys\\<lparr>W := {}\\<rparr>))\n                     x) \\<union>\n                 ghost_honorary_grey\n                  ((s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n                      sys := s sys\\<lparr>W := {}\\<rparr>))\n                    x)) =\n     (\\<exists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x)))", "apply (simp_all add: fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gc_W s = {} \\<Longrightarrow>\n    (marked r s \\<and>\n     (\\<forall>x.\n         (x = gc \\<longrightarrow>\n          r \\<notin> sys_W s \\<and>\n          r \\<notin> gc_ghost_honorary_grey s) \\<and>\n         (x \\<noteq> gc \\<longrightarrow>\n          (x = sys \\<longrightarrow>\n           r \\<notin> sys_ghost_honorary_grey s) \\<and>\n          (x \\<noteq> sys \\<longrightarrow>\n           r \\<notin> W (s x) \\<and>\n           r \\<notin> ghost_honorary_grey (s x))))) =\n    (marked r s \\<and>\n     (\\<forall>x.\n         r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x)))\n 2. gc_W s = {} \\<Longrightarrow>\n    (\\<exists>x.\n        (x = gc \\<longrightarrow>\n         r \\<in> sys_W s \\<or> r \\<in> gc_ghost_honorary_grey s) \\<and>\n        (x \\<noteq> gc \\<longrightarrow>\n         (x = sys \\<longrightarrow>\n          r \\<in> sys_ghost_honorary_grey s) \\<and>\n         (x \\<noteq> sys \\<longrightarrow>\n          r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)))) =\n    (\\<exists>x. r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x))", "apply safe"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> W (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        r \\<in> sys_W s\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        r \\<in> gc_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        sys \\<noteq> gc; r \\<in> sys_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        x \\<noteq> gc; x \\<noteq> sys; r \\<in> W (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        x \\<noteq> gc; x \\<noteq> sys;\n        r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>gc_W s = {}; x \\<noteq> gc; x \\<noteq> sys;\n        r \\<in> W (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            r \\<in> W (s x) \\<or>\n                            r \\<in> ghost_honorary_grey (s x)\n 9. \\<And>x.\n       \\<lbrakk>gc_W s = {}; x \\<noteq> gc; x \\<noteq> sys;\n        r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            r \\<in> W (s x) \\<or>\n                            r \\<in> ghost_honorary_grey (s x)\n 10. \\<And>x.\n        \\<lbrakk>gc_W s = {}; sys \\<noteq> gc;\n         r \\<in> sys_ghost_honorary_grey s;\n         \\<nexists>x.\n            r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 26 subgoals...", "apply (case_tac [!] x)"], ["proof (prove)\ngoal (78 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> W (s x); x = mutator x1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> W (s x); x = gc\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> W (s x); x = sys\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x x1.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> ghost_honorary_grey (s x); x = mutator x1\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> ghost_honorary_grey (s x); x = gc\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           (x = gc \\<longrightarrow>\n            r \\<notin> sys_W s \\<and>\n            r \\<notin> gc_ghost_honorary_grey s) \\<and>\n           (x \\<noteq> gc \\<longrightarrow>\n            (x = sys \\<longrightarrow>\n             r \\<notin> sys_ghost_honorary_grey s) \\<and>\n            (x \\<noteq> sys \\<longrightarrow>\n             r \\<notin> W (s x) \\<and>\n             r \\<notin> ghost_honorary_grey (s x)));\n        r \\<in> ghost_honorary_grey (s x); x = sys\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x x1.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        r \\<in> sys_W s; x = mutator x1\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        r \\<in> sys_W s; x = gc\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x.\n       \\<lbrakk>gc_W s = {}; marked r s;\n        \\<forall>x.\n           r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n        r \\<in> sys_W s; x = sys\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x x1.\n        \\<lbrakk>gc_W s = {}; marked r s;\n         \\<forall>x.\n            r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x);\n         r \\<in> gc_ghost_honorary_grey s; x = mutator x1\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 78 subgoals...", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WL_load_W[simp]:\n  \"gc_W s = {}\n    \\<Longrightarrow> (WL p (s(gc := (s gc)\\<lparr>W := sys_W s\\<rparr>, sys := (s sys)\\<lparr>W := {}\\<rparr>)))\n     = (case p of gc \\<Rightarrow> WL gc s \\<union> sys_W s | mutator m \\<Rightarrow> WL (mutator m) s | sys \\<Rightarrow> sys_ghost_honorary_grey s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gc_W s = {} \\<Longrightarrow>\n    WL p\n     (s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n        sys := s sys\\<lparr>W := {}\\<rparr>)) =\n    (case p of mutator m \\<Rightarrow> WL (mutator m) s\n     | gc \\<Rightarrow> WL gc s \\<union> sys_W s\n     | sys \\<Rightarrow> sys_ghost_honorary_grey s)", "unfolding WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gc_W s = {} \\<Longrightarrow>\n    W ((s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n          sys := s sys\\<lparr>W := {}\\<rparr>))\n        p) \\<union>\n    ghost_honorary_grey\n     ((s(gc := s gc\\<lparr>W := sys_W s\\<rparr>,\n         sys := s sys\\<lparr>W := {}\\<rparr>))\n       p) =\n    (case p of\n     mutator m \\<Rightarrow>\n       W (s (mutator m)) \\<union> ghost_honorary_grey (s (mutator m))\n     | gc \\<Rightarrow>\n         gc_W s \\<union> gc_ghost_honorary_grey s \\<union> sys_W s\n     | sys \\<Rightarrow> sys_ghost_honorary_grey s)", "by (auto simp: fun_upd_apply split: process_name.splits)"], ["", "text\\<open>no grey refs\\<close>"], ["", "lemma no_grey_refs_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit). (\\<lambda>s. \\<Union>p. WL p s))\n          no_grey_refs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp (\\<lambda>_ s. \\<Union>p. WL p s) no_grey_refs", "by (auto simp add: eq_imp_def grey_def no_grey_refs_def set_eq_iff)"], ["", "lemmas no_grey_refs_fun_upd[simp] = eq_imp_fun_upd[OF no_grey_refs_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "lemma no_grey_refs_no_pending_marks:\n  \"\\<lbrakk> no_grey_refs s; valid_W_inv s \\<rbrakk> \\<Longrightarrow> tso_no_pending_marks s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_grey_refs s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         filter is_mw_Mark (sys_mem_store_buffers x s) = []", "unfolding no_grey_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. \\<not> grey x s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         filter is_mw_Mark (sys_mem_store_buffers x s) = []", "by (auto intro!: filter_False dest: valid_W_invD(2))"], ["", "lemma no_grey_refs_not_grey_reachableD:\n  \"no_grey_refs s \\<Longrightarrow> \\<not>grey_reachable x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_grey_refs s \\<Longrightarrow> \\<not> grey_reachable x s", "by (clarsimp simp: no_grey_refs_def grey_reachable_def)"], ["", "lemma no_grey_refsD:\n  \"no_grey_refs s \\<Longrightarrow> r \\<notin> W (s p)\"\n  \"no_grey_refs s \\<Longrightarrow> r \\<notin> WL p s\"\n  \"no_grey_refs s \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (no_grey_refs s \\<Longrightarrow> r \\<notin> W (s p)) &&&\n    (no_grey_refs s \\<Longrightarrow> r \\<notin> WL p s) &&&\n    (no_grey_refs s \\<Longrightarrow> r \\<notin> ghost_honorary_grey (s p))", "by (auto simp: no_grey_refs_def)"], ["", "lemma no_grey_refs_marked[dest]:\n  \"\\<lbrakk> marked r s; no_grey_refs s \\<rbrakk> \\<Longrightarrow> black r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>marked r s; no_grey_refs s\\<rbrakk> \\<Longrightarrow> black r s", "by (auto simp: no_grey_refs_def black_def)"], ["", "lemma no_grey_refs_bwD[dest]:\n  \"\\<lbrakk> heap (s sys) r = Some obj; no_grey_refs s \\<rbrakk> \\<Longrightarrow> black r s \\<or> white r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_heap s r = Some obj; no_grey_refs s\\<rbrakk>\n    \\<Longrightarrow> black r s \\<or> white r s", "by (clarsimp simp: black_def grey_def no_grey_refs_def white_def split: obj_at_splits)"], ["", "context mut_m\nbegin"], ["", "lemma reachable_blackD:\n  \"\\<lbrakk> no_grey_refs s; reachable_snapshot_inv s; reachable r s \\<rbrakk> \\<Longrightarrow> black r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_grey_refs s; reachable_snapshot_inv s;\n     reachable r s\\<rbrakk>\n    \\<Longrightarrow> black r s", "by (simp add: no_grey_refs_def reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def)"], ["", "lemma no_grey_refs_not_reachable:\n  \"\\<lbrakk> no_grey_refs s; reachable_snapshot_inv s; white r s \\<rbrakk> \\<Longrightarrow> \\<not>reachable r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_grey_refs s; reachable_snapshot_inv s; white r s\\<rbrakk>\n    \\<Longrightarrow> \\<not> reachable r s", "by (fastforce simp: no_grey_refs_def reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def\n             split: obj_at_splits)"], ["", "lemma no_grey_refs_not_rootD:\n  \"\\<lbrakk> no_grey_refs s; reachable_snapshot_inv s; white r s \\<rbrakk>\n     \\<Longrightarrow> r \\<notin> mut_roots s \\<and> r \\<notin> mut_ghost_honorary_root s \\<and> r \\<notin> tso_store_refs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_grey_refs s; reachable_snapshot_inv s; white r s\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> mut_roots s \\<and>\n                      r \\<notin> mut_ghost_honorary_root s \\<and>\n                      r \\<notin> tso_store_refs s", "apply (drule (2) no_grey_refs_not_reachable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable_snapshot_inv s; white r s;\n     \\<not> reachable r s\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> mut_roots s \\<and>\n                      r \\<notin> mut_ghost_honorary_root s \\<and>\n                      r \\<notin> tso_store_refs s", "apply (force simp: reachable_def reaches_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reachable_snapshot_inv_white_root:\n  \"\\<lbrakk> white w s; w \\<in> mut_roots s \\<or> w \\<in> mut_ghost_honorary_root s; reachable_snapshot_inv s \\<rbrakk> \\<Longrightarrow> \\<exists>g. (g grey_protects_white w) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>white w s;\n     w \\<in> mut_roots s \\<or> w \\<in> mut_ghost_honorary_root s;\n     reachable_snapshot_inv s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>g. (g grey_protects_white w) s", "unfolding reachable_snapshot_inv_def in_snapshot_def reachable_def grey_protects_white_def reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>white w s;\n     w \\<in> mut_roots s \\<or> w \\<in> mut_ghost_honorary_root s;\n     \\<forall>x.\n        (\\<exists>xa.\n            xa \\<in> mut_roots s \\<union> mut_ghost_honorary_root s \\<union>\n                     tso_store_refs s \\<and>\n            (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa\n             x) \\<longrightarrow>\n        black x s \\<or>\n        (\\<exists>xa. grey xa s \\<and> (xa has_white_path_to x) s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>g. grey g s \\<and> (g has_white_path_to w) s", "by auto"], ["", "end"], ["", "(* colours *)"], ["", "lemma black_dequeue_Mark[simp]:\n  \"black b (s(sys := (s sys)\\<lparr> heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws) \\<rparr>))\n\\<longleftrightarrow> (black b s \\<and> b \\<noteq> r) \\<or> (b = r \\<and> fl = sys_fM s \\<and> valid_ref r s \\<and> \\<not>grey r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. black b\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (p := ws)\\<rparr>)) =\n    (black b s \\<and> b \\<noteq> r \\<or>\n     b = r \\<and>\n     fl = sys_fM s \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and> \\<not> grey r s)", "unfolding black_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (marked b\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (p := ws)\\<rparr>)) \\<and>\n     \\<not> grey b\n             (s(sys := s sys\n                  \\<lparr>heap := (sys_heap s)\n                            (r := map_option\n                                   (obj_mark_update (\\<lambda>_. fl))\n                                   (sys_heap s r)),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (p := ws)\\<rparr>))) =\n    ((marked b s \\<and> \\<not> grey b s) \\<and> b \\<noteq> r \\<or>\n     b = r \\<and>\n     fl = sys_fM s \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and> \\<not> grey r s)", "by (auto simp: fun_upd_apply split: obj_at_splits)"], ["", "lemma colours_sweep_loop_free[iff]:\n  \"black r (s(sys := s sys\\<lparr>heap := (heap (s sys))(r' := None)\\<rparr>)) \\<longleftrightarrow> (black r s \\<and> r \\<noteq> r')\"\n  \"grey r (s(sys := s sys\\<lparr>heap := (heap (s sys))(r' := None)\\<rparr>)) \\<longleftrightarrow> (grey r s)\"\n  \"white r (s(sys := s sys\\<lparr>heap := (heap (s sys))(r' := None)\\<rparr>)) \\<longleftrightarrow> (white r s \\<and> r \\<noteq> r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. black r\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) =\n    (black r s \\<and> r \\<noteq> r') &&&\n    grey r\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) =\n    grey r s &&&\n    white r\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) =\n    (white r s \\<and> r \\<noteq> r')", "unfolding black_def grey_def white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (marked r\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) \\<and>\n     (\\<nexists>x.\n         r \\<in> WL x\n                  (s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r' := None)\\<rparr>)))) =\n    ((marked r s \\<and> (\\<nexists>x. r \\<in> WL x s)) \\<and>\n     r \\<noteq> r') &&&\n    (\\<exists>x.\n        r \\<in> WL x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))) =\n    (\\<exists>x. r \\<in> WL x s) &&&\n    obj_at\n     (\\<lambda>obj.\n         obj_mark obj \\<noteq>\n         sys_fM\n          (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)))\n     r (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) =\n    (obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r s \\<and>\n     r \\<noteq> r')", "by (auto simp: fun_upd_apply split: obj_at_splits)"], ["", "lemma colours_get_work_done[simp]:\n  \"black r (s(mutator m := (s (mutator m))\\<lparr>W := {}\\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> black r s\"\n  \"grey r (s(mutator m := (s (mutator m))\\<lparr>W := {}\\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> grey r s\"\n  \"white r (s(mutator m := (s (mutator m))\\<lparr>W := {}\\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> white r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. black r\n     (s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    black r s &&&\n    grey r\n     (s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    grey r s &&&\n    white r\n     (s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    white r s", "unfolding black_def grey_def WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (marked r\n      (s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s sys\n           \\<lparr>hs_pending := hp',\n              W := sys_W s \\<union> W (s (mutator m)),\n              ghost_hs_in_sync := his'\\<rparr>)) \\<and>\n     (\\<nexists>x.\n         r \\<in> W ((s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n                       sys := s sys\n                         \\<lparr>hs_pending := hp',\n                            W := sys_W s \\<union> W (s (mutator m)),\n                            ghost_hs_in_sync := his'\\<rparr>))\n                     x) \\<union>\n                 ghost_honorary_grey\n                  ((s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n                      sys := s sys\n                        \\<lparr>hs_pending := hp',\n                           W := sys_W s \\<union> W (s (mutator m)),\n                           ghost_hs_in_sync := his'\\<rparr>))\n                    x))) =\n    (marked r s \\<and>\n     (\\<nexists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x))) &&&\n    (\\<exists>x.\n        r \\<in> W ((s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n                      sys := s sys\n                        \\<lparr>hs_pending := hp',\n                           W := sys_W s \\<union> W (s (mutator m)),\n                           ghost_hs_in_sync := his'\\<rparr>))\n                    x) \\<union>\n                ghost_honorary_grey\n                 ((s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>hs_pending := hp',\n                          W := sys_W s \\<union> W (s (mutator m)),\n                          ghost_hs_in_sync := his'\\<rparr>))\n                   x)) =\n    (\\<exists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x)) &&&\n    white r\n     (s(mutator m := s (mutator m)\\<lparr>W := {}\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    white r s", "apply (simp_all add: fun_upd_apply split: obj_at_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>obj.\n       sys_heap s r = Some obj \\<longrightarrow>\n       (obj_mark obj = sys_fM s \\<and>\n        (\\<forall>x.\n            (x = mutator m \\<longrightarrow>\n             r \\<notin> ghost_honorary_grey (s (mutator m))) \\<and>\n            (x \\<noteq> mutator m \\<longrightarrow>\n             (x = sys \\<longrightarrow>\n              r \\<notin> sys_W s \\<and>\n              r \\<notin> W (s (mutator m)) \\<and>\n              r \\<notin> sys_ghost_honorary_grey s) \\<and>\n             (x \\<noteq> sys \\<longrightarrow>\n              r \\<notin> W (s x) \\<and>\n              r \\<notin> ghost_honorary_grey (s x))))) =\n       (obj_mark obj = sys_fM s \\<and>\n        (\\<forall>x.\n            r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x)))\n 2. (\\<exists>x.\n        (x = mutator m \\<longrightarrow>\n         r \\<in> ghost_honorary_grey (s (mutator m))) \\<and>\n        (x \\<noteq> mutator m \\<longrightarrow>\n         (x = sys \\<longrightarrow>\n          r \\<in> sys_W s \\<or>\n          r \\<in> W (s (mutator m)) \\<or>\n          r \\<in> sys_ghost_honorary_grey s) \\<and>\n         (x \\<noteq> sys \\<longrightarrow>\n          r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)))) =\n    (\\<exists>x. r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        (x = mutator m \\<longrightarrow>\n         r \\<in> ghost_honorary_grey (s (mutator m))) \\<and>\n        (x \\<noteq> mutator m \\<longrightarrow>\n         (x = sys \\<longrightarrow>\n          r \\<in> sys_W s \\<or>\n          r \\<in> W (s (mutator m)) \\<or>\n          r \\<in> sys_ghost_honorary_grey s) \\<and>\n         (x \\<noteq> sys \\<longrightarrow>\n          r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)))) =\n    (\\<exists>x. r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x))", "apply (metis process_name.distinct(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma colours_get_roots_done[simp]:\n  \"black r (s(mutator m := (s (mutator m))\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> black r s\"\n  \"grey r (s(mutator m := (s (mutator m))\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> grey r s\"\n  \"white r (s(mutator m := (s (mutator m))\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n              sys := (s sys)\\<lparr> hs_pending := hp', W := W (s sys) \\<union> W (s (mutator m)),\n                              ghost_hs_in_sync := his' \\<rparr>)) \\<longleftrightarrow> white r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. black r\n     (s(mutator m := s (mutator m)\n          \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    black r s &&&\n    grey r\n     (s(mutator m := s (mutator m)\n          \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    grey r s &&&\n    white r\n     (s(mutator m := s (mutator m)\n          \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    white r s", "unfolding black_def grey_def WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (marked r\n      (s(mutator m := s (mutator m)\n           \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n         sys := s sys\n           \\<lparr>hs_pending := hp',\n              W := sys_W s \\<union> W (s (mutator m)),\n              ghost_hs_in_sync := his'\\<rparr>)) \\<and>\n     (\\<nexists>x.\n         r \\<in> W ((s(mutator m := s (mutator m)\n                         \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n                       sys := s sys\n                         \\<lparr>hs_pending := hp',\n                            W := sys_W s \\<union> W (s (mutator m)),\n                            ghost_hs_in_sync := his'\\<rparr>))\n                     x) \\<union>\n                 ghost_honorary_grey\n                  ((s(mutator m := s (mutator m)\n                        \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n                      sys := s sys\n                        \\<lparr>hs_pending := hp',\n                           W := sys_W s \\<union> W (s (mutator m)),\n                           ghost_hs_in_sync := his'\\<rparr>))\n                    x))) =\n    (marked r s \\<and>\n     (\\<nexists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x))) &&&\n    (\\<exists>x.\n        r \\<in> W ((s(mutator m := s (mutator m)\n                        \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n                      sys := s sys\n                        \\<lparr>hs_pending := hp',\n                           W := sys_W s \\<union> W (s (mutator m)),\n                           ghost_hs_in_sync := his'\\<rparr>))\n                    x) \\<union>\n                ghost_honorary_grey\n                 ((s(mutator m := s (mutator m)\n                       \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n                     sys := s sys\n                       \\<lparr>hs_pending := hp',\n                          W := sys_W s \\<union> W (s (mutator m)),\n                          ghost_hs_in_sync := his'\\<rparr>))\n                   x)) =\n    (\\<exists>x. r \\<in> W (s x) \\<union> ghost_honorary_grey (s x)) &&&\n    white r\n     (s(mutator m := s (mutator m)\n          \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    white r s", "apply (simp_all add: fun_upd_apply split: obj_at_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>obj.\n       sys_heap s r = Some obj \\<longrightarrow>\n       (obj_mark obj = sys_fM s \\<and>\n        (\\<forall>x.\n            (x = mutator m \\<longrightarrow>\n             r \\<notin> ghost_honorary_grey (s (mutator m))) \\<and>\n            (x \\<noteq> mutator m \\<longrightarrow>\n             (x = sys \\<longrightarrow>\n              r \\<notin> sys_W s \\<and>\n              r \\<notin> W (s (mutator m)) \\<and>\n              r \\<notin> sys_ghost_honorary_grey s) \\<and>\n             (x \\<noteq> sys \\<longrightarrow>\n              r \\<notin> W (s x) \\<and>\n              r \\<notin> ghost_honorary_grey (s x))))) =\n       (obj_mark obj = sys_fM s \\<and>\n        (\\<forall>x.\n            r \\<notin> W (s x) \\<and> r \\<notin> ghost_honorary_grey (s x)))\n 2. (\\<exists>x.\n        (x = mutator m \\<longrightarrow>\n         r \\<in> ghost_honorary_grey (s (mutator m))) \\<and>\n        (x \\<noteq> mutator m \\<longrightarrow>\n         (x = sys \\<longrightarrow>\n          r \\<in> sys_W s \\<or>\n          r \\<in> W (s (mutator m)) \\<or>\n          r \\<in> sys_ghost_honorary_grey s) \\<and>\n         (x \\<noteq> sys \\<longrightarrow>\n          r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)))) =\n    (\\<exists>x. r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        (x = mutator m \\<longrightarrow>\n         r \\<in> ghost_honorary_grey (s (mutator m))) \\<and>\n        (x \\<noteq> mutator m \\<longrightarrow>\n         (x = sys \\<longrightarrow>\n          r \\<in> sys_W s \\<or>\n          r \\<in> W (s (mutator m)) \\<or>\n          r \\<in> sys_ghost_honorary_grey s) \\<and>\n         (x \\<noteq> sys \\<longrightarrow>\n          r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)))) =\n    (\\<exists>x. r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x))", "apply (metis process_name.distinct(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma colours_flip_fM[simp]:\n  \"fl \\<noteq> sys_fM s \\<Longrightarrow> black b (s(sys := (s sys)\\<lparr>fM := fl, mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<longleftrightarrow> white b s \\<and> \\<not>grey b s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fl \\<noteq> sys_fM s \\<Longrightarrow>\n    black b\n     (s(sys := s sys\n          \\<lparr>fM := fl,\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (p := ws)\\<rparr>)) =\n    (white b s \\<and> \\<not> grey b s)", "unfolding black_def white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fl \\<noteq> sys_fM s \\<Longrightarrow>\n    (marked b\n      (s(sys := s sys\n           \\<lparr>fM := fl,\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (p := ws)\\<rparr>)) \\<and>\n     \\<not> grey b\n             (s(sys := s sys\n                  \\<lparr>fM := fl,\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (p := ws)\\<rparr>))) =\n    (obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) b s \\<and>\n     \\<not> grey b s)", "by (simp add: fun_upd_apply)"], ["", "lemma colours_alloc[simp]:\n  \"heap (s sys) r' = None\n     \\<Longrightarrow> black r (s(mutator m := (s (mutator m))\\<lparr> roots := roots' \\<rparr>, sys := (s sys)\\<lparr>heap := heap (s sys)(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> black r s \\<or> (r' = r \\<and> fl = sys_fM s \\<and> \\<not>grey r' s)\"\n  \"grey r (s(mutator m := (s (mutator m))\\<lparr> roots := roots' \\<rparr>, sys := (s sys)\\<lparr>heap := heap (s sys)(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> grey r s\"\n  \"heap (s sys) r' = None\n     \\<Longrightarrow> white r (s(mutator m := (s (mutator m))\\<lparr> roots := roots' \\<rparr>, sys := (s sys)\\<lparr>heap := heap (s sys)(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> white r s \\<or> (r' = r \\<and> fl \\<noteq> sys_fM s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sys_heap s r' = None \\<Longrightarrow>\n     black r\n      (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n         sys := s sys\n           \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                        obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n     (black r s \\<or>\n      r' = r \\<and> fl = sys_fM s \\<and> \\<not> grey r' s)) &&&\n    grey r\n     (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n    grey r s &&&\n    (sys_heap s r' = None \\<Longrightarrow>\n     white r\n      (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n         sys := s sys\n           \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                        obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n     (white r s \\<or> r' = r \\<and> fl \\<noteq> sys_fM s))", "unfolding black_def white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sys_heap s r' = None \\<Longrightarrow>\n     (marked r\n       (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n          sys := s sys\n            \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                      \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                         obj_payload = Map.empty\\<rparr>)\\<rparr>)) \\<and>\n      \\<not> grey r\n              (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n                 sys := s sys\n                   \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                             \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                                obj_payload =\n                                  Map.empty\\<rparr>)\\<rparr>))) =\n     (marked r s \\<and> \\<not> grey r s \\<or>\n      r' = r \\<and> fl = sys_fM s \\<and> \\<not> grey r' s)) &&&\n    grey r\n     (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n    grey r s &&&\n    (sys_heap s r' = None \\<Longrightarrow>\n     obj_at\n      (\\<lambda>obj.\n          obj_mark obj \\<noteq>\n          sys_fM\n           (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n              sys := s sys\n                \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                          \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                             obj_payload = Map.empty\\<rparr>)\\<rparr>)))\n      r (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n     (obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r s \\<or>\n      r' = r \\<and> fl \\<noteq> sys_fM s))", "by (auto simp: fun_upd_apply split: obj_at_splits)"], ["", "lemma heap_colours_alloc[simp]:\n  \"\\<lbrakk> heap (s sys) r' = None; valid_refs_inv s \\<rbrakk>\n  \\<Longrightarrow> black_heap (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  \\<longleftrightarrow> black_heap s \\<and> fl = sys_fM s\"\n  \"heap (s sys) r' = None\n  \\<Longrightarrow> white_heap (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  \\<longleftrightarrow> white_heap s \\<and> fl \\<noteq> sys_fM s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sys_heap s r' = None; valid_refs_inv s\\<rbrakk>\n     \\<Longrightarrow> black_heap\n                        (s(mutator m := s (mutator m)\n                             \\<lparr>roots := roots'\\<rparr>,\n                           sys := s sys\n                             \\<lparr>heap := sys_heap s(r' \\<mapsto>\n \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n    obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n                       (black_heap s \\<and> fl = sys_fM s)) &&&\n    (sys_heap s r' = None \\<Longrightarrow>\n     white_heap\n      (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n         sys := s sys\n           \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                        obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n     (white_heap s \\<and> fl \\<noteq> sys_fM s))", "unfolding black_heap_def white_def white_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sys_heap s r' = None; valid_refs_inv s\\<rbrakk>\n     \\<Longrightarrow> (\\<forall>x.\n                           obj_at (\\<lambda>s. True) x\n                            (s(mutator m := s (mutator m)\n                                 \\<lparr>roots := roots'\\<rparr>,\n                               sys := s sys\n                                 \\<lparr>heap := sys_heap s(r' \\<mapsto>\n     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n        obj_payload = Map.empty\\<rparr>)\\<rparr>)) \\<longrightarrow>\n                           black x\n                            (s(mutator m := s (mutator m)\n                                 \\<lparr>roots := roots'\\<rparr>,\n                               sys := s sys\n                                 \\<lparr>heap := sys_heap s(r' \\<mapsto>\n     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n        obj_payload = Map.empty\\<rparr>)\\<rparr>))) =\n                       ((\\<forall>x.\n                            obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n                            black x s) \\<and>\n                        fl = sys_fM s)) &&&\n    (sys_heap s r' = None \\<Longrightarrow>\n     (\\<forall>x.\n         obj_at (\\<lambda>s. True) x\n          (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n             sys := s sys\n               \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                         \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                            obj_payload =\n                              Map.empty\\<rparr>)\\<rparr>)) \\<longrightarrow>\n         obj_at\n          (\\<lambda>obj.\n              obj_mark obj \\<noteq>\n              sys_fM\n               (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n                  sys := s sys\n                    \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                              \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                                 obj_payload = Map.empty\\<rparr>)\\<rparr>)))\n          x (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>,\n               sys := s sys\n                 \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                           \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                              obj_payload = Map.empty\\<rparr>)\\<rparr>))) =\n     ((\\<forall>x.\n          obj_at (\\<lambda>s. True) x s \\<longrightarrow>\n          obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) x s) \\<and>\n      fl \\<noteq> sys_fM s))", "apply (simp_all add: fun_upd_apply split: obj_at_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          (sys_heap s x = None \\<longrightarrow>\n                           x = r' \\<longrightarrow>\n                           black r' s \\<or>\n                           fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                          ((\\<exists>obj.\n                               sys_heap s x = Some obj) \\<longrightarrow>\n                           (black x s \\<or>\n                            r' = x \\<and>\n                            fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                           (x = r' \\<longrightarrow>\n                            black r' s \\<or>\n                            fl = sys_fM s \\<and> \\<not> grey r' s))) =\n                      ((\\<forall>x.\n                           (\\<exists>obj.\n                               sys_heap s x = Some obj) \\<longrightarrow>\n                           black x s) \\<and>\n                       fl = sys_fM s)\n 2. sys_heap s r' = None \\<Longrightarrow>\n    (\\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))) =\n    ((\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s))", "apply (rule iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow>\n         black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n        ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         (black x s \\<or>\n          r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n         (x = r' \\<longrightarrow>\n          black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          (\\<exists>obj.\n                              sys_heap s x = Some obj) \\<longrightarrow>\n                          black x s) \\<and>\n                      fl = sys_fM s\n 2. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     (\\<forall>x.\n         (\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         black x s) \\<and>\n     fl = sys_fM s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          black r' s \\<or>\n                          fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                         ((\\<exists>obj.\n                              sys_heap s x = Some obj) \\<longrightarrow>\n                          (black x s \\<or>\n                           r' = x \\<and>\n                           fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                          (x = r' \\<longrightarrow>\n                           black r' s \\<or>\n                           fl = sys_fM s \\<and> \\<not> grey r' s))\n 3. sys_heap s r' = None \\<Longrightarrow>\n    (\\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))) =\n    ((\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n        \\<forall>x.\n           (sys_heap s x = None \\<longrightarrow>\n            x = r' \\<longrightarrow>\n            black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n           ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n            (black x s \\<or>\n             r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n            (x = r' \\<longrightarrow>\n             black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s));\n        \\<exists>obj. sys_heap s x = Some obj\\<rbrakk>\n       \\<Longrightarrow> black x s\n 2. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow>\n         black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n        ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         (black x s \\<or>\n          r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n         (x = r' \\<longrightarrow>\n          black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s))\\<rbrakk>\n    \\<Longrightarrow> fl = sys_fM s\n 3. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     (\\<forall>x.\n         (\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         black x s) \\<and>\n     fl = sys_fM s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          black r' s \\<or>\n                          fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                         ((\\<exists>obj.\n                              sys_heap s x = Some obj) \\<longrightarrow>\n                          (black x s \\<or>\n                           r' = x \\<and>\n                           fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                          (x = r' \\<longrightarrow>\n                           black r' s \\<or>\n                           fl = sys_fM s \\<and> \\<not> grey r' s))\n 4. sys_heap s r' = None \\<Longrightarrow>\n    (\\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))) =\n    ((\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s))", "apply (rename_tac x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n        \\<forall>x.\n           (sys_heap s x = None \\<longrightarrow>\n            x = r' \\<longrightarrow>\n            black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n           ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n            (black x s \\<or>\n             r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n            (x = r' \\<longrightarrow>\n             black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s));\n        \\<exists>obj. sys_heap s x = Some obj\\<rbrakk>\n       \\<Longrightarrow> black x s\n 2. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow>\n         black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n        ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         (black x s \\<or>\n          r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n         (x = r' \\<longrightarrow>\n          black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s))\\<rbrakk>\n    \\<Longrightarrow> fl = sys_fM s\n 3. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     (\\<forall>x.\n         (\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         black x s) \\<and>\n     fl = sys_fM s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          black r' s \\<or>\n                          fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                         ((\\<exists>obj.\n                              sys_heap s x = Some obj) \\<longrightarrow>\n                          (black x s \\<or>\n                           r' = x \\<and>\n                           fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                          (x = r' \\<longrightarrow>\n                           black r' s \\<or>\n                           fl = sys_fM s \\<and> \\<not> grey r' s))\n 4. sys_heap s r' = None \\<Longrightarrow>\n    (\\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))) =\n    ((\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n        \\<exists>obj. sys_heap s x = Some obj;\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow>\n         black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n        ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         (black x s \\<or>\n          r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n         (x = r' \\<longrightarrow>\n          black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s))\\<rbrakk>\n       \\<Longrightarrow> black x s\n 2. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow>\n         black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n        ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         (black x s \\<or>\n          r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n         (x = r' \\<longrightarrow>\n          black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s))\\<rbrakk>\n    \\<Longrightarrow> fl = sys_fM s\n 3. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     (\\<forall>x.\n         (\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         black x s) \\<and>\n     fl = sys_fM s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          black r' s \\<or>\n                          fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                         ((\\<exists>obj.\n                              sys_heap s x = Some obj) \\<longrightarrow>\n                          (black x s \\<or>\n                           r' = x \\<and>\n                           fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                          (x = r' \\<longrightarrow>\n                           black r' s \\<or>\n                           fl = sys_fM s \\<and> \\<not> grey r' s))\n 4. sys_heap s r' = None \\<Longrightarrow>\n    (\\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))) =\n    ((\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow>\n         black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n        ((\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         (black x s \\<or>\n          r' = x \\<and> fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n         (x = r' \\<longrightarrow>\n          black r' s \\<or> fl = sys_fM s \\<and> \\<not> grey r' s))\\<rbrakk>\n    \\<Longrightarrow> fl = sys_fM s\n 2. \\<lbrakk>sys_heap s r' = None; valid_refs_inv s;\n     (\\<forall>x.\n         (\\<exists>obj. sys_heap s x = Some obj) \\<longrightarrow>\n         black x s) \\<and>\n     fl = sys_fM s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          black r' s \\<or>\n                          fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                         ((\\<exists>obj.\n                              sys_heap s x = Some obj) \\<longrightarrow>\n                          (black x s \\<or>\n                           r' = x \\<and>\n                           fl = sys_fM s \\<and> \\<not> grey r' s) \\<and>\n                          (x = r' \\<longrightarrow>\n                           black r' s \\<or>\n                           fl = sys_fM s \\<and> \\<not> grey r' s))\n 3. sys_heap s r' = None \\<Longrightarrow>\n    (\\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))) =\n    ((\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s))", "apply (drule spec[where x=r'], auto simp: reaches_def dest!: valid_refs_invD split: obj_at_splits)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sys_heap s r' = None \\<Longrightarrow>\n    (\\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))) =\n    ((\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sys_heap s r' = None;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x obj.\n                          sys_heap s x = Some obj \\<longrightarrow>\n                          obj_mark obj = (\\<not> sys_fM s)) \\<and>\n                      fl = (\\<not> sys_fM s)\n 2. \\<lbrakk>sys_heap s r' = None;\n     (\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          fl = (\\<not> sys_fM s)) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (obj_mark obj = (\\<not> sys_fM s) \\<or>\n                              x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n                             (x = r' \\<longrightarrow>\n                              fl = (\\<not> sys_fM s)))", "apply (intro allI conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x obj.\n       \\<lbrakk>sys_heap s r' = None;\n        \\<forall>x.\n           (sys_heap s x = None \\<longrightarrow>\n            x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n           (\\<forall>obj.\n               sys_heap s x = Some obj \\<longrightarrow>\n               (obj_mark obj = (\\<not> sys_fM s) \\<or>\n                x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n               (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)));\n        sys_heap s x = Some obj\\<rbrakk>\n       \\<Longrightarrow> obj_mark obj = (\\<not> sys_fM s)\n 2. \\<lbrakk>sys_heap s r' = None;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))\\<rbrakk>\n    \\<Longrightarrow> fl = (\\<not> sys_fM s)\n 3. \\<lbrakk>sys_heap s r' = None;\n     (\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          fl = (\\<not> sys_fM s)) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (obj_mark obj = (\\<not> sys_fM s) \\<or>\n                              x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n                             (x = r' \\<longrightarrow>\n                              fl = (\\<not> sys_fM s)))", "apply (rename_tac x obj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x obj.\n       \\<lbrakk>sys_heap s r' = None;\n        \\<forall>x.\n           (sys_heap s x = None \\<longrightarrow>\n            x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n           (\\<forall>obj.\n               sys_heap s x = Some obj \\<longrightarrow>\n               (obj_mark obj = (\\<not> sys_fM s) \\<or>\n                x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n               (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)));\n        sys_heap s x = Some obj\\<rbrakk>\n       \\<Longrightarrow> obj_mark obj = (\\<not> sys_fM s)\n 2. \\<lbrakk>sys_heap s r' = None;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))\\<rbrakk>\n    \\<Longrightarrow> fl = (\\<not> sys_fM s)\n 3. \\<lbrakk>sys_heap s r' = None;\n     (\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          fl = (\\<not> sys_fM s)) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (obj_mark obj = (\\<not> sys_fM s) \\<or>\n                              x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n                             (x = r' \\<longrightarrow>\n                              fl = (\\<not> sys_fM s)))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x obj.\n       \\<lbrakk>sys_heap s r' = None; sys_heap s x = Some obj;\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))\\<rbrakk>\n       \\<Longrightarrow> obj_mark obj = (\\<not> sys_fM s)\n 2. \\<lbrakk>sys_heap s r' = None;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))\\<rbrakk>\n    \\<Longrightarrow> fl = (\\<not> sys_fM s)\n 3. \\<lbrakk>sys_heap s r' = None;\n     (\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          fl = (\\<not> sys_fM s)) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (obj_mark obj = (\\<not> sys_fM s) \\<or>\n                              x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n                             (x = r' \\<longrightarrow>\n                              fl = (\\<not> sys_fM s)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sys_heap s r' = None;\n     \\<forall>x.\n        (sys_heap s x = None \\<longrightarrow>\n         x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)) \\<and>\n        (\\<forall>obj.\n            sys_heap s x = Some obj \\<longrightarrow>\n            (obj_mark obj = (\\<not> sys_fM s) \\<or>\n             x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n            (x = r' \\<longrightarrow> fl = (\\<not> sys_fM s)))\\<rbrakk>\n    \\<Longrightarrow> fl = (\\<not> sys_fM s)\n 2. \\<lbrakk>sys_heap s r' = None;\n     (\\<forall>x obj.\n         sys_heap s x = Some obj \\<longrightarrow>\n         obj_mark obj = (\\<not> sys_fM s)) \\<and>\n     fl = (\\<not> sys_fM s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (sys_heap s x = None \\<longrightarrow>\n                          x = r' \\<longrightarrow>\n                          fl = (\\<not> sys_fM s)) \\<and>\n                         (\\<forall>obj.\n                             sys_heap s x = Some obj \\<longrightarrow>\n                             (obj_mark obj = (\\<not> sys_fM s) \\<or>\n                              x = r' \\<and> fl = (\\<not> sys_fM s)) \\<and>\n                             (x = r' \\<longrightarrow>\n                              fl = (\\<not> sys_fM s)))", "apply (drule spec[where x=r'], auto dest!: valid_refs_invD split: obj_at_splits)[2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma grey_protects_white_hs_done[simp]:\n  \"(g grey_protects_white w) (s(mutator m := s (mutator m)\\<lparr> W := {}, ghost_hs_phase := hs' \\<rparr>,\n                              sys := s sys\\<lparr> hs_pending := hp', W := sys_W s \\<union> W (s (mutator m)),\n                                            ghost_hs_in_sync := his' \\<rparr>))\n  \\<longleftrightarrow> (g grey_protects_white w) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g grey_protects_white w)\n     (s(mutator m := s (mutator m)\n          \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n        sys := s sys\n          \\<lparr>hs_pending := hp',\n             W := sys_W s \\<union> W (s (mutator m)),\n             ghost_hs_in_sync := his'\\<rparr>)) =\n    (g grey_protects_white w) s", "unfolding grey_protects_white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (grey g\n      (s(mutator m := s (mutator m)\n           \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n         sys := s sys\n           \\<lparr>hs_pending := hp',\n              W := sys_W s \\<union> W (s (mutator m)),\n              ghost_hs_in_sync := his'\\<rparr>)) \\<and>\n     (g has_white_path_to w)\n      (s(mutator m := s (mutator m)\n           \\<lparr>W := {}, ghost_hs_phase := hs'\\<rparr>,\n         sys := s sys\n           \\<lparr>hs_pending := hp',\n              W := sys_W s \\<union> W (s (mutator m)),\n              ghost_hs_in_sync := his'\\<rparr>))) =\n    (grey g s \\<and> (g has_white_path_to w) s)", "by (simp add: fun_upd_apply)"], ["", "lemma grey_protects_white_alloc[simp]:\n  \"\\<lbrakk> fl = sys_fM s; sys_heap s r = None \\<rbrakk>\n     \\<Longrightarrow> (g grey_protects_white w) (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> (g grey_protects_white w) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fl = sys_fM s; sys_heap s r = None\\<rbrakk>\n    \\<Longrightarrow> (g grey_protects_white w)\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>roots := roots'\\<rparr>,\n                          sys := s sys\n                            \\<lparr>heap := sys_heap s(r \\<mapsto>\n\\<lparr>obj_mark = fl, obj_fields = Map.empty,\n   obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n                      (g grey_protects_white w) s", "unfolding grey_protects_white_def has_white_path_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fl = sys_fM s; sys_heap s r = None\\<rbrakk>\n    \\<Longrightarrow> (grey g\n                        (s(mutator m := s (mutator m)\n                             \\<lparr>roots := roots'\\<rparr>,\n                           sys := s sys\n                             \\<lparr>heap := sys_heap s(r \\<mapsto>\n \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n    obj_payload = Map.empty\\<rparr>)\\<rparr>)) \\<and>\n                       (\\<lambda>x y.\n                           (x points_to y)\n                            (s(mutator m := s (mutator m)\n                                 \\<lparr>roots := roots'\\<rparr>,\n                               sys := s sys\n                                 \\<lparr>heap := sys_heap s(r \\<mapsto>\n     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n        obj_payload = Map.empty\\<rparr>)\\<rparr>)) \\<and>\n                           white y\n                            (s(mutator m := s (mutator m)\n                                 \\<lparr>roots := roots'\\<rparr>,\n                               sys := s sys\n                                 \\<lparr>heap := sys_heap s(r \\<mapsto>\n     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n        obj_payload = Map.empty\\<rparr>)\\<rparr>)))\\<^sup>*\\<^sup>*\n                        g w) =\n                      (grey g s \\<and>\n                       (\\<lambda>x y.\n                           (x points_to y) s \\<and>\n                           white y s)\\<^sup>*\\<^sup>*\n                        g w)", "by simp"], ["", "lemma (in mut_m) reachable_snapshot_inv_sweep_loop_free:\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes nmr: \"white r s\"\n  assumes ngs: \"no_grey_refs s\"\n  assumes rsi: \"reachable_snapshot_inv s\"\n  shows \"reachable_snapshot_inv (s(sys := (s sys)\\<lparr>heap := (heap (s sys))(r := None)\\<rparr>))\" (is \"reachable_snapshot_inv ?s'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable_snapshot_inv\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       reachable y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := None)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "fix y :: \"'ref\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       reachable y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := None)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "assume rx: \"reachable y ?s'\""], ["proof (state)\nthis:\n  reachable y\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       reachable y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := None)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  reachable y\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "have \"black y s \\<and> y \\<noteq> r\""], ["proof (prove)\nusing this:\n  reachable y\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (1 subgoal):\n 1. black y s \\<and> y \\<noteq> r", "proof(induct rule: reachable_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_roots\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x.\n       x \\<in> mut_ghost_honorary_root\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 3. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 4. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "case (root x)"], ["proof (state)\nthis:\n  x \\<in> mut_roots\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_roots\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x.\n       x \\<in> mut_ghost_honorary_root\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 3. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 4. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "with ngs nmr rsi"], ["proof (chain)\npicking this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> mut_roots\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> mut_roots\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (1 subgoal):\n 1. black x s \\<and> x \\<noteq> r", "by (auto simp: fun_upd_apply dest: reachable_blackD)"], ["proof (state)\nthis:\n  black x s \\<and> x \\<noteq> r\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_ghost_honorary_root\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 3. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_ghost_honorary_root\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 3. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "case (ghost_honorary_root x)"], ["proof (state)\nthis:\n  x \\<in> mut_ghost_honorary_root\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_ghost_honorary_root\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 3. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "with ngs nmr rsi"], ["proof (chain)\npicking this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> mut_ghost_honorary_root\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> mut_ghost_honorary_root\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (1 subgoal):\n 1. black x s \\<and> x \\<noteq> r", "unfolding reachable_def reaches_def"], ["proof (prove)\nusing this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> mut_ghost_honorary_root\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (1 subgoal):\n 1. black x s \\<and> x \\<noteq> r", "by (auto simp: fun_upd_apply dest: reachable_blackD)"], ["proof (state)\nthis:\n  black x s \\<and> x \\<noteq> r\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "case (tso_root x)"], ["proof (state)\nthis:\n  x \\<in> tso_store_refs\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> tso_store_refs\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := None)\\<rparr>)) \\<Longrightarrow>\n       black x s \\<and> x \\<noteq> r\n 2. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "with ngs nmr rsi"], ["proof (chain)\npicking this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> tso_store_refs\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> tso_store_refs\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (1 subgoal):\n 1. black x s \\<and> x \\<noteq> r", "unfolding reachable_def reaches_def"], ["proof (prove)\nusing this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  x \\<in> tso_store_refs\n           (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal (1 subgoal):\n 1. black x s \\<and> x \\<noteq> r", "by (auto simp: fun_upd_apply dest: reachable_blackD)"], ["proof (state)\nthis:\n  black x s \\<and> x \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "case (reaches x y)"], ["proof (state)\nthis:\n  reachable x\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n  black x s \\<and> x \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>reachable x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>));\n        black x s \\<and> x \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "with ngs nmr rsi"], ["proof (chain)\npicking this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  reachable x\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n  black x s \\<and> x \\<noteq> r", "show ?case"], ["proof (prove)\nusing this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  reachable x\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n  black x s \\<and> x \\<noteq> r\n\ngoal (1 subgoal):\n 1. black y s \\<and> y \\<noteq> r", "unfolding reachable_def reaches_def"], ["proof (prove)\nusing this:\n  no_grey_refs s\n  white r s\n  reachable_snapshot_inv s\n  \\<exists>xa.\n     xa \\<in> mut_roots\n               (s(sys := s sys\n                    \\<lparr>heap := (sys_heap s)\n                              (r := None)\\<rparr>)) \\<union>\n              mut_ghost_honorary_root\n               (s(sys := s sys\n                    \\<lparr>heap := (sys_heap s)\n                              (r := None)\\<rparr>)) \\<union>\n              tso_store_refs\n               (s(sys := s sys\n                    \\<lparr>heap := (sys_heap s)(r := None)\\<rparr>)) \\<and>\n     (\\<lambda>x y.\n         (x points_to y)\n          (s(sys := s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := None)\\<rparr>)))\\<^sup>*\\<^sup>*\n      xa x\n  (x points_to y)\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n  black x s \\<and> x \\<noteq> r\n\ngoal (1 subgoal):\n 1. black y s \\<and> y \\<noteq> r", "apply (clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y.\n            (x points_to y) s \\<and> x \\<noteq> r)\\<^sup>*\\<^sup>*\n         xa x\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "apply (drule predicate2D[OF rtranclp_mono[where s=\"\\<lambda>x y. (x points_to y) s\", OF predicate2I], rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xaa y.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (xaa points_to y) s \\<and> xaa \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> (xaa points_to y) s\n 2. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "apply (clarsimp split: obj_at_splits if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> black y s \\<and> y \\<noteq> r", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> r", "apply (rule reachable_blackD, assumption, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> reachable y s\n 2. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> r", "apply (simp add: reachable_def reaches_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             x \\<in> tso_store_refs s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> r", "apply (blast intro: rtranclp.intros(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to y) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x\\<rbrakk>\n       \\<Longrightarrow> y \\<noteq> r", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to r) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x;\n        y = r\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule (1) reachable_blackD[where r=r])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to r) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x;\n        y = r\\<rbrakk>\n       \\<Longrightarrow> reachable r s\n 2. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to r) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x; y = r;\n        black r s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: reachable_def reaches_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to r) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x;\n        y = r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> mut_roots s \\<or>\n                             x \\<in> mut_ghost_honorary_root s \\<or>\n                             x \\<in> tso_store_refs s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x r\n 2. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to r) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x; y = r;\n        black r s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (blast intro: rtranclp.intros(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>no_grey_refs s; white r s; reachable_snapshot_inv s;\n        (x points_to r) s; black x s; x \\<noteq> r;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x; y = r;\n        black r s\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  black y s \\<and> y \\<noteq> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  black y s \\<and> y \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       reachable y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := None)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  black y s \\<and> y \\<noteq> r", "show \"in_snapshot y ?s'\""], ["proof (prove)\nusing this:\n  black y s \\<and> y \\<noteq> r\n\ngoal (1 subgoal):\n 1. in_snapshot y\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))", "unfolding in_snapshot_def"], ["proof (prove)\nusing this:\n  black y s \\<and> y \\<noteq> r\n\ngoal (1 subgoal):\n 1. black y\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>)) \\<or>\n    (\\<exists>x.\n        (x grey_protects_white y)\n         (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>)))", "by simp"], ["proof (state)\nthis:\n  in_snapshot y\n   (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := None)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_alloc[simp]:\n  assumes rn: \"sys_heap s r = None\"\n  shows \"mut_m.reachable m r' (s(mutator m' := (s (mutator m'))\\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>, sys := (s sys)\\<lparr>heap := (sys_heap s)(r \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> mut_m.reachable m r' s \\<or> (m' = m \\<and> r' = r)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n    (mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload =\n                         Map.empty\\<rparr>)\\<rparr>)) \\<Longrightarrow>\n    mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r\n 2. mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "assume ?lhs"], ["proof (state)\nthis:\n  mut_m.reachable m r'\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal (2 subgoals):\n 1. mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload =\n                         Map.empty\\<rparr>)\\<rparr>)) \\<Longrightarrow>\n    mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r\n 2. mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "from this assms"], ["proof (chain)\npicking this:\n  mut_m.reachable m r'\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  sys_heap s r = None", "show ?rhs"], ["proof (prove)\nusing this:\n  mut_m.reachable m r'\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  sys_heap s r = None\n\ngoal (1 subgoal):\n 1. mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r", "proof(induct rule: reachable_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> roots\n                         ((s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                           (mutator m));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> ghost_honorary_root\n                         ((s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                           (mutator m));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> mut_m.tso_store_refs m\n                         (s(mutator m' := s (mutator m')\n                              \\<lparr>roots :=\n  insert r (roots (s (mutator m')))\\<rparr>,\n                            sys := s sys\n                              \\<lparr>heap := sys_heap s(r \\<mapsto>\n  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n     obj_payload = Map.empty\\<rparr>)\\<rparr>));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 4. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(mutator m' := s (mutator m')\n                      \\<lparr>roots :=\n                                insert r (roots (s (mutator m')))\\<rparr>,\n                    sys := s sys\n                      \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fl,\n                                   obj_fields = Map.empty,\n                                   obj_payload =\n                                     Map.empty\\<rparr>)\\<rparr>));\n        (x points_to y)\n         (s(mutator m' := s (mutator m')\n              \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n            sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto>\n                        \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                           obj_payload = Map.empty\\<rparr>)\\<rparr>));\n        sys_heap s r = None \\<Longrightarrow>\n        mut_m.reachable m x s \\<or> m' = m \\<and> x = r;\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m y s \\<or> m' = m \\<and> y = r", "case (reaches x y)"], ["proof (state)\nthis:\n  mut_m.reachable m x\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  (x points_to y)\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  sys_heap s r = None \\<Longrightarrow>\n  mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n  sys_heap s r = None\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> roots\n                         ((s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                           (mutator m));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> ghost_honorary_root\n                         ((s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                           (mutator m));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> mut_m.tso_store_refs m\n                         (s(mutator m' := s (mutator m')\n                              \\<lparr>roots :=\n  insert r (roots (s (mutator m')))\\<rparr>,\n                            sys := s sys\n                              \\<lparr>heap := sys_heap s(r \\<mapsto>\n  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n     obj_payload = Map.empty\\<rparr>)\\<rparr>));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 4. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(mutator m' := s (mutator m')\n                      \\<lparr>roots :=\n                                insert r (roots (s (mutator m')))\\<rparr>,\n                    sys := s sys\n                      \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fl,\n                                   obj_fields = Map.empty,\n                                   obj_payload =\n                                     Map.empty\\<rparr>)\\<rparr>));\n        (x points_to y)\n         (s(mutator m' := s (mutator m')\n              \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n            sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto>\n                        \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                           obj_payload = Map.empty\\<rparr>)\\<rparr>));\n        sys_heap s r = None \\<Longrightarrow>\n        mut_m.reachable m x s \\<or> m' = m \\<and> x = r;\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m y s \\<or> m' = m \\<and> y = r", "then"], ["proof (chain)\npicking this:\n  mut_m.reachable m x\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  (x points_to y)\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  sys_heap s r = None \\<Longrightarrow>\n  mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n  sys_heap s r = None", "show ?case"], ["proof (prove)\nusing this:\n  mut_m.reachable m x\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  (x points_to y)\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n  sys_heap s r = None \\<Longrightarrow>\n  mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n  sys_heap s r = None\n\ngoal (1 subgoal):\n 1. mut_m.reachable m y s \\<or> m' = m \\<and> y = r", "by clarsimp (fastforce simp: mut_m.reachable_def reaches_def elim: rtranclp.intros(2) split: obj_at_splits)"], ["proof (state)\nthis:\n  mut_m.reachable m y s \\<or> m' = m \\<and> y = r\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> roots\n                         ((s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                           (mutator m));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> ghost_honorary_root\n                         ((s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                           (mutator m));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> mut_m.tso_store_refs m\n                         (s(mutator m' := s (mutator m')\n                              \\<lparr>roots :=\n  insert r (roots (s (mutator m')))\\<rparr>,\n                            sys := s sys\n                              \\<lparr>heap := sys_heap s(r \\<mapsto>\n  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n     obj_payload = Map.empty\\<rparr>)\\<rparr>));\n        sys_heap s r = None\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<or> m' = m \\<and> x = r", "qed (auto simp: fun_upd_apply split: if_splits)"], ["proof (state)\nthis:\n  mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r\n\ngoal (1 subgoal):\n 1. mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "assume ?rhs"], ["proof (state)\nthis:\n  mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r\n\ngoal (1 subgoal):\n 1. mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r", "show ?lhs"], ["proof (prove)\nusing this:\n  mut_m.reachable m r' s \\<or> m' = m \\<and> r' = r\n\ngoal (1 subgoal):\n 1. mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "proof(rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. mut_m.reachable m r' s \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "assume \"mut_m.reachable m r' s\""], ["proof (state)\nthis:\n  mut_m.reachable m r' s\n\ngoal (2 subgoals):\n 1. mut_m.reachable m r' s \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  mut_m.reachable m r' s", "show ?thesis"], ["proof (prove)\nusing this:\n  mut_m.reachable m r' s\n\ngoal (1 subgoal):\n 1. mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "proof(induct rule: reachable_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> roots (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 3. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 4. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x s; (x points_to y) s;\n        mut_m.reachable m x\n         (s(mutator m' := s (mutator m')\n              \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n            sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto>\n                        \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                           obj_payload =\n                             Map.empty\\<rparr>)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m y\n                          (s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))", "case (tso_root x)"], ["proof (state)\nthis:\n  x \\<in> mut_m.tso_store_refs m s\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> roots (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 3. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m s \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 4. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x s; (x points_to y) s;\n        mut_m.reachable m x\n         (s(mutator m' := s (mutator m')\n              \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n            sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto>\n                        \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                           obj_payload =\n                             Map.empty\\<rparr>)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m y\n                          (s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  x \\<in> mut_m.tso_store_refs m s", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. mut_m.reachable m x\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "unfolding mut_m.reachable_def"], ["proof (prove)\nusing this:\n  x \\<in> mut_m.tso_store_refs m s\n\ngoal (1 subgoal):\n 1. \\<exists>xa.\n       xa \\<in> roots\n                 ((s(mutator m' := s (mutator m')\n                       \\<lparr>roots :=\n                                 insert r (roots (s (mutator m')))\\<rparr>,\n                     sys := s sys\n                       \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                 \\<lparr>obj_mark = fl,\n                                    obj_fields = Map.empty,\n                                    obj_payload =\nMap.empty\\<rparr>)\\<rparr>))\n                   (mutator m)) \\<union>\n                ghost_honorary_root\n                 ((s(mutator m' := s (mutator m')\n                       \\<lparr>roots :=\n                                 insert r (roots (s (mutator m')))\\<rparr>,\n                     sys := s sys\n                       \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                 \\<lparr>obj_mark = fl,\n                                    obj_fields = Map.empty,\n                                    obj_payload =\nMap.empty\\<rparr>)\\<rparr>))\n                   (mutator m)) \\<union>\n                mut_m.tso_store_refs m\n                 (s(mutator m' := s (mutator m')\n                      \\<lparr>roots :=\n                                insert r (roots (s (mutator m')))\\<rparr>,\n                    sys := s sys\n                      \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fl,\n                                   obj_fields = Map.empty,\n                                   obj_payload =\n                                     Map.empty\\<rparr>)\\<rparr>)) \\<and>\n       (xa reaches x)\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))", "by fastforce"], ["proof (state)\nthis:\n  mut_m.reachable m x\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> roots (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 3. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x s; (x points_to y) s;\n        mut_m.reachable m x\n         (s(mutator m' := s (mutator m')\n              \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n            sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto>\n                        \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                           obj_payload =\n                             Map.empty\\<rparr>)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m y\n                          (s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> roots (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 3. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x s; (x points_to y) s;\n        mut_m.reachable m x\n         (s(mutator m' := s (mutator m')\n              \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n            sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto>\n                        \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                           obj_payload =\n                             Map.empty\\<rparr>)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m y\n                          (s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))", "case (reaches x y)"], ["proof (state)\nthis:\n  mut_m.reachable m x s\n  (x points_to y) s\n  mut_m.reachable m x\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> roots (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 3. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x s; (x points_to y) s;\n        mut_m.reachable m x\n         (s(mutator m' := s (mutator m')\n              \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n            sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto>\n                        \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                           obj_payload =\n                             Map.empty\\<rparr>)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m y\n                          (s(mutator m' := s (mutator m')\n                               \\<lparr>roots :=\n   insert r (roots (s (mutator m')))\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))", "with rn"], ["proof (chain)\npicking this:\n  sys_heap s r = None\n  mut_m.reachable m x s\n  (x points_to y) s\n  mut_m.reachable m x\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  sys_heap s r = None\n  mut_m.reachable m x s\n  (x points_to y) s\n  mut_m.reachable m x\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal (1 subgoal):\n 1. mut_m.reachable m y\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "unfolding mut_m.reachable_def"], ["proof (prove)\nusing this:\n  sys_heap s r = None\n  \\<exists>xa.\n     xa \\<in> roots (s (mutator m)) \\<union>\n              ghost_honorary_root (s (mutator m)) \\<union>\n              mut_m.tso_store_refs m s \\<and>\n     (xa reaches x) s\n  (x points_to y) s\n  \\<exists>xa.\n     xa \\<in> roots\n               ((s(mutator m' := s (mutator m')\n                     \\<lparr>roots :=\n                               insert r (roots (s (mutator m')))\\<rparr>,\n                   sys := s sys\n                     \\<lparr>heap := sys_heap s(r \\<mapsto>\n                               \\<lparr>obj_mark = fl,\n                                  obj_fields = Map.empty,\n                                  obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                 (mutator m)) \\<union>\n              ghost_honorary_root\n               ((s(mutator m' := s (mutator m')\n                     \\<lparr>roots :=\n                               insert r (roots (s (mutator m')))\\<rparr>,\n                   sys := s sys\n                     \\<lparr>heap := sys_heap s(r \\<mapsto>\n                               \\<lparr>obj_mark = fl,\n                                  obj_fields = Map.empty,\n                                  obj_payload = Map.empty\\<rparr>)\\<rparr>))\n                 (mutator m)) \\<union>\n              mut_m.tso_store_refs m\n               (s(mutator m' := s (mutator m')\n                    \\<lparr>roots :=\n                              insert r (roots (s (mutator m')))\\<rparr>,\n                  sys := s sys\n                    \\<lparr>heap := sys_heap s(r \\<mapsto>\n                              \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                                 obj_payload =\n                                   Map.empty\\<rparr>)\\<rparr>)) \\<and>\n     (xa reaches x)\n      (s(mutator m' := s (mutator m')\n           \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n         sys := s sys\n           \\<lparr>heap := sys_heap s(r \\<mapsto>\n                     \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                        obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> roots\n                ((s(mutator m' := s (mutator m')\n                      \\<lparr>roots :=\n                                insert r (roots (s (mutator m')))\\<rparr>,\n                    sys := s sys\n                      \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fl,\n                                   obj_fields = Map.empty,\n                                   obj_payload =\n                                     Map.empty\\<rparr>)\\<rparr>))\n                  (mutator m)) \\<union>\n               ghost_honorary_root\n                ((s(mutator m' := s (mutator m')\n                      \\<lparr>roots :=\n                                insert r (roots (s (mutator m')))\\<rparr>,\n                    sys := s sys\n                      \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fl,\n                                   obj_fields = Map.empty,\n                                   obj_payload =\n                                     Map.empty\\<rparr>)\\<rparr>))\n                  (mutator m)) \\<union>\n               mut_m.tso_store_refs m\n                (s(mutator m' := s (mutator m')\n                     \\<lparr>roots :=\n                               insert r (roots (s (mutator m')))\\<rparr>,\n                   sys := s sys\n                     \\<lparr>heap := sys_heap s(r \\<mapsto>\n                               \\<lparr>obj_mark = fl,\n                                  obj_fields = Map.empty,\n                                  obj_payload =\n                                    Map.empty\\<rparr>)\\<rparr>)) \\<and>\n       (x reaches y)\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))", "by fastforce"], ["proof (state)\nthis:\n  mut_m.reachable m y\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> roots (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root (s (mutator m)) \\<Longrightarrow>\n       mut_m.reachable m x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))", "qed (auto simp: fun_upd_apply)"], ["proof (state)\nthis:\n  mut_m.reachable m r'\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal (1 subgoal):\n 1. m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "assume \"m' = m \\<and> r' = r\""], ["proof (state)\nthis:\n  m' = m \\<and> r' = r\n\ngoal (1 subgoal):\n 1. m' = m \\<and> r' = r \\<Longrightarrow>\n    mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "with rn"], ["proof (chain)\npicking this:\n  sys_heap s r = None\n  m' = m \\<and> r' = r", "show ?thesis"], ["proof (prove)\nusing this:\n  sys_heap s r = None\n  m' = m \\<and> r' = r\n\ngoal (1 subgoal):\n 1. mut_m.reachable m r'\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "unfolding mut_m.reachable_def"], ["proof (prove)\nusing this:\n  sys_heap s r = None\n  m' = m \\<and> r' = r\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> roots\n                ((s(mutator m' := s (mutator m')\n                      \\<lparr>roots :=\n                                insert r (roots (s (mutator m')))\\<rparr>,\n                    sys := s sys\n                      \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fl,\n                                   obj_fields = Map.empty,\n                                   obj_payload =\n                                     Map.empty\\<rparr>)\\<rparr>))\n                  (mutator m)) \\<union>\n               ghost_honorary_root\n                ((s(mutator m' := s (mutator m')\n                      \\<lparr>roots :=\n                                insert r (roots (s (mutator m')))\\<rparr>,\n                    sys := s sys\n                      \\<lparr>heap := sys_heap s(r \\<mapsto>\n                                \\<lparr>obj_mark = fl,\n                                   obj_fields = Map.empty,\n                                   obj_payload =\n                                     Map.empty\\<rparr>)\\<rparr>))\n                  (mutator m)) \\<union>\n               mut_m.tso_store_refs m\n                (s(mutator m' := s (mutator m')\n                     \\<lparr>roots :=\n                               insert r (roots (s (mutator m')))\\<rparr>,\n                   sys := s sys\n                     \\<lparr>heap := sys_heap s(r \\<mapsto>\n                               \\<lparr>obj_mark = fl,\n                                  obj_fields = Map.empty,\n                                  obj_payload =\n                                    Map.empty\\<rparr>)\\<rparr>)) \\<and>\n       (x reaches r')\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>))", "by (fastforce simp: fun_upd_apply)"], ["proof (state)\nthis:\n  mut_m.reachable m r'\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mut_m.reachable m r'\n   (s(mutator m' := s (mutator m')\n        \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n      sys := s sys\n        \\<lparr>heap := sys_heap s(r \\<mapsto>\n                  \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                     obj_payload = Map.empty\\<rparr>)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "context mut_m\nbegin"], ["", "lemma reachable_snapshot_inv_alloc[simp, elim!]:\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes rsi: \"reachable_snapshot_inv s\"\n  assumes rn: \"sys_heap s r = None\"\n  assumes fl: \"fl = sys_fM s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"reachable_snapshot_inv (s(mutator m' := (s (mutator m'))\\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>, sys := (s sys)\\<lparr>heap := (sys_heap s)(r \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\"\n(is \"reachable_snapshot_inv ?s'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable_snapshot_inv\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "using assms"], ["proof (prove)\nusing this:\n  reachable_snapshot_inv s\n  sys_heap s r = None\n  fl = sys_fM s\n  valid_refs_inv s\n\ngoal (1 subgoal):\n 1. reachable_snapshot_inv\n     (s(mutator m' := s (mutator m')\n          \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n        sys := s sys\n          \\<lparr>heap := sys_heap s(r \\<mapsto>\n                    \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                       obj_payload = Map.empty\\<rparr>)\\<rparr>))", "unfolding reachable_snapshot_inv_def in_snapshot_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     reachable x s \\<longrightarrow>\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\n  sys_heap s r = None\n  fl = sys_fM s\n  valid_refs_inv s\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       reachable x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload =\n                            Map.empty\\<rparr>)\\<rparr>)) \\<longrightarrow>\n       black x\n        (s(mutator m' := s (mutator m')\n             \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n           sys := s sys\n             \\<lparr>heap := sys_heap s(r \\<mapsto>\n                       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                          obj_payload = Map.empty\\<rparr>)\\<rparr>)) \\<or>\n       (\\<exists>xa.\n           (xa grey_protects_white x)\n            (s(mutator m' := s (mutator m')\n                 \\<lparr>roots := insert r (roots (s (mutator m')))\\<rparr>,\n               sys := s sys\n                 \\<lparr>heap := sys_heap s(r \\<mapsto>\n                           \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                              obj_payload = Map.empty\\<rparr>)\\<rparr>)))", "by (auto simp del: reachable_fun_upd)"], ["", "lemma reachable_snapshot_inv_discard_roots[simp]:\n  \"\\<lbrakk> reachable_snapshot_inv s; roots' \\<subseteq> roots (s (mutator m)) \\<rbrakk>\n     \\<Longrightarrow> reachable_snapshot_inv (s(mutator m := (s (mutator m))\\<lparr>roots := roots'\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable_snapshot_inv s;\n     roots' \\<subseteq> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> reachable_snapshot_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>roots := roots'\\<rparr>))", "unfolding reachable_snapshot_inv_def reachable_def in_snapshot_def grey_protects_white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (\\<exists>xa.\n                    xa \\<in> mut_roots s \\<union>\n                             mut_ghost_honorary_root s \\<union>\n                             tso_store_refs s \\<and>\n                    (xa reaches x) s) \\<longrightarrow>\n                black x s \\<or>\n                (\\<exists>xa. grey xa s \\<and> (xa has_white_path_to x) s);\n     roots' \\<subseteq> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (\\<exists>xa.\n                             xa \\<in> mut_roots\n (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>)) \\<union>\nmut_ghost_honorary_root\n (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>)) \\<union>\ntso_store_refs\n (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>)) \\<and>\n                             (xa reaches x)\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>roots :=\n       roots'\\<rparr>))) \\<longrightarrow>\n                         black x\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots := roots'\\<rparr>)) \\<or>\n                         (\\<exists>xa.\n                             grey xa\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>roots := roots'\\<rparr>)) \\<and>\n                             (xa has_white_path_to x)\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>roots := roots'\\<rparr>)))", "by (auto simp: fun_upd_apply)"], ["", "lemma reachable_snapshot_inv_load[simp]:\n  \"\\<lbrakk> reachable_snapshot_inv s; sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'; r \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> reachable_snapshot_inv (s(mutator m := s (mutator m)\\<lparr> roots := mut_roots s \\<union> Option.set_option r' \\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable_snapshot_inv s;\n     sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r';\n     r \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> reachable_snapshot_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>roots :=\nmut_roots s \\<union> set_option r'\\<rparr>))", "unfolding reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                reachable x s \\<longrightarrow>\n                black x s \\<or>\n                (\\<exists>xa. grey xa s \\<and> (xa has_white_path_to x) s);\n     sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r';\n     r \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         reachable x\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s \\<union> set_option r'\\<rparr>)) \\<longrightarrow>\n                         black x\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s \\<union> set_option r'\\<rparr>)) \\<or>\n                         (\\<exists>xa.\n                             grey xa\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>roots :=\n       mut_roots s \\<union> set_option r'\\<rparr>)) \\<and>\n                             (xa has_white_path_to x)\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>roots :=\n       mut_roots s \\<union> set_option r'\\<rparr>)))", "by (simp add: fun_upd_apply)"], ["", "lemma reachable_snapshot_inv_store_ins[simp]:\n  \"\\<lbrakk> reachable_snapshot_inv s; r \\<in> mut_roots s; (\\<exists>r'. opt_r' = Some r') \\<longrightarrow> the opt_r' \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> reachable_snapshot_inv (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_root := {}\\<rparr>,\n                                  sys := s sys\\<lparr>  mem_store_buffers := (mem_store_buffers (s sys))(mutator m := sys_mem_store_buffers (mutator m) s @ [mw_Mutate r f opt_r']) \\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable_snapshot_inv s; r \\<in> mut_roots s;\n     (\\<exists>r'. opt_r' = Some r') \\<longrightarrow>\n     the opt_r' \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> reachable_snapshot_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                          sys := s sys\n                            \\<lparr>mem_store_buffers :=\n(mem_store_buffers (s sys))\n(mutator m :=\n   sys_mem_store_buffers (mutator m) s @ [mw_Mutate r f opt_r'])\\<rparr>))", "unfolding reachable_snapshot_inv_def in_snapshot_def grey_protects_white_def reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (\\<exists>xa.\n                    xa \\<in> mut_roots s \\<union>\n                             mut_ghost_honorary_root s \\<union>\n                             tso_store_refs s \\<and>\n                    (xa reaches x) s) \\<longrightarrow>\n                black x s \\<or>\n                (\\<exists>xa. grey xa s \\<and> (xa has_white_path_to x) s);\n     r \\<in> mut_roots s;\n     (\\<exists>r'. opt_r' = Some r') \\<longrightarrow>\n     the opt_r' \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (\\<exists>xa.\n                             xa \\<in> mut_roots\n (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_root := {}\\<rparr>,\n    sys := s sys\n      \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m :=\n                   sys_mem_store_buffers (mutator m) s @\n                   [mw_Mutate r f opt_r'])\\<rparr>)) \\<union>\nmut_ghost_honorary_root\n (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_root := {}\\<rparr>,\n    sys := s sys\n      \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m :=\n                   sys_mem_store_buffers (mutator m) s @\n                   [mw_Mutate r f opt_r'])\\<rparr>)) \\<union>\ntso_store_refs\n (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_root := {}\\<rparr>,\n    sys := s sys\n      \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m :=\n                   sys_mem_store_buffers (mutator m) s @\n                   [mw_Mutate r f opt_r'])\\<rparr>)) \\<and>\n                             (xa reaches x)\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>ghost_honorary_root :=\n       {}\\<rparr>,\n                                 sys := s sys\n                                   \\<lparr>mem_store_buffers :=\n       (mem_store_buffers (s sys))\n       (mutator m :=\n          sys_mem_store_buffers (mutator m) s @\n          [mw_Mutate r f opt_r'])\\<rparr>))) \\<longrightarrow>\n                         black x\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s @\n      [mw_Mutate r f opt_r'])\\<rparr>)) \\<or>\n                         (\\<exists>xa.\n                             grey xa\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>ghost_honorary_root :=\n       {}\\<rparr>,\n                                 sys := s sys\n                                   \\<lparr>mem_store_buffers :=\n       (mem_store_buffers (s sys))\n       (mutator m :=\n          sys_mem_store_buffers (mutator m) s @\n          [mw_Mutate r f opt_r'])\\<rparr>)) \\<and>\n                             (xa has_white_path_to x)\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>ghost_honorary_root :=\n       {}\\<rparr>,\n                                 sys := s sys\n                                   \\<lparr>mem_store_buffers :=\n       (mem_store_buffers (s sys))\n       (mutator m :=\n          sys_mem_store_buffers (mutator m) s @\n          [mw_Mutate r f opt_r'])\\<rparr>)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>xa.\n                       (xa \\<in> mut_roots s \\<or>\n                        xa \\<in> mut_ghost_honorary_root s \\<or>\n                        xa \\<in> tso_store_refs s) \\<and>\n                       (xa reaches x) s) \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa.\n                       grey xa s \\<and> (xa has_white_path_to x) s);\n        r \\<in> mut_roots s;\n        (\\<exists>r'. opt_r' = Some r') \\<longrightarrow>\n        the opt_r' \\<in> mut_roots s;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f opt_r'])\\<rparr>));\n        (xa reaches x) s;\n        \\<forall>xa.\n           grey xa\n            (s(mutator m := s (mutator m)\n                 \\<lparr>ghost_honorary_root := {}\\<rparr>,\n               sys := s sys\n                 \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m :=\n                              sys_mem_store_buffers (mutator m) s @\n                              [mw_Mutate r f\n                                opt_r'])\\<rparr>)) \\<longrightarrow>\n           \\<not> (xa has_white_path_to x) s\\<rbrakk>\n       \\<Longrightarrow> black x\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s @\n      [mw_Mutate r f opt_r'])\\<rparr>))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s;\n        (\\<exists>r'. opt_r' = Some r') \\<longrightarrow>\n        the opt_r' \\<in> mut_roots s;\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f opt_r'])\\<rparr>));\n        (xa reaches x) s;\n        \\<forall>xa.\n           grey xa\n            (s(mutator m := s (mutator m)\n                 \\<lparr>ghost_honorary_root := {}\\<rparr>,\n               sys := s sys\n                 \\<lparr>mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m :=\n                              sys_mem_store_buffers (mutator m) s @\n                              [mw_Mutate r f\n                                opt_r'])\\<rparr>)) \\<longrightarrow>\n           \\<not> (xa has_white_path_to x) s;\n        (\\<exists>xa.\n            (xa \\<in> mut_roots s \\<or>\n             xa \\<in> mut_ghost_honorary_root s \\<or>\n             xa \\<in> tso_store_refs s) \\<and>\n            (xa reaches x) s) \\<longrightarrow>\n        black x s \\<or>\n        (\\<exists>xa. grey xa s \\<and> (xa has_white_path_to x) s)\\<rbrakk>\n       \\<Longrightarrow> black x\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s @\n      [mw_Mutate r f opt_r'])\\<rparr>))", "apply (auto simp: fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; (xa reaches x) s;\n        \\<forall>xa.\n           grey xa s \\<longrightarrow> \\<not> (xa has_white_path_to x) s;\n        xa \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f None])\\<rparr>));\n        opt_r' = None;\n        \\<forall>xa.\n           xa \\<notin> mut_roots s \\<and>\n           xa \\<notin> mut_ghost_honorary_root s \\<and>\n           xa \\<notin> tso_store_refs s \\<or>\n           \\<not> (xa reaches x) s\\<rbrakk>\n       \\<Longrightarrow> black x s\n 2. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; (xa reaches x) s;\n        \\<forall>xa.\n           grey xa s \\<longrightarrow> \\<not> (xa has_white_path_to x) s;\n        xa \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f opt_r'])\\<rparr>));\n        the opt_r' \\<in> mut_roots s;\n        \\<forall>xa.\n           xa \\<notin> mut_roots s \\<and>\n           xa \\<notin> mut_ghost_honorary_root s \\<and>\n           xa \\<notin> tso_store_refs s \\<or>\n           \\<not> (xa reaches x) s\\<rbrakk>\n       \\<Longrightarrow> black x s", "(* FIXME what's gone wrong here? *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; (xa reaches x) s;\n        \\<forall>xa.\n           grey xa s \\<longrightarrow> \\<not> (xa has_white_path_to x) s;\n        xa \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f None])\\<rparr>));\n        opt_r' = None;\n        \\<forall>xa.\n           xa \\<notin> mut_roots s \\<and>\n           xa \\<notin> mut_ghost_honorary_root s \\<and>\n           xa \\<notin> tso_store_refs s \\<or>\n           \\<not> (xa reaches x) s\\<rbrakk>\n       \\<Longrightarrow> black x s\n 2. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s; (xa reaches x) s;\n        \\<forall>xa.\n           grey xa s \\<longrightarrow> \\<not> (xa has_white_path_to x) s;\n        xa \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f opt_r'])\\<rparr>));\n        the opt_r' \\<in> mut_roots s;\n        \\<forall>xa.\n           xa \\<notin> mut_roots s \\<and>\n           xa \\<notin> mut_ghost_honorary_root s \\<and>\n           xa \\<notin> tso_store_refs s \\<or>\n           \\<not> (xa reaches x) s\\<rbrakk>\n       \\<Longrightarrow> black x s", "apply (subst (asm) tso_store_refs_simps; force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma WL_mo_co_mark[simp]:\n  \"ghost_honorary_grey (s p) = {}\n     \\<Longrightarrow> WL p' (s(p := s p\\<lparr> ghost_honorary_grey := rs \\<rparr>)) = WL p' s \\<union> { r |r. p' = p \\<and> r \\<in> rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n    WL p' (s(p := s p\\<lparr>ghost_honorary_grey := rs\\<rparr>)) =\n    WL p' s \\<union> {r |r. p' = p \\<and> r \\<in> rs}", "unfolding WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n    W ((s(p := s p\\<lparr>ghost_honorary_grey := rs\\<rparr>)) p') \\<union>\n    ghost_honorary_grey\n     ((s(p := s p\\<lparr>ghost_honorary_grey := rs\\<rparr>)) p') =\n    W (s p') \\<union> ghost_honorary_grey (s p') \\<union>\n    {r |r. p' = p \\<and> r \\<in> rs}", "by (simp add: fun_upd_apply)"], ["", "lemma ghost_honorary_grey_mo_co_mark[simp]:\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {} \\<rbrakk> \\<Longrightarrow> black b (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<longleftrightarrow> black b s \\<and> b \\<noteq> r\"\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {} \\<rbrakk> \\<Longrightarrow> grey g (s(p := (s p)\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<longleftrightarrow> grey g s \\<or> g = r\"\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {} \\<rbrakk> \\<Longrightarrow> white w (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))  \\<longleftrightarrow> white w s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n     black b (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) =\n     (black b s \\<and> b \\<noteq> r)) &&&\n    (ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n     grey g (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) =\n     (grey g s \\<or> g = r)) &&&\n    (ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n     white w (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) =\n     white w s)", "unfolding black_def grey_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n     (marked b\n       (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<and>\n      (\\<nexists>x.\n          b \\<in> WL x\n                   (s(p := s p\n                        \\<lparr>ghost_honorary_grey := {r}\\<rparr>)))) =\n     ((marked b s \\<and> (\\<nexists>x. b \\<in> WL x s)) \\<and>\n      b \\<noteq> r)) &&&\n    (ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n     (\\<exists>x.\n         g \\<in> WL x\n                  (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))) =\n     ((\\<exists>x. g \\<in> WL x s) \\<or> g = r)) &&&\n    (ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n     white w (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) =\n     white w s)", "by (auto simp: fun_upd_apply)"], ["", "lemma ghost_honorary_grey_mo_co_W[simp]:\n  \"ghost_honorary_grey (s p') = {r}\n     \\<Longrightarrow> (WL p (s(p' := (s p')\\<lparr>W := insert r (W (s p')), ghost_honorary_grey := {}\\<rparr>))) = (WL p s)\"\n  \"ghost_honorary_grey (s p') = {r}\n     \\<Longrightarrow> grey g (s(p' := (s p')\\<lparr>W := insert r (W (s p')), ghost_honorary_grey := {}\\<rparr>)) \\<longleftrightarrow> grey g s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ghost_honorary_grey (s p') = {r} \\<Longrightarrow>\n     WL p\n      (s(p' := s p'\n           \\<lparr>W := insert r (W (s p')),\n              ghost_honorary_grey := {}\\<rparr>)) =\n     WL p s) &&&\n    (ghost_honorary_grey (s p') = {r} \\<Longrightarrow>\n     grey g\n      (s(p' := s p'\n           \\<lparr>W := insert r (W (s p')),\n              ghost_honorary_grey := {}\\<rparr>)) =\n     grey g s)", "unfolding grey_def WL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ghost_honorary_grey (s p') = {r} \\<Longrightarrow>\n     W ((s(p' := s p'\n             \\<lparr>W := insert r (W (s p')),\n                ghost_honorary_grey := {}\\<rparr>))\n         p) \\<union>\n     ghost_honorary_grey\n      ((s(p' := s p'\n            \\<lparr>W := insert r (W (s p')),\n               ghost_honorary_grey := {}\\<rparr>))\n        p) =\n     W (s p) \\<union> ghost_honorary_grey (s p)) &&&\n    (ghost_honorary_grey (s p') = {r} \\<Longrightarrow>\n     (\\<exists>x.\n         g \\<in> W ((s(p' := s p'\n                         \\<lparr>W := insert r (W (s p')),\n                            ghost_honorary_grey := {}\\<rparr>))\n                     x) \\<union>\n                 ghost_honorary_grey\n                  ((s(p' := s p'\n                        \\<lparr>W := insert r (W (s p')),\n                           ghost_honorary_grey := {}\\<rparr>))\n                    x)) =\n     (\\<exists>x. g \\<in> W (s x) \\<union> ghost_honorary_grey (s x)))", "by (auto simp: fun_upd_apply split: process_name.splits if_splits)"], ["", "lemma reachable_sweep_loop_free:\n  \"mut_m.reachable m r (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\n   \\<Longrightarrow> mut_m.reachable m r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.reachable m r\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r' := None)\\<rparr>)) \\<Longrightarrow>\n    mut_m.reachable m r s", "unfolding mut_m.reachable_def reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> roots\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\n                  (mutator m)) \\<union>\n               ghost_honorary_root\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\n                  (mutator m)) \\<union>\n               mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r' := None)\\<rparr>)) \\<and>\n       (\\<lambda>x y.\n           (x points_to y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r' := None)\\<rparr>)))\\<^sup>*\\<^sup>*\n        x r \\<Longrightarrow>\n    \\<exists>x.\n       x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<and>\n       (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x r", "by (clarsimp simp: fun_upd_apply) (metis (no_types, lifting) mono_rtranclp)"], ["", "lemma reachable_deref_del[simp]:\n  \"\\<lbrakk> sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; r \\<in> mut_m.mut_roots m s; mut_m.mut_ghost_honorary_root m s = {} \\<rbrakk>\n   \\<Longrightarrow> mut_m.reachable m' y (s(mutator m := s (mutator m)\\<lparr> ghost_honorary_root := Option.set_option opt_r', ref := opt_r' \\<rparr>))\n   \\<longleftrightarrow> mut_m.reachable m' y s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r';\n     r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {}\\<rbrakk>\n    \\<Longrightarrow> mut_m.reachable m' y\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>ghost_honorary_root :=\nset_option opt_r',\n                               ref := opt_r'\\<rparr>)) =\n                      mut_m.reachable m' y s", "unfolding mut_m.reachable_def reaches_def sys_load_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(do_load_action (mr_Ref r f) \\<circ>\n              processors_view_of_memory (mutator m))\n              (s sys) =\n             mv_Ref opt_r';\n     r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          x \\<in> roots\n                                   ((s(mutator m := s (mutator m)\n   \\<lparr>ghost_honorary_root := set_option opt_r', ref := opt_r'\\<rparr>))\n                                     (mutator m')) \\<union>\n                                  ghost_honorary_root\n                                   ((s(mutator m := s (mutator m)\n   \\<lparr>ghost_honorary_root := set_option opt_r', ref := opt_r'\\<rparr>))\n                                     (mutator m')) \\<union>\n                                  mut_m.tso_store_refs m'\n                                   (s(mutator m := s (mutator m)\n  \\<lparr>ghost_honorary_root := set_option opt_r',\n     ref := opt_r'\\<rparr>)) \\<and>\n                          (\\<lambda>x y.\n                              (x points_to y)\n                               (s(mutator m := s (mutator m)\n                                    \\<lparr>ghost_honorary_root :=\n        set_option opt_r',\n ref := opt_r'\\<rparr>)))\\<^sup>*\\<^sup>*\n                           x y) =\n                      (\\<exists>x.\n                          x \\<in> roots (s (mutator m')) \\<union>\n                                  ghost_honorary_root\n                                   (s (mutator m')) \\<union>\n                                  mut_m.tso_store_refs m' s \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           x y)", "apply (clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {};\n     opt_r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f);\n     m' = m\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          (x \\<in> roots (s (mutator m)) \\<or>\n                           Option.bind\n                            (heap\n                              (processors_view_of_memory (mutator m)\n                                (s sys))\n                              r)\n                            (\\<lambda>obj. obj_fields obj f) =\n                           Some x \\<or>\n                           x \\<in> mut_m.tso_store_refs m s) \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           x y) =\n                      (\\<exists>x.\n                          (x \\<in> roots (s (mutator m)) \\<or>\n                           x \\<in> mut_m.tso_store_refs m s) \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           x y)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {};\n     opt_r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f);\n     m' = m;\n     \\<exists>x.\n        (x \\<in> roots (s (mutator m)) \\<or>\n         Option.bind\n          (heap (processors_view_of_memory (mutator m) (s sys)) r)\n          (\\<lambda>obj. obj_fields obj f) =\n         Some x \\<or>\n         x \\<in> mut_m.tso_store_refs m s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (x \\<in> roots (s (mutator m)) \\<or>\n                          x \\<in> mut_m.tso_store_refs m s) \\<and>\n                         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                          y\n 2. \\<lbrakk>r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {};\n     opt_r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f);\n     m' = m;\n     \\<exists>x.\n        (x \\<in> roots (s (mutator m)) \\<or>\n         x \\<in> mut_m.tso_store_refs m s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (x \\<in> roots (s (mutator m)) \\<or>\n                          Option.bind\n                           (heap\n                             (processors_view_of_memory (mutator m) (s sys))\n                             r)\n                           (\\<lambda>obj. obj_fields obj f) =\n                          Some x \\<or>\n                          x \\<in> mut_m.tso_store_refs m s) \\<and>\n                         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                          y", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {};\n        opt_r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        m' = m;\n        x \\<in> roots (s (mutator m)) \\<or>\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f) =\n        Some x \\<or>\n        x \\<in> mut_m.tso_store_refs m s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<lbrakk>r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {};\n     opt_r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f);\n     m' = m;\n     \\<exists>x.\n        (x \\<in> roots (s (mutator m)) \\<or>\n         x \\<in> mut_m.tso_store_refs m s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (x \\<in> roots (s (mutator m)) \\<or>\n                          Option.bind\n                           (heap\n                             (processors_view_of_memory (mutator m) (s sys))\n                             r)\n                           (\\<lambda>obj. obj_fields obj f) =\n                          Some x \\<or>\n                          x \\<in> mut_m.tso_store_refs m s) \\<and>\n                         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                          y", "apply (elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {};\n        opt_r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        m' = m; (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> roots (s (mutator m))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {};\n        opt_r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        m' = m; (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 3. \\<And>x.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {};\n        opt_r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        m' = m; (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 4. \\<lbrakk>r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {};\n     opt_r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f);\n     m' = m;\n     \\<exists>x.\n        (x \\<in> roots (s (mutator m)) \\<or>\n         x \\<in> mut_m.tso_store_refs m s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (x \\<in> roots (s (mutator m)) \\<or>\n                          Option.bind\n                           (heap\n                             (processors_view_of_memory (mutator m) (s sys))\n                             r)\n                           (\\<lambda>obj. obj_fields obj f) =\n                          Some x \\<or>\n                          x \\<in> mut_m.tso_store_refs m s) \\<and>\n                         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                          y", "apply metis"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {};\n        opt_r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        m' = m; (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {};\n        opt_r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        m' = m; (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 3. \\<lbrakk>r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {};\n     opt_r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f);\n     m' = m;\n     \\<exists>x.\n        (x \\<in> roots (s (mutator m)) \\<or>\n         x \\<in> mut_m.tso_store_refs m s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (x \\<in> roots (s (mutator m)) \\<or>\n                          Option.bind\n                           (heap\n                             (processors_view_of_memory (mutator m) (s sys))\n                             r)\n                           (\\<lambda>obj. obj_fields obj f) =\n                          Some x \\<or>\n                          x \\<in> mut_m.tso_store_refs m s) \\<and>\n                         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                          y", "apply (erule option_bind_invE; auto dest!: fold_stores_points_to)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {}; opt_r' = Some x; m' = m;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields a f = Some x; (r points_to x) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 2. \\<And>x a w.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {}; opt_r' = Some x; m' = m;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        obj_fields a f = Some x;\n        w \\<in> set (sys_mem_store_buffers (mutator m) s);\n        x \\<in> (case w of\n                 mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                 | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                 | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 3. \\<And>x.\n       \\<lbrakk>r \\<in> roots (s (mutator m));\n        ghost_honorary_root (s (mutator m)) = {};\n        opt_r' =\n        Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n         (\\<lambda>obj. obj_fields obj f);\n        m' = m; (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n        x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x \\<in> roots (s (mutator m)) \\<or>\n                             x \\<in> mut_m.tso_store_refs m s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             x y\n 4. \\<lbrakk>r \\<in> roots (s (mutator m));\n     ghost_honorary_root (s (mutator m)) = {};\n     opt_r' =\n     Option.bind (heap (processors_view_of_memory (mutator m) (s sys)) r)\n      (\\<lambda>obj. obj_fields obj f);\n     m' = m;\n     \\<exists>x.\n        (x \\<in> roots (s (mutator m)) \\<or>\n         x \\<in> mut_m.tso_store_refs m s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (x \\<in> roots (s (mutator m)) \\<or>\n                          Option.bind\n                           (heap\n                             (processors_view_of_memory (mutator m) (s sys))\n                             r)\n                           (\\<lambda>obj. obj_fields obj f) =\n                          Some x \\<or>\n                          x \\<in> mut_m.tso_store_refs m s) \\<and>\n                         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                          y", "apply (auto elim!: converse_rtranclp_into_rtranclp[rotated]\n              simp: mut_m.tso_store_refs_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_black_refs_dequeue[simp]:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; no_black_refs s; valid_W_inv s \\<rbrakk>\n   \\<Longrightarrow> no_black_refs (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\"\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mutate r f r' # ws; no_black_refs s \\<rbrakk>\n     \\<Longrightarrow> no_black_refs (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>) (sys_heap s r)),\n                                      mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n      no_black_refs s; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> no_black_refs\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (p := ws)\\<rparr>))) &&&\n    (\\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n      no_black_refs s\\<rbrakk>\n     \\<Longrightarrow> no_black_refs\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (p := ws)\\<rparr>)))", "unfolding no_black_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n      \\<forall>x. \\<not> black x s; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> \\<forall>x.\n                          \\<not> black x\n                                  (s(sys := s sys\n \\<lparr>heap := (sys_heap s)\n           (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                  (sys_heap s r)),\n    mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))) &&&\n    (\\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n      \\<forall>x. \\<not> black x s\\<rbrakk>\n     \\<Longrightarrow> \\<forall>x.\n                          \\<not> black x\n                                  (s(sys := s sys\n \\<lparr>heap := (sys_heap s)\n           (r := map_option\n                  (\\<lambda>obj. obj\n                      \\<lparr>obj_fields := (obj_fields obj)\n                                (f := r')\\<rparr>)\n                  (sys_heap s r)),\n    mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)))", "by (auto simp: fun_upd_apply dest: valid_W_invD)"], ["", "lemma colours_blacken[simp]:\n  \"valid_W_inv s \\<Longrightarrow> black b (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) \\<longleftrightarrow> black b s \\<or> (r \\<in> gc_W s \\<and> b = r)\"\n  \"\\<lbrakk> r \\<in> gc_W s; valid_W_inv s \\<rbrakk> \\<Longrightarrow> grey g (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) \\<longleftrightarrow> (grey g s \\<and> g \\<noteq> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_W_inv s \\<Longrightarrow>\n     black b (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) =\n     (black b s \\<or> r \\<in> gc_W s \\<and> b = r)) &&&\n    (\\<lbrakk>r \\<in> gc_W s; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> grey g\n                        (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) =\n                       (grey g s \\<and> g \\<noteq> r))", "(*  \"white w (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) \\<longleftrightarrow> white w s\" is redundant *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_W_inv s \\<Longrightarrow>\n     black b (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) =\n     (black b s \\<or> r \\<in> gc_W s \\<and> b = r)) &&&\n    (\\<lbrakk>r \\<in> gc_W s; valid_W_inv s\\<rbrakk>\n     \\<Longrightarrow> grey g\n                        (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) =\n                       (grey g s \\<and> g \\<noteq> r))", "unfolding black_def grey_def valid_W_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x xa.\n         xa \\<in> W (s x) \\<or>\n         sys_mem_lock s \\<noteq> Some x \\<and>\n         xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n         marked xa s) \\<and>\n     (\\<forall>x xa.\n         x \\<noteq> xa \\<longrightarrow>\n         WL x s \\<inter> WL xa s = {}) \\<and>\n     (\\<forall>x xa xb.\n         \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                 xb \\<in> W (s xa))) \\<and>\n     sys_ghost_honorary_grey s = {} \\<and>\n     (\\<forall>x xa xb.\n         mw_Mark xa xb\n         \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n         xb = sys_fM s \\<and>\n         xa \\<in> ghost_honorary_grey (s x) \\<and>\n         sys_mem_lock s = Some x \\<and>\n         white xa s \\<and>\n         filter is_mw_Mark (sys_mem_store_buffers x s) =\n         [mw_Mark xa xb]) \\<Longrightarrow>\n     (marked b (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)) \\<and>\n      (\\<nexists>x.\n          b \\<in> WL x (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)))) =\n     (marked b s \\<and> (\\<nexists>x. b \\<in> WL x s) \\<or>\n      r \\<in> gc_W s \\<and> b = r)) &&&\n    (\\<lbrakk>r \\<in> gc_W s;\n      (\\<forall>x xa.\n          xa \\<in> W (s x) \\<or>\n          sys_mem_lock s \\<noteq> Some x \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n          marked xa s) \\<and>\n      (\\<forall>x xa.\n          x \\<noteq> xa \\<longrightarrow>\n          WL x s \\<inter> WL xa s = {}) \\<and>\n      (\\<forall>x xa xb.\n          \\<not> (xb \\<in> ghost_honorary_grey (s x) \\<and>\n                  xb \\<in> W (s xa))) \\<and>\n      sys_ghost_honorary_grey s = {} \\<and>\n      (\\<forall>x xa xb.\n          mw_Mark xa xb\n          \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n          xb = sys_fM s \\<and>\n          xa \\<in> ghost_honorary_grey (s x) \\<and>\n          sys_mem_lock s = Some x \\<and>\n          white xa s \\<and>\n          filter is_mw_Mark (sys_mem_store_buffers x s) =\n          [mw_Mark xa xb])\\<rbrakk>\n     \\<Longrightarrow> (\\<exists>x.\n                           g \\<in> WL x\n                                    (s(gc := s gc\n   \\<lparr>W := gc_W s - {r}\\<rparr>))) =\n                       ((\\<exists>x. g \\<in> WL x s) \\<and> g \\<noteq> r))", "apply (simp_all add: all_conj_distrib split: obj_at_splits if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<forall>x xa.\n                 (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                 sys_mem_lock s = Some x \\<or>\n                 xa \\<notin> ghost_honorary_grey (s x)) \\<and>\n             (\\<forall>x xa.\n                 xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n                 (\\<forall>obj.\n                     sys_heap s xa = Some obj \\<longrightarrow>\n                     sys_mem_lock s = Some x \\<or>\n                     obj_mark obj = sys_fM s));\n     \\<forall>x xa.\n        x \\<noteq> xa \\<longrightarrow> WL x s \\<inter> WL xa s = {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n     \\<forall>x xa.\n        (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n     \\<forall>x xa.\n        xa \\<in> W (s x) \\<longrightarrow>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            obj_mark obj = sys_fM s)\\<rbrakk>\n    \\<Longrightarrow> (sys_heap s b = None \\<longrightarrow>\n                       r \\<in> gc_W s \\<longrightarrow> b \\<noteq> r) \\<and>\n                      (\\<forall>obj.\n                          sys_heap s b = Some obj \\<longrightarrow>\n                          (obj_mark obj = sys_fM s \\<and>\n                           (\\<forall>x.\n                               b \\<notin> WL x\n     (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>)))) =\n                          (obj_mark obj = sys_fM s \\<and>\n                           (\\<forall>x. b \\<notin> WL x s) \\<or>\n                           r \\<in> gc_W s \\<and> b = r))\n 2. \\<lbrakk>(\\<forall>x xa.\n                 (\\<exists>y. sys_heap s xa = Some y) \\<or>\n                 sys_mem_lock s = Some x \\<or>\n                 xa \\<notin> ghost_honorary_grey (s x)) \\<and>\n             (\\<forall>x xa.\n                 xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n                 (\\<forall>obj.\n                     sys_heap s xa = Some obj \\<longrightarrow>\n                     sys_mem_lock s = Some x \\<or>\n                     obj_mark obj = sys_fM s));\n     \\<forall>x xa.\n        x \\<noteq> xa \\<longrightarrow> WL x s \\<inter> WL xa s = {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n     r \\<in> gc_W s;\n     \\<forall>x xa.\n        (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n     \\<forall>x xa.\n        xa \\<in> W (s x) \\<longrightarrow>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            obj_mark obj = sys_fM s)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x.\n                          g \\<in> WL x\n                                   (s(gc := s gc\n  \\<lparr>W := gc_W s - {r}\\<rparr>))) =\n                      ((\\<exists>x. g \\<in> WL x s) \\<and> g \\<noteq> r)", "apply safe"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<forall>x xa.\n                x \\<noteq> xa \\<longrightarrow>\n                WL x s \\<inter> WL xa s = {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n     \\<forall>x xa.\n        (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n     \\<forall>x xa.\n        xa \\<in> W (s x) \\<longrightarrow>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            obj_mark obj = sys_fM s);\n     \\<forall>x xa.\n        (\\<exists>y. sys_heap s xa = Some y) \\<or>\n        sys_mem_lock s = Some x \\<or> xa \\<notin> ghost_honorary_grey (s x);\n     \\<forall>x xa.\n        xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n     sys_heap s r = None; r \\<in> gc_W s; b = r\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s b = Some obj;\n        \\<forall>x.\n           b \\<notin> WL x (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>));\n        obj_mark obj; sys_fM s; r \\<notin> gc_W s; b \\<in> WL x s\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s b = Some obj;\n        \\<forall>x.\n           b \\<notin> WL x (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>));\n        obj_mark obj; sys_fM s; b \\<noteq> r; b \\<in> WL x s\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s b = Some obj;\n        \\<forall>x.\n           b \\<notin> WL x (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>));\n        \\<not> obj_mark obj; \\<not> sys_fM s; r \\<notin> gc_W s;\n        b \\<in> WL x s\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s b = Some obj;\n        \\<forall>x.\n           b \\<notin> WL x (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>));\n        \\<not> obj_mark obj; \\<not> sys_fM s; b \\<noteq> r;\n        b \\<in> WL x s\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s b = Some obj; \\<forall>x. b \\<notin> WL x s;\n        obj_mark obj; sys_fM s;\n        b \\<in> WL x\n                 (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s b = Some obj; \\<forall>x. b \\<notin> WL x s;\n        \\<not> obj_mark obj; \\<not> sys_fM s;\n        b \\<in> WL x\n                 (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>obj.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s r = Some obj; r \\<in> gc_W s; b = r;\n        obj_mark obj\\<rbrakk>\n       \\<Longrightarrow> sys_fM s\n 9. \\<And>obj.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   WL x s \\<inter> WL xa s = {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s r = Some obj; r \\<in> gc_W s; b = r; sys_fM s\\<rbrakk>\n       \\<Longrightarrow> obj_mark obj\n 10. \\<And>obj x.\n        \\<lbrakk>\\<forall>x xa.\n                    x \\<noteq> xa \\<longrightarrow>\n                    WL x s \\<inter> WL xa s = {};\n         \\<forall>x xa xb.\n            xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n            xb \\<notin> W (s xa);\n         sys_ghost_honorary_grey s = {};\n         \\<forall>x xa xb.\n            mw_Mark xa xb\n            \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n            xb = sys_fM s \\<and>\n            xa \\<in> ghost_honorary_grey (s x) \\<and>\n            sys_mem_lock s = Some x \\<and>\n            white xa s \\<and>\n            filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n         \\<forall>x xa.\n            (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n         \\<forall>x xa.\n            xa \\<in> W (s x) \\<longrightarrow>\n            (\\<forall>obj.\n                sys_heap s xa = Some obj \\<longrightarrow>\n                obj_mark obj = sys_fM s);\n         \\<forall>x xa.\n            (\\<exists>y. sys_heap s xa = Some y) \\<or>\n            sys_mem_lock s = Some x \\<or>\n            xa \\<notin> ghost_honorary_grey (s x);\n         \\<forall>x xa.\n            xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n            (\\<forall>obj.\n                sys_heap s xa = Some obj \\<longrightarrow>\n                sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n         sys_heap s r = Some obj; r \\<in> gc_W s; b = r;\n         r \\<in> WL x\n                  (s(gc := s gc\\<lparr>W := gc_W s - {r}\\<rparr>))\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 13 subgoals...", "apply (simp_all add: WL_def fun_upd_apply split: if_splits)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>x xa.\n                x \\<noteq> xa \\<longrightarrow>\n                (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                {};\n     \\<forall>x xa xb.\n        xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        xb \\<notin> W (s xa);\n     sys_ghost_honorary_grey s = {};\n     \\<forall>x xa xb.\n        mw_Mark xa xb\n        \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n        xb = sys_fM s \\<and>\n        xa \\<in> ghost_honorary_grey (s x) \\<and>\n        sys_mem_lock s = Some x \\<and>\n        white xa s \\<and>\n        filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n     \\<forall>x xa.\n        (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n     \\<forall>x xa.\n        xa \\<in> W (s x) \\<longrightarrow>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            obj_mark obj = sys_fM s);\n     \\<forall>x xa.\n        (\\<exists>y. sys_heap s xa = Some y) \\<or>\n        sys_mem_lock s = Some x \\<or> xa \\<notin> ghost_honorary_grey (s x);\n     \\<forall>x xa.\n        xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n        (\\<forall>obj.\n            sys_heap s xa = Some obj \\<longrightarrow>\n            sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n     sys_heap s r = None; r \\<in> gc_W s; b = r\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>obj x.\n       \\<lbrakk>\\<forall>x.\n                   (x = gc \\<longrightarrow>\n                    b \\<notin> gc_W s \\<and>\n                    b \\<notin> gc_ghost_honorary_grey s) \\<and>\n                   (x = gc \\<or>\n                    b \\<notin> W (s x) \\<and>\n                    b \\<notin> ghost_honorary_grey (s x));\n        obj_mark obj; sys_fM s; b \\<noteq> r;\n        b \\<in> W (s x) \\<or> b \\<in> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow> obj_mark obj);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj);\n        sys_heap s b = Some obj\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>obj x.\n       \\<lbrakk>\\<forall>x.\n                   (x = gc \\<longrightarrow>\n                    b \\<notin> gc_W s \\<and>\n                    b \\<notin> gc_ghost_honorary_grey s) \\<and>\n                   (x = gc \\<or>\n                    b \\<notin> W (s x) \\<and>\n                    b \\<notin> ghost_honorary_grey (s x));\n        \\<not> obj_mark obj; \\<not> sys_fM s; b \\<noteq> r;\n        b \\<in> W (s x) \\<or> b \\<in> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           \\<not> xb \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               \\<not> obj_mark obj);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> \\<not> obj_mark obj);\n        sys_heap s b = Some obj\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s r = Some obj; r \\<in> gc_W s; b = r; x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x = gc;\n        g \\<in> gc_W s \\<and> g \\<noteq> r \\<or>\n        g \\<in> gc_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 7. \\<And>x.\n       \\<lbrakk>g = r;\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply (metis option.distinct(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>obj x.\n       \\<lbrakk>\\<forall>x.\n                   (x = gc \\<longrightarrow>\n                    b \\<notin> gc_W s \\<and>\n                    b \\<notin> gc_ghost_honorary_grey s) \\<and>\n                   (x = gc \\<or>\n                    b \\<notin> W (s x) \\<and>\n                    b \\<notin> ghost_honorary_grey (s x));\n        obj_mark obj; sys_fM s; b \\<noteq> r;\n        b \\<in> W (s x) \\<or> b \\<in> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow> obj_mark obj);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj);\n        sys_heap s b = Some obj\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>obj x.\n       \\<lbrakk>\\<forall>x.\n                   (x = gc \\<longrightarrow>\n                    b \\<notin> gc_W s \\<and>\n                    b \\<notin> gc_ghost_honorary_grey s) \\<and>\n                   (x = gc \\<or>\n                    b \\<notin> W (s x) \\<and>\n                    b \\<notin> ghost_honorary_grey (s x));\n        \\<not> obj_mark obj; \\<not> sys_fM s; b \\<noteq> r;\n        b \\<in> W (s x) \\<or> b \\<in> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           \\<not> xb \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               \\<not> obj_mark obj);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> \\<not> obj_mark obj);\n        sys_heap s b = Some obj\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s r = Some obj; r \\<in> gc_W s; b = r; x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x = gc;\n        g \\<in> gc_W s \\<and> g \\<noteq> r \\<or>\n        g \\<in> gc_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 6. \\<And>x.\n       \\<lbrakk>g = r;\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>obj x.\n       \\<lbrakk>\\<forall>x.\n                   (x = gc \\<longrightarrow>\n                    b \\<notin> gc_W s \\<and>\n                    b \\<notin> gc_ghost_honorary_grey s) \\<and>\n                   (x = gc \\<or>\n                    b \\<notin> W (s x) \\<and>\n                    b \\<notin> ghost_honorary_grey (s x));\n        \\<not> obj_mark obj; \\<not> sys_fM s; b \\<noteq> r;\n        b \\<in> W (s x) \\<or> b \\<in> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           \\<not> xb \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               \\<not> obj_mark obj);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> \\<not> obj_mark obj);\n        sys_heap s b = Some obj\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s r = Some obj; r \\<in> gc_W s; b = r; x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x = gc;\n        g \\<in> gc_W s \\<and> g \\<noteq> r \\<or>\n        g \\<in> gc_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 5. \\<And>x.\n       \\<lbrakk>g = r;\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>obj x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        sys_heap s r = Some obj; r \\<in> gc_W s; b = r; x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x = gc;\n        g \\<in> gc_W s \\<and> g \\<noteq> r \\<or>\n        g \\<in> gc_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 4. \\<And>x.\n       \\<lbrakk>g = r;\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x = gc;\n        g \\<in> gc_W s \\<and> g \\<noteq> r \\<or>\n        g \\<in> gc_ghost_honorary_grey s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 3. \\<And>x.\n       \\<lbrakk>g = r;\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            g \\<in> W (s x) \\<or>\n                            g \\<in> ghost_honorary_grey (s x)\n 2. \\<And>x.\n       \\<lbrakk>g = r;\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>g = r;\n        \\<forall>x xa.\n           x \\<noteq> xa \\<longrightarrow>\n           (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n           (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n           {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        x \\<noteq> gc;\n        r \\<in> W (s x) \\<or> r \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   x \\<noteq> xa \\<longrightarrow>\n                   (W (s x) \\<union> ghost_honorary_grey (s x)) \\<inter>\n                   (W (s xa) \\<union> ghost_honorary_grey (s xa)) =\n                   {};\n        \\<forall>x xa xb.\n           xb \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           xb \\<notin> W (s xa);\n        sys_ghost_honorary_grey s = {};\n        \\<forall>x xa xb.\n           mw_Mark xa xb\n           \\<in> set (sys_mem_store_buffers x s) \\<longrightarrow>\n           xb = sys_fM s \\<and>\n           xa \\<in> ghost_honorary_grey (s x) \\<and>\n           sys_mem_lock s = Some x \\<and>\n           white xa s \\<and>\n           filter is_mw_Mark (sys_mem_store_buffers x s) = [mw_Mark xa xb];\n        r \\<in> gc_W s;\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or> xa \\<notin> W (s x);\n        \\<forall>x xa.\n           xa \\<in> W (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               obj_mark obj = sys_fM s);\n        \\<forall>x xa.\n           (\\<exists>y. sys_heap s xa = Some y) \\<or>\n           sys_mem_lock s = Some x \\<or>\n           xa \\<notin> ghost_honorary_grey (s x);\n        \\<forall>x xa.\n           xa \\<in> ghost_honorary_grey (s x) \\<longrightarrow>\n           (\\<forall>obj.\n               sys_heap s xa = Some obj \\<longrightarrow>\n               sys_mem_lock s = Some x \\<or> obj_mark obj = sys_fM s);\n        g \\<noteq> r;\n        g \\<in> W (s x) \\<or> g \\<in> ghost_honorary_grey (s x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (x = gc \\<longrightarrow>\n                             g \\<in> gc_W s \\<or>\n                             g \\<in> gc_ghost_honorary_grey s) \\<and>\n                            (x \\<noteq> gc \\<longrightarrow>\n                             g \\<in> W (s x) \\<or>\n                             g \\<in> ghost_honorary_grey (s x))", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* FIXME\napply (auto simp: black_def grey_def WL_def split: obj_at_splits)\napply metis+\ndone\n*)"], ["", "lemma no_black_refs_alloc[simp]:\n  \"\\<lbrakk> heap (s sys) r' = None; no_black_refs s \\<rbrakk>\n     \\<Longrightarrow> no_black_refs (s(mutator m' := s (mutator m')\\<lparr>roots := roots'\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\n     \\<longleftrightarrow> fl \\<noteq> sys_fM s \\<or> grey r' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_heap s r' = None; no_black_refs s\\<rbrakk>\n    \\<Longrightarrow> no_black_refs\n                       (s(mutator m' := s (mutator m')\n                            \\<lparr>roots := roots'\\<rparr>,\n                          sys := s sys\n                            \\<lparr>heap := sys_heap s(r' \\<mapsto>\n\\<lparr>obj_mark = fl, obj_fields = Map.empty,\n   obj_payload = Map.empty\\<rparr>)\\<rparr>)) =\n                      (fl \\<noteq> sys_fM s \\<or> grey r' s)", "unfolding no_black_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_heap s r' = None; \\<forall>x. \\<not> black x s\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          \\<not> black x\n                                  (s(mutator m' := s (mutator m')\n \\<lparr>roots := roots'\\<rparr>,\n                                     sys := s sys\n \\<lparr>heap := sys_heap s(r' \\<mapsto>\n           \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n              obj_payload = Map.empty\\<rparr>)\\<rparr>))) =\n                      (fl \\<noteq> sys_fM s \\<or> grey r' s)", "by simp"], ["", "lemma no_black_refs_mo_co_mark[simp]:\n  \"\\<lbrakk> ghost_honorary_grey (s p) = {}; white r s \\<rbrakk>\n     \\<Longrightarrow> no_black_refs (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<longleftrightarrow> no_black_refs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghost_honorary_grey (s p) = {}; white r s\\<rbrakk>\n    \\<Longrightarrow> no_black_refs\n                       (s(p := s p\n                            \\<lparr>ghost_honorary_grey := {r}\\<rparr>)) =\n                      no_black_refs s", "unfolding no_black_refs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ghost_honorary_grey (s p) = {}; white r s\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          \\<not> black x\n                                  (s(p := s p\n \\<lparr>ghost_honorary_grey := {r}\\<rparr>))) =\n                      (\\<forall>x. \\<not> black x s)", "by auto"], ["", "lemma grey_protects_white_mark[simp]:\n  assumes ghg: \"ghost_honorary_grey (s p) = {}\"\n  shows \"(\\<exists>g. (g grey_protects_white w) (s(p := s p\\<lparr> ghost_honorary_grey := {r} \\<rparr>)))\n      \\<longleftrightarrow> (\\<exists>g'. (g' grey_protects_white w) s) \\<or> (r has_white_path_to w) s\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>g.\n        (g grey_protects_white w)\n         (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))) =\n    ((\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n     (r has_white_path_to w) s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\n             \\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<Longrightarrow>\n    (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s\n 2. (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "assume ?lhs"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\n             \\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<Longrightarrow>\n    (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s\n 2. (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "obtain g where \"(g grey_protects_white w) (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\""], ["proof (prove)\nusing this:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        (g grey_protects_white w)\n         (s(p := s p\n              \\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (g grey_protects_white w)\n   (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\n             \\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<Longrightarrow>\n    (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s\n 2. (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "from this ghg"], ["proof (chain)\npicking this:\n  (g grey_protects_white w)\n   (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n  ghost_honorary_grey (s p) = {}", "show ?rhs"], ["proof (prove)\nusing this:\n  (g grey_protects_white w)\n   (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n  ghost_honorary_grey (s p) = {}\n\ngoal (1 subgoal):\n 1. (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s", "by induct (auto simp: fun_upd_apply)"], ["proof (state)\nthis:\n  (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n  (r has_white_path_to w) s\n\ngoal (1 subgoal):\n 1. (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "assume ?rhs"], ["proof (state)\nthis:\n  (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n  (r has_white_path_to w) s\n\ngoal (1 subgoal):\n 1. (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n    (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n  (r has_white_path_to w) s", "show ?lhs"], ["proof (prove)\nusing this:\n  (\\<exists>g'. (g' grey_protects_white w) s) \\<or>\n  (r has_white_path_to w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "proof(safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g'.\n       (g' grey_protects_white w) s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white w)\n           (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n 2. (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g'.\n       (g' grey_protects_white w) s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white w)\n           (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n 2. (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "assume \"(g grey_protects_white w) s\""], ["proof (state)\nthis:\n  (g grey_protects_white w) s\n\ngoal (2 subgoals):\n 1. \\<And>g'.\n       (g' grey_protects_white w) s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white w)\n           (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n 2. (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "from this ghg"], ["proof (chain)\npicking this:\n  (g grey_protects_white w) s\n  ghost_honorary_grey (s p) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  (g grey_protects_white w) s\n  ghost_honorary_grey (s p) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "apply induct"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>grey x s; ghost_honorary_grey (s p) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white x)\n                             (s(p := s p\n                                  \\<lparr>ghost_honorary_grey :=\n      {r}\\<rparr>))\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>));\n        (y points_to z) s; white z s;\n        ghost_honorary_grey (s p) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(p := s p\n                                  \\<lparr>ghost_honorary_grey :=\n      {r}\\<rparr>))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>));\n        (y points_to z) s; white z s;\n        ghost_honorary_grey (s p) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(p := s p\n                                  \\<lparr>ghost_honorary_grey :=\n      {r}\\<rparr>))", "unfolding grey_protects_white_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        ghost_honorary_grey (s p) = {} \\<Longrightarrow>\n        \\<exists>g.\n           grey g\n            (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<and>\n           (g has_white_path_to y)\n            (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>));\n        (y points_to z) s; white z s;\n        ghost_honorary_grey (s p) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(p := s p\n                                  \\<lparr>ghost_honorary_grey :=\n      {r}\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(p := s p\n                                  \\<lparr>ghost_honorary_grey :=\n      {r}\\<rparr>))", "apply (auto simp: fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n\ngoal (1 subgoal):\n 1. (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "assume \"(r has_white_path_to w) s\""], ["proof (state)\nthis:\n  (r has_white_path_to w) s\n\ngoal (1 subgoal):\n 1. (r has_white_path_to w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "with ghg"], ["proof (chain)\npicking this:\n  ghost_honorary_grey (s p) = {}\n  (r has_white_path_to w) s", "show ?thesis"], ["proof (prove)\nusing this:\n  ghost_honorary_grey (s p) = {}\n  (r has_white_path_to w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "unfolding grey_protects_white_def has_white_path_to_def"], ["proof (prove)\nusing this:\n  ghost_honorary_grey (s p) = {}\n  (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* r w\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       grey g (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<and>\n       (\\<lambda>x y.\n           (x points_to y)\n            (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>)) \\<and>\n           white y\n            (s(p := s p\n                 \\<lparr>ghost_honorary_grey :=\n                           {r}\\<rparr>)))\\<^sup>*\\<^sup>*\n        g w", "by (auto simp: fun_upd_apply)"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(p := s p\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_refs_inv_dequeue_Mutate:\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes vri: \"valid_refs_inv s\"\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\"\n  shows \"valid_refs_inv (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>))\" (is \"valid_refs_inv ?s'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "proof(rule valid_refs_invI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                mut_m.tso_store_refs m\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                mut_m.tso_store_refs m\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))", "let ?root = \"\\<lambda>m x. mut_m.root m x \\<^bold>\\<or> grey x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                mut_m.tso_store_refs m\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                mut_m.tso_store_refs m\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))", "assume xy: \"(x reaches y) ?s'\" and x: \"?root m x ?s'\""], ["proof (state)\nthis:\n  (x reaches y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  x \\<in> roots\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m)) \\<union>\n          ghost_honorary_root\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m)) \\<union>\n          mut_m.tso_store_refs m\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m' := ws)\\<rparr>)) \\<or>\n  grey x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>m x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                mut_m.tso_store_refs m\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))", "from xy"], ["proof (chain)\npicking this:\n  (x reaches y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))", "have \"(\\<exists>m x. ?root m x s \\<and> (x reaches y) s) \\<and> valid_ref y ?s'\""], ["proof (prove)\nusing this:\n  (x reaches y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. (\\<exists>m x.\n        (x \\<in> roots (s (mutator m)) \\<union>\n                 ghost_honorary_root (s (mutator m)) \\<union>\n                 mut_m.tso_store_refs m s \\<or>\n         grey x s) \\<and>\n        (x reaches y) s) \\<and>\n    obj_at (\\<lambda>s. True) y\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "unfolding reaches_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x y.\n      (x points_to y)\n       (s(sys := s sys\n            \\<lparr>heap := (sys_heap s)\n                      (r := map_option\n                             (\\<lambda>obj. obj\n                                 \\<lparr>obj_fields := (obj_fields obj)\n     (f := opt_r')\\<rparr>)\n                             (sys_heap s r)),\n               mem_store_buffers := (mem_store_buffers (s sys))\n                 (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n   x y\n\ngoal (1 subgoal):\n 1. (\\<exists>m x.\n        (x \\<in> roots (s (mutator m)) \\<union>\n                 ghost_honorary_root (s (mutator m)) \\<union>\n                 mut_m.tso_store_refs m s \\<or>\n         grey x s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n    obj_at (\\<lambda>s. True) y\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>m xa.\n        (xa \\<in> roots (s (mutator m)) \\<union>\n                  ghost_honorary_root (s (mutator m)) \\<union>\n                  mut_m.tso_store_refs m s \\<or>\n         grey xa s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x) \\<and>\n    obj_at (\\<lambda>s. True) x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))\n 2. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y.\n                    (x points_to y)\n                     (s(sys := s sys\n                          \\<lparr>heap := (sys_heap s)\n                                    (r :=\n map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                             mem_store_buffers :=\n                               (mem_store_buffers (s sys))\n                               (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                 x y;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (\\<exists>m x.\n            (x \\<in> roots (s (mutator m)) \\<union>\n                     ghost_honorary_root (s (mutator m)) \\<union>\n                     mut_m.tso_store_refs m s \\<or>\n             grey x s) \\<and>\n            (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n        obj_at (\\<lambda>s. True) y\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m x.\n                             (x \\<in> roots (s (mutator m)) \\<union>\nghost_honorary_root (s (mutator m)) \\<union>\nmut_m.tso_store_refs m s \\<or>\n                              grey x s) \\<and>\n                             (\\<lambda>x y.\n                                 (x points_to y) s)\\<^sup>*\\<^sup>*\n                              x z) \\<and>\n                         obj_at (\\<lambda>s. True) z\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<exists>m xa.\n        (xa \\<in> roots (s (mutator m)) \\<union>\n                  ghost_honorary_root (s (mutator m)) \\<union>\n                  mut_m.tso_store_refs m s \\<or>\n         grey xa s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x) \\<and>\n    obj_at (\\<lambda>s. True) x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))\n 2. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y.\n                    (x points_to y)\n                     (s(sys := s sys\n                          \\<lparr>heap := (sys_heap s)\n                                    (r :=\n map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                             mem_store_buffers :=\n                               (mem_store_buffers (s sys))\n                               (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                 x y;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (\\<exists>m x.\n            (x \\<in> roots (s (mutator m)) \\<union>\n                     ghost_honorary_root (s (mutator m)) \\<union>\n                     mut_m.tso_store_refs m s \\<or>\n             grey x s) \\<and>\n            (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n        obj_at (\\<lambda>s. True) y\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m x.\n                             (x \\<in> roots (s (mutator m)) \\<union>\nghost_honorary_root (s (mutator m)) \\<union>\nmut_m.tso_store_refs m s \\<or>\n                              grey x s) \\<and>\n                             (\\<lambda>x y.\n                                 (x points_to y) s)\\<^sup>*\\<^sup>*\n                              x z) \\<and>\n                         obj_at (\\<lambda>s. True) z\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "with x sb vri"], ["proof (chain)\npicking this:\n  x \\<in> roots\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m)) \\<union>\n          ghost_honorary_root\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m)) \\<union>\n          mut_m.tso_store_refs m\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m' := ws)\\<rparr>)) \\<or>\n  grey x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  valid_refs_inv s", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> roots\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m)) \\<union>\n          ghost_honorary_root\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m)) \\<union>\n          mut_m.tso_store_refs m\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m' := ws)\\<rparr>)) \\<or>\n  grey x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  valid_refs_inv s\n\ngoal (1 subgoal):\n 1. (\\<exists>m xa.\n        (xa \\<in> roots (s (mutator m)) \\<union>\n                  ghost_honorary_root (s (mutator m)) \\<union>\n                  mut_m.tso_store_refs m s \\<or>\n         grey xa s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x) \\<and>\n    obj_at (\\<lambda>s. True) x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> roots\n                      ((s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))\n                        (mutator m)) \\<union>\n                     ghost_honorary_root\n                      ((s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))\n                        (mutator m)) \\<union>\n                     mut_m.tso_store_refs m\n                      (s(sys := s sys\n                           \\<lparr>heap := (sys_heap s)\n                                     (r :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n   (sys_heap s r)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s sys))\n                                (mutator m' := ws)\\<rparr>)) \\<or>\n             grey x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     valid_refs_inv s\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>m xa.\n                          (xa \\<in> roots (s (mutator m)) \\<union>\n                                    ghost_honorary_root\n                                     (s (mutator m)) \\<union>\n                                    mut_m.tso_store_refs m s \\<or>\n                           grey xa s) \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           xa x) \\<and>\n                      obj_at (\\<lambda>s. True) x\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (\\<lambda>a. sys_mem_store_buffers a s)\n                                 (mutator m' := ws)\\<rparr>))", "apply (subst obj_at_fun_upd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> roots\n                      ((s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))\n                        (mutator m)) \\<union>\n                     ghost_honorary_root\n                      ((s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))\n                        (mutator m)) \\<union>\n                     mut_m.tso_store_refs m\n                      (s(sys := s sys\n                           \\<lparr>heap := (sys_heap s)\n                                     (r :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n   (sys_heap s r)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s sys))\n                                (mutator m' := ws)\\<rparr>)) \\<or>\n             grey x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     valid_refs_inv s\\<rbrakk>\n    \\<Longrightarrow> map_option (\\<lambda>s. True)\n                       (sys_heap\n                         (s(sys := s sys\n                              \\<lparr>heap := (sys_heap s)\n  (r := map_option\n         (\\<lambda>obj. obj\n             \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n         (sys_heap s r)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s sys))\n                                   (mutator m' := ws)\\<rparr>))\n                         x) =\n                      map_option (\\<lambda>s. True) (sys_heap s x)\n 2. \\<lbrakk>x \\<in> roots\n                      ((s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))\n                        (mutator m)) \\<union>\n                     ghost_honorary_root\n                      ((s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))\n                        (mutator m)) \\<union>\n                     mut_m.tso_store_refs m\n                      (s(sys := s sys\n                           \\<lparr>heap := (sys_heap s)\n                                     (r :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n   (sys_heap s r)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s sys))\n                                (mutator m' := ws)\\<rparr>)) \\<or>\n             grey x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     valid_refs_inv s\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>m xa.\n                          (xa \\<in> roots (s (mutator m)) \\<union>\n                                    ghost_honorary_root\n                                     (s (mutator m)) \\<union>\n                                    mut_m.tso_store_refs m s \\<or>\n                           grey xa s) \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           xa x) \\<and>\n                      obj_at (\\<lambda>s. True) x s", "apply (auto simp: mut_m.tso_store_refs_def reaches_def fun_upd_apply split: if_splits intro: valid_refs_invD(5)[where m=m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>sys_mem_store_buffers (mutator m') s =\n                mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s; m = m'; xa \\<in> set ws;\n        x \\<in> (case xa of\n                 mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                 | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                 | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m xa.\n                            (xa \\<in> roots (s (mutator m)) \\<or>\n                             xa \\<in> ghost_honorary_root\n (s (mutator m)) \\<or>\n                             (\\<exists>xaa\n \\<in>set (sys_mem_store_buffers (mutator m) s).\n                                 xa \\<in> (case xaa of\n     mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n     | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n     | _ \\<Rightarrow> {})) \\<or>\n                             grey xa s) \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y) s)\\<^sup>*\\<^sup>*\n                             xa x", "apply (metis list.set_intros(2) rtranclp.rtrancl_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>m xa.\n      (xa \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<or>\n       grey xa s) \\<and>\n      (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x) \\<and>\n  obj_at (\\<lambda>s. True) x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y.\n                    (x points_to y)\n                     (s(sys := s sys\n                          \\<lparr>heap := (sys_heap s)\n                                    (r :=\n map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                             mem_store_buffers :=\n                               (mem_store_buffers (s sys))\n                               (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                 x y;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (\\<exists>m x.\n            (x \\<in> roots (s (mutator m)) \\<union>\n                     ghost_honorary_root (s (mutator m)) \\<union>\n                     mut_m.tso_store_refs m s \\<or>\n             grey x s) \\<and>\n            (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n        obj_at (\\<lambda>s. True) y\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m x.\n                             (x \\<in> roots (s (mutator m)) \\<union>\nghost_honorary_root (s (mutator m)) \\<union>\nmut_m.tso_store_refs m s \\<or>\n                              grey x s) \\<and>\n                             (\\<lambda>x y.\n                                 (x points_to y) s)\\<^sup>*\\<^sup>*\n                              x z) \\<and>\n                         obj_at (\\<lambda>s. True) z\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "(* FIXME rules *)"], ["proof (state)\nthis:\n  (\\<exists>m xa.\n      (xa \\<in> roots (s (mutator m)) \\<union>\n                ghost_honorary_root (s (mutator m)) \\<union>\n                mut_m.tso_store_refs m s \\<or>\n       grey xa s) \\<and>\n      (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa x) \\<and>\n  obj_at (\\<lambda>s. True) x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y.\n                    (x points_to y)\n                     (s(sys := s sys\n                          \\<lparr>heap := (sys_heap s)\n                                    (r :=\n map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                             mem_store_buffers :=\n                               (mem_store_buffers (s sys))\n                               (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                 x y;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (\\<exists>m x.\n            (x \\<in> roots (s (mutator m)) \\<union>\n                     ghost_honorary_root (s (mutator m)) \\<union>\n                     mut_m.tso_store_refs m s \\<or>\n             grey x s) \\<and>\n            (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n        obj_at (\\<lambda>s. True) y\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m x.\n                             (x \\<in> roots (s (mutator m)) \\<union>\nghost_honorary_root (s (mutator m)) \\<union>\nmut_m.tso_store_refs m s \\<or>\n                              grey x s) \\<and>\n                             (\\<lambda>x y.\n                                 (x points_to y) s)\\<^sup>*\\<^sup>*\n                              x z) \\<and>\n                         obj_at (\\<lambda>s. True) z\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y.\n                    (x points_to y)\n                     (s(sys := s sys\n                          \\<lparr>heap := (sys_heap s)\n                                    (r :=\n map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                             mem_store_buffers :=\n                               (mem_store_buffers (s sys))\n                               (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                 x y;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (\\<exists>m x.\n            (x \\<in> roots (s (mutator m)) \\<union>\n                     ghost_honorary_root (s (mutator m)) \\<union>\n                     mut_m.tso_store_refs m s \\<or>\n             grey x s) \\<and>\n            (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n        obj_at (\\<lambda>s. True) y\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m x.\n                             (x \\<in> roots (s (mutator m)) \\<union>\nghost_honorary_root (s (mutator m)) \\<union>\nmut_m.tso_store_refs m s \\<or>\n                              grey x s) \\<and>\n                             (\\<lambda>x y.\n                                 (x points_to y) s)\\<^sup>*\\<^sup>*\n                              x z) \\<and>\n                         obj_at (\\<lambda>s. True) z\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "case (step y z)"], ["proof (state)\nthis:\n  (\\<lambda>x y.\n      (x points_to y)\n       (s(sys := s sys\n            \\<lparr>heap := (sys_heap s)\n                      (r := map_option\n                             (\\<lambda>obj. obj\n                                 \\<lparr>obj_fields := (obj_fields obj)\n     (f := opt_r')\\<rparr>)\n                             (sys_heap s r)),\n               mem_store_buffers := (mem_store_buffers (s sys))\n                 (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n   x y\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (\\<exists>m x.\n      (x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<or>\n       grey x s) \\<and>\n      (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n  obj_at (\\<lambda>s. True) y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(\\<lambda>x y.\n                    (x points_to y)\n                     (s(sys := s sys\n                          \\<lparr>heap := (sys_heap s)\n                                    (r :=\n map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                             mem_store_buffers :=\n                               (mem_store_buffers (s sys))\n                               (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                 x y;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (\\<exists>m x.\n            (x \\<in> roots (s (mutator m)) \\<union>\n                     ghost_honorary_root (s (mutator m)) \\<union>\n                     mut_m.tso_store_refs m s \\<or>\n             grey x s) \\<and>\n            (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n        obj_at (\\<lambda>s. True) y\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m x.\n                             (x \\<in> roots (s (mutator m)) \\<union>\nghost_honorary_root (s (mutator m)) \\<union>\nmut_m.tso_store_refs m s \\<or>\n                              grey x s) \\<and>\n                             (\\<lambda>x y.\n                                 (x points_to y) s)\\<^sup>*\\<^sup>*\n                              x z) \\<and>\n                         obj_at (\\<lambda>s. True) z\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "with sb vri"], ["proof (chain)\npicking this:\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  valid_refs_inv s\n  (\\<lambda>x y.\n      (x points_to y)\n       (s(sys := s sys\n            \\<lparr>heap := (sys_heap s)\n                      (r := map_option\n                             (\\<lambda>obj. obj\n                                 \\<lparr>obj_fields := (obj_fields obj)\n     (f := opt_r')\\<rparr>)\n                             (sys_heap s r)),\n               mem_store_buffers := (mem_store_buffers (s sys))\n                 (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n   x y\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (\\<exists>m x.\n      (x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<or>\n       grey x s) \\<and>\n      (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n  obj_at (\\<lambda>s. True) y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  valid_refs_inv s\n  (\\<lambda>x y.\n      (x points_to y)\n       (s(sys := s sys\n            \\<lparr>heap := (sys_heap s)\n                      (r := map_option\n                             (\\<lambda>obj. obj\n                                 \\<lparr>obj_fields := (obj_fields obj)\n     (f := opt_r')\\<rparr>)\n                             (sys_heap s r)),\n               mem_store_buffers := (mem_store_buffers (s sys))\n                 (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n   x y\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (\\<exists>m x.\n      (x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<or>\n       grey x s) \\<and>\n      (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n  obj_at (\\<lambda>s. True) y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. (\\<exists>m x.\n        (x \\<in> roots (s (mutator m)) \\<union>\n                 ghost_honorary_root (s (mutator m)) \\<union>\n                 mut_m.tso_store_refs m s \\<or>\n         grey x s) \\<and>\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x z) \\<and>\n    obj_at (\\<lambda>s. True) z\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers (mutator m') s =\n             mw_Mutate r f opt_r' # ws;\n     valid_refs_inv s;\n     (\\<lambda>x y.\n         (x points_to y)\n          (s(sys := s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_fields := (obj_fields obj)\n        (f := opt_r')\\<rparr>)\n                                (sys_heap s r)),\n                  mem_store_buffers := (mem_store_buffers (s sys))\n                    (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n      x y;\n     (y points_to z)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>));\n     (\\<exists>m x.\n         (x \\<in> roots (s (mutator m)) \\<union>\n                  ghost_honorary_root (s (mutator m)) \\<union>\n                  mut_m.tso_store_refs m s \\<or>\n          grey x s) \\<and>\n         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n     obj_at (\\<lambda>s. True) y\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (mutator m' := ws)\\<rparr>))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>m x.\n                          (x \\<in> roots (s (mutator m)) \\<union>\n                                   ghost_honorary_root\n                                    (s (mutator m)) \\<union>\n                                   mut_m.tso_store_refs m s \\<or>\n                           grey x s) \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           x z) \\<and>\n                      obj_at (\\<lambda>s. True) z\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (\\<lambda>a. sys_mem_store_buffers a s)\n                                 (mutator m' := ws)\\<rparr>))", "apply (subst obj_at_fun_upd, clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers (mutator m') s =\n             mw_Mutate r f opt_r' # ws;\n     valid_refs_inv s;\n     (\\<lambda>x y.\n         (x points_to y)\n          (s(sys := s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_fields := (obj_fields obj)\n        (f := opt_r')\\<rparr>)\n                                (sys_heap s r)),\n                  mem_store_buffers := (mem_store_buffers (s sys))\n                    (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n      x y;\n     (y points_to z)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>));\n     (\\<exists>m x.\n         (x \\<in> roots (s (mutator m)) \\<union>\n                  ghost_honorary_root (s (mutator m)) \\<union>\n                  mut_m.tso_store_refs m s \\<or>\n          grey x s) \\<and>\n         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n     obj_at (\\<lambda>s. True) y\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (mutator m' := ws)\\<rparr>))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>m x.\n                          (x \\<in> roots (s (mutator m)) \\<union>\n                                   ghost_honorary_root\n                                    (s (mutator m)) \\<union>\n                                   mut_m.tso_store_refs m s \\<or>\n                           grey x s) \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           x z) \\<and>\n                      obj_at (\\<lambda>s. True) z s", "apply (subst (asm) obj_at_fun_upd, fastforce simp: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers (mutator m') s =\n             mw_Mutate r f opt_r' # ws;\n     valid_refs_inv s;\n     (\\<lambda>x y.\n         (x points_to y)\n          (s(sys := s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_fields := (obj_fields obj)\n        (f := opt_r')\\<rparr>)\n                                (sys_heap s r)),\n                  mem_store_buffers := (mem_store_buffers (s sys))\n                    (mutator m' := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n      x y;\n     (y points_to z)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>));\n     (\\<exists>m x.\n         (x \\<in> roots (s (mutator m)) \\<union>\n                  ghost_honorary_root (s (mutator m)) \\<union>\n                  mut_m.tso_store_refs m s \\<or>\n          grey x s) \\<and>\n         (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y) \\<and>\n     obj_at (\\<lambda>s. True) y s\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>m x.\n                          (x \\<in> roots (s (mutator m)) \\<union>\n                                   ghost_honorary_root\n                                    (s (mutator m)) \\<union>\n                                   mut_m.tso_store_refs m s \\<or>\n                           grey x s) \\<and>\n                          (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>*\n                           x z) \\<and>\n                      obj_at (\\<lambda>s. True) z s", "apply (clarsimp simp: points_to_Mutate fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m xa.\n       \\<lbrakk>sys_mem_store_buffers (mutator m') s =\n                mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s;\n        (\\<lambda>x y.\n            r \\<noteq> x \\<and> (x points_to y) s \\<or>\n            r = x \\<and>\n            obj_at (\\<lambda>s. True) r s \\<and>\n            (opt_r' = Some y \\<or>\n             (x points_to y) s \\<and>\n             obj_at\n              (\\<lambda>obj.\n                  \\<exists>f'.\n                     obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n              r s))\\<^sup>*\\<^sup>*\n         x y;\n        r \\<noteq> y \\<and> (y points_to z) s \\<or>\n        r = y \\<and>\n        obj_at (\\<lambda>s. True) r s \\<and>\n        (opt_r' = Some z \\<or>\n         (y points_to z) s \\<and>\n         obj_at\n          (\\<lambda>obj.\n              \\<exists>f'. obj_fields obj f' = Some z \\<and> f \\<noteq> f')\n          r s);\n        obj_at (\\<lambda>s. True) y s;\n        xa \\<in> roots (s (mutator m)) \\<or>\n        xa \\<in> ghost_honorary_root (s (mutator m)) \\<or>\n        xa \\<in> mut_m.tso_store_refs m s \\<or> grey xa s;\n        (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* xa y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>m x.\n                             (x \\<in> roots (s (mutator m)) \\<or>\n                              x \\<in> ghost_honorary_root\n (s (mutator m)) \\<or>\n                              x \\<in> mut_m.tso_store_refs m s \\<or>\n                              grey x s) \\<and>\n                             (\\<lambda>x y.\n                                 (x points_to y) s)\\<^sup>*\\<^sup>*\n                              x z) \\<and>\n                         obj_at (\\<lambda>s. True) z s", "apply (fastforce elim: rtranclp.intros(2) simp: mut_m.tso_store_refs_def reaches_def fun_upd_apply intro: exI[where x=m'] valid_refs_invD(5)[where m=m'])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<exists>m x.\n      (x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<or>\n       grey x s) \\<and>\n      (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x z) \\<and>\n  obj_at (\\<lambda>s. True) z\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>m x.\n      (x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<or>\n       grey x s) \\<and>\n      (x reaches y) s) \\<and>\n  obj_at (\\<lambda>s. True) y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>m x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m' := ws)\\<rparr>))\n                   (mutator m)) \\<union>\n                mut_m.tso_store_refs m\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>m x.\n      (x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<or>\n       grey x s) \\<and>\n      (x reaches y) s) \\<and>\n  obj_at (\\<lambda>s. True) y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))", "show \"valid_ref y ?s'\""], ["proof (prove)\nusing this:\n  (\\<exists>m x.\n      (x \\<in> roots (s (mutator m)) \\<union>\n               ghost_honorary_root (s (mutator m)) \\<union>\n               mut_m.tso_store_refs m s \\<or>\n       grey x s) \\<and>\n      (x reaches y) s) \\<and>\n  obj_at (\\<lambda>s. True) y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>s. True) y\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "by blast"], ["proof (state)\nthis:\n  obj_at (\\<lambda>s. True) y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_refs_inv_dequeue_Mutate_Payload:\n  notes if_split_asm[split del]\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes vri: \"valid_refs_inv s\"\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate_Payload r f pl # ws\"\n  shows \"valid_refs_inv (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>) (sys_heap s r)),\n                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))\" (is \"valid_refs_inv ?s'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_payload := (obj_payload obj)\n   (f := pl)\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m := ws)\\<rparr>))", "apply (rule valid_refs_invI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ma x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m := ws)\\<rparr>))\n                   (mutator ma)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m := ws)\\<rparr>))\n                   (mutator ma)) \\<union>\n                mut_m.tso_store_refs ma\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_payload := (obj_payload obj)\n       (f := pl)\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))", "using assms"], ["proof (prove)\nusing this:\n  valid_refs_inv s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate_Payload r f pl # ws\n\ngoal (1 subgoal):\n 1. \\<And>ma x y.\n       \\<lbrakk>(x reaches y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        x \\<in> roots\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m := ws)\\<rparr>))\n                   (mutator ma)) \\<union>\n                ghost_honorary_root\n                 ((s(sys := s sys\n                       \\<lparr>heap := (sys_heap s)\n                                 (r := map_option\n  (\\<lambda>obj. obj\n      \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n  (sys_heap s r)),\n                          mem_store_buffers := (mem_store_buffers (s sys))\n                            (mutator m := ws)\\<rparr>))\n                   (mutator ma)) \\<union>\n                mut_m.tso_store_refs ma\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>)) \\<or>\n        grey x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_payload := (obj_payload obj)\n       (f := pl)\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))", "apply (clarsimp simp: valid_refs_invD fun_upd_apply split: obj_at_splits mem_store_action.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ma x y.\n       \\<lbrakk>(x reaches y) s;\n        x \\<in> roots (s (mutator ma)) \\<or>\n        x \\<in> ghost_honorary_root (s (mutator ma)) \\<or>\n        x \\<in> (if m = ma then \\<Union> (store_refs ` set ws)\n                 else mut_m.tso_store_refs ma s) \\<or>\n        grey x s;\n        valid_refs_inv s;\n        sys_mem_store_buffers (mutator m') s =\n        mw_Mutate_Payload r f pl # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ma x y.\n       \\<lbrakk>(x reaches y) s; valid_refs_inv s;\n        sys_mem_store_buffers (mutator m') s =\n        mw_Mutate_Payload r f pl # ws;\n        x \\<in> (if m = ma then \\<Union> (store_refs ` set ws)\n                 else mut_m.tso_store_refs ma s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya\n 2. \\<And>x y.\n       \\<lbrakk>(x reaches y) s; valid_refs_inv s;\n        sys_mem_store_buffers (mutator m') s =\n        mw_Mutate_Payload r f pl # ws;\n        grey x s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya", "apply (metis (mono_tags, lifting) UN_insert Un_iff list.simps(15) mut_m.tso_store_refs_def valid_refs_invD(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(x reaches y) s; valid_refs_inv s;\n        sys_mem_store_buffers (mutator m') s =\n        mw_Mutate_Payload r f pl # ws;\n        grey x s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya. sys_heap s y = Some ya", "apply (metis case_optionE obj_at_def valid_refs_invD(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}