{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Global_Noninterference.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma (in sys) strong_tricolour_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP (fM_rel_inv \\<^bold>\\<and> handshake_phase_inv \\<^bold>\\<and> mutators_phase_inv \\<^bold>\\<and> strong_tricolour_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> tso_store_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     sys\n   \\<lbrace> LSTP strong_tricolour_inv \\<rbrace>\"", "lemma black_heap_reachable:\n  assumes \"mut_m.reachable m y s\"\n  assumes bh: \"black_heap s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"black y s\"", "lemma black_heap_valid_ref_marked_insertions:\n  \"\\<lbrakk> black_heap s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> mut_m.marked_insertions m s\"", "lemma reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_Mutate:\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\"\n  assumes bh: \"black_heap s\"\n  assumes ngr: \"no_grey_refs s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"mut_m.reachable_snapshot_inv m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>))\" (is \"mut_m.reachable_snapshot_inv m ?s'\")", "lemma marked_deletions_dequeue_Mark:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; mut_m.marked_deletions m s; tso_store_inv s; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_deletions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\"", "lemma marked_deletions_dequeue_Mutate:\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws; mut_m.marked_deletions m s; mut_m.marked_insertions m' s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_deletions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                 mem_store_buffers := (mem_store_buffers (s sys))((mutator m') := ws)\\<rparr>))\"", "lemma grey_protects_white_dequeue_Mark:\n  assumes fl: \"fl = sys_fM s\"\n  assumes \"r \\<in> ghost_honorary_grey (s p)\"\n  shows \"(\\<exists>g. (g grey_protects_white w) (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)))\n      \\<longleftrightarrow> (\\<exists>g. (g grey_protects_white w) s)\" (is \"(\\<exists>g. (g grey_protects_white w) ?s') \\<longleftrightarrow> ?rhs\")", "lemma reachable_snapshot_inv_dequeue_Mark:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; mut_m.reachable_snapshot_inv m s; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> mut_m.reachable_snapshot_inv m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\"", "lemma marked_insertions_dequeue_Mark:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; mut_m.marked_insertions m s; tso_writes_inv s; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_insertions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\"", "lemma marked_insertions_dequeue_Mutate:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mutate r f r' # ws; mut_m.marked_insertions m s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_insertions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>) (sys_heap s r)),\n                                                    mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\"", "lemma grey_protects_white_dequeue_Mutate:\n  assumes sb: \"sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\"\n  assumes mi: \"mut_m.marked_insertions m s\"\n  assumes md: \"mut_m.marked_deletions m s\"\n  shows \"(\\<exists>g. (g grey_protects_white w) (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)))\n      \\<longleftrightarrow> (\\<exists>g. (g grey_protects_white w) s)\" (is \"(\\<exists>g. (g grey_protects_white w) ?s') \\<longleftrightarrow> ?rhs\")", "lemma reachable_snapshot_inv_dequeue_Mutate:\n  notes grey_protects_white_dequeue_Mutate[simp]\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\"\n  assumes mi: \"mut_m.marked_insertions m' s\"\n  assumes md: \"mut_m.marked_deletions m' s\"\n  assumes rsi: \"mut_m.reachable_snapshot_inv m s\"\n  assumes sti: \"strong_tricolour_inv s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"mut_m.reachable_snapshot_inv m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>))\" (is \"mut_m.reachable_snapshot_inv m ?s'\")", "lemma mutator_phase_inv[intro]:\n  \"\\<lbrace> LSTP (fA_rel_inv \\<^bold>\\<and> fM_rel_inv \\<^bold>\\<and> handshake_phase_inv \\<^bold>\\<and> mutators_phase_inv \\<^bold>\\<and> strong_tricolour_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> tso_store_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     sys\n   \\<lbrace> LSTP (mut_m.mutator_phase_inv m) \\<rbrace>\""], "translations": [["", "lemma (in sys) strong_tricolour_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP (fM_rel_inv \\<^bold>\\<and> handshake_phase_inv \\<^bold>\\<and> mutators_phase_inv \\<^bold>\\<and> strong_tricolour_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> tso_store_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     sys\n   \\<lbrace> LSTP strong_tricolour_inv \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                fM_rel_inv s\\<down> \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                strong_tricolour_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_W_inv\n                 s\\<down>\\<rbrace> sys \\<lbrace>\\<lambda>s.\n             strong_tricolour_inv s\\<down>\\<rbrace>", "unfolding strong_tricolour_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                fM_rel_inv s\\<down> \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                (\\<forall>x xa.\n                    black x s\\<down> \\<longrightarrow>\n                    \\<not> ((x points_to xa) s\\<down> \\<and>\n                            white xa s\\<down>)) \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_W_inv\n                 s\\<down>\\<rbrace> sys \\<lbrace>\\<lambda>s.\n             \\<forall>x xa.\n                black x s\\<down> \\<longrightarrow>\n                \\<not> ((x points_to xa) s\\<down> \\<and>\n                        white xa s\\<down>)\\<rbrace>", "proof(vcg_jackhammer (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> False", "case (tso_dequeue_store_buffer s s' p w ws x xa)"], ["proof (state)\nthis:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. False", "proof(cases w)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mark x11 x12\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "case (mw_Mark ref field)"], ["proof (state)\nthis:\n  w = mw_Mark ref field\n\ngoal (6 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mark x11 x12\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  w = mw_Mark ref field", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  w = mw_Mark ref field\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := do_store_action w (s\\<down> sys)\n        \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                  (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = w # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     (x points_to xa)\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     white xa\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     w = mw_Mark ref field\\<rbrakk>\n    \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj_at\n              (\\<lambda>obj.\n                  (x = ref \\<longrightarrow>\n                   xa \\<in> ran (obj_fields obj)) \\<and>\n                  (x = ref \\<or> xa \\<in> ran (obj_fields obj)))\n              x s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>heap := (sys_heap s\\<down>)\n                    (ref :=\n                       map_option (obj_mark_update (\\<lambda>_. field))\n                        (sys_heap s\\<down> ref)),\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_Mark ref field; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (ref :=\n                     map_option (obj_mark_update (\\<lambda>_. field))\n                      (sys_heap s\\<down> ref)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mark ref field # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x s\\<down> \\<and> x \\<noteq> ref \\<or>\n     x = ref \\<and>\n     field = sys_fM s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) ref s\\<down> \\<and>\n     \\<not> grey ref s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule (1) valid_W_invD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj_at\n              (\\<lambda>obj.\n                  (x = ref \\<longrightarrow>\n                   xa \\<in> ran (obj_fields obj)) \\<and>\n                  (x = ref \\<or> xa \\<in> ran (obj_fields obj)))\n              x s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>heap := (sys_heap s\\<down>)\n                    (ref :=\n                       map_option (obj_mark_update (\\<lambda>_. field))\n                        (sys_heap s\\<down> ref)),\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_Mark ref field; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (ref :=\n                     map_option (obj_mark_update (\\<lambda>_. field))\n                      (sys_heap s\\<down> ref)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mark ref field # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x s\\<down> \\<and> x \\<noteq> ref \\<or>\n     x = ref \\<and>\n     field = sys_fM s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) ref s\\<down> \\<and> \\<not> grey ref s\\<down>;\n     field = sys_fM s\\<down> \\<and>\n     ref \\<in> ghost_honorary_grey (s\\<down> p) \\<and>\n     sys_mem_lock s\\<down> = Some p \\<and>\n     white ref s\\<down> \\<and> filter is_mw_Mark ws = []\\<rbrakk>\n    \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj_at\n              (\\<lambda>obj.\n                  (x = ref \\<longrightarrow>\n                   xa \\<in> ran (obj_fields obj)) \\<and>\n                  (x = ref \\<or> xa \\<in> ran (obj_fields obj)))\n              x s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>heap := (sys_heap s\\<down>)\n                    (ref :=\n                       map_option\n                        (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                        (sys_heap s\\<down> ref)),\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_Mark ref (sys_fM s\\<down>); at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (ref :=\n                     map_option\n                      (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                      (sys_heap s\\<down> ref)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mark ref (sys_fM s\\<down>) # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x s\\<down> \\<and> x \\<noteq> ref \\<or>\n     x = ref \\<and>\n     obj_at (\\<lambda>s. True) ref s\\<down> \\<and> \\<not> grey ref s\\<down>;\n     field = sys_fM s\\<down>; ref \\<in> ghost_honorary_grey (s\\<down> p);\n     sys_mem_lock s\\<down> = Some p; white ref s\\<down>;\n     filter is_mw_Mark ws = []\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases \"x = ref\"; clarsimp simp: grey_def white_def WL_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj_at\n              (\\<lambda>obj.\n                  xa \\<noteq> ref \\<and>\n                  (xa = ref \\<or> obj_mark obj = (\\<not> sys_fM s\\<down>)))\n              xa s\\<down>;\n     w = mw_Mark ref (sys_fM s\\<down>); at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (ref :=\n                     map_option\n                      (obj_mark_update (\\<lambda>_. sys_fM s\\<down>))\n                      (sys_heap s\\<down> ref)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mark ref (sys_fM s\\<down>) # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> obj_at\n                    (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n                    xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     field = sys_fM s\\<down>; ref \\<in> ghost_honorary_grey (s\\<down> p);\n     sys_mem_lock s\\<down> = Some p;\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>)) ref\n      s\\<down>;\n     filter is_mw_Mark ws = []; x \\<noteq> ref;\n     (x points_to xa) s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule_tac x=x in spec; force split: obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "case (mw_Mutate ref field opt_r')"], ["proof (state)\nthis:\n  w = mw_Mutate ref field opt_r'\n\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  w = mw_Mutate ref field opt_r'", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  w = mw_Mutate ref field opt_r'\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := do_store_action w (s\\<down> sys)\n        \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                  (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = w # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     (x points_to xa)\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     white xa\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     w = mw_Mutate ref field opt_r'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: fM_rel_inv_def p_not_sys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (ref :=\n                     map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> ref)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate ref field opt_r' # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p = gc \\<or> (\\<exists>m. p = mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     (x points_to xa)\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>heap := (sys_heap s\\<down>)\n                    (ref :=\n                       map_option\n                        (\\<lambda>obj. obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(field := opt_r')\\<rparr>)\n                        (sys_heap s\\<down> ref)),\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     white xa s\\<down>; w = mw_Mutate ref field opt_r'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim disjE; clarsimp simp: points_to_Mutate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        ref \\<noteq> x \\<and> (x points_to xa) s\\<down> \\<or>\n        ref = x \\<and>\n        obj_at (\\<lambda>s. True) ref s\\<down> \\<and>\n        (opt_r' = Some xa \\<or>\n         (x points_to xa) s\\<down> \\<and>\n         obj_at\n          (\\<lambda>obj.\n              \\<exists>f'.\n                 obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n          ref s\\<down>);\n        white xa s\\<down>; w = mw_Mutate ref field opt_r';\n        p = mutator m\\<rbrakk>\n       \\<Longrightarrow> False", "apply (elim disjE; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"sys_ghost_hs_phase s\\<down>\"; clarsimp simp: hp_step_rel_def heap_colours_colours no_black_refsD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n        no_black_refs s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_InitMark\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Mark\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "proof(goal_cases hp_InitMark hp_Mark hp_IdleMarkSweep)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n        no_black_refs s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_InitMark\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Mark\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "case (hp_InitMark m)"], ["proof (state)\nthis:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n  no_black_refs s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_InitMark\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n        no_black_refs s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_InitMark\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Mark\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n  no_black_refs s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_InitMark", "show ?case"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n  no_black_refs s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_InitMark\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n     no_black_refs s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_InitMark\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule mut_m.handshake_phase_invD[where m=m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n     no_black_refs s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_InitMark;\n     (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n      sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s\\<down> \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s\\<down>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule_tac x=m in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n     no_black_refs s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_InitMark;\n     (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n      sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s\\<down> \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s\\<down>);\n     mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n      s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim disjE; clarsimp simp: hp_step_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := obj_fields obj(field \n \\<mapsto> xa)\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_InitMark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field (Some xa) # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>) \\<longrightarrow>\n     no_black_refs s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field (Some xa); p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_InitMark;\n     mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n      s\\<down>;\n     opt_r' = Some xa;\n     \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_NOOP \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleInit \\<or>\n     sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_NOOP \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark;\n     sys_hs_pending m s\\<down> \\<longrightarrow>\n     \\<not> sys_ghost_hs_in_sync m s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim disjE; clarsimp simp: mut_m.marked_insertions_def no_black_refsD marked_not_white)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Mark\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Mark\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "case (hp_Mark m)"], ["proof (state)\nthis:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_Mark\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n         sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Mark\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_Mark", "show ?case"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_Mark\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_Mark\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule mut_m.handshake_phase_invD[where m=m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_Mark;\n     (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n      sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s\\<down> \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s\\<down>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule_tac x=m in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_Mark;\n     (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n      sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s\\<down> \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s\\<down>);\n     mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n      s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim disjE; clarsimp simp: hp_step_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := obj_fields obj(field \n \\<mapsto> xa)\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field (Some xa) # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field (Some xa); p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_Mark;\n     mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n      s\\<down>;\n     opt_r' = Some xa;\n     \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_NOOP \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark \\<or>\n     sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_NOOP \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n     sys_hs_pending m s\\<down> \\<longrightarrow>\n     \\<not> sys_ghost_hs_in_sync m s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim disjE; clarsimp simp: mut_m.marked_insertions_def no_black_refsD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := obj_fields obj(field \n \\<mapsto> xa)\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field (Some xa) # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field (Some xa); p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_Mark;\n     \\<forall>xb.\n        (xb = mw_Mutate x field (Some xa) \\<longrightarrow>\n         marked xa s\\<down>) \\<and>\n        (xb \\<in> set ws \\<longrightarrow> marked_insertion xb s\\<down>);\n     opt_r' = Some xa; \\<not> sys_ghost_hs_in_sync m s\\<down>;\n     sys_hs_type s\\<down> = ht_NOOP;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := obj_fields obj(field \n \\<mapsto> xa)\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_Mark, gc_fM s\\<down>,\n      sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field (Some xa) # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field (Some xa); p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_Mark; opt_r' = Some xa;\n     \\<not> sys_hs_pending m s\\<down>;\n     \\<forall>xb.\n        (xb = mw_Mutate x field (Some xa) \\<longrightarrow>\n         marked xa s\\<down>) \\<and>\n        (xb \\<in> set ws \\<longrightarrow> marked_insertion xb s\\<down>);\n     mut_m.marked_deletions m s\\<down>; sys_ghost_hs_in_sync m s\\<down>;\n     sys_hs_type s\\<down> = ht_NOOP;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark\\<rbrakk>\n    \\<Longrightarrow> False", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "case (hp_IdleMarkSweep m)"], ["proof (state)\nthis:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep\n  sys_phase s\\<down> = ph_Idle \\<longrightarrow> no_grey_refs s\\<down>\n  mw_Phase ph_Idle\n  \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n  no_grey_refs s\\<down>\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (x := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (field := opt_r')\\<rparr>)\n                            (sys_heap s\\<down> x)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n         gc_fM s\\<down>, sys_fM s\\<down>,\n         filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n         sys_mem_lock s\\<down> = Some gc)\n        \\<in> fM_rel;\n        handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers (mutator m) s\\<down> =\n        mw_Mutate x field opt_r' # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m);\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n        white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n        ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n        opt_r' = Some xa \\<or>\n        (x points_to xa) s\\<down> \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'.\n                obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n         x s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep\n  sys_phase s\\<down> = ph_Idle \\<longrightarrow> no_grey_refs s\\<down>\n  mw_Phase ph_Idle\n  \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n  no_grey_refs s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (x := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> x)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (mutator m := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep, gc_fM s\\<down>,\n   sys_fM s\\<down>, filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n   sys_mem_lock s\\<down> = Some gc)\n  \\<in> fM_rel\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers (mutator m) s\\<down> = mw_Mutate x field opt_r' # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) (mutator m)\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x s\\<down>\n  white xa s\\<down>\n  w = mw_Mutate x field opt_r'\n  p = mutator m\n  ref = x\n  obj_at (\\<lambda>s. True) x s\\<down>\n  opt_r' = Some xa \\<or>\n  (x points_to xa) s\\<down> \\<and>\n  obj_at\n   (\\<lambda>obj.\n       \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n   x s\\<down>\n  sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep\n  sys_phase s\\<down> = ph_Idle \\<longrightarrow> no_grey_refs s\\<down>\n  mw_Phase ph_Idle\n  \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n  no_grey_refs s\\<down>\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     sys_phase s\\<down> = ph_Idle \\<longrightarrow> no_grey_refs s\\<down>;\n     mw_Phase ph_Idle\n     \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n     no_grey_refs s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule mut_m.handshake_phase_invD[where m=m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     sys_phase s\\<down> = ph_Idle \\<longrightarrow> no_grey_refs s\\<down>;\n     mw_Phase ph_Idle\n     \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n     no_grey_refs s\\<down>;\n     (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n      sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s\\<down> \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s\\<down>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule_tac x=m in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field opt_r' # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field opt_r'; p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     opt_r' = Some xa \\<or>\n     (x points_to xa) s\\<down> \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some xa \\<and> field \\<noteq> f')\n      x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     sys_phase s\\<down> = ph_Idle \\<longrightarrow> no_grey_refs s\\<down>;\n     mw_Phase ph_Idle\n     \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n     no_grey_refs s\\<down>;\n     (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n      sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n     \\<in> hp_step_rel \\<and>\n     (sys_hs_pending m s\\<down> \\<longrightarrow>\n      \\<not> sys_ghost_hs_in_sync m s\\<down>);\n     mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n      s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim disjE; clarsimp simp: hp_step_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (x := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := obj_fields obj(field \n \\<mapsto> xa)\\<rparr>)\n                         (sys_heap s\\<down> x)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (mutator m := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), hp_IdleMarkSweep,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     sys_mem_store_buffers (mutator m) s\\<down> =\n     mw_Mutate x field (Some xa) # ws;\n     not_blocked (s\\<down> sys) (mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>; black x s\\<down>;\n     white xa s\\<down>; w = mw_Mutate x field (Some xa); p = mutator m;\n     ref = x; obj_at (\\<lambda>s. True) x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     sys_phase s\\<down> = ph_Idle \\<longrightarrow> no_grey_refs s\\<down>;\n     mw_Phase ph_Idle\n     \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n     no_grey_refs s\\<down>;\n     mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n      s\\<down>;\n     opt_r' = Some xa;\n     \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_GetRoots \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<or>\n     \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_GetWork \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_GetRoots \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep \\<or>\n     sys_ghost_hs_in_sync m s\\<down> \\<and>\n     sys_hs_type s\\<down> = ht_GetWork \\<and>\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n     sys_hs_pending m s\\<down> \\<longrightarrow>\n     \\<not> sys_ghost_hs_in_sync m s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (elim disjE; clarsimp simp: marked_not_white mut_m.marked_insertions_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "case (mw_fM fM)"], ["proof (state)\nthis:\n  w = mw_fM fM\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x5.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fM x5\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  w = mw_fM fM", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fM_rel_inv s\\<down>\n  handshake_phase_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     black x s\\<down> \\<longrightarrow>\n     (\\<forall>xa.\n         (x points_to xa) s\\<down> \\<longrightarrow>\n         \\<not> white xa s\\<down>)\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_W_inv s\\<down>\n  black x\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  (x points_to xa)\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  white xa\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n  w = mw_fM fM\n\ngoal (1 subgoal):\n 1. False", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := do_store_action w (s\\<down> sys)\n        \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                  (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fM_rel_inv s\\<down>;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = w # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     (x points_to xa)\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     white xa\n      (s\\<down>\n       (sys := do_store_action w (s\\<down> sys)\n          \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                    (p := ws)\\<rparr>));\n     w = mw_fM fM\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: fM_rel_inv_def p_not_sys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p; p = gc \\<or> (\\<exists>m. p = mutator m);\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM; p = gc\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM; \\<exists>m. p = mutator m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: fM_rel_def black_heap_def split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := \\<not> sys_fM s\\<down>,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc := ws)\\<rparr>));\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) gc;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = sys_fM s\\<down>; white x s\\<down>;\n     \\<not> grey x s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fM = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys));\n     \\<forall>x.\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        black x s\\<down>;\n     no_grey_refs s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := \\<not> sys_fM s\\<down>,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc := ws)\\<rparr>));\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) gc;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>); white x s\\<down>;\n     \\<not> grey x s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fM = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys)); white_heap s\\<down>;\n     no_grey_refs s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM; \\<exists>m. p = mutator m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis colours_distinct(2) white_valid_ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := \\<not> sys_fM s\\<down>,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc := ws)\\<rparr>));\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) gc;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>); white x s\\<down>;\n     \\<not> grey x s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fM = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys)); white_heap s\\<down>;\n     no_grey_refs s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM; \\<exists>m. p = mutator m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: white_heap_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := \\<not> sys_fM s\\<down>,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc := ws)\\<rparr>));\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) gc;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>); white x s\\<down>;\n     \\<not> grey x s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fM = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys));\n     \\<forall>x.\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        white x s\\<down>;\n     no_grey_refs s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM; \\<exists>m. p = mutator m\\<rbrakk>\n    \\<Longrightarrow> False", "apply ( (drule_tac x=xa in spec)+ )[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := \\<not> sys_fM s\\<down>,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (gc := ws)\\<rparr>));\n     w = mw_fM (\\<not> sys_fM s\\<down>); p = gc;\n     at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := \\<not> sys_fM s\\<down>,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (gc := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers gc s\\<down> =\n     mw_fM (\\<not> sys_fM s\\<down>) # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) gc;\n     sys_fA s\\<down> = (\\<not> sys_fM s\\<down>); white x s\\<down>;\n     \\<not> grey x s\\<down>; sys_ghost_hs_phase s\\<down> = hp_Idle;\n     gc_fM s\\<down> = (\\<not> sys_fM s\\<down>);\n     fM = (\\<not> sys_fM s\\<down>); filter is_mw_fM ws = [];\n     sys_mem_lock s\\<down> \\<noteq> Some gc;\n     All (ghost_hs_in_sync (s\\<down> sys)); no_grey_refs s\\<down>;\n     black xa s\\<down> \\<longrightarrow>\n     (\\<forall>x.\n         (xa points_to x) s\\<down> \\<longrightarrow>\n         \\<not> white x s\\<down>);\n     obj_at (\\<lambda>s. True) xa s\\<down> \\<longrightarrow>\n     white xa s\\<down>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM; \\<exists>m. p = mutator m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (clarsimp simp: white_def split: obj_at_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>fM := fM,\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n     (All (ghost_hs_in_sync (s\\<down> sys)), sys_ghost_hs_phase s\\<down>,\n      gc_fM s\\<down>, sys_fM s\\<down>,\n      filter is_mw_fM (sys_mem_store_buffers gc s\\<down>),\n      sys_mem_lock s\\<down> = Some gc)\n     \\<in> fM_rel;\n     handshake_phase_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_fM fM # ws;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     not_blocked (s\\<down> sys) p;\n     \\<forall>x.\n        black x s\\<down> \\<longrightarrow>\n        (\\<forall>xa.\n            (x points_to xa) s\\<down> \\<longrightarrow>\n            \\<not> white xa s\\<down>);\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n     black x\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     (x points_to xa) s\\<down>;\n     white xa\n      (s\\<down>\n       (sys := s\\<down> sys\n          \\<lparr>fM := fM,\n             mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>));\n     w = mw_fM fM; \\<exists>m. p = mutator m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (fastforce simp: white_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>x31 x32 x33.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x4.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_fA x4\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x6.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fM_rel_inv s\\<down>; handshake_phase_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys;\n        \\<forall>x.\n           black x s\\<down> \\<longrightarrow>\n           (\\<forall>xa.\n               (x points_to xa) s\\<down> \\<longrightarrow>\n               \\<not> white xa s\\<down>);\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_W_inv s\\<down>;\n        black x\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        (x points_to xa)\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        white xa\n         (s\\<down>\n          (sys := do_store_action w (s\\<down> sys)\n             \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                       (p := ws)\\<rparr>));\n        w = mw_Phase x6\\<rbrakk>\n       \\<Longrightarrow> False", "qed (clarsimp simp: fM_rel_inv_def p_not_sys)+"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma black_heap_reachable:\n  assumes \"mut_m.reachable m y s\"\n  assumes bh: \"black_heap s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"black y s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. black y s", "using assms"], ["proof (prove)\nusing this:\n  mut_m.reachable m y s\n  black_heap s\n  valid_refs_inv s\n\ngoal (1 subgoal):\n 1. black y s", "apply (induct rule: reachable_induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> roots (s (mutator m)); black_heap s;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> black x s\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> ghost_honorary_root (s (mutator m)); black_heap s;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> black x s\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> mut_m.tso_store_refs m s; black_heap s;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> black x s\n 4. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x s; (x points_to y) s;\n        \\<lbrakk>black_heap s; valid_refs_inv s\\<rbrakk>\n        \\<Longrightarrow> black x s;\n        black_heap s; valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (simp_all add: black_heap_def valid_refs_invD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x s; (x points_to y) s;\n        \\<forall>x.\n           obj_at (\\<lambda>s. True) x s \\<longrightarrow> black x s;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (metis (full_types) reachable_points_to valid_refs_inv_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma black_heap_valid_ref_marked_insertions:\n  \"\\<lbrakk> black_heap s; valid_refs_inv s \\<rbrakk> \\<Longrightarrow> mut_m.marked_insertions m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>black_heap s; valid_refs_inv s\\<rbrakk>\n    \\<Longrightarrow> mut_m.marked_insertions m s", "by (auto simp: mut_m.marked_insertions_def black_heap_def black_def\n        split: mem_store_action.splits option.splits\n         dest: valid_refs_invD)"], ["", "context sys\nbegin"], ["", "lemma reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_Mutate:\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\"\n  assumes bh: \"black_heap s\"\n  assumes ngr: \"no_grey_refs s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"mut_m.reachable_snapshot_inv m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>))\" (is \"mut_m.reachable_snapshot_inv m ?s'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.reachable_snapshot_inv m\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "apply (rule mut_m.reachable_snapshot_invI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       mut_m.reachable m y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "apply (rule in_snapshotI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       mut_m.reachable m y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       black y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "apply (erule black_heap_reachable)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       black_heap\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>y.\n       valid_refs_inv\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "using bh vri"], ["proof (prove)\nusing this:\n  black_heap s\n  valid_refs_inv s\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       black_heap\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>y.\n       valid_refs_inv\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "apply (simp add: black_heap_def fun_upd_apply; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       valid_refs_inv\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "using bh ngr sb vri"], ["proof (prove)\nusing this:\n  black_heap s\n  no_grey_refs s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  valid_refs_inv s\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       valid_refs_inv\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "apply (subst valid_refs_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>black_heap s; no_grey_refs s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x xa.\n                            mut_m.reachable x xa\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>)) \\<or>\n                            grey_reachable xa\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>)) \\<longrightarrow>\n                            obj_at (\\<lambda>s. True) xa\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>))", "apply (clarsimp simp add: no_grey_refs_def grey_reachable_def fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>black_heap s; \\<forall>x. \\<not> grey x s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s;\n        mut_m.reachable x xa\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s", "apply (drule black_heap_reachable)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>black_heap s; \\<forall>x. \\<not> grey x s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> black_heap\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))\n 2. \\<And>x xa.\n       \\<lbrakk>black_heap s; \\<forall>x. \\<not> grey x s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))\n 3. \\<And>x xa.\n       \\<lbrakk>black_heap s; \\<forall>x. \\<not> grey x s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s;\n        black xa\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s", "apply (simp add: black_heap_def fun_upd_apply; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>black_heap s; \\<forall>x. \\<not> grey x s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))\n 2. \\<And>x xa.\n       \\<lbrakk>black_heap s; \\<forall>x. \\<not> grey x s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s;\n        black xa\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s", "apply (clarsimp simp: valid_refs_inv_dequeue_Mutate; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>black_heap s; \\<forall>x. \\<not> grey x s;\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        valid_refs_inv s;\n        black xa\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s", "apply (clarsimp simp: in_snapshot_def in_snapshot_valid_ref fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma marked_deletions_dequeue_Mark:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; mut_m.marked_deletions m s; tso_store_inv s; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_deletions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n     mut_m.marked_deletions m s; tso_store_inv s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> mut_m.marked_deletions m\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (p := ws)\\<rparr>))", "unfolding mut_m.marked_deletions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_deletion x s;\n     tso_store_inv s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_deletion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "by (auto simp: fun_upd_apply obj_at_field_on_heap_def\n        split: obj_at_splits option.splits mem_store_action.splits\n         dest: valid_W_invD)"], ["", "lemma marked_deletions_dequeue_Mutate:\n  \"\\<lbrakk> sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws; mut_m.marked_deletions m s; mut_m.marked_insertions m' s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_deletions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                 mem_store_buffers := (mem_store_buffers (s sys))((mutator m') := ws)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers (mutator m') s =\n             mw_Mutate r f opt_r' # ws;\n     mut_m.marked_deletions m s; mut_m.marked_insertions m' s\\<rbrakk>\n    \\<Longrightarrow> mut_m.marked_deletions m\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))", "unfolding mut_m.marked_insertions_def mut_m.marked_deletions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers (mutator m') s =\n             mw_Mutate r f opt_r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_deletion x s;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m') s) \\<longrightarrow>\n        marked_insertion x s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := opt_r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (mutator m' := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_deletion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m' := ws)\\<rparr>))", "apply (clarsimp simp: fun_upd_apply split: mem_store_action.splits option.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x21 x22 x23.\n                mw_Mutate x21 x22 x23 \\<in> set ws \\<longrightarrow>\n                (\\<forall>x2. x23 = Some x2 \\<longrightarrow> marked x2 s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f None # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        (\\<forall>x21 x22.\n            (\\<forall>x23. x \\<noteq> mw_Mutate x21 x22 x23) \\<or>\n            obj_at_field_on_heap (\\<lambda>r'. marked r' s) x21 x22 s);\n     opt_r' = None\\<rbrakk>\n    \\<Longrightarrow> (m = m' \\<longrightarrow>\n                       (\\<forall>x21 x22.\n                           (\\<exists>x23.\n                               mw_Mutate x21 x22 x23\n                               \\<in> set ws) \\<longrightarrow>\n                           (r = x21 \\<longrightarrow> f \\<noteq> x22) \\<and>\n                           obj_at_field_on_heap (\\<lambda>r'. marked r' s)\n                            x21 x22 s \\<or>\n                           r = x21 \\<and>\n                           f = x22 \\<and>\n                           obj_at (\\<lambda>s. True) r s)) \\<and>\n                      (m \\<noteq> m' \\<longrightarrow>\n                       (\\<forall>x21 x22.\n                           (\\<exists>x23.\n                               mw_Mutate x21 x22 x23\n                               \\<in> set\n(sys_mem_store_buffers (mutator m) s)) \\<longrightarrow>\n                           (r = x21 \\<longrightarrow> f \\<noteq> x22) \\<and>\n                           obj_at_field_on_heap (\\<lambda>r'. marked r' s)\n                            x21 x22 s \\<or>\n                           r = x21 \\<and>\n                           f = x22 \\<and> obj_at (\\<lambda>s. True) r s))\n 2. \\<And>x2.\n       \\<lbrakk>\\<forall>x21 x22 x2a.\n                   (x2a = x2 \\<longrightarrow>\n                    x22 = f \\<longrightarrow>\n                    x21 = r \\<longrightarrow> marked x2 s) \\<and>\n                   (mw_Mutate x21 x22 (Some x2a)\n                    \\<in> set ws \\<longrightarrow>\n                    marked x2a s);\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f (Some x2) # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           (\\<forall>x21 x22.\n               (\\<forall>x23. x \\<noteq> mw_Mutate x21 x22 x23) \\<or>\n               obj_at_field_on_heap (\\<lambda>r'. marked r' s) x21 x22 s);\n        opt_r' = Some x2\\<rbrakk>\n       \\<Longrightarrow> (m = m' \\<longrightarrow>\n                          (\\<forall>x21 x22.\n                              (\\<exists>x23.\n                                  mw_Mutate x21 x22 x23\n                                  \\<in> set ws) \\<longrightarrow>\n                              (r = x21 \\<longrightarrow>\n                               f \\<noteq> x22) \\<and>\n                              obj_at_field_on_heap\n                               (\\<lambda>r'. marked r' s) x21 x22 s \\<or>\n                              r = x21 \\<and>\n                              f = x22 \\<and>\n                              obj_at (\\<lambda>s. True) r s)) \\<and>\n                         (m \\<noteq> m' \\<longrightarrow>\n                          (\\<forall>x21 x22.\n                              (\\<exists>x23.\n                                  mw_Mutate x21 x22 x23\n                                  \\<in> set\n   (sys_mem_store_buffers (mutator m) s)) \\<longrightarrow>\n                              (r = x21 \\<longrightarrow>\n                               f \\<noteq> x22) \\<and>\n                              obj_at_field_on_heap\n                               (\\<lambda>r'. marked r' s) x21 x22 s \\<or>\n                              r = x21 \\<and>\n                              f = x22 \\<and> obj_at (\\<lambda>s. True) r s))", "apply (metis list.set_intros(2) obj_at_field_on_heap_imp_valid_ref(1))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma grey_protects_white_dequeue_Mark:\n  assumes fl: \"fl = sys_fM s\"\n  assumes \"r \\<in> ghost_honorary_grey (s p)\"\n  shows \"(\\<exists>g. (g grey_protects_white w) (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)))\n      \\<longleftrightarrow> (\\<exists>g. (g grey_protects_white w) s)\" (is \"(\\<exists>g. (g grey_protects_white w) ?s') \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>g.\n        (g grey_protects_white w)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>))) =\n    (\\<exists>g. (g grey_protects_white w) s)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>)) \\<Longrightarrow>\n    \\<exists>g. (g grey_protects_white w) s\n 2. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "assume \"\\<exists>g. (g grey_protects_white w) ?s'\""], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (p := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>)) \\<Longrightarrow>\n    \\<exists>g. (g grey_protects_white w) s\n 2. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (p := ws)\\<rparr>))", "obtain g where \"(g grey_protects_white w) ?s'\""], ["proof (prove)\nusing this:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (p := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        (g grey_protects_white w)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (g grey_protects_white w)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>)) \\<Longrightarrow>\n    \\<exists>g. (g grey_protects_white w) s\n 2. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "from this assms"], ["proof (chain)\npicking this:\n  (g grey_protects_white w)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)", "show ?rhs"], ["proof (prove)\nusing this:\n  (g grey_protects_white w)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>grey x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "case (step x y z)"], ["proof (state)\nthis:\n  (x has_white_path_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  white z\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>grey x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "then"], ["proof (chain)\npicking this:\n  (x has_white_path_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  white z\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)", "show ?case"], ["proof (prove)\nusing this:\n  (x has_white_path_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  white z\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (p := ws)\\<rparr>))\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white z) s", "apply (cases \"y = r\"; clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>(x has_white_path_to r)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. sys_fM s)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        (r points_to z) s;\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        y = r; fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (g grey_protects_white r) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s\n 2. \\<And>g.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. sys_fM s)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        (y points_to z) s;\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        y \\<noteq> r; fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (g grey_protects_white y) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "apply (metis black_dequeue_Mark colours_distinct(2) do_store_action_simps(1) greyI(1) grey_protects_whiteE(1) grey_protects_whiteI marked_imp_black_or_grey(2) valid_ref_valid_null_ref_simps(1) white_valid_ref)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. sys_fM s)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        (y points_to z) s;\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        y \\<noteq> r; fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (g grey_protects_white y) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "apply (metis black_dequeue_Mark colours_distinct(2) do_store_action_simps(1) grey_protects_whiteE(2) grey_protects_whiteI marked_imp_black_or_grey(2) valid_ref_valid_null_ref_simps(1) white_valid_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>g. (g grey_protects_white z) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>grey x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (p := ws)\\<rparr>));\n        fl = sys_fM s; r \\<in> ghost_honorary_grey (s p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white x) s", "qed (fastforce simp: fun_upd_apply)"], ["proof (state)\nthis:\n  \\<exists>g. (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>g. (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>g. (g grey_protects_white w) s", "obtain g' where \"(g' grey_protects_white w) s\""], ["proof (prove)\nusing this:\n  \\<exists>g. (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        (g' grey_protects_white w) s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (g' grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  (g' grey_protects_white w) s", "show \"\\<exists>g. (g grey_protects_white w) ?s'\""], ["proof (prove)\nusing this:\n  (g' grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (p := ws)\\<rparr>))", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       grey x s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white x)\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (obj_mark_update (\\<lambda>_. fl))\n                                 (sys_heap s r)),\n                   mem_store_buffers :=\n                     (\\<lambda>a. sys_mem_store_buffers a s)\n                     (p := ws)\\<rparr>))\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (obj_mark_update (\\<lambda>_. fl))\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (p := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "case (refl g)"], ["proof (state)\nthis:\n  grey g s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       grey x s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white x)\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (obj_mark_update (\\<lambda>_. fl))\n                                 (sys_heap s r)),\n                   mem_store_buffers :=\n                     (\\<lambda>a. sys_mem_store_buffers a s)\n                     (p := ws)\\<rparr>))\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (obj_mark_update (\\<lambda>_. fl))\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (p := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "with assms"], ["proof (chain)\npicking this:\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)\n  grey g s", "show ?case"], ["proof (prove)\nusing this:\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)\n  grey g s\n\ngoal (1 subgoal):\n 1. \\<exists>ga.\n       (ga grey_protects_white g)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (p := ws)\\<rparr>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n     grey g s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ga.\n                         (ga grey_protects_white g)\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (p := ws)\\<rparr>))", "apply (rule exI[where x=g])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n     grey g s\\<rbrakk>\n    \\<Longrightarrow> (g grey_protects_white g)\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (\\<lambda>a. sys_mem_store_buffers a s)\n                                 (p := ws)\\<rparr>))", "apply (rule grey_protects_whiteI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n     grey g s\\<rbrakk>\n    \\<Longrightarrow> grey g\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (\\<lambda>a. sys_mem_store_buffers a s)\n                                 (p := ws)\\<rparr>))", "apply (subst grey_fun_upd; simp add: fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ga.\n     (ga grey_protects_white g)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (p := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (obj_mark_update (\\<lambda>_. fl))\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (p := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "(* FIXME something eta-ish going wrong here: fun_upd_apply triggers too early, why? Maybe the WL rules are borked too *)"], ["proof (state)\nthis:\n  \\<exists>ga.\n     (ga grey_protects_white g)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (p := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (obj_mark_update (\\<lambda>_. fl))\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (p := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (obj_mark_update (\\<lambda>_. fl))\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (p := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "case (step x y z)"], ["proof (state)\nthis:\n  (x has_white_path_to y) s\n  \\<exists>g.\n     (g grey_protects_white y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (p := ws)\\<rparr>))\n  (y points_to z) s\n  white z s\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (obj_mark_update (\\<lambda>_. fl))\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (p := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "with assms"], ["proof (chain)\npicking this:\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)\n  (x has_white_path_to y) s\n  \\<exists>g.\n     (g grey_protects_white y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (p := ws)\\<rparr>))\n  (y points_to z) s\n  white z s", "show ?case"], ["proof (prove)\nusing this:\n  fl = sys_fM s\n  r \\<in> ghost_honorary_grey (s p)\n  (x has_white_path_to y) s\n  \\<exists>g.\n     (g grey_protects_white y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (p := ws)\\<rparr>))\n  (y points_to z) s\n  white z s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white z)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (p := ws)\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        (g grey_protects_white y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (p := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "apply (rename_tac g)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        (g grey_protects_white y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (p := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(p := ws)\\<rparr>))", "apply (clarsimp simp add: grey_protects_white_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>))", "apply (case_tac \"z = r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z = r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>))\n 2. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>))", "apply (rule exI[where x=r])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z = r\\<rbrakk>\n       \\<Longrightarrow> grey r\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>)) \\<and>\n                         (r has_white_path_to z)\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))\n 2. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>))", "apply (clarsimp simp add: grey_protects_white_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to r) s; white r s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z = r\\<rbrakk>\n       \\<Longrightarrow> grey r\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))\n 2. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>))", "apply (subst grey_fun_upd; force simp: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(p := ws)\\<rparr>))", "apply (rule_tac x=g in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>fl = sys_fM s; r \\<in> ghost_honorary_grey (s p);\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (obj_mark_update (\\<lambda>_. sys_fM s))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        z \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> grey g\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>)) \\<and>\n                         (g has_white_path_to z)\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. sys_fM s))\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (fastforce elim!: has_white_path_to_step)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white z)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (p := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (p := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_snapshot_inv_dequeue_Mark:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; mut_m.reachable_snapshot_inv m s; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> mut_m.reachable_snapshot_inv m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n     mut_m.reachable_snapshot_inv m s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (p := ws)\\<rparr>))", "unfolding mut_m.reachable_snapshot_inv_def in_snapshot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         mut_m.reachable m x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>)) \\<longrightarrow>\n                         black x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>)) \\<or>\n                         (\\<exists>xa.\n                             (xa grey_protects_white x)\n                              (s(sys := s sys\n                                   \\<lparr>heap := (sys_heap s)\n       (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\nmem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        valid_W_inv s;\n        mut_m.reachable m x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        black x s \\<longrightarrow> x = r;\n        \\<forall>xa.\n           \\<not> (xa grey_protects_white x)\n                   (s(sys := s sys\n                        \\<lparr>heap := (sys_heap s)\n                                  (r := map_option\n   (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                           mem_store_buffers := (mem_store_buffers (s sys))\n                             (p := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> x = r \\<and>\n                         fl = sys_fM s \\<and>\n                         obj_at (\\<lambda>s. True) r s \\<and>\n                         \\<not> grey r s", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        valid_W_inv s;\n        mut_m.reachable m x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        black x s \\<longrightarrow> x = r;\n        \\<forall>xa.\n           \\<not> (xa grey_protects_white x)\n                   (s(sys := s sys\n                        \\<lparr>heap := (sys_heap s)\n                                  (r := map_option\n   (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                           mem_store_buffers := (mem_store_buffers (s sys))\n                             (p := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> x = r \\<and>\n                         fl = sys_fM s \\<and>\n                         obj_at (\\<lambda>s. True) r s \\<and>\n                         \\<not> grey r s", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        valid_W_inv s;\n        mut_m.reachable m x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option (obj_mark_update (\\<lambda>_. fl))\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (p := ws)\\<rparr>));\n        black x s \\<longrightarrow> x = r;\n        \\<forall>xa.\n           \\<not> (xa grey_protects_white x)\n                   (s(sys := s sys\n                        \\<lparr>heap := (sys_heap s)\n                                  (r := map_option\n   (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                           mem_store_buffers := (mem_store_buffers (s sys))\n                             (p := ws)\\<rparr>));\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> x = r \\<and>\n                         fl = sys_fM s \\<and>\n                         obj_at (\\<lambda>s. True) r s \\<and>\n                         \\<not> grey r s", "apply (subst (asm) arg_cong[where f=Not, OF grey_protects_white_dequeue_Mark, simplified]; simp add: colours_distinct(4) valid_W_invD(1) fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma marked_insertions_dequeue_Mark:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mark r fl # ws; mut_m.marked_insertions m s; tso_writes_inv s; valid_W_inv s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_insertions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)), mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n     mut_m.marked_insertions m s; tso_writes_inv s; valid_W_inv s\\<rbrakk>\n    \\<Longrightarrow> mut_m.marked_insertions m\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (p := ws)\\<rparr>))", "apply (clarsimp simp: mut_m.marked_insertions_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (((mem_store_buffers (s sys))(p := ws))\n                      (mutator m))\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (cases \"mutator m = p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (((mem_store_buffers (s sys))(p := ws)) (mutator m));\n        mutator m = p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (((mem_store_buffers (s sys))(p := ws)) (mutator m));\n        mutator m \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers (mutator m) s = mw_Mark r fl # ws;\n        \\<forall>x. x \\<in> set ws \\<longrightarrow> marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s; x \\<in> set ws;\n        p = mutator m\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (((mem_store_buffers (s sys))(p := ws)) (mutator m));\n        mutator m \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers (mutator m) s = mw_Mark r fl # ws;\n        \\<forall>x. x \\<in> set ws \\<longrightarrow> marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s; x \\<in> set ws;\n        p = mutator m\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (((mem_store_buffers (s sys))(p := ws)) (mutator m));\n        mutator m \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers (mutator m) s = mw_Mark r fl # ws;\n        tso_writes_inv s; valid_W_inv s; x \\<in> set ws; p = mutator m;\n        x \\<in> set ws \\<longrightarrow> marked_insertion x s\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (((mem_store_buffers (s sys))(p := ws)) (mutator m));\n        mutator m \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (auto simp: valid_W_invD split: mem_store_action.splits option.splits obj_at_splits; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (((mem_store_buffers (s sys))(p := ws)) (mutator m));\n        mutator m \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (sys_mem_store_buffers (mutator m) s);\n        mutator m \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (sys_mem_store_buffers (mutator m) s);\n        mutator m \\<noteq> p\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mark r fl # ws;\n        tso_writes_inv s; valid_W_inv s;\n        x \\<in> set (sys_mem_store_buffers (mutator m) s);\n        mutator m \\<noteq> p;\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (auto simp: valid_W_invD split: mem_store_action.splits option.splits obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma marked_insertions_dequeue_Mutate:\n  \"\\<lbrakk> sys_mem_store_buffers p s = mw_Mutate r f r' # ws; mut_m.marked_insertions m s \\<rbrakk>\n     \\<Longrightarrow> mut_m.marked_insertions m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>) (sys_heap s r)),\n                                                    mem_store_buffers := (mem_store_buffers (s sys))(p := ws)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     mut_m.marked_insertions m s\\<rbrakk>\n    \\<Longrightarrow> mut_m.marked_insertions m\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (p := ws)\\<rparr>))", "unfolding mut_m.marked_insertions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (cases \"mutator m = p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s;\n     mutator m = p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))\n 2. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s;\n     mutator m \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers (mutator m) s = mw_Mutate r f r' # ws;\n        \\<forall>x.\n           (x = mw_Mutate r f r' \\<longrightarrow>\n            (case r' of None \\<Rightarrow> True\n             | Some r' \\<Rightarrow> marked r' s)) \\<and>\n           (x \\<in> set ws \\<longrightarrow> marked_insertion x s);\n        p = mutator m; x \\<in> set ws\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s;\n     mutator m \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers (mutator m) s = mw_Mutate r f r' # ws;\n        \\<forall>x.\n           (x = mw_Mutate r f r' \\<longrightarrow>\n            (case r' of None \\<Rightarrow> True\n             | Some r' \\<Rightarrow> marked r' s)) \\<and>\n           (x \\<in> set ws \\<longrightarrow> marked_insertion x s);\n        p = mutator m; x \\<in> set ws\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s;\n     mutator m \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers (mutator m) s = mw_Mutate r f r' # ws;\n        p = mutator m; x \\<in> set ws;\n        (x = mw_Mutate r f r' \\<longrightarrow>\n         (case r' of None \\<Rightarrow> True\n          | Some r' \\<Rightarrow> marked r' s)) \\<and>\n        (x \\<in> set ws \\<longrightarrow> marked_insertion x s)\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s;\n     mutator m \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (auto simp: fun_upd_apply split: mem_store_action.splits option.splits obj_at_splits; fail)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n     \\<forall>x.\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s;\n     mutator m \\<noteq> p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set (sys_mem_store_buffers (mutator m)\n (s(sys := s sys\n      \\<lparr>heap := (sys_heap s)\n                (r := map_option\n                       (\\<lambda>obj. obj\n                           \\<lparr>obj_fields := (obj_fields obj)\n                                     (f := r')\\<rparr>)\n                       (sys_heap s r)),\n         mem_store_buffers := (mem_store_buffers (s sys))\n           (p := ws)\\<rparr>))) \\<longrightarrow>\n                         marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        mutator m \\<noteq> p;\n        x \\<in> set (sys_mem_store_buffers (mutator m) s)\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers (mutator m)\n                         s) \\<longrightarrow>\n           marked_insertion x s;\n        mutator m \\<noteq> p;\n        x \\<in> set (sys_mem_store_buffers (mutator m) s)\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>sys_mem_store_buffers p s = mw_Mutate r f r' # ws;\n        mutator m \\<noteq> p;\n        x \\<in> set (sys_mem_store_buffers (mutator m) s);\n        x \\<in> set (sys_mem_store_buffers (mutator m) s) \\<longrightarrow>\n        marked_insertion x s\\<rbrakk>\n       \\<Longrightarrow> marked_insertion x\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (p := ws)\\<rparr>))", "apply (auto simp: fun_upd_apply split: mem_store_action.splits option.splits obj_at_splits)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* shows the snapshot is preserved by the two marks. *)"], ["", "lemma grey_protects_white_dequeue_Mutate:\n  assumes sb: \"sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\"\n  assumes mi: \"mut_m.marked_insertions m s\"\n  assumes md: \"mut_m.marked_deletions m s\"\n  shows \"(\\<exists>g. (g grey_protects_white w) (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)))\n      \\<longleftrightarrow> (\\<exists>g. (g grey_protects_white w) s)\" (is \"(\\<exists>g. (g grey_protects_white w) ?s') \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>g.\n        (g grey_protects_white w)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>))) =\n    (\\<exists>g. (g grey_protects_white w) s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>)) \\<Longrightarrow>\n    \\<exists>g. (g grey_protects_white w) s\n 2. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "assume \"(\\<exists>g. (g grey_protects_white w) ?s')\""], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>)) \\<Longrightarrow>\n    \\<exists>g. (g grey_protects_white w) s\n 2. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m := ws)\\<rparr>))", "obtain g where \"(g grey_protects_white w) ?s'\""], ["proof (prove)\nusing this:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        (g grey_protects_white w)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (g grey_protects_white w)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>)) \\<Longrightarrow>\n    \\<exists>g. (g grey_protects_white w) s\n 2. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "from this mi sb"], ["proof (chain)\npicking this:\n  (g grey_protects_white w)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws", "show ?rhs"], ["proof (prove)\nusing this:\n  (g grey_protects_white w)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s", "proof(induct rule: grey_protects_white_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>grey x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s =\n        mw_Mutate r f opt_r' # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        \\<lbrakk>mut_m.marked_insertions m s;\n         sys_mem_store_buffers (mutator m) s =\n         mw_Mutate r f opt_r' # ws\\<rbrakk>\n        \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s =\n        mw_Mutate r f opt_r' # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "case (refl x)"], ["proof (state)\nthis:\n  grey x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>grey x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s =\n        mw_Mutate r f opt_r' # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        \\<lbrakk>mut_m.marked_insertions m s;\n         sys_mem_store_buffers (mutator m) s =\n         mw_Mutate r f opt_r' # ws\\<rbrakk>\n        \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s =\n        mw_Mutate r f opt_r' # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "then"], ["proof (chain)\npicking this:\n  grey x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws", "show ?case"], ["proof (prove)\nusing this:\n  grey x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white x) s", "by (fastforce simp: fun_upd_apply)"], ["proof (state)\nthis:\n  \\<exists>g. (g grey_protects_white x) s\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        \\<lbrakk>mut_m.marked_insertions m s;\n         sys_mem_store_buffers (mutator m) s =\n         mw_Mutate r f opt_r' # ws\\<rbrakk>\n        \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s =\n        mw_Mutate r f opt_r' # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        \\<lbrakk>mut_m.marked_insertions m s;\n         sys_mem_store_buffers (mutator m) s =\n         mw_Mutate r f opt_r' # ws\\<rbrakk>\n        \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s =\n        mw_Mutate r f opt_r' # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "case (step x y z)"], ["proof (state)\nthis:\n  (x has_white_path_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  \\<lbrakk>mut_m.marked_insertions m s;\n   sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  white z\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        \\<lbrakk>mut_m.marked_insertions m s;\n         sys_mem_store_buffers (mutator m) s =\n         mw_Mutate r f opt_r' # ws\\<rbrakk>\n        \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s;\n        (y points_to z)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        white z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s =\n        mw_Mutate r f opt_r' # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g. (g grey_protects_white z) s", "then"], ["proof (chain)\npicking this:\n  (x has_white_path_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  \\<lbrakk>mut_m.marked_insertions m s;\n   sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  white z\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws", "show ?case"], ["proof (prove)\nusing this:\n  (x has_white_path_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  \\<lbrakk>mut_m.marked_insertions m s;\n   sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  white z\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white z) s", "unfolding white_def"], ["proof (prove)\nusing this:\n  (x has_white_path_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  \\<lbrakk>mut_m.marked_insertions m s;\n   sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g. (g grey_protects_white y) s\n  (y points_to z)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m := ws)\\<rparr>))\n  obj_at\n   (\\<lambda>obj.\n       obj_mark obj \\<noteq>\n       sys_fM\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>)))\n   z (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m := ws)\\<rparr>))\n  mut_m.marked_insertions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white z) s", "apply (clarsimp simp: points_to_Mutate grey_protects_white_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>(x has_white_path_to y)\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m := ws)\\<rparr>));\n        r \\<noteq> y \\<and> (y points_to z) s \\<or>\n        r = y \\<and>\n        obj_at (\\<lambda>s. True) r s \\<and>\n        (opt_r' = Some z \\<or>\n         (y points_to z) s \\<and>\n         obj_at\n          (\\<lambda>obj.\n              \\<exists>f'. obj_fields obj f' = Some z \\<and> f \\<noteq> f')\n          r s);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s)) z\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        mut_m.marked_insertions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        grey g s; (g has_white_path_to y) s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and> (g has_white_path_to z) s", "apply (auto dest: marked_insertionD simp: marked_not_white whiteI fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>g. (g grey_protects_white z) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g. (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>g. (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g. (g grey_protects_white w) s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  \\<exists>g. (g grey_protects_white w) s", "show \"(\\<exists>g. (g grey_protects_white w) ?s')\""], ["proof (prove)\nusing this:\n  \\<exists>g. (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "proof(clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (g grey_protects_white w) s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white w)\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m := ws)\\<rparr>))", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (g grey_protects_white w) s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white w)\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m := ws)\\<rparr>))", "assume \"(g grey_protects_white w) s\""], ["proof (state)\nthis:\n  (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       (g grey_protects_white w) s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white w)\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m := ws)\\<rparr>))", "from this"], ["proof (chain)\npicking this:\n  (g grey_protects_white w) s", "show ?thesis"], ["proof (prove)\nusing this:\n  (g grey_protects_white w) s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white w)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m := ws)\\<rparr>))", "proof(induct rule: grey_protects_white_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       grey x s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white x)\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers :=\n                     (\\<lambda>a. sys_mem_store_buffers a s)\n                     (mutator m := ws)\\<rparr>))\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (mutator m := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(mutator m := ws)\\<rparr>))", "case (refl x)"], ["proof (state)\nthis:\n  grey x s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       grey x s \\<Longrightarrow>\n       \\<exists>g.\n          (g grey_protects_white x)\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers :=\n                     (\\<lambda>a. sys_mem_store_buffers a s)\n                     (mutator m := ws)\\<rparr>))\n 2. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (mutator m := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(mutator m := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  grey x s", "show ?case"], ["proof (prove)\nusing this:\n  grey x s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white x)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m := ws)\\<rparr>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. grey x s \\<Longrightarrow>\n    \\<exists>g.\n       (g grey_protects_white x)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m := ws)\\<rparr>))", "apply (rule exI[where x=x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. grey x s \\<Longrightarrow>\n    (x grey_protects_white x)\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m := ws)\\<rparr>))", "apply (clarsimp simp: grey_protects_white_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. grey x s \\<Longrightarrow>\n    grey x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m := ws)\\<rparr>))", "apply (subst grey_fun_upd; simp add: fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* FIXME *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white x)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (mutator m := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (mutator m := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(mutator m := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (mutator m := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(mutator m := ws)\\<rparr>))", "case (step x y z)"], ["proof (state)\nthis:\n  (x has_white_path_to y) s\n  \\<exists>g.\n     (g grey_protects_white y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (mutator m := ws)\\<rparr>))\n  (y points_to z) s\n  white z s\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x has_white_path_to y) s;\n        \\<exists>g.\n           (g grey_protects_white y)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers :=\n                      (\\<lambda>a. sys_mem_store_buffers a s)\n                      (mutator m := ws)\\<rparr>));\n        (y points_to z) s; white z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(mutator m := ws)\\<rparr>))", "with md sb"], ["proof (chain)\npicking this:\n  mut_m.marked_deletions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n  (x has_white_path_to y) s\n  \\<exists>g.\n     (g grey_protects_white y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (mutator m := ws)\\<rparr>))\n  (y points_to z) s\n  white z s", "show ?case"], ["proof (prove)\nusing this:\n  mut_m.marked_deletions m s\n  sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws\n  (x has_white_path_to y) s\n  \\<exists>g.\n     (g grey_protects_white y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (mutator m := ws)\\<rparr>))\n  (y points_to z) s\n  white z s\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       (g grey_protects_white z)\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m := ws)\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        (g grey_protects_white y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            (g grey_protects_white z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (\\<lambda>a. sys_mem_store_buffers a s)(mutator m := ws)\\<rparr>))", "apply (clarsimp simp: grey_protects_white_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (rename_tac g)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (case_tac \"y = r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))\n 2. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y \\<noteq> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))\n 2. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (auto simp: points_to_Mutate fun_upd_apply elim!: has_white_path_to_step; fail)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to y) s; (y points_to z) s; white z s;\n        grey g\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        (g has_white_path_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>)) \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := (sys_heap s)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_fields := (obj_fields obj)\n                           (f := opt_r')\\<rparr>)\n             (sys_heap s r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (clarsimp simp: ran_def fun_upd_apply split: obj_at_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj a.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj a = Some z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "(* FIXME rule: witness field for r points_to c *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj a.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj a = Some z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (rename_tac g obj aa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (case_tac \"aa = f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa = f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))\n 2. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))\n 2. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa = f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (rule_tac x=g in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> grey g s \\<and>\n                         (g has_white_path_to z)\n                          (s(sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n   \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa = f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> (g has_white_path_to z)\n                          (s(sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n   \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>))\n 2. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa = f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (clarsimp simp: has_white_path_to_def fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (\\<lambda>x y.\n            (x points_to y)\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)) \\<and>\n            white y s)\\<^sup>*\\<^sup>*\n         g r;\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n         r;\n        sys_heap s r = Some obj; obj_fields obj aa = Some z;\n        aa \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x y.\n                             (x points_to y)\n                              (s(sys := s sys\n                                   \\<lparr>heap := sys_heap s(r \\<mapsto>\n       obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\nmem_store_buffers := (mem_store_buffers (s sys))\n  (mutator m := ws)\\<rparr>)) \\<and>\n                             white y s)\\<^sup>*\\<^sup>*\n                          g z\n 2. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa = f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (erule rtranclp.intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s; y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n         r;\n        sys_heap s r = Some obj; obj_fields obj aa = Some z;\n        aa \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> (r points_to z)\n                          (s(sys := s sys\n                               \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n   \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                  mem_store_buffers :=\n                                    (mem_store_buffers (s sys))\n                                    (mutator m := ws)\\<rparr>)) \\<and>\n                         white z s\n 2. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa = f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (auto simp: fun_upd_apply ran_def split: obj_at_splits; fail)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj aa.\n       \\<lbrakk>white z s; grey g s;\n        (g has_white_path_to r)\n         (s(sys := s sys\n              \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                        \\<lparr>obj_fields := (obj_fields obj)\n                                  (f := opt_r')\\<rparr>),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m := ws)\\<rparr>));\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (x has_white_path_to r) s; sys_heap s r = Some obj;\n        obj_fields obj aa = Some z; aa = f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (g has_white_path_to z)\n                             (s(sys := s sys\n                                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n      \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n                                     mem_store_buffers :=\n (mem_store_buffers (s sys))(mutator m := ws)\\<rparr>))", "apply (clarsimp simp: has_white_path_to_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj.\n       \\<lbrakk>white z s; grey g s;\n        (\\<lambda>x y.\n            (x points_to y)\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)) \\<and>\n            white y\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n         g r;\n        y = r; mut_m.marked_deletions m s;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n         r;\n        sys_heap s r = Some obj; obj_fields obj f = Some z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y)\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)) \\<and>\n                                white y\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                             g z", "apply (clarsimp simp: mut_m.marked_deletions_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj.\n       \\<lbrakk>white z s; grey g s;\n        (\\<lambda>x y.\n            (x points_to y)\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)) \\<and>\n            white y\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n         g r;\n        y = r;\n        \\<forall>x.\n           (x = mw_Mutate r f opt_r' \\<longrightarrow>\n            obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n           (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n         r;\n        sys_heap s r = Some obj; obj_fields obj f = Some z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y)\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)) \\<and>\n                                white y\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                             g z", "(* FIXME rule *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj.\n       \\<lbrakk>white z s; grey g s;\n        (\\<lambda>x y.\n            (x points_to y)\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)) \\<and>\n            white y\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n         g r;\n        y = r;\n        \\<forall>x.\n           (x = mw_Mutate r f opt_r' \\<longrightarrow>\n            obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n           (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n         r;\n        sys_heap s r = Some obj; obj_fields obj f = Some z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y)\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)) \\<and>\n                                white y\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                             g z", "apply (drule spec[where x=\"mw_Mutate r f opt_r'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj.\n       \\<lbrakk>white z s; grey g s;\n        (\\<lambda>x y.\n            (x points_to y)\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)) \\<and>\n            white y\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n         g r;\n        y = r;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n         r;\n        sys_heap s r = Some obj; obj_fields obj f = Some z;\n        (mw_Mutate r f opt_r' = mw_Mutate r f opt_r' \\<longrightarrow>\n         obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n        (mw_Mutate r f opt_r' \\<in> set ws \\<longrightarrow>\n         marked_deletion (mw_Mutate r f opt_r') s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y)\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)) \\<and>\n                                white y\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                             g z", "apply (clarsimp simp: obj_at_field_on_heap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g obj.\n       \\<lbrakk>white z s; grey g s;\n        (\\<lambda>x y.\n            (x points_to y)\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)) \\<and>\n            white y\n             (s(sys := s sys\n                  \\<lparr>heap := sys_heap s(r \\<mapsto> obj\n                            \\<lparr>obj_fields := (obj_fields obj)\n(f := opt_r')\\<rparr>),\n                     mem_store_buffers := (mem_store_buffers (s sys))\n                       (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n         g r;\n        y = r;\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        (\\<lambda>x y. (x points_to y) s \\<and> white y s)\\<^sup>*\\<^sup>* x\n         r;\n        sys_heap s r = Some obj; obj_fields obj f = Some z;\n        marked z s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g.\n                            grey g s \\<and>\n                            (\\<lambda>x y.\n                                (x points_to y)\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)) \\<and>\n                                white y\n                                 (s(sys := s sys\n\\<lparr>heap := sys_heap s(r \\<mapsto> obj\n          \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>),\n   mem_store_buffers := (mem_store_buffers (s sys))\n     (mutator m := ws)\\<rparr>)))\\<^sup>*\\<^sup>*\n                             g z", "apply (simp add: white_def split: obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white z)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                (mutator m := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>g.\n     (g grey_protects_white w)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* write barrier installed but not all mutators are necessarily past get_roots *)"], ["", "lemma reachable_snapshot_inv_dequeue_Mutate:\n  notes grey_protects_white_dequeue_Mutate[simp]\n  fixes s :: \"('field, 'mut, 'payload, 'ref) lsts\"\n  assumes sb: \"sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\"\n  assumes mi: \"mut_m.marked_insertions m' s\"\n  assumes md: \"mut_m.marked_deletions m' s\"\n  assumes rsi: \"mut_m.reachable_snapshot_inv m s\"\n  assumes sti: \"strong_tricolour_inv s\"\n  assumes vri: \"valid_refs_inv s\"\n  shows \"mut_m.reachable_snapshot_inv m (s(sys := s sys\\<lparr>heap := (sys_heap s)(r := map_option (\\<lambda>obj. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                                                        mem_store_buffers := (mem_store_buffers (s sys))(mutator m' := ws)\\<rparr>))\" (is \"mut_m.reachable_snapshot_inv m ?s'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.reachable_snapshot_inv m\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "proof(rule mut_m.reachable_snapshot_invI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       mut_m.reachable m y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       mut_m.reachable m y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "assume y: \"mut_m.reachable m y ?s'\""], ["proof (state)\nthis:\n  mut_m.reachable m y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       mut_m.reachable m y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  mut_m.reachable m y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))", "have \"(mut_m.reachable m y s \\<or> mut_m.reachable m' y s) \\<and> in_snapshot y ?s'\""], ["proof (prove)\nusing this:\n  mut_m.reachable m y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mut_m.reachable m y s \\<or> mut_m.reachable m' y s) \\<and>\n    in_snapshot y\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "proof(induct rule: reachable_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> roots\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>))\n                  (mutator m)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>))\n                  (mutator m)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 3. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 4. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "case (root x)"], ["proof (state)\nthis:\n  x \\<in> roots\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m))\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> roots\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>))\n                  (mutator m)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> ghost_honorary_root\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>))\n                  (mutator m)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 3. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 4. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "with mi md rsi sb"], ["proof (chain)\npicking this:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  x \\<in> roots\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m))", "show ?case"], ["proof (prove)\nusing this:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  x \\<in> roots\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m))\n\ngoal (1 subgoal):\n 1. (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n    in_snapshot x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))", "apply (clarsimp simp: mut_m.reachable_snapshot_inv_def in_snapshot_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     x \\<in> roots (s (mutator m))\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (auto simp: fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> ghost_honorary_root\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>))\n                  (mutator m)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 3. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> ghost_honorary_root\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>))\n                  (mutator m)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 3. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "case (ghost_honorary_root x)"], ["proof (state)\nthis:\n  x \\<in> ghost_honorary_root\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> ghost_honorary_root\n                ((s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>))\n                  (mutator m)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 3. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "with mi md rsi sb"], ["proof (chain)\npicking this:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  x \\<in> ghost_honorary_root\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m))", "show ?case"], ["proof (prove)\nusing this:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  x \\<in> ghost_honorary_root\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m))\n\ngoal (1 subgoal):\n 1. (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n    in_snapshot x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))", "unfolding mut_m.reachable_snapshot_inv_def in_snapshot_def"], ["proof (prove)\nusing this:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  \\<forall>x.\n     mut_m.reachable m x s \\<longrightarrow>\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  x \\<in> ghost_honorary_root\n           ((s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r := map_option\n                                  (\\<lambda>obj. obj\n\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                  (sys_heap s r)),\n                    mem_store_buffers := (mem_store_buffers (s sys))\n                      (mutator m' := ws)\\<rparr>))\n             (mutator m))\n\ngoal (1 subgoal):\n 1. (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n    (black x\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>)) \\<or>\n     (\\<exists>xa.\n         (xa grey_protects_white x)\n          (s(sys := s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_fields := (obj_fields obj)\n        (f := opt_r')\\<rparr>)\n                                (sys_heap s r)),\n                  mem_store_buffers := (mem_store_buffers (s sys))\n                    (mutator m' := ws)\\<rparr>))))", "by (auto simp: fun_upd_apply)"], ["proof (state)\nthis:\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "case (tso_root x)"], ["proof (state)\nthis:\n  x \\<in> mut_m.tso_store_refs m\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m' := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mut_m.tso_store_refs m\n                (s(sys := s sys\n                     \\<lparr>heap := (sys_heap s)\n                               (r := map_option\n(\\<lambda>obj. obj\n    \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n(sys_heap s r)),\n                        mem_store_buffers := (mem_store_buffers (s sys))\n                          (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n       in_snapshot x\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n                  (mutator m' := ws)\\<rparr>))\n 2. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "with mi md rsi sb"], ["proof (chain)\npicking this:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  x \\<in> mut_m.tso_store_refs m\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m' := ws)\\<rparr>))", "show ?case"], ["proof (prove)\nusing this:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  x \\<in> mut_m.tso_store_refs m\n           (s(sys := s sys\n                \\<lparr>heap := (sys_heap s)\n                          (r := map_option\n                                 (\\<lambda>obj. obj\n                                     \\<lparr>obj_fields := (obj_fields obj)\n         (f := opt_r')\\<rparr>)\n                                 (sys_heap s r)),\n                   mem_store_buffers := (mem_store_buffers (s sys))\n                     (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n    in_snapshot x\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))", "apply (clarsimp simp: mut_m.reachable_snapshot_inv_def in_snapshot_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; xa \\<in> set ws;\n        x \\<in> (case xa of\n                 mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                 | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                 | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (rename_tac w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; w \\<in> set ws;\n        x \\<in> (case w of\n                 mw_Mutate r f r' \\<Rightarrow> insert r (set_option r')\n                 | mw_Mutate_Payload r f pl \\<Rightarrow> {r}\n                 | _ \\<Rightarrow> {})\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (case_tac w; simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w x21 x22 x23.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate x21 x22 x23 \\<in> set ws;\n        x = x21 \\<or> x23 = Some x; w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "(* FIXME cut and paste here *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w x21 x22 x23.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate x21 x22 x23 \\<in> set ws;\n        x = x21 \\<or> x23 = Some x; w = mw_Mutate x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (rename_tac ref field option)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w ref field option.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        w = mw_Mutate ref field option\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (clarsimp simp: mut_m.marked_deletions_def mut_m.marked_insertions_def fun_upd_apply)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   (x = mw_Mutate r f opt_r' \\<longrightarrow>\n                    (case opt_r' of None \\<Rightarrow> True\n                     | Some r' \\<Rightarrow> marked r' s)) \\<and>\n                   (x \\<in> set ws \\<longrightarrow> marked_insertion x s);\n        \\<forall>x.\n           (x = mw_Mutate r f opt_r' \\<longrightarrow>\n            obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n           (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (drule_tac x=\"mw_Mutate ref field option\" in spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   (x = mw_Mutate r f opt_r' \\<longrightarrow>\n                    obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f\n                     s) \\<and>\n                   (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        (mw_Mutate ref field option = mw_Mutate r f opt_r' \\<longrightarrow>\n         (case opt_r' of None \\<Rightarrow> True\n          | Some r' \\<Rightarrow> marked r' s)) \\<and>\n        (mw_Mutate ref field option \\<in> set ws \\<longrightarrow>\n         marked_insertion (mw_Mutate ref field option) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (drule_tac x=\"mw_Mutate ref field option\" in spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        (mw_Mutate ref field option = mw_Mutate r f opt_r' \\<longrightarrow>\n         (case opt_r' of None \\<Rightarrow> True\n          | Some r' \\<Rightarrow> marked r' s)) \\<and>\n        (mw_Mutate ref field option \\<in> set ws \\<longrightarrow>\n         marked_insertion (mw_Mutate ref field option) s);\n        (mw_Mutate ref field option = mw_Mutate r f opt_r' \\<longrightarrow>\n         obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n        (mw_Mutate ref field option \\<in> set ws \\<longrightarrow>\n         marked_deletion (mw_Mutate ref field option) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        (case opt_r' of None \\<Rightarrow> True\n         | Some r' \\<Rightarrow> marked r' s);\n        case option of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) ref field s\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (frule spec[where x=x])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        (case opt_r' of None \\<Rightarrow> True\n         | Some r' \\<Rightarrow> marked r' s);\n        case option of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) ref field s;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (subgoal_tac \"mut_m.reachable m x s\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        (case opt_r' of None \\<Rightarrow> True\n         | Some r' \\<Rightarrow> marked r' s);\n        case option of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) ref field s;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        mut_m.reachable m x s\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        (case opt_r' of None \\<Rightarrow> True\n         | Some r' \\<Rightarrow> marked r' s);\n        case option of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) ref field s;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s\n 3. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 4. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (force simp: fun_upd_apply)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        (case opt_r' of None \\<Rightarrow> True\n         | Some r' \\<Rightarrow> marked r' s);\n        case option of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) ref field s;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (rule reachableI(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ref field option.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate ref field option \\<in> set ws;\n        x = ref \\<or> option = Some x;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        (case opt_r' of None \\<Rightarrow> True\n         | Some r' \\<Rightarrow> marked r' s);\n        case option of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        ref = r \\<and> field = f \\<and> option = opt_r' \\<longrightarrow>\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) ref field s;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mut_m.tso_store_refs m s\n 2. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (force simp: mut_m.tso_store_refs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w x31 x32 x33.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x31 x32 x33 \\<in> set ws; x = x31;\n        w = mw_Mutate_Payload x31 x32 x33\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x31 s \\<and>\n                         (black x31\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white x31) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (rename_tac ref field pl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w ref field pl.\n       \\<lbrakk>mut_m.marked_insertions m s; mut_m.marked_deletions m s;\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload ref field pl \\<in> set ws; x = ref;\n        w = mw_Mutate_Payload ref field pl\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m ref s \\<and>\n                         (black ref\n                           (s(sys := s sys\n                                \\<lparr>heap := (sys_heap s)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n           (sys_heap s r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s sys))\n                                     (mutator m := ws)\\<rparr>)) \\<or>\n                          (\\<exists>x. (x grey_protects_white ref) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (clarsimp simp: mut_m.marked_deletions_def mut_m.marked_insertions_def fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   (x = mw_Mutate r f opt_r' \\<longrightarrow>\n                    (case opt_r' of None \\<Rightarrow> True\n                     | Some r' \\<Rightarrow> marked r' s)) \\<and>\n                   (x \\<in> set ws \\<longrightarrow> marked_insertion x s);\n        \\<forall>x.\n           (x = mw_Mutate r f opt_r' \\<longrightarrow>\n            obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n           (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (drule_tac x=\"mw_Mutate_Payload x field pl\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   (x = mw_Mutate r f opt_r' \\<longrightarrow>\n                    obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f\n                     s) \\<and>\n                   (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n        \\<forall>x.\n           mut_m.reachable m x s \\<longrightarrow>\n           black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws;\n        (mw_Mutate_Payload x field pl =\n         mw_Mutate r f opt_r' \\<longrightarrow>\n         (case opt_r' of None \\<Rightarrow> True\n          | Some r' \\<Rightarrow> marked r' s)) \\<and>\n        (mw_Mutate_Payload x field pl \\<in> set ws \\<longrightarrow>\n         marked_insertion (mw_Mutate_Payload x field pl) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (drule_tac x=\"mw_Mutate_Payload x field pl\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws;\n        (mw_Mutate_Payload x field pl =\n         mw_Mutate r f opt_r' \\<longrightarrow>\n         (case opt_r' of None \\<Rightarrow> True\n          | Some r' \\<Rightarrow> marked r' s)) \\<and>\n        (mw_Mutate_Payload x field pl \\<in> set ws \\<longrightarrow>\n         marked_insertion (mw_Mutate_Payload x field pl) s);\n        (mw_Mutate_Payload x field pl =\n         mw_Mutate r f opt_r' \\<longrightarrow>\n         obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n        (mw_Mutate_Payload x field pl \\<in> set ws \\<longrightarrow>\n         marked_deletion (mw_Mutate_Payload x field pl) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (frule spec[where x=x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (subgoal_tac \"mut_m.reachable m x s\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n        mut_m.reachable m x s\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s \\<and>\n                         (black x s \\<or>\n                          (\\<exists>xa. (xa grey_protects_white x) s))\n 2. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s\n 3. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (force simp: fun_upd_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable m x s\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (rule reachableI(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>field pl.\n       \\<lbrakk>\\<forall>x.\n                   mut_m.reachable m x s \\<longrightarrow>\n                   black x s \\<or>\n                   (\\<exists>xa. (xa grey_protects_white x) s);\n        sys_mem_store_buffers (mutator m) s = mw_Mutate r f opt_r' # ws;\n        m' = m; mw_Mutate_Payload x field pl \\<in> set ws;\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mut_m.tso_store_refs m s\n 2. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (force simp: mut_m.tso_store_refs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     m' \\<noteq> m; x \\<in> mut_m.tso_store_refs m s\\<rbrakk>\n    \\<Longrightarrow> (mut_m.reachable m x s \\<or>\n                       mut_m.reachable m' x s) \\<and>\n                      (black x\n                        (s(sys := s sys\n                             \\<lparr>heap := (sys_heap s)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n        (sys_heap s r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s sys))\n                                  (mutator m' := ws)\\<rparr>)) \\<or>\n                       (\\<exists>xa. (xa grey_protects_white x) s))", "apply (auto simp: fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "case (reaches x y)"], ["proof (state)\nthis:\n  mut_m.reachable m x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "from reaches sb"], ["proof (chain)\npicking this:\n  mut_m.reachable m x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws", "have y: \"mut_m.reachable m y s \\<or> mut_m.reachable m' y s\""], ["proof (prove)\nusing this:\n  mut_m.reachable m x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. mut_m.reachable m y s \\<or> mut_m.reachable m' y s", "apply (clarsimp simp: points_to_Mutate mut_m.reachable_snapshot_inv_def in_snapshot_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     r \\<noteq> x \\<and> (x points_to y) s \\<or>\n     r = x \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (opt_r' = Some y \\<or>\n      (x points_to y) s \\<and>\n      obj_at\n       (\\<lambda>obj.\n           \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n       r s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>)) \\<or>\n     (\\<exists>xa.\n         (xa grey_protects_white x)\n          (s(sys := s sys\n               \\<lparr>heap := (sys_heap s)\n                         (r := map_option\n                                (\\<lambda>obj. obj\n                                    \\<lparr>obj_fields := (obj_fields obj)\n        (f := opt_r')\\<rparr>)\n                                (sys_heap s r)),\n                  mem_store_buffers := (mem_store_buffers (s sys))\n                    (mutator m' := ws)\\<rparr>)));\n     \\<not> mut_m.reachable m' y s\\<rbrakk>\n    \\<Longrightarrow> mut_m.reachable m y s", "apply (elim disjE, (force dest!: reachable_points_to mutator_reachable_tso)+)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "from y vri"], ["proof (chain)\npicking this:\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n  valid_refs_inv s", "have \"valid_ref y s\""], ["proof (prove)\nusing this:\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n  valid_refs_inv s\n\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>s. True) y s", "by auto"], ["proof (state)\nthis:\n  obj_at (\\<lambda>s. True) y s\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "with reaches mi md rsi sb sti y"], ["proof (chain)\npicking this:\n  mut_m.reachable m x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  strong_tricolour_inv s\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n  obj_at (\\<lambda>s. True) y s", "have \"(black y s \\<or> (\\<exists>x. (x grey_protects_white y) s))\""], ["proof (prove)\nusing this:\n  mut_m.reachable m x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (x points_to y)\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n  (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n  in_snapshot x\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n  strong_tricolour_inv s\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n  obj_at (\\<lambda>s. True) y s\n\ngoal (1 subgoal):\n 1. black y s \\<or> (\\<exists>x. (x grey_protects_white y) s)", "apply (clarsimp simp: mut_m.reachable_snapshot_inv_def in_snapshot_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     (x points_to y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>));\n     mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s;\n     mut_m.reachable m y s \\<or> mut_m.reachable m' y s;\n     obj_at (\\<lambda>s. True) y s;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>)) \\<or>\n     (\\<exists>xa. (xa grey_protects_white x) s);\n     \\<forall>x. \\<not> (x grey_protects_white y) s\\<rbrakk>\n    \\<Longrightarrow> black y s", "apply (clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     (x points_to y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>));\n     mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s;\n     mut_m.reachable m y s \\<or> mut_m.reachable m' y s;\n     obj_at (\\<lambda>s. True) y s;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     \\<forall>x. \\<not> (x grey_protects_white y) s\\<rbrakk>\n    \\<Longrightarrow> black y s", "apply (drule spec[where x=y])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     (x points_to y)\n      (s(sys := s sys\n           \\<lparr>heap := (sys_heap s)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_fields := (obj_fields obj)\n    (f := opt_r')\\<rparr>)\n                            (sys_heap s r)),\n              mem_store_buffers := (mem_store_buffers (s sys))\n                (mutator m' := ws)\\<rparr>));\n     mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s;\n     mut_m.reachable m y s \\<or> mut_m.reachable m' y s;\n     obj_at (\\<lambda>s. True) y s;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     mut_m.reachable m y s \\<longrightarrow>\n     black y s \\<or> (\\<exists>x. (x grey_protects_white y) s)\\<rbrakk>\n    \\<Longrightarrow> black y s", "apply (clarsimp simp: points_to_Mutate mut_m.marked_insertions_def mut_m.marked_deletions_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     r \\<noteq> x \\<and> (x points_to y) s \\<or>\n     r = x \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (opt_r' = Some y \\<or>\n      (x points_to y) s \\<and>\n      obj_at\n       (\\<lambda>obj.\n           \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n       r s);\n     \\<forall>x.\n        (x = mw_Mutate r f opt_r' \\<longrightarrow>\n         (case opt_r' of None \\<Rightarrow> True\n          | Some r' \\<Rightarrow> marked r' s)) \\<and>\n        (x \\<in> set ws \\<longrightarrow> marked_insertion x s);\n     \\<forall>x.\n        (x = mw_Mutate r f opt_r' \\<longrightarrow>\n         obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n        (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s\\<rbrakk>\n    \\<Longrightarrow> black y s", "(* FIXME lemmas *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     r \\<noteq> x \\<and> (x points_to y) s \\<or>\n     r = x \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (opt_r' = Some y \\<or>\n      (x points_to y) s \\<and>\n      obj_at\n       (\\<lambda>obj.\n           \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n       r s);\n     \\<forall>x.\n        (x = mw_Mutate r f opt_r' \\<longrightarrow>\n         (case opt_r' of None \\<Rightarrow> True\n          | Some r' \\<Rightarrow> marked r' s)) \\<and>\n        (x \\<in> set ws \\<longrightarrow> marked_insertion x s);\n     \\<forall>x.\n        (x = mw_Mutate r f opt_r' \\<longrightarrow>\n         obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n        (x \\<in> set ws \\<longrightarrow> marked_deletion x s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s\\<rbrakk>\n    \\<Longrightarrow> black y s", "apply (drule spec[where x=\"mw_Mutate r f opt_r'\"])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     r \\<noteq> x \\<and> (x points_to y) s \\<or>\n     r = x \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (opt_r' = Some y \\<or>\n      (x points_to y) s \\<and>\n      obj_at\n       (\\<lambda>obj.\n           \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n       r s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     (mw_Mutate r f opt_r' = mw_Mutate r f opt_r' \\<longrightarrow>\n      (case opt_r' of None \\<Rightarrow> True\n       | Some r' \\<Rightarrow> marked r' s)) \\<and>\n     (mw_Mutate r f opt_r' \\<in> set ws \\<longrightarrow>\n      marked_insertion (mw_Mutate r f opt_r') s);\n     (mw_Mutate r f opt_r' = mw_Mutate r f opt_r' \\<longrightarrow>\n      obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s) \\<and>\n     (mw_Mutate r f opt_r' \\<in> set ws \\<longrightarrow>\n      marked_deletion (mw_Mutate r f opt_r') s)\\<rbrakk>\n    \\<Longrightarrow> black y s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     r \\<noteq> x \\<and> (x points_to y) s \\<or>\n     r = x \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (opt_r' = Some y \\<or>\n      (x points_to y) s \\<and>\n      obj_at\n       (\\<lambda>obj.\n           \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n       r s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     mut_m.reachable m x s \\<or> mut_m.reachable m' x s;\n     black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s\\<rbrakk>\n    \\<Longrightarrow> black y s", "apply (elim disjE; clarsimp simp: reachable_points_to)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n     mut_m.reachable m' x s; black x s; r \\<noteq> x;\n     (x points_to y) s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r \\<noteq> x;\n        (x points_to y) s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 3. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m x s; black x s; r = x; obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 4. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 5. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 6. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "(* FIXME probably want points_to_Mutate as an elim rule to make this robust, reduce duplication *)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n     mut_m.reachable m' x s; black x s; r \\<noteq> x;\n     (x points_to y) s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r \\<noteq> x;\n        (x points_to y) s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 3. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m x s; black x s; r = x; obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 4. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 5. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 6. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (drule (3) strong_tricolour_invD)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (r := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s r)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n     mut_m.reachable m' x s; r \\<noteq> x; (x points_to y) s;\n     marked y s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r \\<noteq> x;\n        (x points_to y) s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 3. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m x s; black x s; r = x; obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 4. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 5. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 6. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (metis (no_types) grey_protects_whiteI marked_imp_black_or_grey(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r \\<noteq> x;\n        (x points_to y) s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 2. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m x s; black x s; r = x; obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 3. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 4. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 5. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (metis (no_types) grey_protects_whiteE(2) grey_protects_whiteI marked_imp_black_or_grey(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m x s; black x s; r = x; obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 3. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 4. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (elim disjE; clarsimp simp: reachable_points_to)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := obj_fields obj(f \\<mapsto> y)\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f (Some y) # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s; marked y s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m x s; black x s; r = x; obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 3. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 4. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (force simp: black_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s\n 2. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 3. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (elim disjE; clarsimp simp: reachable_points_to)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := obj_fields obj(f \\<mapsto> y)\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f (Some y) # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s; marked y s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s; opt_r' = Some y\\<rbrakk>\n       \\<Longrightarrow> black y s\n 2. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 3. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (force simp: black_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s;\n     opt_r' = Some y \\<or>\n     (x points_to y) s \\<and>\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (elim disjE; clarsimp simp: reachable_points_to)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := obj_fields obj(f \\<mapsto> y)\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f (Some y) # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s; mut_m.reachable m' y s; marked y s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s; opt_r' = Some y\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s; (x points_to y) s;\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 3. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (force simp: black_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; black x s; r = x;\n     obj_at (\\<lambda>s. True) x s; (x points_to y) s;\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (drule (3) strong_tricolour_invD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>mut_m.reachable m x\n              (s(sys := s sys\n                   \\<lparr>heap := (sys_heap s)\n                             (x := map_option\n                                    (\\<lambda>obj. obj\n  \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n                                    (sys_heap s x)),\n                      mem_store_buffers := (mem_store_buffers (s sys))\n                        (mutator m' := ws)\\<rparr>));\n     sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n     strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n     \\<forall>x. \\<not> (x grey_protects_white y) s;\n     \\<not> mut_m.reachable m y s;\n     case opt_r' of None \\<Rightarrow> True\n     | Some r' \\<Rightarrow> marked r' s;\n     obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n     mut_m.reachable m' x s; r = x; obj_at (\\<lambda>s. True) x s;\n     (x points_to y) s;\n     obj_at\n      (\\<lambda>obj.\n          \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n      x s;\n     marked y s\\<rbrakk>\n    \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (force simp: black_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s;\n        opt_r' = Some y \\<or>\n        (x points_to y) s \\<and>\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (elim disjE; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := obj_fields obj(f \\<mapsto> y)\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f (Some y) # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s; marked y s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s; opt_r' = Some y\\<rbrakk>\n       \\<Longrightarrow> black y s\n 2. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s; (x points_to y) s;\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (force simp: black_def fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (x := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s x)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        sys_mem_store_buffers (mutator m') s = mw_Mutate x f opt_r' # ws;\n        strong_tricolour_inv s; obj_at (\\<lambda>s. True) y s;\n        \\<forall>x. \\<not> (x grey_protects_white y) s;\n        \\<not> mut_m.reachable m y s; mut_m.reachable m' y s;\n        case opt_r' of None \\<Rightarrow> True\n        | Some r' \\<Rightarrow> marked r' s;\n        obj_at_field_on_heap (\\<lambda>r'. marked r' s) x f s;\n        mut_m.reachable m' x s; (xa grey_protects_white x) s; r = x;\n        obj_at (\\<lambda>s. True) x s; (x points_to y) s;\n        obj_at\n         (\\<lambda>obj.\n             \\<exists>f'. obj_fields obj f' = Some y \\<and> f \\<noteq> f')\n         x s\\<rbrakk>\n       \\<Longrightarrow> black y s", "apply (metis (no_types) grey_protects_whiteE(2) grey_protects_whiteI marked_imp_black_or_grey(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  black y s \\<or> (\\<exists>x. (x grey_protects_white y) s)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "moreover"], ["proof (state)\nthis:\n  black y s \\<or> (\\<exists>x. (x grey_protects_white y) s)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "note mi md rsi sb"], ["proof (state)\nthis:\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mut_m.reachable m x\n                 (s(sys := s sys\n                      \\<lparr>heap := (sys_heap s)\n                                (r := map_option\n (\\<lambda>obj. obj\n     \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n (sys_heap s r)),\n                         mem_store_buffers := (mem_store_buffers (s sys))\n                           (mutator m' := ws)\\<rparr>));\n        (x points_to y)\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers := (mem_store_buffers (s sys))\n                   (mutator m' := ws)\\<rparr>));\n        (mut_m.reachable m x s \\<or> mut_m.reachable m' x s) \\<and>\n        in_snapshot x\n         (s(sys := s sys\n              \\<lparr>heap := (sys_heap s)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := opt_r')\\<rparr>)\n                               (sys_heap s r)),\n                 mem_store_buffers :=\n                   (\\<lambda>a. sys_mem_store_buffers a s)\n                   (mutator m' := ws)\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> (mut_m.reachable m y s \\<or>\n                          mut_m.reachable m' y s) \\<and>\n                         in_snapshot y\n                          (s(sys := s sys\n                               \\<lparr>heap := (sys_heap s)\n   (r := map_option\n          (\\<lambda>obj. obj\n              \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n          (sys_heap s r)),\n                                  mem_store_buffers :=\n                                    (\\<lambda>a. sys_mem_store_buffers a s)\n                                    (mutator m' := ws)\\<rparr>))", "ultimately"], ["proof (chain)\npicking this:\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n  black y s \\<or> (\\<exists>x. (x grey_protects_white y) s)\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws", "show ?case"], ["proof (prove)\nusing this:\n  mut_m.reachable m y s \\<or> mut_m.reachable m' y s\n  black y s \\<or> (\\<exists>x. (x grey_protects_white y) s)\n  mut_m.marked_insertions m' s\n  mut_m.marked_deletions m' s\n  mut_m.reachable_snapshot_inv m s\n  sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws\n\ngoal (1 subgoal):\n 1. (mut_m.reachable m y s \\<or> mut_m.reachable m' y s) \\<and>\n    in_snapshot y\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n               (mutator m' := ws)\\<rparr>))", "apply (clarsimp simp: mut_m.reachable_snapshot_inv_def in_snapshot_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mut_m.reachable m y s \\<or> mut_m.reachable m' y s;\n     mut_m.marked_insertions m' s; mut_m.marked_deletions m' s;\n     \\<forall>x.\n        mut_m.reachable m x s \\<longrightarrow>\n        black x s \\<or> (\\<exists>xa. (xa grey_protects_white x) s);\n     sys_mem_store_buffers (mutator m') s = mw_Mutate r f opt_r' # ws;\n     \\<forall>x. \\<not> (x grey_protects_white y) s; black y s\\<rbrakk>\n    \\<Longrightarrow> black y\n                       (s(sys := s sys\n                            \\<lparr>heap := (sys_heap s)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>)\n       (sys_heap s r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m' := ws)\\<rparr>))", "apply (clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (mut_m.reachable m y s \\<or> mut_m.reachable m' y s) \\<and>\n  in_snapshot y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (\\<lambda>a. sys_mem_store_buffers a s)\n             (mutator m' := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mut_m.reachable m y s \\<or> mut_m.reachable m' y s) \\<and>\n  in_snapshot y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       mut_m.reachable m y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>)) \\<Longrightarrow>\n       in_snapshot y\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)\n                       (r := map_option\n                              (\\<lambda>obj. obj\n                                  \\<lparr>obj_fields := (obj_fields obj)\n      (f := opt_r')\\<rparr>)\n                              (sys_heap s r)),\n                mem_store_buffers := (mem_store_buffers (s sys))\n                  (mutator m' := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  (mut_m.reachable m y s \\<or> mut_m.reachable m' y s) \\<and>\n  in_snapshot y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))", "show \"in_snapshot y ?s'\""], ["proof (prove)\nusing this:\n  (mut_m.reachable m y s \\<or> mut_m.reachable m' y s) \\<and>\n  in_snapshot y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. in_snapshot y\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s sys))\n               (mutator m' := ws)\\<rparr>))", "by blast"], ["proof (state)\nthis:\n  in_snapshot y\n   (s(sys := s sys\n        \\<lparr>heap := (sys_heap s)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (f := opt_r')\\<rparr>)\n                         (sys_heap s r)),\n           mem_store_buffers := (mem_store_buffers (s sys))\n             (mutator m' := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mutator_phase_inv[intro]:\n  \"\\<lbrace> LSTP (fA_rel_inv \\<^bold>\\<and> fM_rel_inv \\<^bold>\\<and> handshake_phase_inv \\<^bold>\\<and> mutators_phase_inv \\<^bold>\\<and> strong_tricolour_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> tso_store_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     sys\n   \\<lbrace> LSTP (mut_m.mutator_phase_inv m) \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                fA_rel_inv s\\<down> \\<and>\n                fM_rel_inv s\\<down> \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                strong_tricolour_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv\n                 s\\<down>\\<rbrace> sys \\<lbrace>\\<lambda>s.\n             mut_m.mutator_phase_inv_aux m\n              (ghost_hs_phase (s\\<down> (mutator m))) s\\<down>\\<rbrace>", "proof(vcg_jackhammer (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.mutator_phase_inv_aux m\n                          (ghost_hs_phase (s\\<down> (mutator m)))\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "case (tso_dequeue_store_buffer s s' p w ws)"], ["proof (state)\nthis:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.mutator_phase_inv_aux m\n                          (ghost_hs_phase (s\\<down> (mutator m)))\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "proof(cases w)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x11 x12.\n       w = mw_Mark x11 x12 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x21 x22 x23.\n       w = mw_Mutate x21 x22 x23 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 5. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 6. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "case (mw_Mark ref field)"], ["proof (state)\nthis:\n  w = mw_Mark ref field\n\ngoal (6 subgoals):\n 1. \\<And>x11 x12.\n       w = mw_Mark x11 x12 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x21 x22 x23.\n       w = mw_Mutate x21 x22 x23 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 5. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 6. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mark ref field", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mark ref field\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "by (clarsimp simp: mutator_phase_inv_aux_case\n                           marked_deletions_dequeue_Mark marked_insertions_dequeue_Mark reachable_snapshot_inv_dequeue_Mark\n                    split: hs_phase.splits)"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       w = mw_Mutate x21 x22 x23 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 5. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       w = mw_Mutate x21 x22 x23 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 5. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "case (mw_Mutate ref field opt_r')"], ["proof (state)\nthis:\n  w = mw_Mutate ref field opt_r'\n\ngoal (5 subgoals):\n 1. \\<And>x21 x22 x23.\n       w = mw_Mutate x21 x22 x23 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 5. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "proof(cases \"ghost_hs_phase (s\\<down> (mutator m))\")"], ["proof (state)\ngoal (5 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleInit \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 4. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 5. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "case hp_IdleInit"], ["proof (state)\nthis:\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleInit\n\ngoal (5 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleInit \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 4. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 5. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "with \\<open>sys_mem_store_buffers p s\\<down> = w # ws\\<close> spec[OF \\<open>mutators_phase_inv s\\<down>\\<close>, where x=m] mw_Mutate"], ["proof (chain)\npicking this:\n  sys_mem_store_buffers p s\\<down> = w # ws\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleInit", "show ?thesis"], ["proof (prove)\nusing this:\n  sys_mem_store_buffers p s\\<down> = w # ws\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleInit\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (4 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 4. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 4. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "case hp_InitMark"], ["proof (state)\nthis:\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark\n\ngoal (4 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 4. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "with \\<open>sys_mem_store_buffers p s\\<down> = w # ws\\<close> spec[OF \\<open>mutators_phase_inv s\\<down>\\<close>, where x=m] mw_Mutate"], ["proof (chain)\npicking this:\n  sys_mem_store_buffers p s\\<down> = w # ws\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark", "show ?thesis"], ["proof (prove)\nusing this:\n  sys_mem_store_buffers p s\\<down> = w # ws\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_InitMark\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "by (simp add: marked_insertions_dequeue_Mutate)"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (3 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "case hp_Mark"], ["proof (state)\nthis:\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark\n\ngoal (3 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 3. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "with tso_dequeue_store_buffer mw_Mutate"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := do_store_action w (s\\<down> sys)\n        \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                  (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>; sys_mem_store_buffers p s\\<down> = w # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate ref field opt_r';\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark\\<rbrakk>\n    \\<Longrightarrow> mut_m.mutator_phase_inv_aux m\n                       (ghost_hs_phase (s\\<down> (mutator m)))\n                       (s\\<down>\n                        (sys := do_store_action w (s\\<down> sys)\n                           \\<lparr>mem_store_buffers :=\n                                     (mem_store_buffers (s\\<down> sys))\n                                     (p := ws)\\<rparr>))", "apply (clarsimp simp: mutator_phase_inv_aux_case p_not_sys split: hs_phase.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate ref field opt_r';\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n     at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (ref :=\n                     map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> ref)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate ref field opt_r' # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p = gc \\<or> (\\<exists>m. p = mutator m)\\<rbrakk>\n    \\<Longrightarrow> mut_m.marked_insertions m\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (ref :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n   (sys_heap s\\<down> ref)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>)) \\<and>\n                      mut_m.marked_deletions m\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (ref :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n   (sys_heap s\\<down> ref)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>))", "apply (erule disjE; clarsimp simp: marked_insertions_dequeue_Mutate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_deletions m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (rename_tac m')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m'\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_deletions m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))", "apply (frule mut_m.handshake_phase_invD[where m=m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n         sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n        \\<in> hp_step_rel \\<and>\n        (sys_hs_pending m s\\<down> \\<longrightarrow>\n         \\<not> sys_ghost_hs_in_sync m s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_deletions m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))", "apply (rule marked_deletions_dequeue_Mutate, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n         sys_ghost_hs_phase s\\<down>, hp_Mark)\n        \\<in> hp_step_rel \\<and>\n        (sys_hs_pending m s\\<down> \\<longrightarrow>\n         \\<not> sys_ghost_hs_in_sync m s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>", "apply (drule_tac m=m' in mut_m.handshake_phase_invD, clarsimp simp: hp_step_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        hp_Mark = sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Idle \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_InitMark \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleInit \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Mark \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_InitMark \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Mark \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m' s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>", "using hs_phase.distinct(11) hs_phase.distinct(15) hs_type.distinct(1)"], ["proof (prove)\nusing this:\n  hp_IdleInit \\<noteq> hp_Mark\n  hp_InitMark \\<noteq> hp_Mark\n  ht_NOOP \\<noteq> ht_GetRoots\n\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_Mark;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        hp_Mark = sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Idle \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_InitMark \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleInit \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Mark \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_InitMark \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Mark \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m' s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>", "apply presburger"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "case hp_IdleMarkSweep"], ["proof (state)\nthis:\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\n\ngoal (2 subgoals):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))\n 2. ghost_hs_phase (s\\<down> (mutator m)) =\n    hp_IdleMarkSweep \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "with tso_dequeue_store_buffer mw_Mutate"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mutate ref field opt_r'\n  ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := do_store_action w (s\\<down> sys)\n        \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                  (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>; sys_mem_store_buffers p s\\<down> = w # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate ref field opt_r';\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> mut_m.mutator_phase_inv_aux m\n                       (ghost_hs_phase (s\\<down> (mutator m)))\n                       (s\\<down>\n                        (sys := do_store_action w (s\\<down> sys)\n                           \\<lparr>mem_store_buffers :=\n                                     (mem_store_buffers (s\\<down> sys))\n                                     (p := ws)\\<rparr>))", "apply (clarsimp simp: mutator_phase_inv_aux_case p_not_sys\n                             split: hs_phase.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate ref field opt_r';\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n     at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (ref :=\n                     map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_fields := (obj_fields obj)\n                                    (field := opt_r')\\<rparr>)\n                      (sys_heap s\\<down> ref)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate ref field opt_r' # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p = gc \\<or> (\\<exists>m. p = mutator m)\\<rbrakk>\n    \\<Longrightarrow> mut_m.marked_insertions m\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (ref :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n   (sys_heap s\\<down> ref)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>)) \\<and>\n                      mut_m.marked_deletions m\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (ref :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n   (sys_heap s\\<down> ref)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>)) \\<and>\n                      mut_m.reachable_snapshot_inv m\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (ref :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n   (sys_heap s\\<down> ref)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>))", "apply (intro allI conjI impI; erule disjE; clarsimp simp: sys.marked_insertions_dequeue_Mutate)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_deletions m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (rename_tac m')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m'\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_deletions m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (rule marked_deletions_dequeue_Mutate, simp_all)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m'\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (drule_tac x=m' in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m'.\n       \\<lbrakk>strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        (ghost_hs_phase (s\\<down> (mutator m')) =\n         hp_IdleInit \\<longrightarrow>\n         no_black_refs s\\<down>) \\<and>\n        (ghost_hs_phase (s\\<down> (mutator m')) =\n         hp_InitMark \\<longrightarrow>\n         mut_m.marked_insertions m' s\\<down>) \\<and>\n        (ghost_hs_phase (s\\<down> (mutator m')) = hp_Mark \\<longrightarrow>\n         mut_m.marked_insertions m' s\\<down> \\<and>\n         mut_m.marked_deletions m' s\\<down>) \\<and>\n        (ghost_hs_phase (s\\<down> (mutator m')) =\n         hp_IdleMarkSweep \\<longrightarrow>\n         mut_m.marked_deletions m' s\\<down> \\<and>\n         mut_m.marked_insertions m' s\\<down> \\<and>\n         mut_m.reachable_snapshot_inv m' s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (frule mut_m.handshake_phase_invD[where m=m])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m'.\n       \\<lbrakk>strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        (ghost_hs_phase (s\\<down> (mutator m')) =\n         hp_IdleInit \\<longrightarrow>\n         no_black_refs s\\<down>) \\<and>\n        (ghost_hs_phase (s\\<down> (mutator m')) =\n         hp_InitMark \\<longrightarrow>\n         mut_m.marked_insertions m' s\\<down>) \\<and>\n        (ghost_hs_phase (s\\<down> (mutator m')) = hp_Mark \\<longrightarrow>\n         mut_m.marked_insertions m' s\\<down> \\<and>\n         mut_m.marked_deletions m' s\\<down>) \\<and>\n        (ghost_hs_phase (s\\<down> (mutator m')) =\n         hp_IdleMarkSweep \\<longrightarrow>\n         mut_m.marked_deletions m' s\\<down> \\<and>\n         mut_m.marked_insertions m' s\\<down> \\<and>\n         mut_m.reachable_snapshot_inv m' s\\<down>);\n        (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n         sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n        \\<in> hp_step_rel \\<and>\n        (sys_hs_pending m s\\<down> \\<longrightarrow>\n         \\<not> sys_ghost_hs_in_sync m s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (drule_tac m=m' in mut_m.handshake_phase_invD, clarsimp simp: hp_step_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m'.\n       \\<lbrakk>strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        hp_IdleInit \\<longrightarrow>\n        no_black_refs s\\<down>;\n        \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n        \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        hp_IdleMarkSweep = sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Idle \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_InitMark \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleInit \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Mark \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m' s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down>;\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Mark \\<longrightarrow>\n        mut_m.marked_insertions m' s\\<down> \\<and>\n        mut_m.marked_deletions m' s\\<down>;\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        hp_IdleMarkSweep \\<longrightarrow>\n        mut_m.marked_deletions m' s\\<down> \\<and>\n        mut_m.marked_insertions m' s\\<down> \\<and>\n        mut_m.reachable_snapshot_inv m' s\\<down>;\n        ghost_hs_phase (s\\<down> (mutator m')) \\<noteq> hp_InitMark\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (elim disjE; clarsimp split del: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m'.\n       \\<lbrakk>strong_tricolour_inv s\\<down>; tso_store_inv s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        \\<not> sys_hs_pending m' s\\<down>;\n        if sys_fA s\\<down> = sys_fM s\\<down> then black_heap s\\<down>\n        else white_heap s\\<down>;\n        no_grey_refs s\\<down>; \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Idle;\n        sys_ghost_hs_in_sync m' s\\<down>; sys_hs_type s\\<down> = ht_NOOP;\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (clarsimp simp: fA_rel_inv_def fM_rel_inv_def fA_rel_def fM_rel_def split del: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m'.\n       \\<lbrakk>strong_tricolour_inv s\\<down>; tso_store_inv s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        sys_fM s\\<down> = gc_fM s\\<down> \\<and>\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [] \\<and>\n        (\\<exists>x. \\<not> sys_ghost_hs_in_sync x s\\<down>) \\<or>\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [] \\<and>\n        All (ghost_hs_in_sync (s\\<down> sys)) \\<or>\n        gc_fM s\\<down> = (\\<not> sys_fM s\\<down>) \\<and>\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) =\n        [mw_fM (\\<not> sys_fM s\\<down>)] \\<and>\n        sys_mem_lock s\\<down> \\<noteq> Some gc \\<and>\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        \\<not> sys_hs_pending m' s\\<down>;\n        if sys_fA s\\<down> = sys_fM s\\<down> then black_heap s\\<down>\n        else white_heap s\\<down>;\n        no_grey_refs s\\<down>; \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Idle;\n        sys_ghost_hs_in_sync m' s\\<down>; sys_hs_type s\\<down> = ht_NOOP;\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle;\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        (\\<exists>x.\n            \\<not> sys_ghost_hs_in_sync x s\\<down>) \\<longrightarrow>\n        sys_fA s\\<down> = gc_fM s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.marked_insertions m' s\\<down>\n 2. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (meson black_heap_valid_ref_marked_insertions; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ma.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator ma := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator ma) s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator ma); p = mutator ma\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator ma := ws)\\<rparr>))", "apply (rename_tac m')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m'\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))", "apply (frule_tac m=m  in mut_m.handshake_phase_invD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        handshake_phase_inv s\\<down>;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        (sys_ghost_hs_in_sync m s\\<down>, sys_hs_type s\\<down>,\n         sys_ghost_hs_phase s\\<down>, ghost_hs_phase (s\\<down> (mutator m)))\n        \\<in> hp_step_rel \\<and>\n        (sys_hs_pending m s\\<down> \\<longrightarrow>\n         \\<not> sys_ghost_hs_in_sync m s\\<down>)\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))", "apply (drule_tac m=m' in mut_m.handshake_phase_invD, clarsimp simp: hp_step_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n        \\<not> sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        hp_IdleMarkSweep = sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Idle \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_InitMark \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleInit \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_Mark \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_InitMark \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Mark \\<or>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetRoots \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_GetWork \\<and>\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_IdleMarkSweep \\<or>\n        sys_ghost_hs_in_sync m' s\\<down> \\<and>\n        sys_hs_type s\\<down> = ht_NOOP \\<and>\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down> \\<and>\n        (sys_ghost_hs_phase s\\<down> = hp_Idle \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_IdleInit \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_InitMark \\<or>\n         sys_ghost_hs_phase s\\<down> = hp_Mark);\n        sys_hs_pending m' s\\<down> \\<longrightarrow>\n        \\<not> sys_ghost_hs_in_sync m' s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))", "apply (elim disjE; clarsimp simp: reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_Mutate reachable_snapshot_inv_dequeue_Mutate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        \\<not> sys_hs_pending m' s\\<down>;\n        \\<forall>x.\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_IdleInit \\<longrightarrow>\n            no_black_refs s\\<down>) \\<and>\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_InitMark \\<longrightarrow>\n            mut_m.marked_insertions x s\\<down>) \\<and>\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_Mark \\<longrightarrow>\n            mut_m.marked_insertions x s\\<down> \\<and>\n            mut_m.marked_deletions x s\\<down>) \\<and>\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_IdleMarkSweep \\<longrightarrow>\n            mut_m.marked_deletions x s\\<down> \\<and>\n            mut_m.marked_insertions x s\\<down> \\<and>\n            mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_fA s\\<down> = (\\<not> sys_fM s\\<down>);\n        \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Idle;\n        sys_ghost_hs_in_sync m' s\\<down>; sys_hs_type s\\<down> = ht_NOOP;\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle;\n        white_heap s\\<down>; no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))", "apply (clarsimp simp: fA_rel_inv_def fM_rel_inv_def fA_rel_def fM_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m'.\n       \\<lbrakk>tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate ref field opt_r';\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (ref :=\n                        map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_fields := (obj_fields obj)\n (field := opt_r')\\<rparr>)\n                         (sys_heap s\\<down> ref)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (mutator m' := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        sys_fM s\\<down> = gc_fM s\\<down> \\<and>\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [] \\<and>\n        (\\<exists>x. \\<not> sys_ghost_hs_in_sync x s\\<down>) \\<or>\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [] \\<and>\n        All (ghost_hs_in_sync (s\\<down> sys)) \\<or>\n        gc_fM s\\<down> = (\\<not> sys_fM s\\<down>) \\<and>\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) =\n        [mw_fM (\\<not> sys_fM s\\<down>)] \\<and>\n        sys_mem_lock s\\<down> \\<noteq> Some gc \\<and>\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_mem_store_buffers (mutator m') s\\<down> =\n        mw_Mutate ref field opt_r' # ws;\n        not_blocked (s\\<down> sys) (mutator m'); p = mutator m';\n        \\<not> sys_hs_pending m' s\\<down>;\n        \\<forall>x.\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_IdleInit \\<longrightarrow>\n            no_black_refs s\\<down>) \\<and>\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_InitMark \\<longrightarrow>\n            mut_m.marked_insertions x s\\<down>) \\<and>\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_Mark \\<longrightarrow>\n            mut_m.marked_insertions x s\\<down> \\<and>\n            mut_m.marked_deletions x s\\<down>) \\<and>\n           (ghost_hs_phase (s\\<down> (mutator x)) =\n            hp_IdleMarkSweep \\<longrightarrow>\n            mut_m.marked_deletions x s\\<down> \\<and>\n            mut_m.marked_insertions x s\\<down> \\<and>\n            mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_fA s\\<down> = (\\<not> sys_fM s\\<down>);\n        \\<not> sys_ghost_hs_in_sync m s\\<down>;\n        sys_ghost_hs_phase s\\<down> = hp_Idle;\n        sys_ghost_hs_in_sync m' s\\<down>; sys_hs_type s\\<down> = ht_NOOP;\n        ghost_hs_phase (s\\<down> (mutator m')) = hp_Idle;\n        white_heap s\\<down>; no_grey_refs s\\<down>;\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        (\\<exists>x.\n            \\<not> sys_ghost_hs_in_sync x s\\<down>) \\<longrightarrow>\n        (\\<not> sys_fM s\\<down>) = gc_fM s\\<down>\\<rbrakk>\n       \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (ref :=\n     map_option\n      (\\<lambda>obj. obj\n          \\<lparr>obj_fields := (obj_fields obj)(field := opt_r')\\<rparr>)\n      (sys_heap s\\<down> ref)),\n                                 mem_store_buffers :=\n                                   (mem_store_buffers (s\\<down> sys))\n                                   (mutator m' := ws)\\<rparr>))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. ghost_hs_phase (s\\<down> (mutator m)) = hp_Idle \\<Longrightarrow>\n    mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "qed simp"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "case (mw_Mutate_Payload r f pl)"], ["proof (state)\nthis:\n  w = mw_Mutate_Payload r f pl\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32 x33.\n       w = mw_Mutate_Payload x31 x32 x33 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 4. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mutate_Payload r f pl", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Mutate_Payload r f pl\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "apply (clarsimp simp: mutator_phase_inv_aux_case fun_upd_apply split: hs_phase.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate_Payload r f pl; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_payload := (obj_payload obj)\n (f := pl)\\<rparr>)\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> mut_m.reachable_snapshot_inv m\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (r :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n   (sys_heap s\\<down> r)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>))", "apply (subst reachable_snapshot_fun_upd)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate_Payload r f pl; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_payload := (obj_payload obj)\n (f := pl)\\<rparr>)\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> roots\n                       ((s\\<down>\n                         (sys := s\\<down> sys\n                            \\<lparr>heap := (sys_heap s\\<down>)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n       (sys_heap s\\<down> r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s\\<down> sys))\n                                 (p := ws)\\<rparr>))\n                         (mutator m)) =\n                      roots (s\\<down> (mutator m))\n 2. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate_Payload r f pl; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_payload := (obj_payload obj)\n (f := pl)\\<rparr>)\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> ghost_honorary_root\n                       ((s\\<down>\n                         (sys := s\\<down> sys\n                            \\<lparr>heap := (sys_heap s\\<down>)\n(r := map_option\n       (\\<lambda>obj. obj\n           \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n       (sys_heap s\\<down> r)),\n                               mem_store_buffers :=\n                                 (mem_store_buffers (s\\<down> sys))\n                                 (p := ws)\\<rparr>))\n                         (mutator m)) =\n                      ghost_honorary_root (s\\<down> (mutator m))\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate_Payload r f pl;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_payload := (obj_payload obj)\n    (f := pl)\\<rparr>)\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n        handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys;\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> (\\<Union>pa.\nWL pa\n (s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (r := map_option\n                      (\\<lambda>obj. obj\n                          \\<lparr>obj_payload := (obj_payload obj)\n                                    (f := pl)\\<rparr>)\n                      (sys_heap s\\<down> r)),\n        mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n          (p := ws)\\<rparr>)))) =\n                         (x \\<in> (\\<Union>p. WL p s\\<down>))\n 4. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate_Payload r f pl; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_payload := (obj_payload obj)\n (f := pl)\\<rparr>)\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> sys_fM\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (r :=\n  map_option\n   (\\<lambda>obj. obj\n       \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n   (sys_heap s\\<down> r)),\n                              mem_store_buffers :=\n                                (mem_store_buffers (s\\<down> sys))\n                                (p := ws)\\<rparr>)) =\n                      sys_fM s\\<down>\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate_Payload r f pl;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_payload := (obj_payload obj)\n    (f := pl)\\<rparr>)\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n        handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys;\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n       \\<Longrightarrow> \\<Union>\n                          (ran `\n                           obj_fields `\n                           set_option\n                            (sys_heap\n                              (s\\<down>\n                               (sys := s\\<down> sys\n                                  \\<lparr>heap := (sys_heap s\\<down>)\n      (r := map_option\n             (\\<lambda>obj. obj\n                 \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n             (sys_heap s\\<down> r)),\n                                     mem_store_buffers :=\n (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))\n                              x)) =\n                         \\<Union>\n                          (ran `\n                           obj_fields ` set_option (sys_heap s\\<down> x))\n 6. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleInit \\<longrightarrow>\n                    no_black_refs s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_InitMark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_Mark \\<longrightarrow>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.marked_deletions x s\\<down>) \\<and>\n                   (ghost_hs_phase (s\\<down> (mutator x)) =\n                    hp_IdleMarkSweep \\<longrightarrow>\n                    mut_m.marked_deletions x s\\<down> \\<and>\n                    mut_m.marked_insertions x s\\<down> \\<and>\n                    mut_m.reachable_snapshot_inv x s\\<down>);\n        strong_tricolour_inv s\\<down>;\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n        tso_store_inv s\\<down>; valid_refs_inv s\\<down>;\n        valid_W_inv s\\<down>; w = mw_Mutate_Payload r f pl;\n        at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (r := map_option\n                            (\\<lambda>obj. obj\n                                \\<lparr>obj_payload := (obj_payload obj)\n    (f := pl)\\<rparr>)\n                            (sys_heap s\\<down> r)),\n              mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        fA_rel_inv s\\<down>; fM_rel_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n        handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n        p \\<noteq> sys;\n        ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n       \\<Longrightarrow> map_option obj_mark\n                          (sys_heap\n                            (s\\<down>\n                             (sys := s\\<down> sys\n                                \\<lparr>heap := (sys_heap s\\<down>)\n    (r := map_option\n           (\\<lambda>obj. obj\n               \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n           (sys_heap s\\<down> r)),\n                                   mem_store_buffers :=\n                                     (mem_store_buffers (s\\<down> sys))\n                                     (p := ws)\\<rparr>))\n                            x) =\n                         map_option obj_mark (sys_heap s\\<down> x)\n 7. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate_Payload r f pl; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_payload := (obj_payload obj)\n (f := pl)\\<rparr>)\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> filter\n                       (\\<lambda>s.\n                           is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n                       (sys_mem_store_buffers (mutator m)\n                         (s\\<down>\n                          (sys := s\\<down> sys\n                             \\<lparr>heap := (sys_heap s\\<down>)\n (r := map_option\n        (\\<lambda>obj. obj\n            \\<lparr>obj_payload := (obj_payload obj)(f := pl)\\<rparr>)\n        (sys_heap s\\<down> r)),\n                                mem_store_buffers :=\n                                  (mem_store_buffers (s\\<down> sys))\n                                  (p := ws)\\<rparr>))) =\n                      filter\n                       (\\<lambda>s.\n                           is_mw_Mutate s \\<or> is_mw_Mutate_Payload s)\n                       (sys_mem_store_buffers (mutator m) s\\<down>)\n 8. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate_Payload r f pl; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_payload := (obj_payload obj)\n (f := pl)\\<rparr>)\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> mut_m.reachable_snapshot_inv m s\\<down>", "apply (simp_all add: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleInit \\<longrightarrow>\n                 no_black_refs s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_InitMark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_Mark \\<longrightarrow>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.marked_deletions x s\\<down>) \\<and>\n                (ghost_hs_phase (s\\<down> (mutator x)) =\n                 hp_IdleMarkSweep \\<longrightarrow>\n                 mut_m.marked_deletions x s\\<down> \\<and>\n                 mut_m.marked_insertions x s\\<down> \\<and>\n                 mut_m.reachable_snapshot_inv x s\\<down>);\n     strong_tricolour_inv s\\<down>;\n     sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>;\n     tso_store_inv s\\<down>; valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     w = mw_Mutate_Payload r f pl; at sys tso_dequeue_store_buffer s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option\n                         (\\<lambda>obj. obj\n                             \\<lparr>obj_payload := (obj_payload obj)\n (f := pl)\\<rparr>)\n                         (sys_heap s\\<down> r)),\n           mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n             (p := ws)\\<rparr>);\n     taken sys tso_dequeue_store_buffer s';\n     \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''; fA_rel_inv s\\<down>;\n     fM_rel_inv s\\<down>;\n     sys_mem_store_buffers p s\\<down> = mw_Mutate_Payload r f pl # ws;\n     handshake_phase_inv s\\<down>; not_blocked (s\\<down> sys) p;\n     p \\<noteq> sys;\n     ghost_hs_phase (s\\<down> (mutator m)) = hp_IdleMarkSweep\\<rbrakk>\n    \\<Longrightarrow> mutator m \\<noteq> p", "apply (metis (no_types, lifting) list.set_intros(1) mem_store_action.simps(39) tso_store_inv_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (3 subgoals):\n 1. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "case (mw_fA mark)"], ["proof (state)\nthis:\n  w = mw_fA mark\n\ngoal (3 subgoals):\n 1. \\<And>x4.\n       w = mw_fA x4 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 3. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_fA mark", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_fA mark\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "by (clarsimp simp: mutator_phase_inv_aux_case fun_upd_apply split: hs_phase.splits)"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "case (mw_fM mark)"], ["proof (state)\nthis:\n  w = mw_fM mark\n\ngoal (2 subgoals):\n 1. \\<And>x5.\n       w = mw_fM x5 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))\n 2. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_fM mark", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_fM mark\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "using mut_m_not_idle_no_fM_writeD"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_fM mark\n  \\<lbrakk>sys_mem_store_buffers ?p ?s = mw_fM ?fl # ?ws;\n   ghost_hs_phase (?s (mutator ?m)) \\<noteq> hp_Idle; fM_rel_inv ?s;\n   handshake_phase_inv ?s; tso_store_inv ?s; ?p \\<noteq> sys\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "by fastforce"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "case (mw_Phase phase)"], ["proof (state)\nthis:\n  w = mw_Phase phase\n\ngoal (1 subgoal):\n 1. \\<And>x6.\n       w = mw_Phase x6 \\<Longrightarrow>\n       mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n        (s\\<down>\n         (sys := do_store_action w (s\\<down> sys)\n            \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                      (p := ws)\\<rparr>))", "with tso_dequeue_store_buffer"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Phase phase", "show ?thesis"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  fA_rel_inv s\\<down>\n  fM_rel_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  handshake_phase_inv s\\<down>\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  strong_tricolour_inv s\\<down>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down>\n  tso_store_inv s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  w = mw_Phase phase\n\ngoal (1 subgoal):\n 1. mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "by (clarsimp simp: mutator_phase_inv_aux_case fun_upd_apply split: hs_phase.splits)"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mut_m.mutator_phase_inv_aux m (ghost_hs_phase (s\\<down> (mutator m)))\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}