{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Proofs_Basis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma Set_bind_insert[simp]:\n  \"Set.bind (insert a A) B = B a \\<union> (Set.bind A B)\"", "lemma option_bind_invE[elim]:\n  \"\\<lbrakk> Option.bind f g = None; \\<And>a. \\<lbrakk> f = Some a; g a = None \\<rbrakk> \\<Longrightarrow> Q; f = None \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk> Option.bind f g = Some x; \\<And>a. \\<lbrakk> f = Some a; g a = Some x \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"", "lemmas conj_explode = conj_imp_eq_imp_imp", "lemmas all_com_defs =\n  (* gc.com_def *) handshake_done_def handshake_init_def handshake_noop_def handshake_get_roots_def handshake_get_work_def\n  mark_object_fn_def", "lemmas com_def2 = com_def[simplified all_com_defs append.simps if_True if_False]", "lemmas all_com_defs =\n  (* mut.com_def *) mut_m.handshake_def mut_m.store_def\n  mark_object_fn_def", "lemmas com_def2 = mut_m.com_def[simplified all_com_defs append.simps if_True if_False]", "lemmas all_com_defs =\n  (* sys.com_def *) sys.alloc_def sys.free_def sys.mem_TSO_def sys.handshake_def", "lemmas com_def2 = com_def[simplified all_com_defs append.simps if_True if_False]", "lemmas all_com_interned_defs = gc.com_interned mut_m.com_interned sys.com_interned", "lemma colours_distinct[dest]:\n  \"black r s \\<Longrightarrow> \\<not>grey r s\"\n  \"black r s \\<Longrightarrow> \\<not>white r s\"\n  \"grey r s  \\<Longrightarrow> \\<not>black r s\"\n  \"white r s \\<Longrightarrow> \\<not>black r s\"", "lemma marked_imp_black_or_grey:\n  \"marked r s \\<Longrightarrow> black r s \\<or> grey r s\"\n  \"\\<not> white r s \\<Longrightarrow> \\<not> valid_ref r s \\<or> black r s \\<or> grey r s\"", "lemmas eq_imp_simps = \\<comment>\\<open>equations for deriving useful things from @{const \\<open>eq_imp\\<close>} facts\\<close>\n  eq_imp_def\n  all_conj_distrib\n  split_paired_All split_def fst_conv snd_conv prod_eq_iff\n  conj_explode\n  simp_thms", "lemma p_not_sys:\n  \"p \\<noteq> sys \\<longleftrightarrow> p = gc \\<or> (\\<exists>m. p = mutator m)\"", "lemma (in mut_m') m'm[iff]: \"m' \\<noteq> m\"", "lemma obj_at_cong[cong]:\n  \"\\<lbrakk>\\<And>obj. sys_heap s r = Some obj \\<Longrightarrow> P obj = P' obj; r = r'; s = s'\\<rbrakk>\n   \\<Longrightarrow> obj_at P r s \\<longleftrightarrow> obj_at P' r' s'\"", "lemma obj_at_split:\n  \"Q (obj_at P r s) = ((sys_heap s r = None \\<longrightarrow> Q False) \\<and> (\\<forall>obj. sys_heap s r = Some obj \\<longrightarrow> Q (P obj)))\"", "lemma obj_at_split_asm:\n  \"Q (obj_at P r s) = (\\<not> ((sys_heap s r = None \\<and> \\<not>Q False) \\<or> (\\<exists>obj. sys_heap s r = Some obj \\<and> \\<not> Q (P obj))))\"", "lemmas obj_at_splits = obj_at_split obj_at_split_asm", "lemma obj_at_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. map_option P (sys_heap s r))\n          (obj_at P r)\"", "lemmas obj_at_fun_upd[simp] = eq_imp_fun_upd[OF obj_at_eq_imp, simplified eq_imp_simps]", "lemma obj_at_simps:\n  \"obj_at (\\<lambda>obj. P obj \\<and> Q obj) r s \\<longleftrightarrow> obj_at P r s \\<and> obj_at Q r s\"", "lemma obj_at_field_on_heap_cong[cong]:\n  \"\\<lbrakk>\\<And>r' obj. \\<lbrakk>sys_heap s r = Some obj; obj_fields obj f = Some r'\\<rbrakk>\\<Longrightarrow> P r' = P' r'; r = r'; f = f'; s = s'\\<rbrakk>\n   \\<Longrightarrow> obj_at_field_on_heap P r f s \\<longleftrightarrow> obj_at_field_on_heap P' r' f' s'\"", "lemma obj_at_field_on_heap_split:\n  \"Q (obj_at_field_on_heap P r f s) \\<longleftrightarrow> ((sys_heap s r = None \\<longrightarrow> Q False)\n                                 \\<and> (\\<forall>obj. sys_heap s r = Some obj \\<and> obj_fields obj f = None \\<longrightarrow> Q True)\n                                 \\<and> (\\<forall>r' obj. sys_heap s r = Some obj \\<and> obj_fields obj f = Some r' \\<longrightarrow> Q (P r')))\"", "lemma obj_at_field_on_heap_split_asm:\n  \"Q (obj_at_field_on_heap P r f s) \\<longleftrightarrow> (\\<not> ((sys_heap s r = None \\<and> \\<not>Q False)\n                                    \\<or> (\\<exists>obj. sys_heap s r = Some obj \\<and> obj_fields obj f = None \\<and> \\<not> Q True)\n                                    \\<or> (\\<exists>r' obj. sys_heap s r = Some obj \\<and> obj_fields obj f = Some r' \\<and> \\<not> Q (P r'))))\"", "lemmas obj_at_field_on_heap_splits = obj_at_field_on_heap_split obj_at_field_on_heap_split_asm", "lemma obj_at_field_on_heap_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. sys_heap s r)\n          (obj_at_field_on_heap P r f)\"", "lemmas obj_at_field_on_heap_fun_upd[simp] = eq_imp_fun_upd[OF obj_at_field_on_heap_eq_imp, simplified eq_imp_simps]", "lemma obj_at_field_on_heap_imp_valid_ref[elim]:\n  \"obj_at_field_on_heap P r f s \\<Longrightarrow> valid_ref r s\"\n  \"obj_at_field_on_heap P r f s \\<Longrightarrow> valid_null_ref (Some r) s\"", "lemma obj_at_field_on_heapE[elim]:\n  \"\\<lbrakk> obj_at_field_on_heap P r f s; sys_heap s' r = sys_heap s r; \\<And>r'. P r' \\<Longrightarrow> P' r' \\<rbrakk>\n       \\<Longrightarrow> obj_at_field_on_heap P' r f s'\"", "lemma valid_null_ref_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. Option.bind r (map_option \\<langle>True\\<rangle> \\<circ> sys_heap s))\n          (valid_null_ref r)\"", "lemmas valid_null_ref_fun_upd[simp] = eq_imp_fun_upd[OF valid_null_ref_eq_imp, simplified]", "lemma valid_null_ref_simps[simp]:\n  \"valid_null_ref None s\"\n  \"valid_null_ref (Some r) s \\<longleftrightarrow> valid_ref r s\"", "lemma do_store_action_prj_simps[simp]:\n  \"fM (do_store_action w s) = fl \\<longleftrightarrow> (fM s = fl \\<and> w \\<noteq> mw_fM (\\<not>fM s)) \\<or> w = mw_fM fl\"\n  \"fl = fM (do_store_action w s) \\<longleftrightarrow> (fl = fM s \\<and> w \\<noteq> mw_fM (\\<not>fM s)) \\<or> w = mw_fM fl\"\n  \"fA (do_store_action w s) = fl \\<longleftrightarrow> (fA s = fl \\<and> w \\<noteq> mw_fA (\\<not>fA s)) \\<or> w = mw_fA fl\"\n  \"fl = fA (do_store_action w s) \\<longleftrightarrow> (fl = fA s \\<and> w \\<noteq> mw_fA (\\<not>fA s)) \\<or> w = mw_fA fl\"\n  \"ghost_hs_in_sync (do_store_action w s) = ghost_hs_in_sync s\"\n  \"ghost_hs_phase (do_store_action w s) = ghost_hs_phase s\"\n  \"ghost_honorary_grey (do_store_action w s) = ghost_honorary_grey s\"\n  \"hs_pending (do_store_action w s) = hs_pending s\"\n  \"hs_type (do_store_action w s) = hs_type s\"\n  \"heap (do_store_action w s) r = None \\<longleftrightarrow> heap s r = None\"\n  \"mem_lock (do_store_action w s) = mem_lock s\"\n  \"phase (do_store_action w s) = ph \\<longleftrightarrow> (phase s = ph \\<and> (\\<forall>ph'. w \\<noteq> mw_Phase ph') \\<or> w = mw_Phase ph)\"\n  \"ph = phase (do_store_action w s) \\<longleftrightarrow> (ph = phase s \\<and> (\\<forall>ph'. w \\<noteq> mw_Phase ph') \\<or> w = mw_Phase ph)\"\n  \"W (do_store_action w s) = W s\"", "lemma reaches_refl[iff]:\n  \"(r reaches r) s\"", "lemma reaches_step[intro]:\n  \"\\<lbrakk>(x reaches y) s; (y points_to z) s\\<rbrakk> \\<Longrightarrow> (x reaches z) s\"\n  \"\\<lbrakk>(y reaches z) s; (x points_to y) s\\<rbrakk> \\<Longrightarrow> (x reaches z) s\"", "lemma reaches_induct[consumes 1, case_names refl step, induct set: reaches]:\n  assumes \"(x reaches y) s\"\n  assumes \"\\<And>x. P x x\"\n  assumes \"\\<And>x y z. \\<lbrakk>(x reaches y) s; P x y; (y points_to z) s\\<rbrakk> \\<Longrightarrow> P x z\"\n  shows \"P x y\"", "lemma converse_reachesE[consumes 1, case_names base step]:\n  assumes \"(x reaches z) s\"\n  assumes \"x = z \\<Longrightarrow> P\"\n  assumes \"\\<And>y. \\<lbrakk>(x points_to y) s; (y reaches z) s\\<rbrakk> \\<Longrightarrow> P\"\n  shows P", "lemma reaches_fields: \\<comment> \\<open>Complicated condition takes care of \\<open>alloc\\<close>: collapses no object and object with no fields\\<close>\n  assumes \"(x reaches y) s'\"\n  assumes \"\\<forall>r'. \\<Union>(ran ` obj_fields ` set_option (sys_heap s' r')) = \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))\"\n  shows \"(x reaches y) s\"", "lemma reaches_eq_imp:\n  \"eq_imp (\\<lambda>r' s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r')))\n          (x reaches y)\"", "lemmas reaches_fun_upd[simp] = eq_imp_fun_upd[OF reaches_eq_imp, simplified eq_imp_simps, rule_format]", "lemma obj_at_mark_dequeue[simp]:\n  \"obj_at P r (s(sys := s sys\\<lparr> heap := (sys_heap s)(r' := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r')), mem_store_buffers := wb' \\<rparr>))\n\\<longleftrightarrow> obj_at (\\<lambda>obj. (P (if r = r' then obj\\<lparr> obj_mark := fl \\<rparr> else obj))) r s\"", "lemma obj_at_field_on_heap_mw_simps[simp]:\n  \"obj_at_field_on_heap P r0 f0\n         (s(sys := (s sys)\\<lparr> heap := (sys_heap s)(r := map_option (\\<lambda>obj :: ('field, 'payload, 'ref) object. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                            mem_store_buffers := (mem_store_buffers (s Sys))(p := ws) \\<rparr>))\n\\<longleftrightarrow> ( (r \\<noteq> r0 \\<or> f \\<noteq> f0) \\<and> obj_at_field_on_heap P r0 f0 s )\n   \\<or> (r = r0 \\<and> f = f0 \\<and> valid_ref r s \\<and> (case opt_r' of Some r'' \\<Rightarrow> P r'' | _ \\<Rightarrow> True))\"\n  \"obj_at_field_on_heap P r f (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r')), mem_store_buffers := sb'\\<rparr>))\n\\<longleftrightarrow> obj_at_field_on_heap P r f s\"", "lemma obj_at_field_on_heap_no_pending_stores:\n  \"\\<lbrakk> sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; \\<forall>opt_r'. mw_Mutate r f opt_r' \\<notin> set (sys_mem_store_buffers (mutator m) s); valid_ref r s \\<rbrakk>\n     \\<Longrightarrow> obj_at_field_on_heap (\\<lambda>r. opt_r' = Some r) r f s\""], "translations": [["", "lemma Set_bind_insert[simp]:\n  \"Set.bind (insert a A) B = B a \\<union> (Set.bind A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.bind (insert a A) B = B a \\<union> Set.bind A B", "by (auto simp: Set.bind_def)"], ["", "lemma option_bind_invE[elim]:\n  \"\\<lbrakk> Option.bind f g = None; \\<And>a. \\<lbrakk> f = Some a; g a = None \\<rbrakk> \\<Longrightarrow> Q; f = None \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\"\n  \"\\<lbrakk> Option.bind f g = Some x; \\<And>a. \\<lbrakk> f = Some a; g a = Some x \\<rbrakk> \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Option.bind f g = None;\n      \\<And>a. \\<lbrakk>f = Some a; g a = None\\<rbrakk> \\<Longrightarrow> Q;\n      f = None \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q) &&&\n    (\\<lbrakk>Option.bind f g = Some x;\n      \\<And>a.\n         \\<lbrakk>f = Some a; g a = Some x\\<rbrakk>\n         \\<Longrightarrow> Q\\<rbrakk>\n     \\<Longrightarrow> Q)", "by (case_tac [!] f) simp_all"], ["", "lemmas conj_explode = conj_imp_eq_imp_imp"], ["", "text\\<open>\n\nTweak the default simpset:\n\\<^item> \"not in dom\" as a premise negates the goal\n\\<^item> we always want to execute suffix\n\\<^item> we try to make simplification rules about @{const \\<open>fun_upd\\<close>} more stable\n\n\\<close>"], ["", "declare dom_def[simp]"], ["", "declare suffix_to_prefix[simp]"], ["", "declare map_option.compositionality[simp]"], ["", "declare o_def[simp]"], ["", "declare Option.Option.option.set_map[simp]"], ["", "declare bind_image[simp]"], ["", "declare fun_upd_apply[simp del]"], ["", "declare fun_upd_same[simp]"], ["", "declare fun_upd_other[simp]"], ["", "declare gc_phase.case_cong[cong]"], ["", "declare mem_store_action.case_cong[cong]"], ["", "declare process_name.case_cong[cong]"], ["", "declare hs_phase.case_cong[cong]"], ["", "declare hs_type.case_cong[cong]"], ["", "declare if_split_asm[split]"], ["", "text\\<open>\n\nCollect the component definitions. Inline everything. This is what the proofs work on.\nObserve we lean heavily on locales.\n\n\\<close>"], ["", "context gc\nbegin"], ["", "lemmas all_com_defs =\n  (* gc.com_def *) handshake_done_def handshake_init_def handshake_noop_def handshake_get_roots_def handshake_get_work_def\n  mark_object_fn_def"], ["", "lemmas com_def2 = com_def[simplified all_com_defs append.simps if_True if_False]"], ["", "intern_com com_def2"], ["", "end"], ["", "context mut_m\nbegin"], ["", "lemmas all_com_defs =\n  (* mut.com_def *) mut_m.handshake_def mut_m.store_def\n  mark_object_fn_def"], ["", "lemmas com_def2 = mut_m.com_def[simplified all_com_defs append.simps if_True if_False]"], ["", "intern_com com_def2"], ["", "end"], ["", "context sys\nbegin"], ["", "lemmas all_com_defs =\n  (* sys.com_def *) sys.alloc_def sys.free_def sys.mem_TSO_def sys.handshake_def"], ["", "lemmas com_def2 = com_def[simplified all_com_defs append.simps if_True if_False]"], ["", "intern_com com_def2"], ["", "end"], ["", "lemmas all_com_interned_defs = gc.com_interned mut_m.com_interned sys.com_interned"], ["", "named_theorems inv \"Location-sensitive invariant definitions\""], ["", "named_theorems nie \"Non-interference elimination rules\""], ["", "subsection\\<open> Model-specific functions and predicates \\<close>"], ["", "text\\<open>\n\nWe define a pile of predicates and accessor functions for the\nprocess's local states. One might hope that a more sophisticated\napproach would automate all of this (cf @{cite [cite_macro=citet]\n\"DBLP:journals/entcs/SchirmerW09\"}).\n\n\\<close>"], ["", "abbreviation prefixed :: \"location \\<Rightarrow> location set\" where\n  \"prefixed p \\<equiv> { l . prefix p l }\""], ["", "abbreviation suffixed :: \"location \\<Rightarrow> location set\" where\n  \"suffixed p \\<equiv> { l . suffix p l }\""], ["", "abbreviation \"is_mw_Mark w \\<equiv> \\<exists>r fl. w = mw_Mark r fl\""], ["", "abbreviation \"is_mw_Mutate w \\<equiv> \\<exists>r f r'. w = mw_Mutate r f r'\""], ["", "abbreviation \"is_mw_Mutate_Payload w \\<equiv> \\<exists>r f pl. w = mw_Mutate_Payload r f pl\""], ["", "abbreviation \"is_mw_fA w \\<equiv> \\<exists>fl. w = mw_fA fl\""], ["", "abbreviation \"is_mw_fM w \\<equiv> \\<exists>fl. w = mw_fM fl\""], ["", "abbreviation \"is_mw_Phase w \\<equiv> \\<exists>ph. w = mw_Phase ph\""], ["", "abbreviation (input) pred_in_W :: \"'ref \\<Rightarrow> 'mut process_name \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" (infix \"in'_W\" 50) where\n  \"r in_W p \\<equiv> \\<lambda>s. r \\<in> W (s p)\""], ["", "abbreviation (input) pred_in_ghost_honorary_grey :: \"'ref \\<Rightarrow> 'mut process_name \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" (infix \"in'_ghost'_honorary'_grey\" 50) where\n  \"r in_ghost_honorary_grey p \\<equiv> \\<lambda>s. r \\<in> ghost_honorary_grey (s p)\""], ["", "abbreviation \"gc_cas_mark s \\<equiv> cas_mark (s gc)\""], ["", "abbreviation \"gc_fM s \\<equiv> fM (s gc)\""], ["", "abbreviation \"gc_field s \\<equiv> field (s gc)\""], ["", "abbreviation \"gc_field_set s \\<equiv> field_set (s gc)\""], ["", "abbreviation \"gc_mark s \\<equiv> mark (s gc)\""], ["", "abbreviation \"gc_mut s \\<equiv> mut (s gc)\""], ["", "abbreviation \"gc_muts s \\<equiv> muts (s gc)\""], ["", "abbreviation \"gc_phase s \\<equiv> phase (s gc)\""], ["", "abbreviation \"gc_tmp_ref s \\<equiv> tmp_ref (s gc)\""], ["", "abbreviation \"gc_ghost_honorary_grey s \\<equiv> ghost_honorary_grey (s gc)\""], ["", "abbreviation \"gc_ref s \\<equiv> ref (s gc)\""], ["", "abbreviation \"gc_refs s \\<equiv> refs (s gc)\""], ["", "abbreviation \"gc_the_ref \\<equiv> the \\<circ> gc_ref\""], ["", "abbreviation \"gc_W s \\<equiv> W (s gc)\""], ["", "abbreviation at_gc :: \"location \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred \\<Rightarrow> ('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"at_gc l P \\<equiv> at gc l \\<^bold>\\<longrightarrow> LSTP P\""], ["", "abbreviation atS_gc :: \"location set \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred \\<Rightarrow> ('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"atS_gc ls P \\<equiv> atS gc ls \\<^bold>\\<longrightarrow> LSTP P\""], ["", "context mut_m\nbegin"], ["", "abbreviation at_mut :: \"location \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred \\<Rightarrow> ('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"at_mut l P \\<equiv> at (mutator m) l \\<^bold>\\<longrightarrow> LSTP P\""], ["", "abbreviation atS_mut :: \"location set \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred \\<Rightarrow> ('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"atS_mut ls P \\<equiv> atS (mutator m) ls \\<^bold>\\<longrightarrow> LSTP P\""], ["", "abbreviation \"mut_cas_mark s \\<equiv> cas_mark (s (mutator m))\""], ["", "abbreviation \"mut_field s \\<equiv> field (s (mutator m))\""], ["", "abbreviation \"mut_fM s \\<equiv> fM (s (mutator m))\""], ["", "abbreviation \"mut_ghost_honorary_grey s \\<equiv> ghost_honorary_grey (s (mutator m))\""], ["", "abbreviation \"mut_ghost_hs_phase s \\<equiv> ghost_hs_phase (s (mutator m))\""], ["", "abbreviation \"mut_ghost_honorary_root s \\<equiv> ghost_honorary_root (s (mutator m))\""], ["", "abbreviation \"mut_hs_pending s \\<equiv> mutator_hs_pending (s (mutator m))\""], ["", "abbreviation \"mut_hs_type s \\<equiv> hs_type (s (mutator m))\""], ["", "abbreviation \"mut_mark s \\<equiv> mark (s (mutator m))\""], ["", "abbreviation \"mut_new_ref s \\<equiv> new_ref (s (mutator m))\""], ["", "abbreviation \"mut_phase s \\<equiv> phase (s (mutator m))\""], ["", "abbreviation \"mut_ref s \\<equiv> ref (s (mutator m))\""], ["", "abbreviation \"mut_tmp_ref s \\<equiv> tmp_ref (s (mutator m))\""], ["", "abbreviation \"mut_the_new_ref \\<equiv> the \\<circ> mut_new_ref\""], ["", "abbreviation \"mut_the_ref \\<equiv> the \\<circ> mut_ref\""], ["", "abbreviation \"mut_refs s \\<equiv> refs (s (mutator m))\""], ["", "abbreviation \"mut_roots s \\<equiv> roots (s (mutator m))\""], ["", "abbreviation \"mut_W s \\<equiv> W (s (mutator m))\""], ["", "end"], ["", "abbreviation sys_heap :: \"('field, 'mut, 'payload, 'ref) lsts \\<Rightarrow> 'ref \\<Rightarrow> ('field, 'payload, 'ref) object option\" where \"sys_heap s \\<equiv> heap (s sys)\""], ["", "abbreviation \"sys_fA s \\<equiv> fA (s sys)\""], ["", "abbreviation \"sys_fM s \\<equiv> fM (s sys)\""], ["", "abbreviation \"sys_ghost_honorary_grey s \\<equiv> ghost_honorary_grey (s sys)\""], ["", "abbreviation \"sys_ghost_hs_in_sync m s \\<equiv> ghost_hs_in_sync (s sys) m\""], ["", "abbreviation \"sys_ghost_hs_phase s \\<equiv> ghost_hs_phase (s sys)\""], ["", "abbreviation \"sys_hs_pending m s \\<equiv> hs_pending (s sys) m\""], ["", "abbreviation \"sys_hs_type s \\<equiv> hs_type (s sys)\""], ["", "abbreviation \"sys_mem_store_buffers p s \\<equiv> mem_store_buffers (s sys) p\""], ["", "abbreviation \"sys_mem_lock s \\<equiv> mem_lock (s sys)\""], ["", "abbreviation \"sys_phase s \\<equiv> phase (s sys)\""], ["", "abbreviation \"sys_W s \\<equiv> W (s sys)\""], ["", "abbreviation atS_sys :: \"location set \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred \\<Rightarrow> ('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"atS_sys ls P \\<equiv> atS sys ls \\<^bold>\\<longrightarrow> LSTP P\""], ["", "text\\<open>Projections on TSO buffers.\\<close>"], ["", "abbreviation (input) \"tso_unlocked s \\<equiv> mem_lock (s sys) = None\""], ["", "abbreviation (input) \"tso_locked_by p s \\<equiv> mem_lock (s sys) = Some p\""], ["", "abbreviation (input) \"tso_pending p P s \\<equiv> filter P (mem_store_buffers (s sys) p)\""], ["", "abbreviation (input) \"tso_pending_store p w s \\<equiv> w \\<in> set (mem_store_buffers (s sys) p)\""], ["", "abbreviation (input) \"tso_pending_fA p \\<equiv> tso_pending p is_mw_fA\""], ["", "abbreviation (input) \"tso_pending_fM p \\<equiv> tso_pending p is_mw_fM\""], ["", "abbreviation (input) \"tso_pending_mark p \\<equiv> tso_pending p is_mw_Mark\""], ["", "abbreviation (input) \"tso_pending_mw_mutate p \\<equiv> tso_pending p is_mw_Mutate\""], ["", "abbreviation (input) \"tso_pending_mutate p \\<equiv> tso_pending p (is_mw_Mutate \\<^bold>\\<or> is_mw_Mutate_Payload)\" \\<comment>\\<open> TSO makes it (mostly) not worth distinguishing these. \\<close>"], ["", "abbreviation (input) \"tso_pending_phase p \\<equiv> tso_pending p is_mw_Phase\""], ["", "abbreviation (input) \"tso_no_pending_marks \\<equiv> \\<^bold>\\<forall>p. LIST_NULL (tso_pending_mark p)\""], ["", "text\\<open>\n\nA somewhat-useful abstraction of the heap, following l4.verified,\nwhich asserts that there is an object at the given reference with the\ngiven property. In some sense this encodes a three-valued logic.\n\n\\<close>"], ["", "definition obj_at :: \"(('field, 'payload, 'ref) object \\<Rightarrow> bool) \\<Rightarrow> 'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"obj_at P r \\<equiv> \\<lambda>s. case sys_heap s r of None \\<Rightarrow> False | Some obj \\<Rightarrow> P obj\""], ["", "abbreviation (input) valid_ref :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"valid_ref r \\<equiv> obj_at \\<langle>True\\<rangle> r\""], ["", "definition valid_null_ref :: \"'ref option \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"valid_null_ref r \\<equiv> case r of None \\<Rightarrow> \\<langle>True\\<rangle> | Some r' \\<Rightarrow> valid_ref r'\""], ["", "abbreviation pred_points_to :: \"'ref \\<Rightarrow> 'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" (infix \"points'_to\" 51) where\n  \"x points_to y \\<equiv> \\<lambda>s. obj_at (\\<lambda>obj. y \\<in> ran (obj_fields obj)) x s\""], ["", "text\\<open>\n\nWe use Isabelle's standard transitive-reflexive closure to define\nreachability through the heap.\n\n\\<close>"], ["", "definition reaches :: \"'ref \\<Rightarrow> 'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" (infix \"reaches\" 51) where\n  \"x reaches y = (\\<lambda>s. (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y)\""], ["", "text\\<open>\n\nThe predicate \\<open>obj_at_field_on_heap\\<close> asserts that @{term \\<open>valid_ref r\\<close>}\nand if \\<open>f\\<close> is a field of the object referred to by \\<open>r\\<close> then it it satisfies \\<open>P\\<close>.\n\n\\<close>"], ["", "definition obj_at_field_on_heap :: \"('ref \\<Rightarrow> bool) \\<Rightarrow> 'ref \\<Rightarrow> 'field \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"obj_at_field_on_heap P r f \\<equiv> \\<lambda>s.\n     case map_option obj_fields (sys_heap s r) of\n         None \\<Rightarrow> False\n       | Some fs \\<Rightarrow> (case fs f of None \\<Rightarrow> True\n                               | Some r' \\<Rightarrow> P r')\""], ["", "subsection\\<open>Object colours\\<close>"], ["", "text\\<open>\n\nWe adopt the classical tricolour scheme for object colours due to\n@{cite [cite_macro=citet] \"DBLP:journals/cacm/DijkstraLMSS78\"}, but\ntweak it somewhat in the presence of worklists and TSO. Intuitively:\n\\begin{description}\n\\item[White] potential garbage, not yet reached\n\\item[Grey] reached, presumed live, a source of possible new references (work)\n\\item[Black] reached, presumed live, not a source of new references\n\\end{description}\n\nIn this particular setting we use the following interpretation:\n\\begin{description}\n\\item[White:] not marked\n\\item[Grey:] on a worklist or @{const \\<open>ghost_honorary_grey\\<close>}\n\\item[Black:] marked and not on a worklist\n\\end{description}\n\nNote that this allows the colours to overlap: an object being marked\nmay be white (on the heap) and in @{const \"ghost_honorary_grey\"} for\nsome process, i.e. grey.\n\n\\<close>"], ["", "abbreviation marked :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"marked r s \\<equiv> obj_at (\\<lambda>obj. obj_mark obj = sys_fM s) r s\""], ["", "definition white :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"white r s \\<equiv> obj_at (\\<lambda>obj. obj_mark obj \\<noteq> sys_fM s) r s\""], ["", "definition WL :: \"'mut process_name \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts \\<Rightarrow> 'ref set\" where\n  \"WL p = (\\<lambda>s. W (s p) \\<union> ghost_honorary_grey (s p))\""], ["", "definition grey :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"grey r = (\\<^bold>\\<exists>p. \\<langle>r\\<rangle> \\<^bold>\\<in> WL p)\""], ["", "definition black :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"black r \\<equiv> marked r \\<^bold>\\<and> \\<^bold>\\<not>grey r\""], ["", "text\\<open> These demonstrate the overlap in colours. \\<close>"], ["", "lemma colours_distinct[dest]:\n  \"black r s \\<Longrightarrow> \\<not>grey r s\"\n  \"black r s \\<Longrightarrow> \\<not>white r s\"\n  \"grey r s  \\<Longrightarrow> \\<not>black r s\"\n  \"white r s \\<Longrightarrow> \\<not>black r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((black r s \\<Longrightarrow> \\<not> grey r s) &&&\n     (black r s \\<Longrightarrow> \\<not> white r s)) &&&\n    (grey r s \\<Longrightarrow> \\<not> black r s) &&&\n    (white r s \\<Longrightarrow> \\<not> black r s)", "by (auto simp: black_def white_def obj_at_def split: option.splits)"], ["", "(* FIXME invisible *)"], ["", "lemma marked_imp_black_or_grey:\n  \"marked r s \\<Longrightarrow> black r s \\<or> grey r s\"\n  \"\\<not> white r s \\<Longrightarrow> \\<not> valid_ref r s \\<or> black r s \\<or> grey r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (marked r s \\<Longrightarrow> black r s \\<or> grey r s) &&&\n    (\\<not> white r s \\<Longrightarrow>\n     \\<not> obj_at (\\<lambda>s. True) r s \\<or> black r s \\<or> grey r s)", "by (auto simp: black_def grey_def white_def obj_at_def split: option.splits)"], ["", "(* FIXME invisible *)"], ["", "text\\<open>\n\nIn some phases the heap is monochrome.\n\n\\<close>"], ["", "definition black_heap :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"black_heap = (\\<^bold>\\<forall>r. valid_ref r \\<^bold>\\<longrightarrow> black r)\""], ["", "definition white_heap :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"white_heap = (\\<^bold>\\<forall>r. valid_ref r \\<^bold>\\<longrightarrow> white r)\""], ["", "definition no_black_refs :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"no_black_refs = (\\<^bold>\\<forall>r. \\<^bold>\\<not>black r)\""], ["", "definition no_grey_refs :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"no_grey_refs = (\\<^bold>\\<forall>r. \\<^bold>\\<not>grey r)\""], ["", "subsection\\<open>Reachability\\<close>"], ["", "text\\<open>\n\nWe treat pending TSO heap mutations as extra mutator roots.\n\n\\<close>"], ["", "abbreviation store_refs :: \"('field, 'payload, 'ref) mem_store_action \\<Rightarrow> 'ref set\" where\n  \"store_refs w \\<equiv> case w of mw_Mutate r f r' \\<Rightarrow> {r} \\<union> Option.set_option r' | mw_Mutate_Payload r f pl \\<Rightarrow> {r} | _ \\<Rightarrow> {}\""], ["", "definition (in mut_m) tso_store_refs :: \"('field, 'mut, 'payload, 'ref) lsts \\<Rightarrow> 'ref set\" where\n  \"tso_store_refs = (\\<lambda>s. \\<Union>w \\<in> set (sys_mem_store_buffers (mutator m) s). store_refs w)\""], ["", "abbreviation (in mut_m) root :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"root x \\<equiv> \\<langle>x\\<rangle> \\<^bold>\\<in> mut_roots \\<^bold>\\<union> mut_ghost_honorary_root \\<^bold>\\<union> tso_store_refs\""], ["", "definition (in mut_m) reachable :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"reachable y = (\\<^bold>\\<exists>x. root x \\<^bold>\\<and> x reaches y)\""], ["", "definition grey_reachable :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"grey_reachable y = (\\<^bold>\\<exists>g. grey g \\<^bold>\\<and> g reaches y)\""], ["", "subsection\\<open> Sundry detritus \\<close>"], ["", "lemmas eq_imp_simps = \\<comment>\\<open>equations for deriving useful things from @{const \\<open>eq_imp\\<close>} facts\\<close>\n  eq_imp_def\n  all_conj_distrib\n  split_paired_All split_def fst_conv snd_conv prod_eq_iff\n  conj_explode\n  simp_thms"], ["", "lemma p_not_sys:\n  \"p \\<noteq> sys \\<longleftrightarrow> p = gc \\<or> (\\<exists>m. p = mutator m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> sys) = (p = gc \\<or> (\\<exists>m. p = mutator m))", "by (cases p) simp_all"], ["", "lemma (in mut_m') m'm[iff]: \"m' \\<noteq> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<noteq> m", "using mm'"], ["proof (prove)\nusing this:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. m' \\<noteq> m", "by blast"], ["", "text\\<open> obj at \\<close>"], ["", "lemma obj_at_cong[cong]:\n  \"\\<lbrakk>\\<And>obj. sys_heap s r = Some obj \\<Longrightarrow> P obj = P' obj; r = r'; s = s'\\<rbrakk>\n   \\<Longrightarrow> obj_at P r s \\<longleftrightarrow> obj_at P' r' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>obj.\n                sys_heap s r = Some obj \\<Longrightarrow> P obj = P' obj;\n     r = r'; s = s'\\<rbrakk>\n    \\<Longrightarrow> obj_at P r s = obj_at P' r' s'", "unfolding obj_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>obj.\n                sys_heap s r = Some obj \\<Longrightarrow> P obj = P' obj;\n     r = r'; s = s'\\<rbrakk>\n    \\<Longrightarrow> (case sys_heap s r of None \\<Rightarrow> False\n                       | Some x \\<Rightarrow> P x) =\n                      (case sys_heap s' r' of None \\<Rightarrow> False\n                       | Some x \\<Rightarrow> P' x)", "by (simp cong: option.case_cong)"], ["", "lemma obj_at_split:\n  \"Q (obj_at P r s) = ((sys_heap s r = None \\<longrightarrow> Q False) \\<and> (\\<forall>obj. sys_heap s r = Some obj \\<longrightarrow> Q (P obj)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (obj_at P r s) =\n    ((sys_heap s r = None \\<longrightarrow> Q False) \\<and>\n     (\\<forall>obj. sys_heap s r = Some obj \\<longrightarrow> Q (P obj)))", "by (simp add: obj_at_def split: option.splits)"], ["", "lemma obj_at_split_asm:\n  \"Q (obj_at P r s) = (\\<not> ((sys_heap s r = None \\<and> \\<not>Q False) \\<or> (\\<exists>obj. sys_heap s r = Some obj \\<and> \\<not> Q (P obj))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (obj_at P r s) =\n    (\\<not> (sys_heap s r = None \\<and> \\<not> Q False \\<or>\n             (\\<exists>obj.\n                 sys_heap s r = Some obj \\<and> \\<not> Q (P obj))))", "by (simp add: obj_at_def split: option.splits)"], ["", "lemmas obj_at_splits = obj_at_split obj_at_split_asm"], ["", "lemma obj_at_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. map_option P (sys_heap s r))\n          (obj_at P r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp (\\<lambda>_ s. map_option P (sys_heap s r)) (obj_at P r)", "by (simp add: eq_imp_def obj_at_def split: option.splits)"], ["", "lemmas obj_at_fun_upd[simp] = eq_imp_fun_upd[OF obj_at_eq_imp, simplified eq_imp_simps]"], ["", "lemma obj_at_simps:\n  \"obj_at (\\<lambda>obj. P obj \\<and> Q obj) r s \\<longleftrightarrow> obj_at P r s \\<and> obj_at Q r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>obj. P obj \\<and> Q obj) r s =\n    (obj_at P r s \\<and> obj_at Q r s)", "(*  \"obj_at (\\<lambda>obj. R) r s \\<longleftrightarrow> valid_ref r s \\<and> R\" looks good but applies to valid_ref *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at (\\<lambda>obj. P obj \\<and> Q obj) r s =\n    (obj_at P r s \\<and> obj_at Q r s)", "by (simp_all split: obj_at_splits)"], ["", "text\\<open> obj at field on heap \\<close>"], ["", "lemma obj_at_field_on_heap_cong[cong]:\n  \"\\<lbrakk>\\<And>r' obj. \\<lbrakk>sys_heap s r = Some obj; obj_fields obj f = Some r'\\<rbrakk>\\<Longrightarrow> P r' = P' r'; r = r'; f = f'; s = s'\\<rbrakk>\n   \\<Longrightarrow> obj_at_field_on_heap P r f s \\<longleftrightarrow> obj_at_field_on_heap P' r' f' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r' obj.\n                \\<lbrakk>sys_heap s r = Some obj;\n                 obj_fields obj f = Some r'\\<rbrakk>\n                \\<Longrightarrow> P r' = P' r';\n     r = r'; f = f'; s = s'\\<rbrakk>\n    \\<Longrightarrow> obj_at_field_on_heap P r f s =\n                      obj_at_field_on_heap P' r' f' s'", "unfolding obj_at_field_on_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r' obj.\n                \\<lbrakk>sys_heap s r = Some obj;\n                 obj_fields obj f = Some r'\\<rbrakk>\n                \\<Longrightarrow> P r' = P' r';\n     r = r'; f = f'; s = s'\\<rbrakk>\n    \\<Longrightarrow> (case map_option obj_fields (sys_heap s r) of\n                       None \\<Rightarrow> False\n                       | Some fs \\<Rightarrow>\n                           case fs f of None \\<Rightarrow> True\n                           | Some x \\<Rightarrow> P x) =\n                      (case map_option obj_fields (sys_heap s' r') of\n                       None \\<Rightarrow> False\n                       | Some fs \\<Rightarrow>\n                           case fs f' of None \\<Rightarrow> True\n                           | Some x \\<Rightarrow> P' x)", "by (simp cong: option.case_cong)"], ["", "lemma obj_at_field_on_heap_split:\n  \"Q (obj_at_field_on_heap P r f s) \\<longleftrightarrow> ((sys_heap s r = None \\<longrightarrow> Q False)\n                                 \\<and> (\\<forall>obj. sys_heap s r = Some obj \\<and> obj_fields obj f = None \\<longrightarrow> Q True)\n                                 \\<and> (\\<forall>r' obj. sys_heap s r = Some obj \\<and> obj_fields obj f = Some r' \\<longrightarrow> Q (P r')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (obj_at_field_on_heap P r f s) =\n    ((sys_heap s r = None \\<longrightarrow> Q False) \\<and>\n     (\\<forall>obj.\n         sys_heap s r = Some obj \\<and>\n         obj_fields obj f = None \\<longrightarrow>\n         Q True) \\<and>\n     (\\<forall>r' obj.\n         sys_heap s r = Some obj \\<and>\n         obj_fields obj f = Some r' \\<longrightarrow>\n         Q (P r')))", "by (simp add: obj_at_field_on_heap_def split: option.splits)"], ["", "lemma obj_at_field_on_heap_split_asm:\n  \"Q (obj_at_field_on_heap P r f s) \\<longleftrightarrow> (\\<not> ((sys_heap s r = None \\<and> \\<not>Q False)\n                                    \\<or> (\\<exists>obj. sys_heap s r = Some obj \\<and> obj_fields obj f = None \\<and> \\<not> Q True)\n                                    \\<or> (\\<exists>r' obj. sys_heap s r = Some obj \\<and> obj_fields obj f = Some r' \\<and> \\<not> Q (P r'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (obj_at_field_on_heap P r f s) =\n    (\\<not> (sys_heap s r = None \\<and> \\<not> Q False \\<or>\n             (\\<exists>obj.\n                 sys_heap s r = Some obj \\<and>\n                 obj_fields obj f = None \\<and> \\<not> Q True) \\<or>\n             (\\<exists>r' obj.\n                 sys_heap s r = Some obj \\<and>\n                 obj_fields obj f = Some r' \\<and> \\<not> Q (P r'))))", "by (simp add: obj_at_field_on_heap_def split: option.splits)"], ["", "lemmas obj_at_field_on_heap_splits = obj_at_field_on_heap_split obj_at_field_on_heap_split_asm"], ["", "lemma obj_at_field_on_heap_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. sys_heap s r)\n          (obj_at_field_on_heap P r f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp (\\<lambda>_ s. sys_heap s r) (obj_at_field_on_heap P r f)", "by (simp add: eq_imp_def obj_at_field_on_heap_def)"], ["", "lemmas obj_at_field_on_heap_fun_upd[simp] = eq_imp_fun_upd[OF obj_at_field_on_heap_eq_imp, simplified eq_imp_simps]"], ["", "lemma obj_at_field_on_heap_imp_valid_ref[elim]:\n  \"obj_at_field_on_heap P r f s \\<Longrightarrow> valid_ref r s\"\n  \"obj_at_field_on_heap P r f s \\<Longrightarrow> valid_null_ref (Some r) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (obj_at_field_on_heap P r f s \\<Longrightarrow>\n     obj_at (\\<lambda>s. True) r s) &&&\n    (obj_at_field_on_heap P r f s \\<Longrightarrow>\n     valid_null_ref (Some r) s)", "by (auto simp: obj_at_field_on_heap_def valid_null_ref_def split: obj_at_splits option.splits)"], ["", "lemma obj_at_field_on_heapE[elim]:\n  \"\\<lbrakk> obj_at_field_on_heap P r f s; sys_heap s' r = sys_heap s r; \\<And>r'. P r' \\<Longrightarrow> P' r' \\<rbrakk>\n       \\<Longrightarrow> obj_at_field_on_heap P' r f s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obj_at_field_on_heap P r f s; sys_heap s' r = sys_heap s r;\n     \\<And>r'. P r' \\<Longrightarrow> P' r'\\<rbrakk>\n    \\<Longrightarrow> obj_at_field_on_heap P' r f s'", "by (simp add: obj_at_field_on_heap_def split: option.splits)"], ["", "lemma valid_null_ref_eq_imp:\n  \"eq_imp (\\<lambda>(_::unit) s. Option.bind r (map_option \\<langle>True\\<rangle> \\<circ> sys_heap s))\n          (valid_null_ref r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>_ s.\n         Option.bind r (map_option (\\<lambda>s. True) \\<circ> sys_heap s))\n     (valid_null_ref r)", "by (simp add: eq_imp_def obj_at_def valid_null_ref_def split: option.splits)"], ["", "lemmas valid_null_ref_fun_upd[simp] = eq_imp_fun_upd[OF valid_null_ref_eq_imp, simplified]"], ["", "lemma valid_null_ref_simps[simp]:\n  \"valid_null_ref None s\"\n  \"valid_null_ref (Some r) s \\<longleftrightarrow> valid_ref r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_null_ref None s &&&\n    valid_null_ref (Some r) s = obj_at (\\<lambda>s. True) r s", "unfolding valid_null_ref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case None of None \\<Rightarrow> \\<lambda>s. True\n     | Some r' \\<Rightarrow> obj_at (\\<lambda>s. True) r')\n     s &&&\n    (case Some r of None \\<Rightarrow> \\<lambda>s. True\n     | Some r' \\<Rightarrow> obj_at (\\<lambda>s. True) r')\n     s =\n    obj_at (\\<lambda>s. True) r s", "by simp_all"], ["", "text\\<open>Derive simplification rules from \\<open>case\\<close> expressions\\<close>"], ["", "simps_of_case hs_step_simps[simp]: hs_step_def (splits: hs_phase.split)"], ["", "simps_of_case do_load_action_simps[simp]: fun_cong[OF do_load_action_def[simplified atomize_eq]] (splits: mem_load_action.split)"], ["", "simps_of_case do_store_action_simps[simp]: fun_cong[OF do_store_action_def[simplified atomize_eq]] (splits: mem_store_action.split)"], ["", "(* This gives some indication of how much we're cheating on the TSO front. *)"], ["", "lemma do_store_action_prj_simps[simp]:\n  \"fM (do_store_action w s) = fl \\<longleftrightarrow> (fM s = fl \\<and> w \\<noteq> mw_fM (\\<not>fM s)) \\<or> w = mw_fM fl\"\n  \"fl = fM (do_store_action w s) \\<longleftrightarrow> (fl = fM s \\<and> w \\<noteq> mw_fM (\\<not>fM s)) \\<or> w = mw_fM fl\"\n  \"fA (do_store_action w s) = fl \\<longleftrightarrow> (fA s = fl \\<and> w \\<noteq> mw_fA (\\<not>fA s)) \\<or> w = mw_fA fl\"\n  \"fl = fA (do_store_action w s) \\<longleftrightarrow> (fl = fA s \\<and> w \\<noteq> mw_fA (\\<not>fA s)) \\<or> w = mw_fA fl\"\n  \"ghost_hs_in_sync (do_store_action w s) = ghost_hs_in_sync s\"\n  \"ghost_hs_phase (do_store_action w s) = ghost_hs_phase s\"\n  \"ghost_honorary_grey (do_store_action w s) = ghost_honorary_grey s\"\n  \"hs_pending (do_store_action w s) = hs_pending s\"\n  \"hs_type (do_store_action w s) = hs_type s\"\n  \"heap (do_store_action w s) r = None \\<longleftrightarrow> heap s r = None\"\n  \"mem_lock (do_store_action w s) = mem_lock s\"\n  \"phase (do_store_action w s) = ph \\<longleftrightarrow> (phase s = ph \\<and> (\\<forall>ph'. w \\<noteq> mw_Phase ph') \\<or> w = mw_Phase ph)\"\n  \"ph = phase (do_store_action w s) \\<longleftrightarrow> (ph = phase s \\<and> (\\<forall>ph'. w \\<noteq> mw_Phase ph') \\<or> w = mw_Phase ph)\"\n  \"W (do_store_action w s) = W s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((fM (do_store_action w s) = fl) =\n      (fM s = fl \\<and> w \\<noteq> mw_fM (\\<not> fM s) \\<or>\n       w = mw_fM fl) &&&\n      (fl = fM (do_store_action w s)) =\n      (fl = fM s \\<and> w \\<noteq> mw_fM (\\<not> fM s) \\<or>\n       w = mw_fM fl) &&&\n      (fA (do_store_action w s) = fl) =\n      (fA s = fl \\<and> w \\<noteq> mw_fA (\\<not> fA s) \\<or>\n       w = mw_fA fl)) &&&\n     ((fl = fA (do_store_action w s)) =\n      (fl = fA s \\<and> w \\<noteq> mw_fA (\\<not> fA s) \\<or>\n       w = mw_fA fl) &&&\n      ghost_hs_in_sync (do_store_action w s) = ghost_hs_in_sync s) &&&\n     ghost_hs_phase (do_store_action w s) = ghost_hs_phase s &&&\n     ghost_honorary_grey (do_store_action w s) = ghost_honorary_grey s) &&&\n    (hs_pending (do_store_action w s) = hs_pending s &&&\n     hs_type (do_store_action w s) = hs_type s &&&\n     (heap (do_store_action w s) r = None) = (heap s r = None)) &&&\n    (mem_lock (do_store_action w s) = mem_lock s &&&\n     (phase (do_store_action w s) = ph) =\n     (phase s = ph \\<and> (\\<forall>ph'. w \\<noteq> mw_Phase ph') \\<or>\n      w = mw_Phase ph)) &&&\n    (ph = phase (do_store_action w s)) =\n    (ph = phase s \\<and> (\\<forall>ph'. w \\<noteq> mw_Phase ph') \\<or>\n     w = mw_Phase ph) &&&\n    W (do_store_action w s) = W s", "by (auto simp: do_store_action_def fun_upd_apply split: mem_store_action.splits obj_at_splits)"], ["", "text\\<open> reaches \\<close>"], ["", "lemma reaches_refl[iff]:\n  \"(r reaches r) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r reaches r) s", "unfolding reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* r r", "by blast"], ["", "lemma reaches_step[intro]:\n  \"\\<lbrakk>(x reaches y) s; (y points_to z) s\\<rbrakk> \\<Longrightarrow> (x reaches z) s\"\n  \"\\<lbrakk>(y reaches z) s; (x points_to y) s\\<rbrakk> \\<Longrightarrow> (x reaches z) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(x reaches y) s; (y points_to z) s\\<rbrakk>\n     \\<Longrightarrow> (x reaches z) s) &&&\n    (\\<lbrakk>(y reaches z) s; (x points_to y) s\\<rbrakk>\n     \\<Longrightarrow> (x reaches z) s)", "unfolding reaches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y;\n      (y points_to z) s\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                        z) &&&\n    (\\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* y z;\n      (x points_to y) s\\<rbrakk>\n     \\<Longrightarrow> (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x\n                        z)", "apply (simp add: rtranclp.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* y z;\n     (x points_to y) s\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x z", "apply (simp add: converse_rtranclp_into_rtranclp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reaches_induct[consumes 1, case_names refl step, induct set: reaches]:\n  assumes \"(x reaches y) s\"\n  assumes \"\\<And>x. P x x\"\n  assumes \"\\<And>x y z. \\<lbrakk>(x reaches y) s; P x y; (y points_to z) s\\<rbrakk> \\<Longrightarrow> P x z\"\n  shows \"P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y", "using assms"], ["proof (prove)\nusing this:\n  (x reaches y) s\n  P ?x ?x\n  \\<lbrakk>(?x reaches ?y) s; P ?x ?y; (?y points_to ?z) s\\<rbrakk>\n  \\<Longrightarrow> P ?x ?z\n\ngoal (1 subgoal):\n 1. P x y", "unfolding reaches_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x y\n  P ?x ?x\n  \\<lbrakk>(\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* ?x ?y; P ?x ?y;\n   (?y points_to ?z) s\\<rbrakk>\n  \\<Longrightarrow> P ?x ?z\n\ngoal (1 subgoal):\n 1. P x y", "by (rule rtranclp.induct)"], ["", "lemma converse_reachesE[consumes 1, case_names base step]:\n  assumes \"(x reaches z) s\"\n  assumes \"x = z \\<Longrightarrow> P\"\n  assumes \"\\<And>y. \\<lbrakk>(x points_to y) s; (y reaches z) s\\<rbrakk> \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  (x reaches z) s\n  x = z \\<Longrightarrow> P\n  \\<lbrakk>(x points_to ?y) s; (?y reaches z) s\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "unfolding reaches_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* x z\n  x = z \\<Longrightarrow> P\n  \\<lbrakk>(x points_to ?y) s;\n   (\\<lambda>x y. (x points_to y) s)\\<^sup>*\\<^sup>* ?y z\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (blast elim: converse_rtranclpE)"], ["", "lemma reaches_fields: \\<comment> \\<open>Complicated condition takes care of \\<open>alloc\\<close>: collapses no object and object with no fields\\<close>\n  assumes \"(x reaches y) s'\"\n  assumes \"\\<forall>r'. \\<Union>(ran ` obj_fields ` set_option (sys_heap s' r')) = \\<Union>(ran ` obj_fields ` set_option (sys_heap s r'))\"\n  shows \"(x reaches y) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x reaches y) s", "using assms"], ["proof (prove)\nusing this:\n  (x reaches y) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n\ngoal (1 subgoal):\n 1. (x reaches y) s", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>r'.\n          \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n          \\<Union>\n           (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n       (x reaches x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x reaches y) s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union>\n            (ran `\n             obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n        (x reaches y) s;\n        (y points_to z) s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\\<rbrakk>\n       \\<Longrightarrow> (x reaches z) s", "case (step x y z)"], ["proof (state)\nthis:\n  (x reaches y) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union>\n      (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n  (x reaches y) s\n  (y points_to z) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>r'.\n          \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n          \\<Union>\n           (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n       (x reaches x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x reaches y) s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union>\n            (ran `\n             obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n        (x reaches y) s;\n        (y points_to z) s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\\<rbrakk>\n       \\<Longrightarrow> (x reaches z) s", "then"], ["proof (chain)\npicking this:\n  (x reaches y) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union>\n      (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n  (x reaches y) s\n  (y points_to z) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))", "have \"(y points_to z) s\""], ["proof (prove)\nusing this:\n  (x reaches y) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union>\n      (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n  (x reaches y) s\n  (y points_to z) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n\ngoal (1 subgoal):\n 1. (y points_to z) s", "by (cases \"sys_heap s y\")\n       (auto 10 10 simp: ran_def obj_at_def split: option.splits dest!: spec[where x=y])"], ["proof (state)\nthis:\n  (y points_to z) s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>r'.\n          \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n          \\<Union>\n           (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n       (x reaches x) s\n 2. \\<And>x y z.\n       \\<lbrakk>(x reaches y) s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union>\n            (ran `\n             obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n        (x reaches y) s;\n        (y points_to z) s';\n        \\<forall>r'.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\\<rbrakk>\n       \\<Longrightarrow> (x reaches z) s", "with step"], ["proof (chain)\npicking this:\n  (x reaches y) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union>\n      (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n  (x reaches y) s\n  (y points_to z) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  (y points_to z) s", "show ?case"], ["proof (prove)\nusing this:\n  (x reaches y) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union>\n      (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n  (x reaches y) s\n  (y points_to z) s'\n  \\<forall>r'.\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n     \\<Union> (ran ` obj_fields ` set_option (sys_heap s r'))\n  (y points_to z) s\n\ngoal (1 subgoal):\n 1. (x reaches z) s", "by blast"], ["proof (state)\nthis:\n  (x reaches z) s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>r'.\n          \\<Union> (ran ` obj_fields ` set_option (sys_heap s' r')) =\n          \\<Union>\n           (ran ` obj_fields ` set_option (sys_heap s r')) \\<Longrightarrow>\n       (x reaches x) s", "qed simp"], ["", "lemma reaches_eq_imp:\n  \"eq_imp (\\<lambda>r' s. \\<Union>(ran ` obj_fields ` set_option (sys_heap s r')))\n          (x reaches y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_imp\n     (\\<lambda>r' s.\n         \\<Union> (ran ` obj_fields ` set_option (sys_heap s r')))\n     (x reaches y)", "unfolding eq_imp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (\\<forall>x.\n           \\<Union> (ran ` obj_fields ` set_option (sys_heap s x)) =\n           \\<Union>\n            (ran `\n             obj_fields ` set_option (sys_heap s' x))) \\<longrightarrow>\n       (x reaches y) s = (x reaches y) s'", "by (metis reaches_fields)"], ["", "lemmas reaches_fun_upd[simp] = eq_imp_fun_upd[OF reaches_eq_imp, simplified eq_imp_simps, rule_format]"], ["", "text\\<open>\n\nLocation-specific facts.\n\n\\<close>"], ["", "lemma obj_at_mark_dequeue[simp]:\n  \"obj_at P r (s(sys := s sys\\<lparr> heap := (sys_heap s)(r' := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r')), mem_store_buffers := wb' \\<rparr>))\n\\<longleftrightarrow> obj_at (\\<lambda>obj. (P (if r = r' then obj\\<lparr> obj_mark := fl \\<rparr> else obj))) r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at P r\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r' :=\n                       map_option (obj_mark_update (\\<lambda>_. fl))\n                        (sys_heap s r')),\n             mem_store_buffers := wb'\\<rparr>)) =\n    obj_at\n     (\\<lambda>obj.\n         P (if r = r' then obj\\<lparr>obj_mark := fl\\<rparr> else obj))\n     r s", "by (clarsimp simp: fun_upd_apply split: obj_at_splits)"], ["", "lemma obj_at_field_on_heap_mw_simps[simp]:\n  \"obj_at_field_on_heap P r0 f0\n         (s(sys := (s sys)\\<lparr> heap := (sys_heap s)(r := map_option (\\<lambda>obj :: ('field, 'payload, 'ref) object. obj\\<lparr>obj_fields := (obj_fields obj)(f := opt_r')\\<rparr>) (sys_heap s r)),\n                            mem_store_buffers := (mem_store_buffers (s Sys))(p := ws) \\<rparr>))\n\\<longleftrightarrow> ( (r \\<noteq> r0 \\<or> f \\<noteq> f0) \\<and> obj_at_field_on_heap P r0 f0 s )\n   \\<or> (r = r0 \\<and> f = f0 \\<and> valid_ref r s \\<and> (case opt_r' of Some r'' \\<Rightarrow> P r'' | _ \\<Rightarrow> True))\"\n  \"obj_at_field_on_heap P r f (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := map_option (obj_mark_update (\\<lambda>_. fl)) (sys_heap s r')), mem_store_buffers := sb'\\<rparr>))\n\\<longleftrightarrow> obj_at_field_on_heap P r f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obj_at_field_on_heap P r0 f0\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := opt_r')\\<rparr>)\n                           (sys_heap s r)),\n             mem_store_buffers := (mem_store_buffers (s Sys))\n               (p := ws)\\<rparr>)) =\n    ((r \\<noteq> r0 \\<or> f \\<noteq> f0) \\<and>\n     obj_at_field_on_heap P r0 f0 s \\<or>\n     r = r0 \\<and>\n     f = f0 \\<and>\n     obj_at (\\<lambda>s. True) r s \\<and>\n     (case opt_r' of None \\<Rightarrow> True\n      | Some r'' \\<Rightarrow> P r'')) &&&\n    obj_at_field_on_heap P r f\n     (s(sys := s sys\n          \\<lparr>heap := (sys_heap s)\n                    (r' :=\n                       map_option (obj_mark_update (\\<lambda>_. fl))\n                        (sys_heap s r')),\n             mem_store_buffers := sb'\\<rparr>)) =\n    obj_at_field_on_heap P r f s", "by (auto simp: obj_at_field_on_heap_def fun_upd_apply split: option.splits obj_at_splits)"], ["", "lemma obj_at_field_on_heap_no_pending_stores:\n  \"\\<lbrakk> sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; \\<forall>opt_r'. mw_Mutate r f opt_r' \\<notin> set (sys_mem_store_buffers (mutator m) s); valid_ref r s \\<rbrakk>\n     \\<Longrightarrow> obj_at_field_on_heap (\\<lambda>r. opt_r' = Some r) r f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r';\n     \\<forall>opt_r'.\n        mw_Mutate r f opt_r'\n        \\<notin> set (sys_mem_store_buffers (mutator m) s);\n     obj_at (\\<lambda>s. True) r s\\<rbrakk>\n    \\<Longrightarrow> obj_at_field_on_heap (\\<lambda>r. opt_r' = Some r) r f\n                       s", "unfolding sys_load_def fold_stores_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(do_load_action (mr_Ref r f) \\<circ>\n              (\\<lambda>s.\n                  fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n                   (mem_store_buffers s (mutator m)) id s))\n              (s sys) =\n             mv_Ref opt_r';\n     \\<forall>opt_r'.\n        mw_Mutate r f opt_r'\n        \\<notin> set (sys_mem_store_buffers (mutator m) s);\n     obj_at (\\<lambda>s. True) r s\\<rbrakk>\n    \\<Longrightarrow> obj_at_field_on_heap (\\<lambda>r. opt_r' = Some r) r f\n                       s", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>opt_r'.\n                mw_Mutate r f opt_r'\n                \\<notin> set (sys_mem_store_buffers (mutator m) s);\n     obj_at (\\<lambda>s. True) r s;\n     opt_r' =\n     Option.bind\n      (heap\n        (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n          (sys_mem_store_buffers (mutator m) s) id (s sys))\n        r)\n      (\\<lambda>obj. obj_fields obj f)\\<rbrakk>\n    \\<Longrightarrow> obj_at_field_on_heap\n                       (\\<lambda>ra.\n                           Option.bind\n                            (heap\n                              (fold\n                                (\\<lambda>w. (\\<circ>) (do_store_action w))\n                                (sys_mem_store_buffers (mutator m) s) id\n                                (s sys))\n                              r)\n                            (\\<lambda>obj. obj_fields obj f) =\n                           Some ra)\n                       r f s", "apply (rule fold_invariant[where P=\"\\<lambda>fr. obj_at_field_on_heap (\\<lambda>r'. Option.bind (heap (fr (s sys)) r) (\\<lambda>obj. obj_fields obj f) = Some r') r f s\"\n                             and Q=\"\\<lambda>w. w \\<in> set (sys_mem_store_buffers (mutator m) s)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>opt_r'.\n                   mw_Mutate r f opt_r'\n                   \\<notin> set (sys_mem_store_buffers (mutator m) s);\n        obj_at (\\<lambda>s. True) r s;\n        opt_r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        x \\<in> set (sys_mem_store_buffers (mutator m) s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (sys_mem_store_buffers (mutator m) s)\n 2. \\<lbrakk>\\<forall>opt_r'.\n                mw_Mutate r f opt_r'\n                \\<notin> set (sys_mem_store_buffers (mutator m) s);\n     obj_at (\\<lambda>s. True) r s;\n     opt_r' =\n     Option.bind\n      (heap\n        (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n          (sys_mem_store_buffers (mutator m) s) id (s sys))\n        r)\n      (\\<lambda>obj. obj_fields obj f)\\<rbrakk>\n    \\<Longrightarrow> obj_at_field_on_heap\n                       (\\<lambda>ra.\n                           Option.bind (heap (id (s sys)) r)\n                            (\\<lambda>obj. obj_fields obj f) =\n                           Some ra)\n                       r f s\n 3. \\<And>x sa.\n       \\<lbrakk>\\<forall>opt_r'.\n                   mw_Mutate r f opt_r'\n                   \\<notin> set (sys_mem_store_buffers (mutator m) s);\n        obj_at (\\<lambda>s. True) r s;\n        opt_r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        x \\<in> set (sys_mem_store_buffers (mutator m) s);\n        obj_at_field_on_heap\n         (\\<lambda>ra.\n             Option.bind (heap (sa (s sys)) r)\n              (\\<lambda>obj. obj_fields obj f) =\n             Some ra)\n         r f s\\<rbrakk>\n       \\<Longrightarrow> obj_at_field_on_heap\n                          (\\<lambda>ra.\n                              Option.bind\n                               (heap\n                                 ((do_store_action x \\<circ> sa) (s sys)) r)\n                               (\\<lambda>obj. obj_fields obj f) =\n                              Some ra)\n                          r f s", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>opt_r'.\n                mw_Mutate r f opt_r'\n                \\<notin> set (sys_mem_store_buffers (mutator m) s);\n     obj_at (\\<lambda>s. True) r s;\n     opt_r' =\n     Option.bind\n      (heap\n        (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n          (sys_mem_store_buffers (mutator m) s) id (s sys))\n        r)\n      (\\<lambda>obj. obj_fields obj f)\\<rbrakk>\n    \\<Longrightarrow> obj_at_field_on_heap\n                       (\\<lambda>ra.\n                           Option.bind (heap (id (s sys)) r)\n                            (\\<lambda>obj. obj_fields obj f) =\n                           Some ra)\n                       r f s\n 2. \\<And>x sa.\n       \\<lbrakk>\\<forall>opt_r'.\n                   mw_Mutate r f opt_r'\n                   \\<notin> set (sys_mem_store_buffers (mutator m) s);\n        obj_at (\\<lambda>s. True) r s;\n        opt_r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        x \\<in> set (sys_mem_store_buffers (mutator m) s);\n        obj_at_field_on_heap\n         (\\<lambda>ra.\n             Option.bind (heap (sa (s sys)) r)\n              (\\<lambda>obj. obj_fields obj f) =\n             Some ra)\n         r f s\\<rbrakk>\n       \\<Longrightarrow> obj_at_field_on_heap\n                          (\\<lambda>ra.\n                              Option.bind\n                               (heap\n                                 ((do_store_action x \\<circ> sa) (s sys)) r)\n                               (\\<lambda>obj. obj_fields obj f) =\n                              Some ra)\n                          r f s", "apply (fastforce simp: obj_at_field_on_heap_def split: option.splits obj_at_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x sa.\n       \\<lbrakk>\\<forall>opt_r'.\n                   mw_Mutate r f opt_r'\n                   \\<notin> set (sys_mem_store_buffers (mutator m) s);\n        obj_at (\\<lambda>s. True) r s;\n        opt_r' =\n        Option.bind\n         (heap\n           (fold (\\<lambda>w. (\\<circ>) (do_store_action w))\n             (sys_mem_store_buffers (mutator m) s) id (s sys))\n           r)\n         (\\<lambda>obj. obj_fields obj f);\n        x \\<in> set (sys_mem_store_buffers (mutator m) s);\n        obj_at_field_on_heap\n         (\\<lambda>ra.\n             Option.bind (heap (sa (s sys)) r)\n              (\\<lambda>obj. obj_fields obj f) =\n             Some ra)\n         r f s\\<rbrakk>\n       \\<Longrightarrow> obj_at_field_on_heap\n                          (\\<lambda>ra.\n                              Option.bind\n                               (heap\n                                 ((do_store_action x \\<circ> sa) (s sys)) r)\n                               (\\<lambda>obj. obj_fields obj f) =\n                              Some ra)\n                          r f s", "apply (auto simp: do_store_action_def map_option_case fun_upd_apply\n           split: obj_at_field_on_heap_splits option.splits obj_at_splits mem_store_action.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}