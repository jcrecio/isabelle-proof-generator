{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Global_Invariants.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma \"strong_tricolour_inv s \\<Longrightarrow> weak_tricolour_inv s\""], "translations": [["", "lemma \"strong_tricolour_inv s \\<Longrightarrow> weak_tricolour_inv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strong_tricolour_inv s \\<Longrightarrow> weak_tricolour_inv s", "by (clarsimp simp: strong_tricolour_inv_def weak_tricolour_inv_def grey_protects_white_def)"], ["", "(* FIXME elide *)"], ["", "text\\<open>\n\nThe key invariant that the mutators establish as they perform \\<open>get_roots\\<close>: they protect their white-reachable references with grey\nobjects.\n\n\\<close>"], ["", "definition in_snapshot :: \"'ref \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"in_snapshot r = (black r \\<^bold>\\<or> (\\<^bold>\\<exists>g. g grey_protects_white r))\""], ["", "definition (in mut_m) reachable_snapshot_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"reachable_snapshot_inv = (\\<^bold>\\<forall>r. reachable r \\<^bold>\\<longrightarrow> in_snapshot r)\""], ["", "subsection\\<open>Phase invariants \\label{sec:phase-invariants}\\<close>"], ["", "text (in mut_m) \\<open>\n\nThe phase structure of this GC algorithm greatly complicates this\nsafety proof. The following assertions capture this structure in\nseveral relations.\n\nWe begin by relating the mutators' @{const\n\"mut_ghost_hs_phase\"} to @{const \"sys_ghost_hs_phase\"},\nwhich tracks the GC's. Each mutator can be at most one handshake step\nbehind the GC. If any mutator is behind then the GC is stalled on a\npending handshake. We include the handshake type as\n\\<open>get_work\\<close> can occur any number of times.\n\n\\<close>"], ["", "definition hp_step_rel :: \"(bool \\<times> hs_type \\<times> hs_phase \\<times> hs_phase) set\" where\n  \"hp_step_rel =\n  { True }  \\<times> ({ (ht_NOOP, hp, hp) |hp. hp \\<in> {hp_Idle, hp_IdleInit, hp_InitMark, hp_Mark} }\n            \\<union> { (ht_GetRoots, hp_IdleMarkSweep, hp_IdleMarkSweep)\n              , (ht_GetWork,  hp_IdleMarkSweep, hp_IdleMarkSweep) })\n\\<union> { False } \\<times> { (ht_NOOP,     hp_Idle,          hp_IdleMarkSweep)\n              , (ht_NOOP,     hp_IdleInit,      hp_Idle)\n              , (ht_NOOP,     hp_InitMark,      hp_IdleInit)\n              , (ht_NOOP,     hp_Mark,          hp_InitMark)\n              , (ht_GetRoots, hp_IdleMarkSweep, hp_Mark)\n              , (ht_GetWork,  hp_IdleMarkSweep, hp_IdleMarkSweep) }\""], ["", "definition handshake_phase_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"handshake_phase_inv = (\\<^bold>\\<forall>m.\n     sys_ghost_hs_in_sync m \\<^bold>\\<otimes> sys_hs_type \\<^bold>\\<otimes> sys_ghost_hs_phase \\<^bold>\\<otimes> mut_m.mut_ghost_hs_phase m \\<^bold>\\<in> \\<langle>hp_step_rel\\<rangle>\n  \\<^bold>\\<and> (sys_hs_pending m \\<^bold>\\<longrightarrow> \\<^bold>\\<not>sys_ghost_hs_in_sync m))\""], ["", "text \\<open>\n\nIn some phases we need to know that the insertion and deletion\nbarriers are installed, in order to preserve the snapshot. These can\nignore TSO effects as the process doing the marking holds the TSO lock\nuntil the mark is committed to the shared memory (see\n\\S\\ref{def:valid_W_inv}).\n\nNote that it is not easy to specify precisely when the snapshot (of\nobjects the GC will retain) is taken due to the raggedness of the\ninitialisation.\n\nRead the following as ``when mutator \\<open>m\\<close> is past the\nspecified handshake, and has yet to reach the next one, ... holds.''\n\n\\<close>"], ["", "abbreviation marked_insertion :: \"('field, 'payload, 'ref) mem_store_action \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"marked_insertion w \\<equiv> \\<lambda>s. case w of mw_Mutate r f (Some r') \\<Rightarrow> marked r' s | _ \\<Rightarrow> True\""], ["", "abbreviation marked_deletion :: \"('field, 'payload, 'ref) mem_store_action \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"marked_deletion w \\<equiv> \\<lambda>s. case w of mw_Mutate r f opt_r' \\<Rightarrow> obj_at_field_on_heap (\\<lambda>r'. marked r' s) r f s | _ \\<Rightarrow> True\""], ["", "context mut_m\nbegin"], ["", "definition marked_insertions :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"marked_insertions = (\\<^bold>\\<forall>w. tso_pending_store (mutator m) w \\<^bold>\\<longrightarrow> marked_insertion w)\""], ["", "definition marked_deletions :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"marked_deletions = (\\<^bold>\\<forall>w. tso_pending_store (mutator m) w \\<^bold>\\<longrightarrow> marked_deletion w)\""], ["", "primrec mutator_phase_inv_aux :: \"hs_phase \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"mutator_phase_inv_aux hp_Idle          = \\<langle>True\\<rangle>\"\n| \"mutator_phase_inv_aux hp_IdleInit      = no_black_refs\"\n| \"mutator_phase_inv_aux hp_InitMark      = marked_insertions\"\n| \"mutator_phase_inv_aux hp_Mark          = (marked_insertions \\<^bold>\\<and> marked_deletions)\"\n| \"mutator_phase_inv_aux hp_IdleMarkSweep = (marked_insertions \\<^bold>\\<and> marked_deletions \\<^bold>\\<and> reachable_snapshot_inv)\""], ["", "abbreviation mutator_phase_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"mutator_phase_inv \\<equiv> mutator_phase_inv_aux \\<^bold>$ mut_ghost_hs_phase\""], ["", "end"], ["", "abbreviation mutators_phase_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"mutators_phase_inv \\<equiv> (\\<^bold>\\<forall>m. mut_m.mutator_phase_inv m)\""], ["", "text\\<open>\n\nThis is what the GC guarantees. Read this as ``when the GC is at or\npast the specified handshake, ... holds.''\n\n\\<close>"], ["", "primrec sys_phase_inv_aux :: \"hs_phase \\<Rightarrow> ('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"sys_phase_inv_aux hp_Idle          = ( (If sys_fA \\<^bold>= sys_fM Then black_heap Else white_heap) \\<^bold>\\<and> no_grey_refs )\"\n| \"sys_phase_inv_aux hp_IdleInit      = no_black_refs\"\n| \"sys_phase_inv_aux hp_InitMark      = (sys_fA \\<^bold>\\<noteq> sys_fM \\<^bold>\\<longrightarrow> no_black_refs)\"\n| \"sys_phase_inv_aux hp_Mark          = \\<langle>True\\<rangle>\"\n| \"sys_phase_inv_aux hp_IdleMarkSweep = ( (sys_phase \\<^bold>= \\<langle>ph_Idle\\<rangle> \\<^bold>\\<or> tso_pending_store gc (mw_Phase ph_Idle)) \\<^bold>\\<longrightarrow> no_grey_refs )\""], ["", "abbreviation sys_phase_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"sys_phase_inv \\<equiv> sys_phase_inv_aux \\<^bold>$ sys_ghost_hs_phase\""], ["", "subsubsection\\<open>Writes to shared GC variables\\<close>"], ["", "text\\<open>\n\nRelate @{const \"sys_ghost_hs_phase\"}, @{const \"gc_phase\"},\n@{const \"sys_phase\"} and writes to the phase in the GC's TSO buffer.\n\nThe first relation treats the case when the GC's TSO buffer does not\ncontain any writes to the phase.\n\nThe second relation exhibits the data race on the phase variable: we\nneed to precisely track the possible states of the GC's TSO buffer.\n\n\\<close>"], ["", "definition handshake_phase_rel :: \"hs_phase \\<Rightarrow> bool \\<Rightarrow> gc_phase \\<Rightarrow> bool\" where\n  \"handshake_phase_rel hp in_sync ph =\n     (case hp of\n       hp_Idle          \\<Rightarrow> ph = ph_Idle\n     | hp_IdleInit      \\<Rightarrow> ph = ph_Idle \\<or> (in_sync \\<and> ph = ph_Init)\n     | hp_InitMark      \\<Rightarrow> ph = ph_Init \\<or> (in_sync \\<and> ph = ph_Mark)\n     | hp_Mark          \\<Rightarrow> ph = ph_Mark\n     | hp_IdleMarkSweep \\<Rightarrow> ph = ph_Mark \\<or> (in_sync \\<and> ph \\<in> { ph_Idle, ph_Sweep }))\""], ["", "definition phase_rel :: \"(bool \\<times> hs_phase \\<times> gc_phase \\<times> gc_phase \\<times> ('field, 'payload, 'ref) mem_store_action list) set\" where\n  \"phase_rel =\n     ({ (in_sync, hp, ph, ph, []) |in_sync hp ph. handshake_phase_rel hp in_sync ph }\n    \\<union> ({True} \\<times> { (hp_IdleInit, ph_Init, ph_Idle, [mw_Phase ph_Init]),\n                  (hp_InitMark, ph_Mark, ph_Init, [mw_Phase ph_Mark]),\n                  (hp_IdleMarkSweep, ph_Sweep, ph_Mark, [mw_Phase ph_Sweep]),\n                  (hp_IdleMarkSweep, ph_Idle, ph_Mark, [mw_Phase ph_Sweep, mw_Phase ph_Idle]),\n                  (hp_IdleMarkSweep, ph_Idle, ph_Sweep, [mw_Phase ph_Idle]) }))\""], ["", "definition phase_rel_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"phase_rel_inv = ((\\<^bold>\\<forall>m. sys_ghost_hs_in_sync m) \\<^bold>\\<otimes> sys_ghost_hs_phase \\<^bold>\\<otimes> gc_phase \\<^bold>\\<otimes> sys_phase \\<^bold>\\<otimes> tso_pending_phase gc \\<^bold>\\<in> \\<langle>phase_rel\\<rangle>)\""], ["", "text\\<open>\n\nSimilarly we track the validity of @{const \"sys_fM\"} (respectively,\n@{const \"sys_fA\"}) wrt @{const \"gc_fM\"} (@{const \"sys_fA\"}) and the\nhandshake phase. We also include the TSO lock to rule out the GC\nhaving any pending marks during the @{const \"hp_Idle\"} handshake\nphase.\n\n\\<close>"], ["", "definition fM_rel :: \"(bool \\<times> hs_phase \\<times> gc_mark \\<times> gc_mark \\<times> ('field, 'payload, 'ref) mem_store_action list \\<times> bool) set\" where\n  \"fM_rel =\n      { (in_sync, hp, fM, fM, [], l) |fM hp in_sync l. hp = hp_Idle \\<longrightarrow> \\<not>in_sync }\n    \\<union> { (in_sync, hp_Idle, fM, fM', [], l) |fM fM' in_sync l. in_sync }\n    \\<union> { (in_sync, hp_Idle, \\<not>fM, fM, [mw_fM (\\<not>fM)], False) |fM in_sync. in_sync }\""], ["", "definition fM_rel_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"fM_rel_inv = ((\\<^bold>\\<forall>m. sys_ghost_hs_in_sync m) \\<^bold>\\<otimes> sys_ghost_hs_phase \\<^bold>\\<otimes> gc_fM \\<^bold>\\<otimes> sys_fM \\<^bold>\\<otimes> tso_pending_fM gc \\<^bold>\\<otimes> (sys_mem_lock \\<^bold>= \\<langle>Some gc\\<rangle>) \\<^bold>\\<in> \\<langle>fM_rel\\<rangle>)\""], ["", "definition fA_rel :: \"(bool \\<times> hs_phase \\<times> gc_mark \\<times> gc_mark \\<times> ('field, 'payload, 'ref) mem_store_action list) set\" where\n  \"fA_rel =\n      { (in_sync, hp_Idle,          fA,  fM, []) |fA fM in_sync. \\<not>in_sync \\<longrightarrow> fA = fM }\n    \\<union> { (in_sync, hp_IdleInit,      fA, \\<not>fA, []) |fA in_sync. True }\n    \\<union> { (in_sync, hp_InitMark,      fA, \\<not>fA, [mw_fA (\\<not>fA)]) |fA in_sync. in_sync }\n    \\<union> { (in_sync, hp_InitMark,      fA,  fM, []) |fA fM in_sync. \\<not>in_sync \\<longrightarrow> fA \\<noteq> fM }\n    \\<union> { (in_sync, hp_Mark,          fA,  fA, []) |fA in_sync. True }\n    \\<union> { (in_sync, hp_IdleMarkSweep, fA,  fA, []) |fA in_sync. True }\""], ["", "definition fA_rel_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"fA_rel_inv = ((\\<^bold>\\<forall>m. sys_ghost_hs_in_sync m) \\<^bold>\\<otimes> sys_ghost_hs_phase \\<^bold>\\<otimes> sys_fA \\<^bold>\\<otimes> gc_fM \\<^bold>\\<otimes> tso_pending_fA gc \\<^bold>\\<in> \\<langle>fA_rel\\<rangle>)\""], ["", "subsection\\<open>Worklist invariants \\label{def:valid_W_inv}\\<close>"], ["", "text\\<open>\n\nThe worklists track the grey objects. The following invariant asserts\nthat grey objects are marked on the heap except for a few steps near\nthe end of @{const \"mark_object_fn\"}, the processes' worklists and\n@{const \"ghost_honorary_grey\"}s are disjoint, and that pending marks\nare sensible.\n\nThe safety of the collector does not to depend on disjointness; we\ninclude it as proof that the single-threading of grey objects in the\nimplementation is sound.\n\nNote that the phase invariants of \\S\\ref{sec:phase-invariants} limit\nthe scope of this invariant.\n\n\\<close>"], ["", "definition valid_W_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"valid_W_inv =\n    ((\\<^bold>\\<forall>p r. r in_W p \\<^bold>\\<or> (sys_mem_lock \\<^bold>\\<noteq> \\<langle>Some p\\<rangle> \\<^bold>\\<and> r in_ghost_honorary_grey p) \\<^bold>\\<longrightarrow> marked r)\n  \\<^bold>\\<and> (\\<^bold>\\<forall>p q. \\<langle>p \\<noteq> q\\<rangle> \\<^bold>\\<longrightarrow> WL p \\<^bold>\\<inter> WL q \\<^bold>= \\<langle>{}\\<rangle>)\n  \\<^bold>\\<and> (\\<^bold>\\<forall>p q r. \\<^bold>\\<not>(r in_ghost_honorary_grey p \\<^bold>\\<and> r in_W q))\n  \\<^bold>\\<and> (EMPTY sys_ghost_honorary_grey)\n  \\<^bold>\\<and> (\\<^bold>\\<forall>p r fl. tso_pending_store p (mw_Mark r fl)\n       \\<^bold>\\<longrightarrow> \\<langle>fl\\<rangle> \\<^bold>= sys_fM\n         \\<^bold>\\<and> r in_ghost_honorary_grey p\n         \\<^bold>\\<and> tso_locked_by p\n         \\<^bold>\\<and> white r\n         \\<^bold>\\<and> tso_pending_mark p \\<^bold>= \\<langle>[mw_Mark r fl]\\<rangle> ))\""], ["", "subsection\\<open>Coarse invariants about the stores a process can issue\\<close>"], ["", "abbreviation gc_writes :: \"('field, 'payload, 'ref) mem_store_action \\<Rightarrow> bool\" where\n  \"gc_writes w \\<equiv> case w of mw_Mark _ _ \\<Rightarrow> True | mw_Phase _ \\<Rightarrow> True | mw_fM _ \\<Rightarrow> True | mw_fA _ \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "abbreviation mut_writes :: \"('field, 'payload, 'ref) mem_store_action \\<Rightarrow> bool\" where\n  \"mut_writes w \\<equiv> case w of mw_Mutate _ _ _ \\<Rightarrow> True | mw_Mark _ _ \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "definition tso_store_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"tso_store_inv =\n    ((\\<^bold>\\<forall>w.   tso_pending_store gc          w \\<^bold>\\<longrightarrow> \\<langle>gc_writes w\\<rangle>)\n   \\<^bold>\\<and> (\\<^bold>\\<forall>m w. tso_pending_store (mutator m) w \\<^bold>\\<longrightarrow> \\<langle>mut_writes w\\<rangle>))\""], ["", "subsection\\<open>The global invariants collected\\<close>"], ["", "definition invs :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"invs =\n   (handshake_phase_inv\n  \\<^bold>\\<and> phase_rel_inv\n  \\<^bold>\\<and> strong_tricolour_inv\n  \\<^bold>\\<and> sys_phase_inv\n  \\<^bold>\\<and> tso_store_inv\n  \\<^bold>\\<and> valid_refs_inv\n  \\<^bold>\\<and> valid_W_inv\n  \\<^bold>\\<and> mutators_phase_inv\n  \\<^bold>\\<and> fA_rel_inv \\<^bold>\\<and> fM_rel_inv)\""], ["", "subsection\\<open>Initial conditions \\label{sec:initial-conditions}\\<close>"], ["", "text\\<open>\n\nWe ask that the GC and system initially agree on some things:\n\\begin{itemize}\n\n\\item All objects on the heap are marked (have their flags equal to\n  @{const \"sys_fM\"}, and there are no grey references, i.e. the heap\n  is uniformly black.\n\n\\item The GC and system have the same values for @{term \"fA\"}, @{term\n  \"fM\"}, etc. and the phase is @{term \"Idle\"}.\n\n\\item No process holds the TSO lock and all write buffers are empty.\n\n\\item All root-reachable references are backed by objects.\n\n\\end{itemize}\nNote that these are merely sufficient initial conditions and can be\nweakened.\n\n\\<close>"], ["", "locale gc_system =\n  fixes initial_mark :: gc_mark\nbegin"], ["", "definition gc_initial_state :: \"('field, 'mut, 'payload, 'ref) lst_pred\" where\n  \"gc_initial_state s =\n    (fM s = initial_mark\n   \\<and> phase s = ph_Idle\n   \\<and> ghost_honorary_grey s = {}\n   \\<and> W s = {})\""], ["", "definition mut_initial_state :: \"('field, 'mut, 'payload, 'ref) lst_pred\" where\n  \"mut_initial_state s =\n    (ghost_hs_phase s = hp_IdleMarkSweep\n   \\<and> ghost_honorary_grey s = {}\n   \\<and> ghost_honorary_root s = {}\n   \\<and> W s = {})\""], ["", "definition sys_initial_state :: \"('field, 'mut, 'payload, 'ref) lst_pred\" where\n  \"sys_initial_state s =\n    ((\\<forall>m. \\<not>hs_pending s m \\<and> ghost_hs_in_sync s m)\n   \\<and> ghost_hs_phase s = hp_IdleMarkSweep \\<and> hs_type s = ht_GetRoots\n   \\<and> obj_mark ` ran (heap s) \\<subseteq> {initial_mark}\n   \\<and> fA s = initial_mark\n   \\<and> fM s = initial_mark\n   \\<and> phase s = ph_Idle\n   \\<and> ghost_honorary_grey s = {}\n   \\<and> W s = {}\n   \\<and> (\\<forall>p. mem_store_buffers s p = [])\n   \\<and> mem_lock s = None)\""], ["", "abbreviation\n  \"root_reachable y \\<equiv> \\<^bold>\\<exists>m x. \\<langle>x\\<rangle> \\<^bold>\\<in> mut_m.mut_roots m \\<^bold>\\<and> x reaches y\""], ["", "definition valid_refs :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"valid_refs = (\\<^bold>\\<forall>y. root_reachable y \\<^bold>\\<longrightarrow> valid_ref y)\""], ["", "definition gc_system_init :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"gc_system_init =\n      ((\\<lambda>s. gc_initial_state (s gc))\n     \\<^bold>\\<and> (\\<lambda>s. \\<forall>m. mut_initial_state (s (mutator m)))\n     \\<^bold>\\<and> (\\<lambda>s. sys_initial_state (s sys))\n     \\<^bold>\\<and> valid_refs)\""], ["", "text\\<open>\n\nThe system consists of the programs and these constraints on the initial state.\n\n\\<close>"], ["", "abbreviation gc_system :: \"('field, 'mut, 'payload, 'ref) gc_system\" where\n  \"gc_system \\<equiv> \\<lparr>PGMs = gc_coms, INIT = gc_system_init, FAIR = \\<langle>True\\<rangle>\\<rparr>\""], ["", "(* FIXME add fairness hypotheses *)"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}