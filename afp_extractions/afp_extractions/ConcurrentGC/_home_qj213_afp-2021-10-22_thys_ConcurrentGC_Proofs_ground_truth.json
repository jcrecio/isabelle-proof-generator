{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma (in gc) I:\n  \"\\<lbrace> I \\<rbrace> gc\"", "lemma (in sys) I:\n  \"\\<lbrace> I \\<rbrace> sys\"", "lemma mut_invsL[intro]:\n  \"\\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>\"", "lemma mutators_phase_inv[intro]:\n  \"\\<lbrace> I \\<rbrace> mutator m  \\<lbrace> LSTP (mut_m.mutator_phase_inv m') \\<rbrace>\"", "lemma (in mut_m) I:\n  \"\\<lbrace> I \\<rbrace> mutator m\"", "theorem I: \"gc_system \\<Turnstile>\\<^bsub>pre\\<^esub> I\""], "translations": [["", "lemma (in gc) I:\n  \"\\<lbrace> I \\<rbrace> gc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> gc", "apply (simp add: I_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s.\n                 fM_fA_invL s \\<and>\n                 gc_mark.mark_object_invL s \\<and>\n                 gc_W_empty_invL s \\<and>\n                 handshake_invL s \\<and>\n                 obj_fields_marked_invL s \\<and>\n                 phase_invL s \\<and>\n                 sweep_loop_invL s \\<and>\n                 tso_lock_invL s \\<and>\n                 (\\<forall>x.\n                     mut_m.mark_object_invL x s \\<and>\n                     mut_get_roots.mark_object_invL x s \\<and>\n                     mut_store_ins.mark_object_invL x s \\<and>\n                     mut_store_del.mark_object_invL x s \\<and>\n                     mut_m.handshake_invL x s \\<and>\n                     mut_m.tso_lock_invL x s) \\<and>\n                 handshake_phase_inv s\\<down> \\<and>\n                 phase_rel_inv s\\<down> \\<and>\n                 strong_tricolour_inv s\\<down> \\<and>\n                 sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                  s\\<down> \\<and>\n                 tso_store_inv s\\<down> \\<and>\n                 valid_refs_inv s\\<down> \\<and>\n                 valid_W_inv s\\<down> \\<and>\n                 (\\<forall>x.\n                     mut_m.mutator_phase_inv_aux x\n                      (ghost_hs_phase (s\\<down> (mutator x)))\n                      s\\<down>) \\<and>\n                 fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>)\\<rbrace> gc", "apply (rule valid_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?Q\\<rbrace> gc \\<lbrace>\\<lambda>s.\n  fM_fA_invL s \\<and>\n  gc_mark.mark_object_invL s \\<and>\n  gc_W_empty_invL s \\<and>\n  handshake_invL s \\<and>\n  obj_fields_marked_invL s \\<and>\n  phase_invL s \\<and>\n  sweep_loop_invL s \\<and>\n  tso_lock_invL s \\<and>\n  (\\<forall>x.\n      mut_m.mark_object_invL x s \\<and>\n      mut_get_roots.mark_object_invL x s \\<and>\n      mut_store_ins.mark_object_invL x s \\<and>\n      mut_store_del.mark_object_invL x s \\<and>\n      mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n  handshake_phase_inv s\\<down> \\<and>\n  phase_rel_inv s\\<down> \\<and>\n  strong_tricolour_inv s\\<down> \\<and>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n  tso_store_inv s\\<down> \\<and>\n  valid_refs_inv s\\<down> \\<and>\n  valid_W_inv s\\<down> \\<and>\n  (\\<forall>x.\n      mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n       s\\<down>) \\<and>\n  fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>\\<rbrace>\n 2. \\<And>s.\n       fM_fA_invL s \\<and>\n       gc_mark.mark_object_invL s \\<and>\n       gc_W_empty_invL s \\<and>\n       handshake_invL s \\<and>\n       obj_fields_marked_invL s \\<and>\n       phase_invL s \\<and>\n       sweep_loop_invL s \\<and>\n       tso_lock_invL s \\<and>\n       (\\<forall>x.\n           mut_m.mark_object_invL x s \\<and>\n           mut_get_roots.mark_object_invL x s \\<and>\n           mut_store_ins.mark_object_invL x s \\<and>\n           mut_store_del.mark_object_invL x s \\<and>\n           mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n       handshake_phase_inv s\\<down> \\<and>\n       phase_rel_inv s\\<down> \\<and>\n       strong_tricolour_inv s\\<down> \\<and>\n       sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n       tso_store_inv s\\<down> \\<and>\n       valid_refs_inv s\\<down> \\<and>\n       valid_W_inv s\\<down> \\<and>\n       (\\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n       fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down> \\<Longrightarrow>\n       ?Q s", "apply ( rule valid_conj_lift valid_all_lift | fastforce )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in sys) I:\n  \"\\<lbrace> I \\<rbrace> sys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> sys", "apply (simp add: I_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s.\n                 gc.fM_fA_invL s \\<and>\n                 gc_mark.mark_object_invL s \\<and>\n                 gc.gc_W_empty_invL s \\<and>\n                 gc.handshake_invL s \\<and>\n                 gc.obj_fields_marked_invL s \\<and>\n                 gc.phase_invL s \\<and>\n                 gc.sweep_loop_invL s \\<and>\n                 gc.tso_lock_invL s \\<and>\n                 (\\<forall>x.\n                     mut_m.mark_object_invL x s \\<and>\n                     mut_get_roots.mark_object_invL x s \\<and>\n                     mut_store_ins.mark_object_invL x s \\<and>\n                     mut_store_del.mark_object_invL x s \\<and>\n                     mut_m.handshake_invL x s \\<and>\n                     mut_m.tso_lock_invL x s) \\<and>\n                 handshake_phase_inv s\\<down> \\<and>\n                 phase_rel_inv s\\<down> \\<and>\n                 strong_tricolour_inv s\\<down> \\<and>\n                 sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                  s\\<down> \\<and>\n                 tso_store_inv s\\<down> \\<and>\n                 valid_refs_inv s\\<down> \\<and>\n                 valid_W_inv s\\<down> \\<and>\n                 (\\<forall>x.\n                     mut_m.mutator_phase_inv_aux x\n                      (ghost_hs_phase (s\\<down> (mutator x)))\n                      s\\<down>) \\<and>\n                 fA_rel_inv s\\<down> \\<and>\n                 fM_rel_inv s\\<down>)\\<rbrace> sys", "apply (rule valid_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?Q\\<rbrace> sys \\<lbrace>\\<lambda>s.\n   gc.fM_fA_invL s \\<and>\n   gc_mark.mark_object_invL s \\<and>\n   gc.gc_W_empty_invL s \\<and>\n   gc.handshake_invL s \\<and>\n   gc.obj_fields_marked_invL s \\<and>\n   gc.phase_invL s \\<and>\n   gc.sweep_loop_invL s \\<and>\n   gc.tso_lock_invL s \\<and>\n   (\\<forall>x.\n       mut_m.mark_object_invL x s \\<and>\n       mut_get_roots.mark_object_invL x s \\<and>\n       mut_store_ins.mark_object_invL x s \\<and>\n       mut_store_del.mark_object_invL x s \\<and>\n       mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n   handshake_phase_inv s\\<down> \\<and>\n   phase_rel_inv s\\<down> \\<and>\n   strong_tricolour_inv s\\<down> \\<and>\n   sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n   tso_store_inv s\\<down> \\<and>\n   valid_refs_inv s\\<down> \\<and>\n   valid_W_inv s\\<down> \\<and>\n   (\\<forall>x.\n       mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n        s\\<down>) \\<and>\n   fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>\\<rbrace>\n 2. \\<And>s.\n       gc.fM_fA_invL s \\<and>\n       gc_mark.mark_object_invL s \\<and>\n       gc.gc_W_empty_invL s \\<and>\n       gc.handshake_invL s \\<and>\n       gc.obj_fields_marked_invL s \\<and>\n       gc.phase_invL s \\<and>\n       gc.sweep_loop_invL s \\<and>\n       gc.tso_lock_invL s \\<and>\n       (\\<forall>x.\n           mut_m.mark_object_invL x s \\<and>\n           mut_get_roots.mark_object_invL x s \\<and>\n           mut_store_ins.mark_object_invL x s \\<and>\n           mut_store_del.mark_object_invL x s \\<and>\n           mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n       handshake_phase_inv s\\<down> \\<and>\n       phase_rel_inv s\\<down> \\<and>\n       strong_tricolour_inv s\\<down> \\<and>\n       sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n       tso_store_inv s\\<down> \\<and>\n       valid_refs_inv s\\<down> \\<and>\n       valid_W_inv s\\<down> \\<and>\n       (\\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n       fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down> \\<Longrightarrow>\n       ?Q s", "apply ( rule valid_conj_lift valid_all_lift | fastforce )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\nWe need to separately treat the two cases of a single mutator and\nmultiple mutators. In the latter case we have the additional\nobligation of showing mutual non-interference amongst mutators.\n\n\\<close>"], ["", "lemma mut_invsL[intro]:\n  \"\\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>", "proof(cases \"m = m'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>\n 2. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>", "case True"], ["proof (state)\nthis:\n  m = m'\n\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>\n 2. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>", "interpret mut_m m'"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>\n 2. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>", "from True"], ["proof (chain)\npicking this:\n  m = m'", "show ?thesis"], ["proof (prove)\nusing this:\n  m = m'\n\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>", "apply (simp add: I_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                gc.fM_fA_invL s \\<and>\n                gc_mark.mark_object_invL s \\<and>\n                gc.gc_W_empty_invL s \\<and>\n                gc.handshake_invL s \\<and>\n                gc.obj_fields_marked_invL s \\<and>\n                gc.phase_invL s \\<and>\n                gc.sweep_loop_invL s \\<and>\n                gc.tso_lock_invL s \\<and>\n                (\\<forall>x.\n                    mut_m.mark_object_invL x s \\<and>\n                    mut_get_roots.mark_object_invL x s \\<and>\n                    mut_store_ins.mark_object_invL x s \\<and>\n                    mut_store_del.mark_object_invL x s \\<and>\n                    mut_m.handshake_invL x s \\<and>\n                    mut_m.tso_lock_invL x s) \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                phase_rel_inv s\\<down> \\<and>\n                strong_tricolour_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                fA_rel_inv s\\<down> \\<and>\n                fM_rel_inv\n                 s\\<down>\\<rbrace> mutator\n                                    m' \\<lbrace>\\<lambda>s.\n             mark_object_invL s \\<and>\n             mut_get_roots.mark_object_invL m' s \\<and>\n             mut_store_ins.mark_object_invL m' s \\<and>\n             mut_store_del.mark_object_invL m' s \\<and>\n             handshake_invL s \\<and> tso_lock_invL s\\<rbrace>", "apply (rule valid_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>?Q1\\<rbrace> mutator\n                           m' \\<lbrace>\\<lambda>s.\n    mark_object_invL s \\<and>\n    mut_get_roots.mark_object_invL m' s \\<and>\n    mut_store_ins.mark_object_invL m' s \\<and>\n    mut_store_del.mark_object_invL m' s \\<and>\n    handshake_invL s \\<and> tso_lock_invL s\\<rbrace>\n 2. \\<And>s.\n       \\<lbrakk>m = m';\n        gc.fM_fA_invL s \\<and>\n        gc_mark.mark_object_invL s \\<and>\n        gc.gc_W_empty_invL s \\<and>\n        gc.handshake_invL s \\<and>\n        gc.obj_fields_marked_invL s \\<and>\n        gc.phase_invL s \\<and>\n        gc.sweep_loop_invL s \\<and>\n        gc.tso_lock_invL s \\<and>\n        (\\<forall>x.\n            mut_m.mark_object_invL x s \\<and>\n            mut_get_roots.mark_object_invL x s \\<and>\n            mut_store_ins.mark_object_invL x s \\<and>\n            mut_store_del.mark_object_invL x s \\<and>\n            mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n        handshake_phase_inv s\\<down> \\<and>\n        phase_rel_inv s\\<down> \\<and>\n        strong_tricolour_inv s\\<down> \\<and>\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n        tso_store_inv s\\<down> \\<and>\n        valid_refs_inv s\\<down> \\<and>\n        valid_W_inv s\\<down> \\<and>\n        (\\<forall>x.\n            mut_m.mutator_phase_inv_aux x\n             (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n        fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>\\<rbrakk>\n       \\<Longrightarrow> ?Q1 s", "apply ( rule valid_conj_lift | fastforce )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>\n\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>", "case False"], ["proof (state)\nthis:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>mut_m.invsL m'\\<rbrace>", "then"], ["proof (chain)\npicking this:\n  m \\<noteq> m'", "interpret mut_m' m' m"], ["proof (prove)\nusing this:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. mut_m' m' m", "by unfold_locales blast"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>", "from False"], ["proof (chain)\npicking this:\n  m \\<noteq> m'", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>", "apply (simp add: I_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                gc.fM_fA_invL s \\<and>\n                gc_mark.mark_object_invL s \\<and>\n                gc.gc_W_empty_invL s \\<and>\n                gc.handshake_invL s \\<and>\n                gc.obj_fields_marked_invL s \\<and>\n                gc.phase_invL s \\<and>\n                gc.sweep_loop_invL s \\<and>\n                gc.tso_lock_invL s \\<and>\n                (\\<forall>x.\n                    mut_m.mark_object_invL x s \\<and>\n                    mut_get_roots.mark_object_invL x s \\<and>\n                    mut_store_ins.mark_object_invL x s \\<and>\n                    mut_store_del.mark_object_invL x s \\<and>\n                    mut_m.handshake_invL x s \\<and>\n                    mut_m.tso_lock_invL x s) \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                phase_rel_inv s\\<down> \\<and>\n                strong_tricolour_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                fA_rel_inv s\\<down> \\<and>\n                fM_rel_inv\n                 s\\<down>\\<rbrace> mutator\n                                    m \\<lbrace>\\<lambda>s.\n            mark_object_invL s \\<and>\n            mut_get_roots.mark_object_invL m' s \\<and>\n            mut_store_ins.mark_object_invL m' s \\<and>\n            mut_store_del.mark_object_invL m' s \\<and>\n            handshake_invL s \\<and> tso_lock_invL s\\<rbrace>", "apply (rule valid_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?Q1\\<rbrace> mutator\n                           m \\<lbrace>\\<lambda>s.\n   mark_object_invL s \\<and>\n   mut_get_roots.mark_object_invL m' s \\<and>\n   mut_store_ins.mark_object_invL m' s \\<and>\n   mut_store_del.mark_object_invL m' s \\<and>\n   handshake_invL s \\<and> tso_lock_invL s\\<rbrace>\n 2. \\<And>s.\n       gc.fM_fA_invL s \\<and>\n       gc_mark.mark_object_invL s \\<and>\n       gc.gc_W_empty_invL s \\<and>\n       gc.handshake_invL s \\<and>\n       gc.obj_fields_marked_invL s \\<and>\n       gc.phase_invL s \\<and>\n       gc.sweep_loop_invL s \\<and>\n       gc.tso_lock_invL s \\<and>\n       (\\<forall>x.\n           mut_m.mark_object_invL x s \\<and>\n           mut_get_roots.mark_object_invL x s \\<and>\n           mut_store_ins.mark_object_invL x s \\<and>\n           mut_store_del.mark_object_invL x s \\<and>\n           mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n       handshake_phase_inv s\\<down> \\<and>\n       phase_rel_inv s\\<down> \\<and>\n       strong_tricolour_inv s\\<down> \\<and>\n       sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n       tso_store_inv s\\<down> \\<and>\n       valid_refs_inv s\\<down> \\<and>\n       valid_W_inv s\\<down> \\<and>\n       (\\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n       fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down> \\<Longrightarrow>\n       ?Q1 s", "apply ( rule valid_conj_lift | fastforce )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrace>I\\<rbrace> mutator m \\<lbrace>local.invsL\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "(* FIXME split mutators_phase_inv from global invs to local invs. Move to StrongTricolour or similar. note dependence on I *)"], ["", "lemma mutators_phase_inv[intro]:\n  \"\\<lbrace> I \\<rbrace> mutator m  \\<lbrace> LSTP (mut_m.mutator_phase_inv m') \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mut_m.mutator_phase_inv_aux m' (ghost_hs_phase (s\\<down> (mutator m')))\n  s\\<down>\\<rbrace>", "proof(cases \"m = m'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mut_m.mutator_phase_inv_aux m' (ghost_hs_phase (s\\<down> (mutator m')))\n  s\\<down>\\<rbrace>\n 2. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mut_m.mutator_phase_inv_aux m' (ghost_hs_phase (s\\<down> (mutator m')))\n  s\\<down>\\<rbrace>", "case True"], ["proof (state)\nthis:\n  m = m'\n\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mut_m.mutator_phase_inv_aux m' (ghost_hs_phase (s\\<down> (mutator m')))\n  s\\<down>\\<rbrace>\n 2. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mut_m.mutator_phase_inv_aux m' (ghost_hs_phase (s\\<down> (mutator m')))\n  s\\<down>\\<rbrace>", "interpret mut_m m'"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>\n 2. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>", "from True"], ["proof (chain)\npicking this:\n  m = m'", "show ?thesis"], ["proof (prove)\nusing this:\n  m = m'\n\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>", "apply (simp add: I_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                gc.fM_fA_invL s \\<and>\n                gc_mark.mark_object_invL s \\<and>\n                gc.gc_W_empty_invL s \\<and>\n                gc.handshake_invL s \\<and>\n                gc.obj_fields_marked_invL s \\<and>\n                gc.phase_invL s \\<and>\n                gc.sweep_loop_invL s \\<and>\n                gc.tso_lock_invL s \\<and>\n                (\\<forall>x.\n                    mut_m.mark_object_invL x s \\<and>\n                    mut_get_roots.mark_object_invL x s \\<and>\n                    mut_store_ins.mark_object_invL x s \\<and>\n                    mut_store_del.mark_object_invL x s \\<and>\n                    mut_m.handshake_invL x s \\<and>\n                    mut_m.tso_lock_invL x s) \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                phase_rel_inv s\\<down> \\<and>\n                strong_tricolour_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                fA_rel_inv s\\<down> \\<and>\n                fM_rel_inv\n                 s\\<down>\\<rbrace> mutator\n                                    m' \\<lbrace>\\<lambda>s.\n             mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>)\n              s\\<down>\\<rbrace>", "apply (rule valid_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = m' \\<Longrightarrow>\n    \\<lbrace>?Q1\\<rbrace> mutator\n                           m' \\<lbrace>\\<lambda>s.\n    mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>\n 2. \\<And>s.\n       \\<lbrakk>m = m';\n        gc.fM_fA_invL s \\<and>\n        gc_mark.mark_object_invL s \\<and>\n        gc.gc_W_empty_invL s \\<and>\n        gc.handshake_invL s \\<and>\n        gc.obj_fields_marked_invL s \\<and>\n        gc.phase_invL s \\<and>\n        gc.sweep_loop_invL s \\<and>\n        gc.tso_lock_invL s \\<and>\n        (\\<forall>x.\n            mut_m.mark_object_invL x s \\<and>\n            mut_get_roots.mark_object_invL x s \\<and>\n            mut_store_ins.mark_object_invL x s \\<and>\n            mut_store_del.mark_object_invL x s \\<and>\n            mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n        handshake_phase_inv s\\<down> \\<and>\n        phase_rel_inv s\\<down> \\<and>\n        strong_tricolour_inv s\\<down> \\<and>\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n        tso_store_inv s\\<down> \\<and>\n        valid_refs_inv s\\<down> \\<and>\n        valid_W_inv s\\<down> \\<and>\n        (\\<forall>x.\n            mut_m.mutator_phase_inv_aux x\n             (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n        fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>\\<rbrakk>\n       \\<Longrightarrow> ?Q1 s", "apply ( rule valid_conj_lift valid_all_lift | fastforce )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrace>I\\<rbrace> mutator\n                       m \\<lbrace>\\<lambda>s.\n                                     mutator_phase_inv_aux\n(mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>\n\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mut_m.mutator_phase_inv_aux m' (ghost_hs_phase (s\\<down> (mutator m')))\n  s\\<down>\\<rbrace>", "case False"], ["proof (state)\nthis:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mut_m.mutator_phase_inv_aux m' (ghost_hs_phase (s\\<down> (mutator m')))\n  s\\<down>\\<rbrace>", "then"], ["proof (chain)\npicking this:\n  m \\<noteq> m'", "interpret mut_m' m' m"], ["proof (prove)\nusing this:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. mut_m' m' m", "by unfold_locales blast"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> m' \\<Longrightarrow>\n    \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>", "from False"], ["proof (chain)\npicking this:\n  m \\<noteq> m'", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> mutator\n                         m \\<lbrace>\\<lambda>s.\n mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>", "apply (simp add: I_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                gc.fM_fA_invL s \\<and>\n                gc_mark.mark_object_invL s \\<and>\n                gc.gc_W_empty_invL s \\<and>\n                gc.handshake_invL s \\<and>\n                gc.obj_fields_marked_invL s \\<and>\n                gc.phase_invL s \\<and>\n                gc.sweep_loop_invL s \\<and>\n                gc.tso_lock_invL s \\<and>\n                (\\<forall>x.\n                    mut_m.mark_object_invL x s \\<and>\n                    mut_get_roots.mark_object_invL x s \\<and>\n                    mut_store_ins.mark_object_invL x s \\<and>\n                    mut_store_del.mark_object_invL x s \\<and>\n                    mut_m.handshake_invL x s \\<and>\n                    mut_m.tso_lock_invL x s) \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                phase_rel_inv s\\<down> \\<and>\n                strong_tricolour_inv s\\<down> \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                tso_store_inv s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                fA_rel_inv s\\<down> \\<and>\n                fM_rel_inv\n                 s\\<down>\\<rbrace> mutator\n                                    m \\<lbrace>\\<lambda>s.\n            mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>)\n             s\\<down>\\<rbrace>", "apply (rule valid_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?Q1\\<rbrace> mutator\n                           m \\<lbrace>\\<lambda>s.\n   mutator_phase_inv_aux (mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>\n 2. \\<And>s.\n       gc.fM_fA_invL s \\<and>\n       gc_mark.mark_object_invL s \\<and>\n       gc.gc_W_empty_invL s \\<and>\n       gc.handshake_invL s \\<and>\n       gc.obj_fields_marked_invL s \\<and>\n       gc.phase_invL s \\<and>\n       gc.sweep_loop_invL s \\<and>\n       gc.tso_lock_invL s \\<and>\n       (\\<forall>x.\n           mut_m.mark_object_invL x s \\<and>\n           mut_get_roots.mark_object_invL x s \\<and>\n           mut_store_ins.mark_object_invL x s \\<and>\n           mut_store_del.mark_object_invL x s \\<and>\n           mut_m.handshake_invL x s \\<and> mut_m.tso_lock_invL x s) \\<and>\n       handshake_phase_inv s\\<down> \\<and>\n       phase_rel_inv s\\<down> \\<and>\n       strong_tricolour_inv s\\<down> \\<and>\n       sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n       tso_store_inv s\\<down> \\<and>\n       valid_refs_inv s\\<down> \\<and>\n       valid_W_inv s\\<down> \\<and>\n       (\\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n       fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down> \\<Longrightarrow>\n       ?Q1 s", "apply ( rule valid_conj_lift valid_all_lift | fastforce )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrace>I\\<rbrace> mutator\n                       m \\<lbrace>\\<lambda>s.\n                                     mutator_phase_inv_aux\n(mut_ghost_hs_phase s\\<down>) s\\<down>\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in mut_m) I:\n  \"\\<lbrace> I \\<rbrace> mutator m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>I\\<rbrace> mutator m", "apply (simp add: I_def gc.invsL_def invs_def Local_Invariants.invsL_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s.\n                 gc.fM_fA_invL s \\<and>\n                 gc_mark.mark_object_invL s \\<and>\n                 gc.gc_W_empty_invL s \\<and>\n                 gc.handshake_invL s \\<and>\n                 gc.obj_fields_marked_invL s \\<and>\n                 gc.phase_invL s \\<and>\n                 gc.sweep_loop_invL s \\<and>\n                 gc.tso_lock_invL s \\<and>\n                 (\\<forall>x. mut_m.invsL x s) \\<and>\n                 handshake_phase_inv s\\<down> \\<and>\n                 phase_rel_inv s\\<down> \\<and>\n                 strong_tricolour_inv s\\<down> \\<and>\n                 sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                  s\\<down> \\<and>\n                 tso_store_inv s\\<down> \\<and>\n                 valid_refs_inv s\\<down> \\<and>\n                 valid_W_inv s\\<down> \\<and>\n                 (\\<forall>x.\n                     mut_m.mutator_phase_inv_aux x\n                      (ghost_hs_phase (s\\<down> (mutator x)))\n                      s\\<down>) \\<and>\n                 fA_rel_inv s\\<down> \\<and>\n                 fM_rel_inv s\\<down>)\\<rbrace> mutator m", "apply (rule valid_pre)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>?Q\\<rbrace> mutator\n                          m \\<lbrace>\\<lambda>s.\n  gc.fM_fA_invL s \\<and>\n  gc_mark.mark_object_invL s \\<and>\n  gc.gc_W_empty_invL s \\<and>\n  gc.handshake_invL s \\<and>\n  gc.obj_fields_marked_invL s \\<and>\n  gc.phase_invL s \\<and>\n  gc.sweep_loop_invL s \\<and>\n  gc.tso_lock_invL s \\<and>\n  (\\<forall>x. mut_m.invsL x s) \\<and>\n  handshake_phase_inv s\\<down> \\<and>\n  phase_rel_inv s\\<down> \\<and>\n  strong_tricolour_inv s\\<down> \\<and>\n  sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n  tso_store_inv s\\<down> \\<and>\n  valid_refs_inv s\\<down> \\<and>\n  valid_W_inv s\\<down> \\<and>\n  (\\<forall>x.\n      mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n       s\\<down>) \\<and>\n  fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>\\<rbrace>\n 2. \\<And>s.\n       gc.fM_fA_invL s \\<and>\n       gc_mark.mark_object_invL s \\<and>\n       gc.gc_W_empty_invL s \\<and>\n       gc.handshake_invL s \\<and>\n       gc.obj_fields_marked_invL s \\<and>\n       gc.phase_invL s \\<and>\n       gc.sweep_loop_invL s \\<and>\n       gc.tso_lock_invL s \\<and>\n       (\\<forall>x. mut_m.invsL x s) \\<and>\n       handshake_phase_inv s\\<down> \\<and>\n       phase_rel_inv s\\<down> \\<and>\n       strong_tricolour_inv s\\<down> \\<and>\n       sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n       tso_store_inv s\\<down> \\<and>\n       valid_refs_inv s\\<down> \\<and>\n       valid_W_inv s\\<down> \\<and>\n       (\\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n       fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down> \\<Longrightarrow>\n       ?Q s", "apply ( rule valid_conj_lift valid_all_lift | fastforce )+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       gc.fM_fA_invL s \\<and>\n       gc_mark.mark_object_invL s \\<and>\n       gc.gc_W_empty_invL s \\<and>\n       gc.handshake_invL s \\<and>\n       gc.obj_fields_marked_invL s \\<and>\n       gc.phase_invL s \\<and>\n       gc.sweep_loop_invL s \\<and>\n       gc.tso_lock_invL s \\<and>\n       (\\<forall>x. mut_m.invsL x s) \\<and>\n       handshake_phase_inv s\\<down> \\<and>\n       phase_rel_inv s\\<down> \\<and>\n       strong_tricolour_inv s\\<down> \\<and>\n       sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n       tso_store_inv s\\<down> \\<and>\n       valid_refs_inv s\\<down> \\<and>\n       valid_W_inv s\\<down> \\<and>\n       (\\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n       fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down> \\<Longrightarrow>\n       gc.fM_fA_invL s \\<and>\n       gc_mark.mark_object_invL s \\<and>\n       (handshake_invL s \\<and>\n        mark_object_invL s \\<and>\n        tso_lock_invL s \\<and>\n        mut_get_roots.mark_object_invL m s \\<and>\n        mut_store_del.mark_object_invL m s \\<and>\n        mut_store_ins.mark_object_invL m s \\<and>\n        gc.handshake_invL s \\<and>\n        gc.obj_fields_marked_invL s \\<and>\n        gc.gc_W_empty_invL s \\<and>\n        handshake_phase_inv s\\<down> \\<and>\n        (\\<forall>x.\n            mut_m.mutator_phase_inv_aux x\n             (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n        valid_W_inv s\\<down>) \\<and>\n       (handshake_invL s \\<and> gc.handshake_invL s) \\<and>\n       (handshake_invL s \\<and>\n        gc.handshake_invL s \\<and>\n        gc.obj_fields_marked_invL s \\<and>\n        tso_store_inv s\\<down> \\<and> valid_refs_inv s\\<down>) \\<and>\n       gc.phase_invL s \\<and>\n       (gc.fM_fA_invL s \\<and>\n        gc.handshake_invL s \\<and>\n        gc.sweep_loop_invL s \\<and>\n        (\\<forall>x.\n            mut_m.mutator_phase_inv_aux x\n             (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n        valid_refs_inv s\\<down>) \\<and>\n       gc.tso_lock_invL s \\<and>\n       (\\<forall>x. I s) \\<and>\n       (handshake_invL s \\<and> handshake_phase_inv s\\<down>) \\<and>\n       (handshake_invL s \\<and>\n        handshake_phase_inv s\\<down> \\<and> phase_rel_inv s\\<down>) \\<and>\n       (mark_object_invL s \\<and>\n        mut_get_roots.mark_object_invL m s \\<and>\n        mut_store_del.mark_object_invL m s \\<and>\n        mut_store_ins.mark_object_invL m s \\<and>\n        fA_rel_inv s\\<down> \\<and>\n        fM_rel_inv s\\<down> \\<and>\n        handshake_phase_inv s\\<down> \\<and>\n        (\\<forall>x.\n            mut_m.mutator_phase_inv_aux x\n             (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n        strong_tricolour_inv s\\<down> \\<and>\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n        valid_refs_inv s\\<down>) \\<and>\n       (handshake_invL s \\<and>\n        mark_object_invL s \\<and>\n        mut_get_roots.mark_object_invL m s \\<and>\n        mut_store_del.mark_object_invL m s \\<and>\n        mut_store_ins.mark_object_invL m s \\<and>\n        fA_rel_inv s\\<down> \\<and>\n        fM_rel_inv s\\<down> \\<and>\n        handshake_phase_inv s\\<down> \\<and>\n        (\\<forall>x.\n            mut_m.mutator_phase_inv_aux x\n             (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>) \\<and>\n        phase_rel_inv s\\<down> \\<and>\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n        valid_refs_inv s\\<down>) \\<and>\n       tso_store_inv s\\<down> \\<and>\n       (mark_object_invL s \\<and>\n        mut_get_roots.mark_object_invL m s \\<and>\n        mut_store_del.mark_object_invL m s \\<and>\n        mut_store_ins.mark_object_invL m s \\<and>\n        valid_refs_inv s\\<down>) \\<and>\n       (handshake_invL s \\<and>\n        mark_object_invL s \\<and>\n        tso_lock_invL s \\<and>\n        mut_get_roots.mark_object_invL m s \\<and>\n        mut_store_del.mark_object_invL m s \\<and>\n        mut_store_ins.mark_object_invL m s \\<and>\n        fM_rel_inv s\\<down> \\<and>\n        sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n        valid_refs_inv s\\<down> \\<and> valid_W_inv s\\<down>) \\<and>\n       (\\<forall>x. I s) \\<and>\n       fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>", "apply (simp add: I_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context gc_system\nbegin"], ["", "theorem I: \"gc_system \\<Turnstile>\\<^bsub>pre\\<^esub> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n       FAIR = \\<lambda>s. True\\<rparr> \\<Turnstile>\\<^bsub>pre\\<^esub> I", "apply (rule VCG)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s.\n       initial_state\n        \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n           FAIR = \\<lambda>s. True\\<rparr>\n        s \\<longrightarrow>\n       I \\<lparr>GST = s, HST = []\\<rparr>\n 2. \\<And>p.\n       \\<forall>(c, aft)\n                \\<in>vcg_fragments\n                      (PGMs\n                        \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                           FAIR = \\<lambda>s. True\\<rparr>\n                        p).\n          PGMs\n           \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n              FAIR = \\<lambda>s. True\\<rparr>, p, aft \\<turnstile>\n          \\<lbrace>I\\<rbrace> c", "apply (rule init_inv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>(c, aft)\n                \\<in>vcg_fragments\n                      (PGMs\n                        \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                           FAIR = \\<lambda>s. True\\<rparr>\n                        p).\n          PGMs\n           \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n              FAIR = \\<lambda>s. True\\<rparr>, p, aft \\<turnstile>\n          \\<lbrace>I\\<rbrace> c", "apply (rename_tac p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>(c, aft)\n                \\<in>vcg_fragments\n                      (PGMs\n                        \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                           FAIR = \\<lambda>s. True\\<rparr>\n                        p).\n          PGMs\n           \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n              FAIR = \\<lambda>s. True\\<rparr>, p, aft \\<turnstile>\n          \\<lbrace>I\\<rbrace> c", "apply (case_tac p, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p x1.\n       p = mutator x1 \\<Longrightarrow>\n       \\<forall>x\\<in>vcg_fragments (mut_m.com x1).\n          case x of\n          (c, aft) \\<Rightarrow> gc_coms, mutator x1, aft \\<turnstile>\n            \\<lbrace>I\\<rbrace> c\n 2. \\<And>p.\n       p = gc \\<Longrightarrow>\n       \\<forall>x\\<in>vcg_fragments gc.com.\n          case x of\n          (c, aft) \\<Rightarrow> gc_coms, gc, aft \\<turnstile>\n            \\<lbrace>I\\<rbrace> c\n 3. \\<And>p.\n       p = sys \\<Longrightarrow>\n       \\<forall>x\\<in>vcg_fragments sys.com.\n          case x of\n          (c, aft) \\<Rightarrow> gc_coms, sys, aft \\<turnstile>\n            \\<lbrace>I\\<rbrace> c", "apply (rule mut_m.I[unfolded valid_proc_def, simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p = gc \\<Longrightarrow>\n       \\<forall>x\\<in>vcg_fragments gc.com.\n          case x of\n          (c, aft) \\<Rightarrow> gc_coms, gc, aft \\<turnstile>\n            \\<lbrace>I\\<rbrace> c\n 2. \\<And>p.\n       p = sys \\<Longrightarrow>\n       \\<forall>x\\<in>vcg_fragments sys.com.\n          case x of\n          (c, aft) \\<Rightarrow> gc_coms, sys, aft \\<turnstile>\n            \\<lbrace>I\\<rbrace> c", "apply (rule gc.I[unfolded valid_proc_def, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p = sys \\<Longrightarrow>\n       \\<forall>x\\<in>vcg_fragments sys.com.\n          case x of\n          (c, aft) \\<Rightarrow> gc_coms, sys, aft \\<turnstile>\n            \\<lbrace>I\\<rbrace> c", "apply (rule sys.I[unfolded valid_proc_def, simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\n\\label{sec:proofs-headline-safety}\n\nOur headline safety result follows directly.\n\n\\<close>"], ["", "corollary safety: \"gc_system \\<Turnstile>\\<^bsub>pre\\<^esub> LSTP valid_refs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n       FAIR =\n         \\<lambda>s.\n            True\\<rparr> \\<Turnstile>\\<^bsub>pre\\<^esub> \\<lambda>s.\n                      valid_refs s\\<down>", "using I"], ["proof (prove)\nusing this:\n  \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n     FAIR = \\<lambda>s. True\\<rparr> \\<Turnstile>\\<^bsub>pre\\<^esub> I\n\ngoal (1 subgoal):\n 1. \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n       FAIR =\n         \\<lambda>s.\n            True\\<rparr> \\<Turnstile>\\<^bsub>pre\\<^esub> \\<lambda>s.\n                      valid_refs s\\<down>", "unfolding I_def invs_def valid_refs_def prerun_valid_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     prerun\n      \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n         FAIR = \\<lambda>s. True\\<rparr>\n      \\<sigma> \\<longrightarrow>\n     (\\<box>\\<lceil>\\<lambda>s.\n                       invsL s \\<and>\n                       handshake_phase_inv s\\<down> \\<and>\n                       phase_rel_inv s\\<down> \\<and>\n                       strong_tricolour_inv s\\<down> \\<and>\n                       sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                        s\\<down> \\<and>\n                       tso_store_inv s\\<down> \\<and>\n                       valid_refs_inv s\\<down> \\<and>\n                       valid_W_inv s\\<down> \\<and>\n                       (\\<forall>x.\n                           mut_m.mutator_phase_inv_aux x\n                            (ghost_hs_phase (s\\<down> (mutator x)))\n                            s\\<down>) \\<and>\n                       fA_rel_inv s\\<down> \\<and>\n                       fM_rel_inv s\\<down>\\<rceil>)\n      \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       prerun\n        \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n           FAIR = \\<lambda>s. True\\<rparr>\n        \\<sigma> \\<longrightarrow>\n       (\\<box>\\<lceil>\\<lambda>s.\n                         \\<forall>x.\n                            (\\<exists>xa xb.\n                                xb \\<in> roots\n    (s\\<down> (mutator xa)) \\<and>\n                                (xb reaches x) s\\<down>) \\<longrightarrow>\n                            obj_at (\\<lambda>s. True) x s\\<down>\\<rceil>)\n        \\<sigma>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<forall>\\<sigma>.\n                   prerun\n                    \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                       FAIR = \\<lambda>s. True\\<rparr>\n                    \\<sigma> \\<longrightarrow>\n                   (\\<box>\\<lceil>\\<lambda>s.\n                                     invsL s \\<and>\n                                     handshake_phase_inv s\\<down> \\<and>\n                                     phase_rel_inv s\\<down> \\<and>\n                                     strong_tricolour_inv s\\<down> \\<and>\n                                     sys_phase_inv_aux\n(sys_ghost_hs_phase s\\<down>) s\\<down> \\<and>\n                                     tso_store_inv s\\<down> \\<and>\n                                     valid_refs_inv s\\<down> \\<and>\n                                     valid_W_inv s\\<down> \\<and>\n                                     (\\<forall>x.\n   mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n    s\\<down>) \\<and>\n                                     fA_rel_inv s\\<down> \\<and>\n                                     fM_rel_inv s\\<down>\\<rceil>)\n                    \\<sigma>;\n        prerun\n         \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n            FAIR = \\<lambda>s. True\\<rparr>\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>\\<lceil>\\<lambda>s.\n     \\<forall>x.\n        (\\<exists>xa xb.\n            xb \\<in> roots (s\\<down> (mutator xa)) \\<and>\n            (xb reaches x) s\\<down>) \\<longrightarrow>\n        obj_at (\\<lambda>s. True) x s\\<down>\\<rceil>)\n                          \\<sigma>", "apply (drule_tac x=\\<sigma> in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>prerun\n                 \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                    FAIR = \\<lambda>s. True\\<rparr>\n                 \\<sigma>;\n        prerun\n         \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n            FAIR = \\<lambda>s. True\\<rparr>\n         \\<sigma> \\<longrightarrow>\n        (\\<box>\\<lceil>\\<lambda>s.\n                          invsL s \\<and>\n                          handshake_phase_inv s\\<down> \\<and>\n                          phase_rel_inv s\\<down> \\<and>\n                          strong_tricolour_inv s\\<down> \\<and>\n                          sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                           s\\<down> \\<and>\n                          tso_store_inv s\\<down> \\<and>\n                          valid_refs_inv s\\<down> \\<and>\n                          valid_W_inv s\\<down> \\<and>\n                          (\\<forall>x.\n                              mut_m.mutator_phase_inv_aux x\n                               (ghost_hs_phase (s\\<down> (mutator x)))\n                               s\\<down>) \\<and>\n                          fA_rel_inv s\\<down> \\<and>\n                          fM_rel_inv s\\<down>\\<rceil>)\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>\\<lceil>\\<lambda>s.\n     \\<forall>x.\n        (\\<exists>xa xb.\n            xb \\<in> roots (s\\<down> (mutator xa)) \\<and>\n            (xb reaches x) s\\<down>) \\<longrightarrow>\n        obj_at (\\<lambda>s. True) x s\\<down>\\<rceil>)\n                          \\<sigma>", "apply (drule (1) mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>prerun\n                 \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                    FAIR = \\<lambda>s. True\\<rparr>\n                 \\<sigma>;\n        (\\<box>\\<lceil>\\<lambda>s.\n                          invsL s \\<and>\n                          handshake_phase_inv s\\<down> \\<and>\n                          phase_rel_inv s\\<down> \\<and>\n                          strong_tricolour_inv s\\<down> \\<and>\n                          sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                           s\\<down> \\<and>\n                          tso_store_inv s\\<down> \\<and>\n                          valid_refs_inv s\\<down> \\<and>\n                          valid_W_inv s\\<down> \\<and>\n                          (\\<forall>x.\n                              mut_m.mutator_phase_inv_aux x\n                               (ghost_hs_phase (s\\<down> (mutator x)))\n                               s\\<down>) \\<and>\n                          fA_rel_inv s\\<down> \\<and>\n                          fM_rel_inv s\\<down>\\<rceil>)\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (\\<box>\\<lceil>\\<lambda>s.\n     \\<forall>x.\n        (\\<exists>xa xb.\n            xb \\<in> roots (s\\<down> (mutator xa)) \\<and>\n            (xb reaches x) s\\<down>) \\<longrightarrow>\n        obj_at (\\<lambda>s. True) x s\\<down>\\<rceil>)\n                          \\<sigma>", "apply (rule alwaysI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i.\n       \\<lbrakk>prerun\n                 \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                    FAIR = \\<lambda>s. True\\<rparr>\n                 \\<sigma>;\n        (\\<box>\\<lceil>\\<lambda>s.\n                          invsL s \\<and>\n                          handshake_phase_inv s\\<down> \\<and>\n                          phase_rel_inv s\\<down> \\<and>\n                          strong_tricolour_inv s\\<down> \\<and>\n                          sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                           s\\<down> \\<and>\n                          tso_store_inv s\\<down> \\<and>\n                          valid_refs_inv s\\<down> \\<and>\n                          valid_W_inv s\\<down> \\<and>\n                          (\\<forall>x.\n                              mut_m.mutator_phase_inv_aux x\n                               (ghost_hs_phase (s\\<down> (mutator x)))\n                               s\\<down>) \\<and>\n                          fA_rel_inv s\\<down> \\<and>\n                          fM_rel_inv s\\<down>\\<rceil>)\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lambda>s.\n                                    \\<forall>x.\n (\\<exists>xa xb.\n     xb \\<in> roots (s\\<down> (mutator xa)) \\<and>\n     (xb reaches x) s\\<down>) \\<longrightarrow>\n obj_at (\\<lambda>s. True) x s\\<down>\\<rceil>\n                          (\\<sigma> |\\<^sub>s i)", "apply (erule_tac i=i in alwaysE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> i.\n       \\<lbrakk>prerun\n                 \\<lparr>PGMs = gc_coms, INIT = gc_system_init,\n                    FAIR = \\<lambda>s. True\\<rparr>\n                 \\<sigma>;\n        \\<lceil>\\<lambda>s.\n                   invsL s \\<and>\n                   handshake_phase_inv s\\<down> \\<and>\n                   phase_rel_inv s\\<down> \\<and>\n                   strong_tricolour_inv s\\<down> \\<and>\n                   sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                    s\\<down> \\<and>\n                   tso_store_inv s\\<down> \\<and>\n                   valid_refs_inv s\\<down> \\<and>\n                   valid_W_inv s\\<down> \\<and>\n                   (\\<forall>x.\n                       mut_m.mutator_phase_inv_aux x\n                        (ghost_hs_phase (s\\<down> (mutator x)))\n                        s\\<down>) \\<and>\n                   fA_rel_inv s\\<down> \\<and> fM_rel_inv s\\<down>\\<rceil>\n         (\\<sigma> |\\<^sub>s i)\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lambda>s.\n                                    \\<forall>x.\n (\\<exists>xa xb.\n     xb \\<in> roots (s\\<down> (mutator xa)) \\<and>\n     (xb reaches x) s\\<down>) \\<longrightarrow>\n obj_at (\\<lambda>s. True) x s\\<down>\\<rceil>\n                          (\\<sigma> |\\<^sub>s i)", "apply (clarsimp simp: valid_refs_invD(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text\\<open>\n\nThe GC is correct for the remaining fixed-but-arbitrary initial\nconditions.\n\n\\<close>"], ["", "interpretation gc_system_interpretation: gc_system undefined"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* unused_thms Main Sublist CIMP - *)"], ["", "section\\<open> A concrete system state \\label{sec:concrete-system-state} \\<close>"], ["", "text\\<open>\n\nWe demonstrate that our definitions are not vacuous by exhibiting a\nconcrete initial state that satisfies the initial conditions. The heap\nis shown in Figure~\\ref{fig:concrete-heap}. We use Isabelle's notation\nfor types of a given size.\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{heap.pdf}\n  \\caption{A concrete system state.}\n  \\label{fig:concrete-heap}\n\\end{figure}\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}