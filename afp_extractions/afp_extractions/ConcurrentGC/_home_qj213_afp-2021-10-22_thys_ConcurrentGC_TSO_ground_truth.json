{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/TSO.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma tso_lock_invL[intro]:\n  \"\\<lbrace> tso_lock_invL \\<rbrace> gc\"", "lemma tso_store_inv[intro]:\n  \"\\<lbrace> LSTP tso_store_inv \\<rbrace> gc\"", "lemma mut_tso_lock_invL[intro]:\n  \"\\<lbrace> mut_m.tso_lock_invL m \\<rbrace> gc\"", "lemma tso_store_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP tso_store_inv \\<rbrace> mutator m\"", "lemma gc_tso_lock_invL[intro]:\n  \"\\<lbrace> gc.tso_lock_invL \\<rbrace> mutator m\"", "lemma tso_lock_invL[intro]:\n  \"\\<lbrace> tso_lock_invL \\<rbrace> mutator m\"", "lemma tso_lock_invL[intro]:\n  \"\\<lbrace> tso_lock_invL \\<rbrace> mutator m'\"", "lemma tso_gc_store_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP tso_store_inv \\<rbrace> sys\"", "lemma gc_tso_lock_invL[intro]:\n  \"\\<lbrace> gc.tso_lock_invL \\<rbrace> sys\"", "lemma mut_tso_lock_invL[intro]:\n  \"\\<lbrace> mut_m.tso_lock_invL m \\<rbrace> sys\""], "translations": [["", "lemma tso_lock_invL[intro]:\n  \"\\<lbrace> tso_lock_invL \\<rbrace> gc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>tso_lock_invL\\<rbrace> gc", "by vcg_jackhammer"], ["", "lemma tso_store_inv[intro]:\n  \"\\<lbrace> LSTP tso_store_inv \\<rbrace> gc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s. tso_store_inv s\\<down>)\\<rbrace> gc", "unfolding tso_store_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s.\n                 (\\<forall>x.\n                     x \\<in> set (sys_mem_store_buffers gc\n                                   s\\<down>) \\<longrightarrow>\n                     gc_writes x) \\<and>\n                 (\\<forall>x xa.\n                     xa \\<in> set (sys_mem_store_buffers (mutator x)\n                                    s\\<down>) \\<longrightarrow>\n                     mut_writes xa))\\<rbrace> gc", "by vcg_jackhammer"], ["", "lemma mut_tso_lock_invL[intro]:\n  \"\\<lbrace> mut_m.tso_lock_invL m \\<rbrace> gc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>mut_m.tso_lock_invL m\\<rbrace> gc", "by (vcg_chainsaw mut_m.tso_lock_invL_def)"], ["", "end"], ["", "context mut_m\nbegin"], ["", "lemma tso_store_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP tso_store_inv \\<rbrace> mutator m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s. tso_store_inv s\\<down>)\\<rbrace> mutator m", "unfolding tso_store_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s.\n                 (\\<forall>x.\n                     x \\<in> set (sys_mem_store_buffers gc\n                                   s\\<down>) \\<longrightarrow>\n                     gc_writes x) \\<and>\n                 (\\<forall>x xa.\n                     xa \\<in> set (sys_mem_store_buffers (mutator x)\n                                    s\\<down>) \\<longrightarrow>\n                     mut_writes xa))\\<rbrace> mutator m", "by vcg_jackhammer"], ["", "lemma gc_tso_lock_invL[intro]:\n  \"\\<lbrace> gc.tso_lock_invL \\<rbrace> mutator m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>gc.tso_lock_invL\\<rbrace> mutator m", "by (vcg_chainsaw gc.tso_lock_invL_def)"], ["", "lemma tso_lock_invL[intro]:\n  \"\\<lbrace> tso_lock_invL \\<rbrace> mutator m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>tso_lock_invL\\<rbrace> mutator m", "by vcg_jackhammer"], ["", "end"], ["", "context mut_m'\nbegin"], ["", "lemma tso_lock_invL[intro]:\n  \"\\<lbrace> tso_lock_invL \\<rbrace> mutator m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>tso_lock_invL\\<rbrace> mutator m'", "by (vcg_chainsaw tso_lock_invL)"], ["", "end"], ["", "context sys\nbegin"], ["", "lemma tso_gc_store_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> LSTP tso_store_inv \\<rbrace> sys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>(\\<lambda>s. tso_store_inv s\\<down>)\\<rbrace> sys", "apply (vcg_chainsaw tso_store_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' w ws x xa.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (mutator x := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        sys_mem_store_buffers (mutator x) s\\<down> = w # ws;\n        not_blocked (s\\<down> sys) (mutator x);\n        \\<forall>x.\n           x \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n           gc_writes x;\n        \\<forall>x xa.\n           xa \\<in> set (sys_mem_store_buffers (mutator x)\n                          s\\<down>) \\<longrightarrow>\n           mut_writes xa;\n        xa \\<in> set ws\\<rbrakk>\n       \\<Longrightarrow> mut_writes xa", "apply (metis (no_types) list.set_intros(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gc_tso_lock_invL[intro]:\n  \"\\<lbrace> gc.tso_lock_invL \\<rbrace> sys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>gc.tso_lock_invL\\<rbrace> sys", "by (vcg_chainsaw gc.tso_lock_invL_def)"], ["", "lemma mut_tso_lock_invL[intro]:\n  \"\\<lbrace> mut_m.tso_lock_invL m \\<rbrace> sys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>mut_m.tso_lock_invL m\\<rbrace> sys", "by (vcg_chainsaw mut_m.tso_lock_invL_def)"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}