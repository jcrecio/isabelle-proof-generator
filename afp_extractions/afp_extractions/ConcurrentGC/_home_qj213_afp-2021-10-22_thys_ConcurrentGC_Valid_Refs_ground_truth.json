{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Valid_Refs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemma valid_refs_inv_sweep_loop_free:\n  assumes \"valid_refs_inv s\"\n  assumes ngr: \"no_grey_refs s\"\n  assumes rsi: \"\\<forall>m'. mut_m.reachable_snapshot_inv m' s\"\n  assumes \"white r' s\"\n  shows \"valid_refs_inv (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\"", "lemma (in gc) valid_refs_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> fM_fA_invL \\<^bold>\\<and> handshake_invL \\<^bold>\\<and> gc_W_empty_invL \\<^bold>\\<and> gc_mark.mark_object_invL \\<^bold>\\<and> obj_fields_marked_invL \\<^bold>\\<and> phase_invL \\<^bold>\\<and> sweep_loop_invL\n       \\<^bold>\\<and> LSTP (handshake_phase_inv \\<^bold>\\<and> mutators_phase_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     gc\n   \\<lbrace> LSTP valid_refs_inv \\<rbrace>\"", "lemma valid_refs_inv_discard_roots:\n  \"\\<lbrakk> valid_refs_inv s; roots' \\<subseteq> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>))\"", "lemma valid_refs_inv_load:\n  \"\\<lbrakk> valid_refs_inv s; sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'; r \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>roots := mut_roots s \\<union> Option.set_option r'\\<rparr>))\"", "lemma valid_refs_inv_alloc:\n  \"\\<lbrakk> valid_refs_inv s; sys_heap s r' = None \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>roots := insert r' (mut_roots s)\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\"", "lemma valid_refs_inv_store_ins:\n  \"\\<lbrakk> valid_refs_inv s; r \\<in> mut_roots s; (\\<exists>r'. opt_r' = Some r') \\<longrightarrow> the opt_r' \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr> ghost_honorary_root := {} \\<rparr>,\n                          sys := s sys\\<lparr> mem_store_buffers := (mem_store_buffers (s sys))(mutator m := sys_mem_store_buffers (mutator m) s @ [mw_Mutate r f opt_r']) \\<rparr>))\"", "lemma valid_refs_inv_deref_del:\n  \"\\<lbrakk> valid_refs_inv s; sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; r \\<in> mut_roots s; mut_ghost_honorary_root s = {} \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_root := Option.set_option opt_r', ref := opt_r'\\<rparr>))\"", "lemma valid_refs_inv_mo_co_mark:\n  \"\\<lbrakk> r \\<in> mut_roots s \\<union> mut_ghost_honorary_root s; mut_ghost_honorary_grey s = {}; valid_refs_inv s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\"", "lemma valid_refs_inv[intro]:\n  notes fun_upd_apply[simp]\n  notes valid_refs_inv_discard_roots[simp]\n  notes valid_refs_inv_load[simp]\n  notes valid_refs_inv_alloc[simp]\n  notes valid_refs_inv_store_ins[simp]\n  notes valid_refs_inv_deref_del[simp]\n  notes valid_refs_inv_mo_co_mark[simp]\n  shows\n  \"\\<lbrace> mark_object_invL\n       \\<^bold>\\<and> mut_get_roots.mark_object_invL m\n       \\<^bold>\\<and> mut_store_del.mark_object_invL m\n       \\<^bold>\\<and> mut_store_ins.mark_object_invL m\n       \\<^bold>\\<and> LSTP valid_refs_inv \\<rbrace>\n     mutator m\n   \\<lbrace> LSTP valid_refs_inv \\<rbrace>\"", "lemma (in sys) valid_refs_inv[intro]:\n  \"\\<lbrace> LSTP (valid_refs_inv \\<^bold>\\<and> tso_store_inv) \\<rbrace> sys \\<lbrace> LSTP valid_refs_inv \\<rbrace>\""], "translations": [["", "lemma valid_refs_inv_sweep_loop_free:\n  assumes \"valid_refs_inv s\"\n  assumes ngr: \"no_grey_refs s\"\n  assumes rsi: \"\\<forall>m'. mut_m.reachable_snapshot_inv m' s\"\n  assumes \"white r' s\"\n  shows \"valid_refs_inv (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))", "using assms"], ["proof (prove)\nusing this:\n  valid_refs_inv s\n  no_grey_refs s\n  \\<forall>m'. mut_m.reachable_snapshot_inv m' s\n  white r' s\n\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))", "unfolding valid_refs_inv_def grey_reachable_def no_grey_refs_def"], ["proof (prove)\nusing this:\n  \\<forall>x xa.\n     mut_m.reachable x xa s \\<or>\n     (\\<exists>x. grey x s \\<and> (x reaches xa) s) \\<longrightarrow>\n     obj_at (\\<lambda>s. True) xa s\n  \\<forall>x. \\<not> grey x s\n  \\<forall>m'. mut_m.reachable_snapshot_inv m' s\n  white r' s\n\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       mut_m.reachable x xa\n        (s(sys := s sys\n             \\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) \\<or>\n       (\\<exists>x.\n           grey x\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>)) \\<and>\n           (x reaches xa)\n            (s(sys := s sys\n                 \\<lparr>heap := (sys_heap s)\n                           (r' := None)\\<rparr>))) \\<longrightarrow>\n       obj_at (\\<lambda>s. True) xa\n        (s(sys := s sys\\<lparr>heap := (sys_heap s)(r' := None)\\<rparr>))", "apply (clarsimp dest!: reachable_sweep_loop_free)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   mut_m.reachable x xa s \\<longrightarrow>\n                   obj_at (\\<lambda>s. True) xa s;\n        \\<forall>x. \\<not> grey x s;\n        \\<forall>m'. mut_m.reachable_snapshot_inv m' s; white r' s;\n        mut_m.reachable x r' s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule mut_m.reachable_blackD[OF ngr spec[OF rsi]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x xa.\n                   mut_m.reachable x xa s \\<longrightarrow>\n                   obj_at (\\<lambda>s. True) xa s;\n        \\<forall>x. \\<not> grey x s;\n        \\<forall>m'. mut_m.reachable_snapshot_inv m' s; white r' s;\n        black r' s\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto split: obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in gc) valid_refs_inv[intro]:\n  notes fun_upd_apply[simp]\n  shows\n  \"\\<lbrace> fM_fA_invL \\<^bold>\\<and> handshake_invL \\<^bold>\\<and> gc_W_empty_invL \\<^bold>\\<and> gc_mark.mark_object_invL \\<^bold>\\<and> obj_fields_marked_invL \\<^bold>\\<and> phase_invL \\<^bold>\\<and> sweep_loop_invL\n       \\<^bold>\\<and> LSTP (handshake_phase_inv \\<^bold>\\<and> mutators_phase_inv \\<^bold>\\<and> sys_phase_inv \\<^bold>\\<and> valid_refs_inv \\<^bold>\\<and> valid_W_inv) \\<rbrace>\n     gc\n   \\<lbrace> LSTP valid_refs_inv \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                fM_fA_invL s \\<and>\n                handshake_invL s \\<and>\n                gc_W_empty_invL s \\<and>\n                gc_mark.mark_object_invL s \\<and>\n                obj_fields_marked_invL s \\<and>\n                phase_invL s \\<and>\n                sweep_loop_invL s \\<and>\n                handshake_phase_inv s\\<down> \\<and>\n                (\\<forall>x.\n                    mut_m.mutator_phase_inv_aux x\n                     (ghost_hs_phase (s\\<down> (mutator x)))\n                     s\\<down>) \\<and>\n                sys_phase_inv_aux (sys_ghost_hs_phase s\\<down>)\n                 s\\<down> \\<and>\n                valid_refs_inv s\\<down> \\<and>\n                valid_W_inv\n                 s\\<down>\\<rbrace> gc \\<lbrace>\\<lambda>s.\n            valid_refs_inv s\\<down>\\<rbrace>", "proof(vcg_jackhammer (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (gc_tmp_ref s\\<down> := None)\\<rparr>);\n        taken gc sweep_loop_free s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_phase s\\<down> = ph_Sweep;\n        \\<forall>x.\n           x \\<notin> gc_refs s\\<down> \\<and>\n           obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>; no_grey_refs s\\<down>;\n        gc_W s\\<down> = {}; gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n         (gc_tmp_ref s\\<down>) s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (gc_tmp_ref s\\<down> := None)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_hs_type s\\<down> = ht_GetWork; gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        gc_field_set s\\<down> = {}; sys_fA s\\<down> = sys_fM s\\<down>;\n        gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "case (sweep_loop_free s s')"], ["proof (state)\nthis:\n  at gc sweep_loop_free s\n  at sys sys.sys_free s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (gc_tmp_ref s\\<down> := None)\\<rparr>)\n  taken gc sweep_loop_free s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  handshake_phase_inv s\\<down>\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_fA s\\<down> = sys_fM s\\<down>\n  filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = []\n  gc_phase s\\<down> = ph_Sweep\n  \\<forall>x.\n     x \\<notin> gc_refs s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  gc_fM s\\<down> = sys_fM s\\<down>\n  no_grey_refs s\\<down>\n  gc_W s\\<down> = {}\n  gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = []\n  \\<forall>x. \\<not> sys_hs_pending x s\\<down>\n  All (ghost_hs_in_sync (s\\<down> sys))\n  sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep\n  gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n   (gc_tmp_ref s\\<down>) s\\<down>\n\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n        s'\\<down> = s\\<down>\n        (sys := s\\<down> sys\n           \\<lparr>heap := (sys_heap s\\<down>)\n                     (gc_tmp_ref s\\<down> := None)\\<rparr>);\n        taken gc sweep_loop_free s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_phase s\\<down> = ph_Sweep;\n        \\<forall>x.\n           x \\<notin> gc_refs s\\<down> \\<and>\n           obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n           marked x s\\<down>;\n        gc_fM s\\<down> = sys_fM s\\<down>; no_grey_refs s\\<down>;\n        gc_W s\\<down> = {}; gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n        obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n         (gc_tmp_ref s\\<down>) s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (sys := s\\<down> sys\n                              \\<lparr>heap := (sys_heap s\\<down>)\n  (gc_tmp_ref s\\<down> := None)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_hs_type s\\<down> = ht_GetWork; gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 3. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        gc_field_set s\\<down> = {}; sys_fA s\\<down> = sys_fM s\\<down>;\n        gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 4. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>))\n 5. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at gc sweep_loop_free s\n  at sys sys.sys_free s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (gc_tmp_ref s\\<down> := None)\\<rparr>)\n  taken gc sweep_loop_free s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  handshake_phase_inv s\\<down>\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_fA s\\<down> = sys_fM s\\<down>\n  filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = []\n  gc_phase s\\<down> = ph_Sweep\n  \\<forall>x.\n     x \\<notin> gc_refs s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  gc_fM s\\<down> = sys_fM s\\<down>\n  no_grey_refs s\\<down>\n  gc_W s\\<down> = {}\n  gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = []\n  \\<forall>x. \\<not> sys_hs_pending x s\\<down>\n  All (ghost_hs_in_sync (s\\<down> sys))\n  sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep\n  gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n   (gc_tmp_ref s\\<down>) s\\<down>", "show ?case"], ["proof (prove)\nusing this:\n  at gc sweep_loop_free s\n  at sys sys.sys_free s\n  s'\\<down> = s\\<down>\n  (sys := s\\<down> sys\n     \\<lparr>heap := (sys_heap s\\<down>)\n               (gc_tmp_ref s\\<down> := None)\\<rparr>)\n  taken gc sweep_loop_free s'\n  \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p''\n  handshake_phase_inv s\\<down>\n  \\<forall>x.\n     mut_m.mutator_phase_inv_aux x (ghost_hs_phase (s\\<down> (mutator x)))\n      s\\<down>\n  valid_refs_inv s\\<down>\n  valid_W_inv s\\<down>\n  sys_fA s\\<down> = sys_fM s\\<down>\n  filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = []\n  gc_phase s\\<down> = ph_Sweep\n  \\<forall>x.\n     x \\<notin> gc_refs s\\<down> \\<and>\n     obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n     marked x s\\<down>\n  gc_fM s\\<down> = sys_fM s\\<down>\n  no_grey_refs s\\<down>\n  gc_W s\\<down> = {}\n  gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>\n  gc_ghost_honorary_grey s\\<down> = {}\n  filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = []\n  \\<forall>x. \\<not> sys_hs_pending x s\\<down>\n  All (ghost_hs_in_sync (s\\<down> sys))\n  sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep\n  gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>)\n  obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n   (gc_tmp_ref s\\<down>) s\\<down>\n\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s\\<down>\n      (sys := s\\<down> sys\n         \\<lparr>heap := (sys_heap s\\<down>)\n                   (gc_tmp_ref s\\<down> := None)\\<rparr>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (gc_tmp_ref s\\<down> := None)\\<rparr>);\n     taken gc sweep_loop_free s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_fA s\\<down> = sys_fM s\\<down>;\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n     gc_phase s\\<down> = ph_Sweep;\n     \\<forall>x.\n        x \\<notin> gc_refs s\\<down> \\<and>\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        marked x s\\<down>;\n     gc_fM s\\<down> = sys_fM s\\<down>; no_grey_refs s\\<down>;\n     gc_W s\\<down> = {}; gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n     gc_ghost_honorary_grey s\\<down> = {};\n     filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n     \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n     All (ghost_hs_in_sync (s\\<down> sys));\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n      (gc_tmp_ref s\\<down>) s\\<down>\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (gc_tmp_ref s\\<down> := None)\\<rparr>))", "apply (drule (1) handshake_in_syncD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (gc_tmp_ref s\\<down> := None)\\<rparr>);\n     taken gc sweep_loop_free s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_fA s\\<down> = sys_fM s\\<down>;\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n     gc_phase s\\<down> = ph_Sweep;\n     \\<forall>x.\n        x \\<notin> gc_refs s\\<down> \\<and>\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        marked x s\\<down>;\n     gc_fM s\\<down> = sys_fM s\\<down>; no_grey_refs s\\<down>;\n     gc_W s\\<down> = {}; gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n     gc_ghost_honorary_grey s\\<down> = {};\n     filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n     \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n      (gc_tmp_ref s\\<down>) s\\<down>;\n     \\<forall>m'.\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down>\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s\\<down>\n                        (sys := s\\<down> sys\n                           \\<lparr>heap := (sys_heap s\\<down>)\n                                     (gc_tmp_ref s\\<down> := None)\\<rparr>))", "apply (rule valid_refs_inv_sweep_loop_free, assumption, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (gc_tmp_ref s\\<down> := None)\\<rparr>);\n     taken gc sweep_loop_free s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_fA s\\<down> = sys_fM s\\<down>;\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n     gc_phase s\\<down> = ph_Sweep;\n     \\<forall>x.\n        x \\<notin> gc_refs s\\<down> \\<and>\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        marked x s\\<down>;\n     gc_fM s\\<down> = sys_fM s\\<down>; no_grey_refs s\\<down>;\n     gc_W s\\<down> = {}; gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n     gc_ghost_honorary_grey s\\<down> = {};\n     filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n     \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n      (gc_tmp_ref s\\<down>) s\\<down>;\n     \\<forall>m'.\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>m'. mut_m.reachable_snapshot_inv m' s\\<down>\n 2. \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (gc_tmp_ref s\\<down> := None)\\<rparr>);\n     taken gc sweep_loop_free s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_fA s\\<down> = sys_fM s\\<down>;\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n     gc_phase s\\<down> = ph_Sweep;\n     \\<forall>x.\n        x \\<notin> gc_refs s\\<down> \\<and>\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        marked x s\\<down>;\n     gc_fM s\\<down> = sys_fM s\\<down>; no_grey_refs s\\<down>;\n     gc_W s\\<down> = {}; gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n     gc_ghost_honorary_grey s\\<down> = {};\n     filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n     \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n      (gc_tmp_ref s\\<down>) s\\<down>;\n     \\<forall>m'.\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down>\\<rbrakk>\n    \\<Longrightarrow> white (gc_tmp_ref s\\<down>) s\\<down>", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>at gc sweep_loop_free s; at sys sys.sys_free s;\n     s'\\<down> = s\\<down>\n     (sys := s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (gc_tmp_ref s\\<down> := None)\\<rparr>);\n     taken gc sweep_loop_free s';\n     \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n     handshake_phase_inv s\\<down>;\n     \\<forall>x.\n        mut_m.mutator_phase_inv_aux x\n         (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n     valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n     sys_fA s\\<down> = sys_fM s\\<down>;\n     filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n     gc_phase s\\<down> = ph_Sweep;\n     \\<forall>x.\n        x \\<notin> gc_refs s\\<down> \\<and>\n        obj_at (\\<lambda>s. True) x s\\<down> \\<longrightarrow>\n        marked x s\\<down>;\n     gc_fM s\\<down> = sys_fM s\\<down>; no_grey_refs s\\<down>;\n     gc_W s\\<down> = {}; gc_tmp_ref s\\<down> \\<in> gc_refs s\\<down>;\n     gc_ghost_honorary_grey s\\<down> = {};\n     filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n     \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n     sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n     gc_mark s\\<down> = Some (\\<not> sys_fM s\\<down>);\n     obj_at (\\<lambda>obj. obj_mark obj = (\\<not> sys_fM s\\<down>))\n      (gc_tmp_ref s\\<down>) s\\<down>;\n     \\<forall>m'.\n        ghost_hs_phase (s\\<down> (mutator m')) =\n        sys_ghost_hs_phase s\\<down>\\<rbrakk>\n    \\<Longrightarrow> white (gc_tmp_ref s\\<down>) s\\<down>", "apply (simp add: white_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* FIXME rule? *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_refs_inv\n   (s\\<down>\n    (sys := s\\<down> sys\n       \\<lparr>heap := (sys_heap s\\<down>)\n                 (gc_tmp_ref s\\<down> := None)\\<rparr>))\n\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_work_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_work_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_hs_type s\\<down> = ht_GetWork; gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_blacken s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\n           \\<lparr>W := gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>);\n        taken gc mark_loop_blacken s';\n        \\<forall>p''\\<in>- {gc}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        gc_field_set s\\<down> = {}; sys_fA s\\<down> = sys_fM s\\<down>;\n        gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W :=\n  gc_W s\\<down> - {gc_tmp_ref s\\<down>}\\<rparr>))\n 3. \\<And>s s' y.\n       \\<lbrakk>at gc mark_loop_mo_co_mark s; at sys sys.tso_store s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>ghost_honorary_grey := {y}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (gc :=\n                        sys_mem_store_buffers gc s\\<down> @\n                        [mw_Mark y (sys_fM s\\<down>)])\\<rparr>);\n        taken gc mark_loop_mo_co_mark s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        obj_at_field_on_heap (\\<lambda>r'. y = r' \\<or> marked r' s\\<down>)\n         (gc_tmp_ref s\\<down>) (gc_field s\\<down>) s\\<down>;\n        \\<forall>x.\n           (y reaches x) s\\<down> \\<longrightarrow>\n           obj_at (\\<lambda>s. True) x s\\<down>;\n        gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>;\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        gc_cas_mark s\\<down> = gc_mark s\\<down>; obj_fields_marked s\\<down>;\n        gc_tmp_ref s\\<down> \\<in> gc_W s\\<down>; gc_ref s\\<down> = Some y;\n        white y s\\<down>;\n        filter is_mw_Mark (sys_mem_store_buffers gc s\\<down>) = []\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>ghost_honorary_grey := {y}\\<rparr>))\n 4. \\<And>s s'.\n       \\<lbrakk>at gc mark_loop_get_roots_load_W s;\n        at sys sys.sys_hs_gc_load_W s;\n        s'\\<down> = s\\<down>\n        (gc := s\\<down> gc\\<lparr>W := sys_W s\\<down>\\<rparr>,\n         sys := s\\<down> sys\\<lparr>W := {}\\<rparr>);\n        taken gc mark_loop_get_roots_load_W s';\n        \\<forall>p''\\<in>- {gc, sys}. GST s' p'' = GST s p'';\n        handshake_phase_inv s\\<down>;\n        \\<forall>x.\n           mut_m.mutator_phase_inv_aux x\n            (ghost_hs_phase (s\\<down> (mutator x))) s\\<down>;\n        valid_refs_inv s\\<down>; valid_W_inv s\\<down>;\n        sys_W s\\<down> = {} \\<longrightarrow> no_grey_refs s\\<down>;\n        sys_fA s\\<down> = sys_fM s\\<down>;\n        \\<forall>x. mut_m.gc_W_empty_mut_inv x s\\<down>;\n        sys_hs_type s\\<down> = ht_GetRoots; gc_phase s\\<down> = ph_Mark;\n        filter is_mw_fM (sys_mem_store_buffers gc s\\<down>) = [];\n        filter is_mw_Phase (sys_mem_store_buffers gc s\\<down>) = [];\n        gc_fM s\\<down> = sys_fM s\\<down>; gc_W s\\<down> = {};\n        gc_ghost_honorary_grey s\\<down> = {};\n        filter is_mw_fA (sys_mem_store_buffers gc s\\<down>) = [];\n        \\<forall>x. \\<not> sys_hs_pending x s\\<down>;\n        All (ghost_hs_in_sync (s\\<down> sys));\n        sys_ghost_hs_phase s\\<down> = hp_IdleMarkSweep;\n        sys_phase s\\<down> = ph_Idle \\<longrightarrow>\n        no_grey_refs s\\<down>;\n        mw_Phase ph_Idle\n        \\<in> set (sys_mem_store_buffers gc s\\<down>) \\<longrightarrow>\n        no_grey_refs s\\<down>\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (gc := s\\<down> gc\n                              \\<lparr>W := sys_W s\\<down>\\<rparr>,\n                            sys := s\\<down> sys\\<lparr>W := {}\\<rparr>))", "qed (auto simp: valid_refs_inv_def grey_reachable_def)"], ["", "context mut_m\nbegin"], ["", "lemma valid_refs_inv_discard_roots:\n  \"\\<lbrakk> valid_refs_inv s; roots' \\<subseteq> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_refs_inv s; roots' \\<subseteq> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>roots := roots'\\<rparr>))", "unfolding valid_refs_inv_def mut_m.reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>xb.\n                    xb \\<in> roots (s (mutator x)) \\<union>\n                             ghost_honorary_root (s (mutator x)) \\<union>\n                             mut_m.tso_store_refs x s \\<and>\n                    (xb reaches xa) s) \\<or>\n                grey_reachable xa s \\<longrightarrow>\n                obj_at (\\<lambda>s. True) xa s;\n     roots' \\<subseteq> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x xa.\n                         (\\<exists>xb.\n                             xb \\<in> roots\n ((s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>))\n   (mutator x)) \\<union>\nghost_honorary_root\n ((s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>))\n   (mutator x)) \\<union>\nmut_m.tso_store_refs x\n (s(mutator m := s (mutator m)\\<lparr>roots := roots'\\<rparr>)) \\<and>\n                             (xb reaches xa)\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>roots := roots'\\<rparr>))) \\<or>\n                         grey_reachable xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   roots'\\<rparr>)) \\<longrightarrow>\n                         obj_at (\\<lambda>s. True) xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots := roots'\\<rparr>))", "by (auto simp: fun_upd_apply)"], ["", "lemma valid_refs_inv_load:\n  \"\\<lbrakk> valid_refs_inv s; sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r'; r \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>roots := mut_roots s \\<union> Option.set_option r'\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_refs_inv s;\n     sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r';\n     r \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>roots :=\nmut_roots s \\<union> set_option r'\\<rparr>))", "unfolding valid_refs_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x xa.\n                mut_m.reachable x xa s \\<or>\n                grey_reachable xa s \\<longrightarrow>\n                obj_at (\\<lambda>s. True) xa s;\n     sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref r';\n     r \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x xa.\n                         mut_m.reachable x xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s \\<union> set_option r'\\<rparr>)) \\<or>\n                         grey_reachable xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s \\<union> set_option r'\\<rparr>)) \\<longrightarrow>\n                         obj_at (\\<lambda>s. True) xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   mut_roots s \\<union> set_option r'\\<rparr>))", "by (simp add: fun_upd_apply)"], ["", "lemma valid_refs_inv_alloc:\n  \"\\<lbrakk> valid_refs_inv s; sys_heap s r' = None \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>roots := insert r' (mut_roots s)\\<rparr>, sys := s sys\\<lparr>heap := sys_heap s(r' \\<mapsto> \\<lparr>obj_mark = fl, obj_fields = Map.empty, obj_payload = Map.empty\\<rparr>)\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_refs_inv s; sys_heap s r' = None\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>roots :=\ninsert r' (mut_roots s)\\<rparr>,\n                          sys := s sys\n                            \\<lparr>heap := sys_heap s(r' \\<mapsto>\n\\<lparr>obj_mark = fl, obj_fields = Map.empty,\n   obj_payload = Map.empty\\<rparr>)\\<rparr>))", "unfolding valid_refs_inv_def mut_m.reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x xa.\n                (\\<exists>xb.\n                    xb \\<in> roots (s (mutator x)) \\<union>\n                             ghost_honorary_root (s (mutator x)) \\<union>\n                             mut_m.tso_store_refs x s \\<and>\n                    (xb reaches xa) s) \\<or>\n                grey_reachable xa s \\<longrightarrow>\n                obj_at (\\<lambda>s. True) xa s;\n     sys_heap s r' = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x xa.\n                         (\\<exists>xb.\n                             xb \\<in> roots\n ((s(mutator m := s (mutator m)\n       \\<lparr>roots := insert r' (mut_roots s)\\<rparr>,\n     sys := s sys\n       \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                 \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                    obj_payload = Map.empty\\<rparr>)\\<rparr>))\n   (mutator x)) \\<union>\nghost_honorary_root\n ((s(mutator m := s (mutator m)\n       \\<lparr>roots := insert r' (mut_roots s)\\<rparr>,\n     sys := s sys\n       \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                 \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                    obj_payload = Map.empty\\<rparr>)\\<rparr>))\n   (mutator x)) \\<union>\nmut_m.tso_store_refs x\n (s(mutator m := s (mutator m)\n      \\<lparr>roots := insert r' (mut_roots s)\\<rparr>,\n    sys := s sys\n      \\<lparr>heap := sys_heap s(r' \\<mapsto>\n                \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n                   obj_payload = Map.empty\\<rparr>)\\<rparr>)) \\<and>\n                             (xb reaches xa)\n                              (s(mutator m := s (mutator m)\n                                   \\<lparr>roots :=\n       insert r' (mut_roots s)\\<rparr>,\n                                 sys := s sys\n                                   \\<lparr>heap := sys_heap s(r' \\<mapsto>\n       \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n          obj_payload = Map.empty\\<rparr>)\\<rparr>))) \\<or>\n                         grey_reachable xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   insert r' (mut_roots s)\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r' \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>)) \\<longrightarrow>\n                         obj_at (\\<lambda>s. True) xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>roots :=\n   insert r' (mut_roots s)\\<rparr>,\n                             sys := s sys\n                               \\<lparr>heap := sys_heap s(r' \\<mapsto>\n   \\<lparr>obj_mark = fl, obj_fields = Map.empty,\n      obj_payload = Map.empty\\<rparr>)\\<rparr>))", "apply (clarsimp simp: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<forall>x xa.\n                   ((\\<exists>xb.\n                        (xb \\<in> roots (s (mutator x)) \\<or>\n                         xb \\<in> ghost_honorary_root (s (mutator x)) \\<or>\n                         xb \\<in> mut_m.tso_store_refs x s) \\<and>\n                        (xb reaches xa) s) \\<longrightarrow>\n                    obj_at (\\<lambda>s. True) xa s) \\<and>\n                   (grey_reachable xa s \\<longrightarrow>\n                    obj_at (\\<lambda>s. True) xa s);\n        sys_heap s r' = None;\n        xa = r' \\<or>\n        xa \\<in> mut_roots s \\<or>\n        xa \\<in> mut_ghost_honorary_root s \\<or> xa \\<in> tso_store_refs s;\n        (xa reaches x) s; x \\<noteq> r'\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) x s", "apply (auto elim: converse_reachesE split: obj_at_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_refs_inv_store_ins:\n  \"\\<lbrakk> valid_refs_inv s; r \\<in> mut_roots s; (\\<exists>r'. opt_r' = Some r') \\<longrightarrow> the opt_r' \\<in> mut_roots s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr> ghost_honorary_root := {} \\<rparr>,\n                          sys := s sys\\<lparr> mem_store_buffers := (mem_store_buffers (s sys))(mutator m := sys_mem_store_buffers (mutator m) s @ [mw_Mutate r f opt_r']) \\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s;\n     (\\<exists>r'. opt_r' = Some r') \\<longrightarrow>\n     the opt_r' \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                          sys := s sys\n                            \\<lparr>mem_store_buffers :=\n(mem_store_buffers (s sys))\n(mutator m :=\n   sys_mem_store_buffers (mutator m) s @ [mw_Mutate r f opt_r'])\\<rparr>))", "apply (subst valid_refs_inv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s;\n     (\\<exists>r'. opt_r' = Some r') \\<longrightarrow>\n     the opt_r' \\<in> mut_roots s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x xa.\n                         mut_m.reachable x xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s @\n      [mw_Mutate r f opt_r'])\\<rparr>)) \\<or>\n                         grey_reachable xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s @\n      [mw_Mutate r f opt_r'])\\<rparr>)) \\<longrightarrow>\n                         obj_at (\\<lambda>s. True) xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                             sys := s sys\n                               \\<lparr>mem_store_buffers :=\n   (mem_store_buffers (s sys))\n   (mutator m :=\n      sys_mem_store_buffers (mutator m) s @\n      [mw_Mutate r f opt_r'])\\<rparr>))", "apply (auto simp: grey_reachable_def mut_m.reachable_def fun_upd_apply)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s; opt_r' = None;\n        (xb reaches xa) s;\n        xb \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f None])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s\n 2. \\<And>x xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s; opt_r' = None;\n        x \\<noteq> m; (xb reaches xa) s;\n        xb \\<in> mut_m.tso_store_refs x\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f None])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s\n 3. \\<And>xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s;\n        the opt_r' \\<in> mut_roots s; (xb reaches xa) s;\n        xb \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f\nopt_r'])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s\n 4. \\<And>x xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s;\n        the opt_r' \\<in> mut_roots s; x \\<noteq> m; (xb reaches xa) s;\n        xb \\<in> mut_m.tso_store_refs x\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f\nopt_r'])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s", "(* FIXME what's gone wrong here? *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s; opt_r' = None;\n        (xb reaches xa) s;\n        xb \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f None])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s\n 2. \\<And>x xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s; opt_r' = None;\n        x \\<noteq> m; (xb reaches xa) s;\n        xb \\<in> mut_m.tso_store_refs x\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f None])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s\n 3. \\<And>xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s;\n        the opt_r' \\<in> mut_roots s; (xb reaches xa) s;\n        xb \\<in> tso_store_refs\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f\nopt_r'])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s\n 4. \\<And>x xa xb.\n       \\<lbrakk>valid_refs_inv s; r \\<in> mut_roots s;\n        the opt_r' \\<in> mut_roots s; x \\<noteq> m; (xb reaches xa) s;\n        xb \\<in> mut_m.tso_store_refs x\n                  (s(mutator m := s (mutator m)\n                       \\<lparr>ghost_honorary_root := {}\\<rparr>,\n                     sys := s sys\n                       \\<lparr>mem_store_buffers :=\n                                 (mem_store_buffers (s sys))\n                                 (mutator m :=\n                                    sys_mem_store_buffers (mutator m) s @\n                                    [mw_Mutate r f\nopt_r'])\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) xa s", "apply (subst (asm) tso_store_refs_simps; force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_refs_inv_deref_del:\n  \"\\<lbrakk> valid_refs_inv s; sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r'; r \\<in> mut_roots s; mut_ghost_honorary_root s = {} \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_root := Option.set_option opt_r', ref := opt_r'\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_refs_inv s;\n     sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r';\n     r \\<in> mut_roots s; mut_ghost_honorary_root s = {}\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>ghost_honorary_root :=\nset_option opt_r',\n                               ref := opt_r'\\<rparr>))", "unfolding valid_refs_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x xa.\n                mut_m.reachable x xa s \\<or>\n                grey_reachable xa s \\<longrightarrow>\n                obj_at (\\<lambda>s. True) xa s;\n     sys_load (mutator m) (mr_Ref r f) (s sys) = mv_Ref opt_r';\n     r \\<in> mut_roots s; mut_ghost_honorary_root s = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x xa.\n                         mut_m.reachable x xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root :=\n   set_option opt_r',\n                                  ref := opt_r'\\<rparr>)) \\<or>\n                         grey_reachable xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root :=\n   set_option opt_r',\n                                  ref := opt_r'\\<rparr>)) \\<longrightarrow>\n                         obj_at (\\<lambda>s. True) xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_root :=\n   set_option opt_r',\n                                  ref := opt_r'\\<rparr>))", "by (simp add: fun_upd_apply)"], ["", "lemma valid_refs_inv_mo_co_mark:\n  \"\\<lbrakk> r \\<in> mut_roots s \\<union> mut_ghost_honorary_root s; mut_ghost_honorary_grey s = {}; valid_refs_inv s \\<rbrakk>\n     \\<Longrightarrow> valid_refs_inv (s(mutator m := s (mutator m)\\<lparr>ghost_honorary_grey := {r}\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> mut_roots s \\<union> mut_ghost_honorary_root s;\n     mut_ghost_honorary_grey s = {}; valid_refs_inv s\\<rbrakk>\n    \\<Longrightarrow> valid_refs_inv\n                       (s(mutator m := s (mutator m)\n                            \\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "unfolding valid_refs_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> mut_roots s \\<union> mut_ghost_honorary_root s;\n     mut_ghost_honorary_grey s = {};\n     \\<forall>x xa.\n        mut_m.reachable x xa s \\<or> grey_reachable xa s \\<longrightarrow>\n        obj_at (\\<lambda>s. True) xa s\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x xa.\n                         mut_m.reachable x xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_grey :=\n   {r}\\<rparr>)) \\<or>\n                         grey_reachable xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_grey :=\n   {r}\\<rparr>)) \\<longrightarrow>\n                         obj_at (\\<lambda>s. True) xa\n                          (s(mutator m := s (mutator m)\n                               \\<lparr>ghost_honorary_grey := {r}\\<rparr>))", "apply (clarsimp simp: grey_reachable_def fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>r \\<in> mut_roots s \\<or> r \\<in> mut_ghost_honorary_root s;\n        mut_ghost_honorary_grey s = {};\n        \\<forall>x xa.\n           (mut_m.reachable x xa s \\<longrightarrow>\n            obj_at (\\<lambda>s. True) xa s) \\<and>\n           ((\\<exists>x. grey x s \\<and> (x reaches xa) s) \\<longrightarrow>\n            obj_at (\\<lambda>s. True) xa s);\n        grey xa s \\<or> xa = r; (xa reaches x) s\\<rbrakk>\n       \\<Longrightarrow> obj_at (\\<lambda>s. True) x s", "apply (metis grey_reachable_def valid_refs_invD(1) valid_refs_invD(10) valid_refs_inv_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_refs_inv[intro]:\n  notes fun_upd_apply[simp]\n  notes valid_refs_inv_discard_roots[simp]\n  notes valid_refs_inv_load[simp]\n  notes valid_refs_inv_alloc[simp]\n  notes valid_refs_inv_store_ins[simp]\n  notes valid_refs_inv_deref_del[simp]\n  notes valid_refs_inv_mo_co_mark[simp]\n  shows\n  \"\\<lbrace> mark_object_invL\n       \\<^bold>\\<and> mut_get_roots.mark_object_invL m\n       \\<^bold>\\<and> mut_store_del.mark_object_invL m\n       \\<^bold>\\<and> mut_store_ins.mark_object_invL m\n       \\<^bold>\\<and> LSTP valid_refs_inv \\<rbrace>\n     mutator m\n   \\<lbrace> LSTP valid_refs_inv \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                mark_object_invL s \\<and>\n                mut_get_roots.mark_object_invL m s \\<and>\n                mut_store_del.mark_object_invL m s \\<and>\n                mut_store_ins.mark_object_invL m s \\<and>\n                valid_refs_inv\n                 s\\<down>\\<rbrace> mutator\n                                    m \\<lbrace>\\<lambda>s.\n            valid_refs_inv s\\<down>\\<rbrace>", "proof(vcg_jackhammer (keep_locs) (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "case (hs_get_roots_done s s')"], ["proof (state)\nthis:\n  at (mutator m) hs_get_roots_done s\n  at sys sys.sys_hs_mut_done s\n  AT s' = (AT s)\n  (mutator m :=\n     {hs_load_pending, mut_mfence, mut_store_payload_choose,\n      mut_load_payload_choose, store_choose, mut_load_choose, discard_refs,\n      Proofs_Basis.mut_m.alloc, mut_local_computation},\n   sys :=\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load})\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := {},\n        ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_roots_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  \\<forall>x. x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))\n 2. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_roots_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\n           \\<lparr>W := {},\n              ghost_hs_phase :=\n                hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_roots_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>;\n        \\<forall>x.\n           x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>;\n        mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {},\n                                 ghost_hs_phase :=\n                                   hs_step\n                                    (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_roots_done s\n  at sys sys.sys_hs_mut_done s\n  AT s' = (AT s)\n  (mutator m :=\n     {hs_load_pending, mut_mfence, mut_store_payload_choose,\n      mut_load_payload_choose, store_choose, mut_load_choose, discard_refs,\n      Proofs_Basis.mut_m.alloc, mut_local_computation},\n   sys :=\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load})\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := {},\n        ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_roots_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  \\<forall>x. x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_roots_done s\n  at sys sys.sys_hs_mut_done s\n  AT s' = (AT s)\n  (mutator m :=\n     {hs_load_pending, mut_mfence, mut_store_payload_choose,\n      mut_load_payload_choose, store_choose, mut_load_choose, discard_refs,\n      Proofs_Basis.mut_m.alloc, mut_local_computation},\n   sys :=\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load})\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\n     \\<lparr>W := {},\n        ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_roots_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  \\<forall>x. x \\<in> mut_roots s\\<down> \\<longrightarrow> marked x s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\n         \\<lparr>W := {},\n            ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                   (m := False),\n            W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n            ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n              (m := True)\\<rparr>))", "by (clarsimp simp: valid_refs_inv_def grey_reachable_def)"], ["proof (state)\nthis:\n  valid_refs_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\n       \\<lparr>W := {},\n          ghost_hs_phase := hs_step (mut_ghost_hs_phase s\\<down>)\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                 (m := False),\n          W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n          ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n            (m := True)\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "case (hs_get_work_done s s')"], ["proof (state)\nthis:\n  at (mutator m) hs_get_work_done s\n  at sys sys.sys_hs_mut_done s\n  AT s' = (AT s)\n  (mutator m :=\n     {hs_load_pending, mut_mfence, mut_store_payload_choose,\n      mut_load_payload_choose, store_choose, mut_load_choose, discard_refs,\n      Proofs_Basis.mut_m.alloc, mut_local_computation},\n   sys :=\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load})\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_work_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>at (mutator m) hs_get_work_done s;\n        at sys sys.sys_hs_mut_done s;\n        AT s' = (AT s)\n        (mutator m :=\n           {hs_load_pending, mut_mfence, mut_store_payload_choose,\n            mut_load_payload_choose, store_choose, mut_load_choose,\n            discard_refs, Proofs_Basis.mut_m.alloc, mut_local_computation},\n         sys :=\n           {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n            sys.sys_hs_gc_load_W, sys.sys_hs_gc_done,\n            sys.sys_hs_gc_mut_reqs, sys.sys_hs_gc_set_type, sys.sys_free,\n            Proofs_Basis.sys.alloc, sys.tso_dequeue_store_buffer,\n            sys.tso_unlock, sys.tso_lock, sys.tso_mfence, sys.tso_store,\n            sys.tso_load});\n        s'\\<down> = s\\<down>\n        (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n         sys := s\\<down> sys\n           \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                     (m := False),\n              W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n              ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n                (m := True)\\<rparr>);\n        taken (mutator m) hs_get_work_done s';\n        \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; mut_ghost_honorary_grey s\\<down> = {};\n        mut_ghost_honorary_root s\\<down> = {}\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (mutator m := s\\<down> (mutator m)\n                              \\<lparr>W := {}\\<rparr>,\n                            sys := s\\<down> sys\n                              \\<lparr>hs_pending :=\n  (local_state.hs_pending (s\\<down> sys))(m := False),\n                                 W := sys_W s\\<down> \\<union>\nmut_W s\\<down>,\n                                 ghost_hs_in_sync :=\n                                   (ghost_hs_in_sync (s\\<down> sys))\n                                   (m := True)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at (mutator m) hs_get_work_done s\n  at sys sys.sys_hs_mut_done s\n  AT s' = (AT s)\n  (mutator m :=\n     {hs_load_pending, mut_mfence, mut_store_payload_choose,\n      mut_load_payload_choose, store_choose, mut_load_choose, discard_refs,\n      Proofs_Basis.mut_m.alloc, mut_local_computation},\n   sys :=\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load})\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_work_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}", "show ?case"], ["proof (prove)\nusing this:\n  at (mutator m) hs_get_work_done s\n  at sys sys.sys_hs_mut_done s\n  AT s' = (AT s)\n  (mutator m :=\n     {hs_load_pending, mut_mfence, mut_store_payload_choose,\n      mut_load_payload_choose, store_choose, mut_load_choose, discard_refs,\n      Proofs_Basis.mut_m.alloc, mut_local_computation},\n   sys :=\n     {sys.sys_hs_mut_done, sys.sys_hs_mut, sys.sys_hs_mut_pending,\n      sys.sys_hs_gc_load_W, sys.sys_hs_gc_done, sys.sys_hs_gc_mut_reqs,\n      sys.sys_hs_gc_set_type, sys.sys_free, Proofs_Basis.sys.alloc,\n      sys.tso_dequeue_store_buffer, sys.tso_unlock, sys.tso_lock,\n      sys.tso_mfence, sys.tso_store, sys.tso_load})\n  s'\\<down> = s\\<down>\n  (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n   sys := s\\<down> sys\n     \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n               (m := False),\n        W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n        ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n          (m := True)\\<rparr>)\n  taken (mutator m) hs_get_work_done s'\n  \\<forall>p''\\<in>- {mutator m, sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  mut_ghost_honorary_grey s\\<down> = {}\n  mut_ghost_honorary_root s\\<down> = {}\n\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s\\<down>\n      (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n       sys := s\\<down> sys\n         \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                   (m := False),\n            W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n            ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n              (m := True)\\<rparr>))", "by (clarsimp simp: valid_refs_inv_def grey_reachable_def)"], ["proof (state)\nthis:\n  valid_refs_inv\n   (s\\<down>\n    (mutator m := s\\<down> (mutator m)\\<lparr>W := {}\\<rparr>,\n     sys := s\\<down> sys\n       \\<lparr>hs_pending := (local_state.hs_pending (s\\<down> sys))\n                 (m := False),\n          W := sys_W s\\<down> \\<union> mut_W s\\<down>,\n          ghost_hs_in_sync := (ghost_hs_in_sync (s\\<down> sys))\n            (m := True)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in sys) valid_refs_inv[intro]:\n  \"\\<lbrace> LSTP (valid_refs_inv \\<^bold>\\<and> tso_store_inv) \\<rbrace> sys \\<lbrace> LSTP valid_refs_inv \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>s.\n                valid_refs_inv s\\<down> \\<and>\n                tso_store_inv\n                 s\\<down>\\<rbrace> sys \\<lbrace>\\<lambda>s.\n             valid_refs_inv s\\<down>\\<rbrace>", "proof(vcg_jackhammer (no_thin_post_inv), vcg_name_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; tso_store_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "case (tso_dequeue_store_buffer s s' p w ws)"], ["proof (state)\nthis:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  tso_store_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n\ngoal (1 subgoal):\n 1. \\<And>s s' p w ws.\n       \\<lbrakk>at sys tso_dequeue_store_buffer s;\n        s'\\<down> = s\\<down>\n        (sys := do_store_action w (s\\<down> sys)\n           \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                     (p := ws)\\<rparr>);\n        taken sys tso_dequeue_store_buffer s';\n        \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p'';\n        valid_refs_inv s\\<down>; tso_store_inv s\\<down>;\n        sys_mem_store_buffers p s\\<down> = w # ws;\n        not_blocked (s\\<down> sys) p; p \\<noteq> sys\\<rbrakk>\n       \\<Longrightarrow> valid_refs_inv\n                          (s\\<down>\n                           (sys := do_store_action w (s\\<down> sys)\n                              \\<lparr>mem_store_buffers :=\n  (mem_store_buffers (s\\<down> sys))(p := ws)\\<rparr>))", "then"], ["proof (chain)\npicking this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  tso_store_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys", "show ?case"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys := do_store_action w (s\\<down> sys)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  tso_store_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s\\<down>\n      (sys := do_store_action w (s\\<down> sys)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "unfolding do_store_action_def"], ["proof (prove)\nusing this:\n  at sys tso_dequeue_store_buffer s\n  s'\\<down> = s\\<down>\n  (sys :=\n     (case w of\n      mw_Mark r gc_mark \\<Rightarrow> s\\<down> sys\n        \\<lparr>heap := (sys_heap s\\<down>)\n                  (r := map_option (obj_mark_update (\\<lambda>_. gc_mark))\n                         (sys_heap s\\<down> r))\\<rparr>\n      | mw_Mutate r f new_r \\<Rightarrow> s\\<down> sys\n          \\<lparr>heap := (sys_heap s\\<down>)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_fields := (obj_fields obj)\n   (f := new_r)\\<rparr>)\n                           (sys_heap s\\<down> r))\\<rparr>\n      | mw_Mutate_Payload r f pl \\<Rightarrow> s\\<down> sys\n          \\<lparr>heap := (sys_heap s\\<down>)\n                    (r := map_option\n                           (\\<lambda>obj. obj\n                               \\<lparr>obj_payload := (obj_payload obj)\n   (f := pl)\\<rparr>)\n                           (sys_heap s\\<down> r))\\<rparr>\n      | mw_fA gc_mark \\<Rightarrow> s\\<down> sys\n          \\<lparr>fA := gc_mark\\<rparr>\n      | mw_fM gc_mark \\<Rightarrow> s\\<down> sys\n          \\<lparr>fM := gc_mark\\<rparr>\n      | mw_Phase gc_phase \\<Rightarrow> s\\<down> sys\n          \\<lparr>phase := gc_phase\\<rparr>)\n     \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n               (p := ws)\\<rparr>)\n  taken sys tso_dequeue_store_buffer s'\n  \\<forall>p''\\<in>- {sys}. GST s' p'' = GST s p''\n  valid_refs_inv s\\<down>\n  tso_store_inv s\\<down>\n  sys_mem_store_buffers p s\\<down> = w # ws\n  not_blocked (s\\<down> sys) p\n  p \\<noteq> sys\n\ngoal (1 subgoal):\n 1. valid_refs_inv\n     (s\\<down>\n      (sys :=\n         (case w of\n          mw_Mark r gc_mark \\<Rightarrow> s\\<down> sys\n            \\<lparr>heap := (sys_heap s\\<down>)\n                      (r := map_option\n                             (obj_mark_update (\\<lambda>_. gc_mark))\n                             (sys_heap s\\<down> r))\\<rparr>\n          | mw_Mutate r f new_r \\<Rightarrow> s\\<down> sys\n              \\<lparr>heap := (sys_heap s\\<down>)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_fields := (obj_fields obj)\n       (f := new_r)\\<rparr>)\n                               (sys_heap s\\<down> r))\\<rparr>\n          | mw_Mutate_Payload r f pl \\<Rightarrow> s\\<down> sys\n              \\<lparr>heap := (sys_heap s\\<down>)\n                        (r := map_option\n                               (\\<lambda>obj. obj\n                                   \\<lparr>obj_payload := (obj_payload obj)\n       (f := pl)\\<rparr>)\n                               (sys_heap s\\<down> r))\\<rparr>\n          | mw_fA gc_mark \\<Rightarrow> s\\<down> sys\n              \\<lparr>fA := gc_mark\\<rparr>\n          | mw_fM gc_mark \\<Rightarrow> s\\<down> sys\n              \\<lparr>fM := gc_mark\\<rparr>\n          | mw_Phase gc_phase \\<Rightarrow> s\\<down> sys\n              \\<lparr>phase := gc_phase\\<rparr>)\n         \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                   (p := ws)\\<rparr>))", "apply (auto simp: p_not_sys valid_refs_inv_dequeue_Mutate valid_refs_inv_dequeue_Mutate_Payload fun_upd_apply split: mem_store_action.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valid_refs_inv\n   (s\\<down>\n    (sys := do_store_action w (s\\<down> sys)\n       \\<lparr>mem_store_buffers := (mem_store_buffers (s\\<down> sys))\n                 (p := ws)\\<rparr>))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}