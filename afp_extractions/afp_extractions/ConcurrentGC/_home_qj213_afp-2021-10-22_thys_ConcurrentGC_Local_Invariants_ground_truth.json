{"file_name": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC/Local_Invariants.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ConcurrentGC", "problem_names": ["lemmas (in gc) gc_mark_mark_object_invL_def2[inv] = gc_mark.mark_object_invL_def[unfolded loc_defs, simplified, folded loc_defs]", "lemmas (in mut_m) mut_get_roots_mark_object_invL_def2[inv] = mut_get_roots.mark_object_invL_def[unfolded loc_defs, simplified, folded loc_defs]", "lemmas (in mut_m) mut_store_del_mark_object_invL_def2[inv] = mut_store_del.mark_object_invL_def[simplified, folded loc_defs]", "lemmas (in mut_m) mut_store_ins_mark_object_invL_def2[inv] = mut_store_ins.mark_object_invL_def[unfolded loc_defs, simplified, folded loc_defs]"], "translations": [["", "lemmas (in gc) gc_mark_mark_object_invL_def2[inv] = gc_mark.mark_object_invL_def[unfolded loc_defs, simplified, folded loc_defs]"], ["", "interpretation mut_get_roots: mark_object \"mutator m\" \"mut_m.hs_get_roots_loop\" \"\\<langle>True\\<rangle>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_object (mutator m) (\\<lambda>s. True)", "by standard (simp add: eq_imp_def)"], ["", "lemmas (in mut_m) mut_get_roots_mark_object_invL_def2[inv] = mut_get_roots.mark_object_invL_def[unfolded loc_defs, simplified, folded loc_defs]"], ["", "text\\<open>\n\nThe most interesting cases are the two asynchronous uses of @{const\n\"mark_object_fn\"} in the mutators: we need something that holds even\nbefore we read the phase. In particular we need to avoid interference\nby an @{const \"fM\"} flip.\n\n\\<close>"], ["", "interpretation mut_store_del: mark_object \"mutator m\" \"''store_del''\" \"mut_m.mut_ghost_hs_phase m \\<^bold>\\<noteq> \\<langle>hp_Idle\\<rangle>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_object (mutator m)\n     (\\<lambda>s. ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle)", "(* FIXME store del, why the string? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_object (mutator m)\n     (\\<lambda>s. ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle)", "by standard (simp add: eq_imp_def)"], ["", "lemmas (in mut_m) mut_store_del_mark_object_invL_def2[inv] = mut_store_del.mark_object_invL_def[simplified, folded loc_defs]"], ["", "interpretation mut_store_ins: mark_object \"mutator m\" \"mut_m.store_ins\"  \"mut_m.mut_ghost_hs_phase m \\<^bold>\\<noteq> \\<langle>hp_Idle\\<rangle>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_object (mutator m)\n     (\\<lambda>s. ghost_hs_phase (s (mutator m)) \\<noteq> hp_Idle)", "by standard (simp add: eq_imp_def)"], ["", "lemmas (in mut_m) mut_store_ins_mark_object_invL_def2[inv] = mut_store_ins.mark_object_invL_def[unfolded loc_defs, simplified, folded loc_defs]"], ["", "text\\<open>\n\nLocal invariant for the mutator's uses of \\<open>mark_object\\<close>.\n\n\\<close>"], ["", "context mut_m\nbegin"], ["", "locset_definition \"hs_get_roots_loop_locs = prefixed ''hs_get_roots_loop''\""], ["", "locset_definition \"hs_get_roots_loop_mo_locs =\n  prefixed ''hs_get_roots_loop_mo'' \\<union> {hs_get_roots_loop_done}\""], ["", "abbreviation \"mut_async_mark_object_prefixes \\<equiv> { ''store_del'', ''store_ins'' }\""], ["", "locset_definition \"hs_not_hp_Idle_locs =\n  (\\<Union>pref\\<in>mut_async_mark_object_prefixes.\n     \\<Union>l\\<in>{''mo_co_lock'', ''mo_co_cmark'', ''mo_co_ctest'', ''mo_co_mark'', ''mo_co_unlock'', ''mo_co_won'', ''mo_co_W''}. {pref @ ''_'' @ l})\""], ["", "locset_definition \"async_mo_ptest_locs =\n  (\\<Union>pref\\<in>mut_async_mark_object_prefixes. {pref @ ''_mo_ptest''})\""], ["", "locset_definition \"mo_ptest_locs =\n  (\\<Union>pref\\<in>mut_async_mark_object_prefixes. {pref @ ''_mo_ptest''})\""], ["", "locset_definition \"mo_valid_ref_locs =\n  (prefixed ''store_del'' \\<union> prefixed ''store_ins'' \\<union> {deref_del, lop_store_ins})\""], ["", "(*>*)"], ["", "text\\<open>\n\nThis local invariant for the mutators illustrates the handshake\nstructure: we can rely on the insertion barrier earlier than on the\ndeletion barrier. Both need to be installed before \\<open>get_roots\\<close>\nto ensure we preserve the strong tricolour invariant. All black\nobjects at that point are allocated: we need to know that the\ninsertion barrier is installed to preserve it. This limits when \\<open>fA\\<close> can be set.\n\nIt is interesting to contrast the two barriers. Intuitively a mutator\ncan locally guarantee that it, in the relevant phases, will insert\nonly marked references. Less often can it be sure that the reference\nit is overwriting is marked. We also need to consider stores pending\nin TSO buffers: it is key that after the \\<open>''init_noop''\\<close>\nhandshake there are no pending white insertions\n(mutations that insert unmarked references). This ensures the deletion barrier\ndoes its job.\n\n\\<close>"], ["", "locset_definition\n  \"ghost_honorary_grey_empty_locs =\n     (- (\\<Union>pref\\<in>{ ''hs_get_roots_loop'', ''store_del'', ''store_ins'' }.\n        \\<Union>l\\<in>{ ''mo_co_unlock'', ''mo_co_won'', ''mo_co_W'' }. {pref @ ''_'' @ l}))\""], ["", "locset_definition\n  \"ghost_honorary_root_empty_locs =\n     (- (prefixed ''store_del'' \\<union> {lop_store_ins} \\<union> prefixed ''store_ins''))\""], ["", "locset_definition \"ghost_honorary_root_nonempty_locs = prefixed ''store_del'' - {store_del_mo_null}\""], ["", "locset_definition \"not_idle_locs = suffixed ''_mo_ptest''\""], ["", "locset_definition \"ins_barrier_locs = prefixed ''store_ins''\""], ["", "locset_definition \"del_barrier1_locs = prefixed ''store_del_mo'' \\<union> {lop_store_ins}\""], ["", "definition mark_object_invL :: \"('field, 'mut, 'payload, 'ref) gc_pred\" where\n[inv]: \"mark_object_invL =\n   (atS_mut hs_get_roots_loop_locs        (mut_refs \\<^bold>\\<subseteq> mut_roots \\<^bold>\\<and> (\\<^bold>\\<forall>r. \\<langle>r\\<rangle> \\<^bold>\\<in> mut_roots \\<^bold>- mut_refs \\<^bold>\\<longrightarrow> marked r))\n  \\<^bold>\\<and> atS_mut hs_get_roots_loop_mo_locs     (\\<^bold>\\<not>NULL mut_ref \\<^bold>\\<and> mut_the_ref \\<^bold>\\<in> mut_roots)\n  \\<^bold>\\<and> at_mut hs_get_roots_loop_done         (marked \\<^bold>$ mut_the_ref)\n  \\<^bold>\\<and> at_mut hs_get_roots_loop_mo_ptest     (mut_phase \\<^bold>\\<noteq> \\<langle>ph_Idle\\<rangle>)\n  \\<^bold>\\<and> at_mut hs_get_roots_done              (\\<^bold>\\<forall>r. \\<langle>r\\<rangle> \\<^bold>\\<in> mut_roots \\<^bold>\\<longrightarrow> marked r)\n\n  \\<^bold>\\<and> atS_mut mo_valid_ref_locs             ( (\\<^bold>\\<not>NULL mut_new_ref \\<^bold>\\<longrightarrow> mut_the_new_ref \\<^bold>\\<in> mut_roots)\n                                          \\<^bold>\\<and> (mut_tmp_ref \\<^bold>\\<in> mut_roots) )\n  \\<^bold>\\<and> at_mut store_del_mo_null              (\\<^bold>\\<not>NULL mut_ref \\<^bold>\\<longrightarrow> mut_the_ref \\<^bold>\\<in> mut_ghost_honorary_root)\n  \\<^bold>\\<and> atS_mut ghost_honorary_root_nonempty_locs   (mut_the_ref \\<^bold>\\<in> mut_ghost_honorary_root)\n\n  \\<^bold>\\<and> atS_mut not_idle_locs                 (mut_phase \\<^bold>\\<noteq> \\<langle>ph_Idle\\<rangle> \\<^bold>\\<longrightarrow> mut_ghost_hs_phase \\<^bold>\\<noteq> \\<langle>hp_Idle\\<rangle>)\n  \\<^bold>\\<and> atS_mut hs_not_hp_Idle_locs           (mut_ghost_hs_phase \\<^bold>\\<noteq> \\<langle>hp_Idle\\<rangle>)\n\n  \\<^bold>\\<and> atS_mut mo_ptest_locs                 (mut_phase \\<^bold>= \\<langle>ph_Idle\\<rangle> \\<^bold>\\<longrightarrow> (mut_ghost_hs_phase \\<^bold>\\<in> \\<langle>{hp_Idle, hp_IdleInit}\\<rangle>\n                                                                          \\<^bold>\\<or> (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_IdleMarkSweep\\<rangle>\n                                                                                \\<^bold>\\<and> sys_phase \\<^bold>= \\<langle>ph_Idle\\<rangle>)))\n  \\<^bold>\\<and> atS_mut ghost_honorary_grey_empty_locs (EMPTY mut_ghost_honorary_grey)\n\\<comment> \\<open>insertion barrier\\<close>\n  \\<^bold>\\<and> at_mut store_ins                      ( (mut_ghost_hs_phase \\<^bold>\\<in> \\<langle>{hp_InitMark, hp_Mark}\\<rangle>\n                                            \\<^bold>\\<or> (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_IdleMarkSweep\\<rangle> \\<^bold>\\<and> sys_phase \\<^bold>\\<noteq> \\<langle>ph_Idle\\<rangle>))\n                                           \\<^bold>\\<and> \\<^bold>\\<not>NULL mut_new_ref\n                                           \\<^bold>\\<longrightarrow> marked \\<^bold>$ mut_the_new_ref )\n  \\<^bold>\\<and> atS_mut ins_barrier_locs              ( ( (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_Mark\\<rangle>\n                                              \\<^bold>\\<or> (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_IdleMarkSweep\\<rangle> \\<^bold>\\<and> sys_phase \\<^bold>\\<noteq> \\<langle>ph_Idle\\<rangle>))\n                                            \\<^bold>\\<and> (\\<lambda>s. \\<forall>opt_r'. \\<not>tso_pending_store (mutator m) (mw_Mutate (mut_tmp_ref s) (mut_field s) opt_r') s)\n                                            \\<^bold>\\<longrightarrow> (\\<lambda>s. obj_at_field_on_heap (\\<lambda>r'. marked r' s) (mut_tmp_ref s) (mut_field s) s) )\n                                          \\<^bold>\\<and> (mut_ref \\<^bold>= mut_new_ref) )\n\\<comment> \\<open>deletion barrier\\<close>\n  \\<^bold>\\<and> atS_mut del_barrier1_locs             ( (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_Mark\\<rangle>\n                                            \\<^bold>\\<or> (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_IdleMarkSweep\\<rangle> \\<^bold>\\<and> sys_phase \\<^bold>\\<noteq> \\<langle>ph_Idle\\<rangle>))\n                                           \\<^bold>\\<and> (\\<lambda>s. \\<forall>opt_r'. \\<not>tso_pending_store (mutator m) (mw_Mutate (mut_tmp_ref s) (mut_field s) opt_r') s)\n                                          \\<^bold>\\<longrightarrow> (\\<lambda>s. obj_at_field_on_heap (\\<lambda>r. mut_ref s = Some r \\<or> marked r s) (mut_tmp_ref s) (mut_field s) s))\n  \\<^bold>\\<and> at_mut lop_store_ins                  ( (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_Mark\\<rangle>\n                                             \\<^bold>\\<or> (mut_ghost_hs_phase \\<^bold>= \\<langle>hp_IdleMarkSweep\\<rangle> \\<^bold>\\<and> sys_phase \\<^bold>\\<noteq> \\<langle>ph_Idle\\<rangle>))\n                                           \\<^bold>\\<and> \\<^bold>\\<not>NULL mut_ref\n                                          \\<^bold>\\<longrightarrow> marked \\<^bold>$ mut_the_ref )\n\\<comment>\\<open>after \\<open>init_noop\\<close>. key: no pending white insertions \\<open>at_mut hs_noop_done\\<close> which we get from @{const \\<open>handshake_invL\\<close>}.\\<close>\n  \\<^bold>\\<and> at_mut mut_load                         (mut_tmp_ref \\<^bold>\\<in> mut_roots)\n  \\<^bold>\\<and> atS_mut ghost_honorary_root_empty_locs  (EMPTY mut_ghost_honorary_root) )\""], ["", "end"], ["", "subsection\\<open>The infamous termination argument\\<close>"], ["", "text\\<open>\n\nWe need to know that if the GC does not receive any further work to do\nat \\<open>get_roots\\<close> and \\<open>get_work\\<close>, then there are no grey\nobjects left. Essentially this encodes the stability property that\ngrey objects must exist for mutators to create grey objects.\n\nNote that this is not invariant across the scan: it is possible for\nthe GC to hold all the grey references. The two handshakes transform\nthe GC's local knowledge that it has no more work to do into a global\nproperty, or gives it more work.\n\n\\<close>"], ["", "(* FIXME this is an assertion? *)"], ["", "definition (in mut_m) gc_W_empty_mut_inv :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"gc_W_empty_mut_inv =\n      ((EMPTY sys_W \\<^bold>\\<and> sys_ghost_hs_in_sync m \\<^bold>\\<and> \\<^bold>\\<not>EMPTY (WL (mutator m)))\n   \\<^bold>\\<longrightarrow> (\\<^bold>\\<exists>m'. \\<^bold>\\<not>sys_ghost_hs_in_sync m' \\<^bold>\\<and> \\<^bold>\\<not>EMPTY (WL (mutator m'))))\""], ["", "context gc\nbegin"], ["", "locset_definition gc_W_empty_locs :: \"location set\" where\n  \"gc_W_empty_locs =\n       idle_locs \\<union> init_locs \\<union> sweep_locs \\<union> {mark_load_fM, mark_store_fA, mark_end}\n     \\<union> prefixed ''mark_noop''\n     \\<union> prefixed ''mark_loop_get_roots''\n     \\<union> prefixed ''mark_loop_get_work''\""], ["", "locset_definition \"get_roots_UN_get_work_locs = hs_get_roots_locs \\<union> hs_get_work_locs\""], ["", "locset_definition \"black_heap_locs = {sweep_idle, idle_noop_mfence, idle_noop_init_type}\""], ["", "locset_definition \"no_grey_refs_locs = black_heap_locs \\<union> sweep_locs \\<union> {mark_end}\""], ["", "definition gc_W_empty_invL :: \"('field, 'mut, 'payload, 'ref) gc_pred\" where\n[inv]: \"gc_W_empty_invL =\n   (atS_gc get_roots_UN_get_work_locs   (\\<^bold>\\<forall>m. mut_m.gc_W_empty_mut_inv m)\n  \\<^bold>\\<and> at_gc mark_loop_get_roots_load_W    (EMPTY sys_W \\<^bold>\\<longrightarrow> no_grey_refs)\n  \\<^bold>\\<and> at_gc mark_loop_get_work_load_W     (EMPTY sys_W \\<^bold>\\<longrightarrow> no_grey_refs)\n  \\<^bold>\\<and> at_gc mark_loop                     (EMPTY gc_W \\<^bold>\\<longrightarrow> no_grey_refs)\n  \\<^bold>\\<and> atS_gc no_grey_refs_locs            no_grey_refs\n  \\<^bold>\\<and> atS_gc gc_W_empty_locs              (EMPTY gc_W))\""], ["", "end"], ["", "subsection\\<open>Sweep loop invariants\\<close>"], ["", "context gc\nbegin"], ["", "locset_definition \"sweep_loop_locs = prefixed ''sweep_loop''\""], ["", "locset_definition \"sweep_loop_not_choose_ref_locs = (prefixed ''sweep_loop_'' - {sweep_loop_choose_ref})\""], ["", "definition sweep_loop_invL :: \"('field, 'mut, 'payload, 'ref) gc_pred\" where\n[inv]: \"sweep_loop_invL =\n   (at_gc sweep_loop_check            ( (\\<^bold>\\<not>NULL gc_mark \\<^bold>\\<longrightarrow> (\\<lambda>s. obj_at (\\<lambda>obj. Some (obj_mark obj) = gc_mark s) (gc_tmp_ref s) s))\n                                      \\<^bold>\\<and> ( NULL gc_mark \\<^bold>\\<and> valid_ref \\<^bold>$ gc_tmp_ref \\<^bold>\\<longrightarrow> marked \\<^bold>$ gc_tmp_ref ) )\n  \\<^bold>\\<and> at_gc sweep_loop_free             ( \\<^bold>\\<not>NULL gc_mark \\<^bold>\\<and> the \\<circ> gc_mark \\<^bold>\\<noteq> gc_fM \\<^bold>\\<and> (\\<lambda>s. obj_at (\\<lambda>obj. Some (obj_mark obj) = gc_mark s) (gc_tmp_ref s) s) )\n  \\<^bold>\\<and> at_gc sweep_loop_ref_done         (valid_ref \\<^bold>$ gc_tmp_ref \\<^bold>\\<longrightarrow> marked \\<^bold>$ gc_tmp_ref)\n  \\<^bold>\\<and> atS_gc sweep_loop_locs            (\\<^bold>\\<forall>r. \\<^bold>\\<not>\\<langle>r\\<rangle> \\<^bold>\\<in> gc_refs \\<^bold>\\<and> valid_ref r \\<^bold>\\<longrightarrow> marked r)\n  \\<^bold>\\<and> atS_gc black_heap_locs            (\\<^bold>\\<forall>r. valid_ref r \\<^bold>\\<longrightarrow> marked r)\n  \\<^bold>\\<and> atS_gc sweep_loop_not_choose_ref_locs (gc_tmp_ref \\<^bold>\\<in> gc_refs))\""], ["", "text\\<open>\n\nFor showing that the GC's use of @{const \"mark_object_fn\"} is correct.\n\nWhen we take grey @{const \"tmp_ref\"} to black, all of the objects it\npoints to are marked, ergo the new black does not point to white, and\nso we preserve the strong tricolour invariant.\n\n\\<close>"], ["", "definition obj_fields_marked :: \"('field, 'mut, 'payload, 'ref) lsts_pred\" where\n  \"obj_fields_marked =\n     (\\<^bold>\\<forall>f. \\<langle>f\\<rangle> \\<^bold>\\<in> (- gc_field_set) \\<^bold>\\<longrightarrow> (\\<lambda>s. obj_at_field_on_heap (\\<lambda>r. marked r s) (gc_tmp_ref s) f s))\""], ["", "locset_definition \"mark_loop_mo_locs = prefixed ''mark_loop_mo''\""], ["", "locset_definition \"obj_fields_marked_good_ref_locs = mark_loop_mo_locs \\<union> {mark_loop_mark_field_done}\""], ["", "locset_definition\n  \"ghost_honorary_grey_empty_locs =\n     (- { mark_loop_mo_co_unlock, mark_loop_mo_co_won, mark_loop_mo_co_W })\""], ["", "locset_definition\n  \"obj_fields_marked_locs =\n     {mark_loop_mark_object_loop, mark_loop_mark_choose_field, mark_loop_mark_deref, mark_loop_mark_field_done, mark_loop_blacken}\n   \\<union> mark_loop_mo_locs\""], ["", "definition obj_fields_marked_invL :: \"('field, 'mut, 'payload, 'ref) gc_pred\" where\n[inv]: \"obj_fields_marked_invL =\n    (atS_gc obj_fields_marked_locs       (obj_fields_marked \\<^bold>\\<and> gc_tmp_ref \\<^bold>\\<in> gc_W)\n  \\<^bold>\\<and> atS_gc obj_fields_marked_good_ref_locs (\\<lambda>s. obj_at_field_on_heap (\\<lambda>r. gc_ref s = Some r \\<or> marked r s) (gc_tmp_ref s) (gc_field s) s)\n  \\<^bold>\\<and> atS_gc mark_loop_mo_locs            (\\<^bold>\\<forall>y. \\<^bold>\\<not>NULL gc_ref \\<^bold>\\<and> (\\<lambda>s. ((gc_the_ref s) reaches y) s) \\<^bold>\\<longrightarrow> valid_ref y)\n  \\<^bold>\\<and> at_gc mark_loop_fields              (gc_tmp_ref \\<^bold>\\<in> gc_W)\n  \\<^bold>\\<and> at_gc mark_loop_mark_field_done     (\\<^bold>\\<not>NULL gc_ref \\<^bold>\\<longrightarrow> marked \\<^bold>$ gc_the_ref)\n  \\<^bold>\\<and> at_gc mark_loop_blacken             (EMPTY gc_field_set)\n  \\<^bold>\\<and> atS_gc ghost_honorary_grey_empty_locs (EMPTY gc_ghost_honorary_grey))\""], ["", "end"], ["", "subsection\\<open> The local innvariants collected \\<close>"], ["", "definition (in gc) invsL :: \"('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"invsL =\n   (fM_fA_invL\n  \\<^bold>\\<and> gc_mark.mark_object_invL\n  \\<^bold>\\<and> gc_W_empty_invL\n  \\<^bold>\\<and> handshake_invL\n  \\<^bold>\\<and> obj_fields_marked_invL\n  \\<^bold>\\<and> phase_invL\n  \\<^bold>\\<and> sweep_loop_invL\n  \\<^bold>\\<and> tso_lock_invL)\""], ["", "definition (in mut_m) invsL :: \"('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"invsL =\n   (mark_object_invL\n  \\<^bold>\\<and> mut_get_roots.mark_object_invL m\n  \\<^bold>\\<and> mut_store_ins.mark_object_invL m\n  \\<^bold>\\<and> mut_store_del.mark_object_invL m\n  \\<^bold>\\<and> handshake_invL\n  \\<^bold>\\<and> tso_lock_invL)\""], ["", "definition invsL :: \"('field, 'mut, 'payload, 'ref) gc_pred\" where\n  \"invsL = (gc.invsL \\<^bold>\\<and> (\\<^bold>\\<forall>m. mut_m.invsL m))\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}