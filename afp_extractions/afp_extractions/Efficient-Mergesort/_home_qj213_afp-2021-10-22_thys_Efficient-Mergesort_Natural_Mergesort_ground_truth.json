{"file_name": "/home/qj213/afp-2021-10-22/thys/Efficient-Mergesort/Natural_Mergesort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Efficient-Mergesort", "problem_names": ["lemma C_merge_adj':\n  \"C_merge_adj xss \\<le> length (concat xss)\"", "lemma length_concat_merge_adj:\n  \"length (concat (merge_adj xss)) = length (concat xss)\"", "lemma C_merge_all':\n  \"C_merge_all xss \\<le> length (concat xss) * \\<lceil>log 2 (length xss)\\<rceil>\"", "lemma ascP_Cons [simp]: \"ascP ((#) x)\"", "lemma ascP_comp_Cons [simp]: \"ascP f \\<Longrightarrow> ascP (f \\<circ> (#) x)\"", "lemma ascP_simp [simp]:\n  assumes \"ascP f\"\n  shows \"f [x] = f [] @ [x]\"", "lemma\n  shows mset_runs: \"\\<Sum>\\<^sub># (image_mset mset (mset (runs xs))) = mset xs\"\n    and mset_asc: \"ascP f \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset mset (mset (asc x f ys))) = {#x#} + mset (f []) + mset ys\"\n    and mset_desc: \"\\<Sum>\\<^sub># (image_mset mset (mset (desc x xs ys))) = {#x#} + mset xs + mset ys\"", "lemma mset_nmsort:\n  \"mset (nmsort xs) = mset xs\"", "lemma\n  shows sorted_runs: \"\\<forall>x\\<in>set (runs xs). sorted x\"\n    and sorted_asc: \"ascP f \\<Longrightarrow> sorted (f []) \\<Longrightarrow> \\<forall>x\\<in>set (f []). x \\<le> a \\<Longrightarrow> \\<forall>x\\<in>set (asc a f ys). sorted x\"\n    and sorted_desc: \"sorted xs \\<Longrightarrow> \\<forall>x\\<in>set xs. a \\<le> x \\<Longrightarrow> \\<forall>x\\<in>set (desc a xs ys). sorted x\"", "lemma sorted_nmsort:\n  \"sorted (nmsort xs)\"", "lemma\n  fixes a :: \"'a::linorder\" and xs ys :: \"'a list\"\n  shows C_runs: \"C_runs xs \\<le> length xs - 1\"\n    and C_asc: \"C_asc a ys \\<le> length ys\"\n    and C_desc: \"C_desc a ys \\<le> length ys\"", "lemma\n  shows length_runs: \"length (runs xs) \\<le> length xs\"\n    and length_asc: \"ascP f \\<Longrightarrow> length (asc a f ys) \\<le> 1 + length ys\"\n    and length_desc: \"length (desc a xs ys) \\<le> 1 + length ys\"", "lemma\n  shows length_concat_runs [simp]: \"length (concat (runs xs)) = length xs\"\n    and length_concat_asc: \"ascP f \\<Longrightarrow> length (concat (asc a f ys)) = 1 + length (f []) + length ys\"\n    and length_concat_desc: \"length (concat (desc a xs ys)) = 1 + length xs + length ys\"", "lemma log2_mono:\n  \"x > 0 \\<Longrightarrow> x \\<le> y \\<Longrightarrow> log 2 x \\<le> log 2 y\"", "lemma\n  shows runs_ne: \"xs \\<noteq> [] \\<Longrightarrow> runs xs \\<noteq> []\"\n    and \"ascP f \\<Longrightarrow> asc a f ys \\<noteq> []\"\n    and \"desc a xs ys \\<noteq> []\"", "lemma C_nmsort:\n  assumes [simp]: \"length xs = n\"\n  shows \"C_nmsort xs \\<le> n + n * \\<lceil>log 2 n\\<rceil>\""], "translations": [["", "lemma C_merge_adj':\n  \"C_merge_adj xss \\<le> length (concat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_merge_adj xss \\<le> length (concat xss)", "proof (induct xss rule: C_merge_adj.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. C_merge_adj [] \\<le> length (concat [])\n 2. \\<And>xs. C_merge_adj [xs] \\<le> length (concat [xs])\n 3. \\<And>xs ys zss.\n       C_merge_adj zss \\<le> length (concat zss) \\<Longrightarrow>\n       C_merge_adj (xs # ys # zss) \\<le> length (concat (xs # ys # zss))", "case (3 xs ys zss)"], ["proof (state)\nthis:\n  C_merge_adj zss \\<le> length (concat zss)\n\ngoal (3 subgoals):\n 1. C_merge_adj [] \\<le> length (concat [])\n 2. \\<And>xs. C_merge_adj [xs] \\<le> length (concat [xs])\n 3. \\<And>xs ys zss.\n       C_merge_adj zss \\<le> length (concat zss) \\<Longrightarrow>\n       C_merge_adj (xs # ys # zss) \\<le> length (concat (xs # ys # zss))", "then"], ["proof (chain)\npicking this:\n  C_merge_adj zss \\<le> length (concat zss)", "show ?case"], ["proof (prove)\nusing this:\n  C_merge_adj zss \\<le> length (concat zss)\n\ngoal (1 subgoal):\n 1. C_merge_adj (xs # ys # zss) \\<le> length (concat (xs # ys # zss))", "using C_merge_ub [of xs ys]"], ["proof (prove)\nusing this:\n  C_merge_adj zss \\<le> length (concat zss)\n  C_merge xs ys \\<le> length xs + length ys\n\ngoal (1 subgoal):\n 1. C_merge_adj (xs # ys # zss) \\<le> length (concat (xs # ys # zss))", "by simp"], ["proof (state)\nthis:\n  C_merge_adj (xs # ys # zss) \\<le> length (concat (xs # ys # zss))\n\ngoal (2 subgoals):\n 1. C_merge_adj [] \\<le> length (concat [])\n 2. \\<And>xs. C_merge_adj [xs] \\<le> length (concat [xs])", "qed simp_all"], ["", "lemma length_concat_merge_adj:\n  \"length (concat (merge_adj xss)) = length (concat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (merge_adj xss)) = length (concat xss)", "by (induct xss rule: merge_adj.induct) (simp_all add: length_merge)"], ["", "lemma C_merge_all':\n  \"C_merge_all xss \\<le> length (concat xss) * \\<lceil>log 2 (length xss)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (C_merge_all xss)\n    \\<le> int (length (concat xss)) *\n          \\<lceil>log 2 (real (length xss))\\<rceil>", "proof (induction xss rule: C_merge_all.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "case (3 xs ys zss)"], ["proof (state)\nthis:\n  int (C_merge_all (merge_adj (xs # ys # zss)))\n  \\<le> int (length (concat (merge_adj (xs # ys # zss)))) *\n        \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "let ?xss = \"xs # ys # zss\""], ["proof (state)\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "let ?m = \"length (concat ?xss)\""], ["proof (state)\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have *: \"\\<lceil>log 2 (real n + 2)\\<rceil> = \\<lceil>log 2 (Suc n div 2 + 1)\\<rceil> + 1\" for n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>log 2 (real n + 2)\\<rceil> =\n    \\<lceil>log 2 (real (Suc n div 2 + 1))\\<rceil> + 1", "using ceiling_log2_div2 [of \"n + 2\"]"], ["proof (prove)\nusing this:\n  2 \\<le> n + 2 \\<Longrightarrow>\n  \\<lceil>log 2 (real (n + 2))\\<rceil> =\n  \\<lceil>log 2 (real ((n + 2 - 1) div 2 + 1))\\<rceil> + 1\n\ngoal (1 subgoal):\n 1. \\<lceil>log 2 (real n + 2)\\<rceil> =\n    \\<lceil>log 2 (real (Suc n div 2 + 1))\\<rceil> + 1", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<lceil>log 2 (real ?n + 2)\\<rceil> =\n  \\<lceil>log 2 (real (Suc ?n div 2 + 1))\\<rceil> + 1\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"C_merge_all ?xss = C_merge_adj ?xss + C_merge_all (merge_adj ?xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_merge_all (xs # ys # zss) =\n    C_merge_adj (xs # ys # zss) + C_merge_all (merge_adj (xs # ys # zss))", "by simp"], ["proof (state)\nthis:\n  C_merge_all (xs # ys # zss) =\n  C_merge_adj (xs # ys # zss) + C_merge_all (merge_adj (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "also"], ["proof (state)\nthis:\n  C_merge_all (xs # ys # zss) =\n  C_merge_adj (xs # ys # zss) + C_merge_all (merge_adj (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"\\<dots> \\<le> ?m + C_merge_all (merge_adj ?xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_merge_adj (xs # ys # zss) + C_merge_all (merge_adj (xs # ys # zss))\n    \\<le> length (concat (xs # ys # zss)) +\n          C_merge_all (merge_adj (xs # ys # zss))", "using C_merge_adj' [of ?xss]"], ["proof (prove)\nusing this:\n  C_merge_adj (xs # ys # zss) \\<le> length (concat (xs # ys # zss))\n\ngoal (1 subgoal):\n 1. C_merge_adj (xs # ys # zss) + C_merge_all (merge_adj (xs # ys # zss))\n    \\<le> length (concat (xs # ys # zss)) +\n          C_merge_all (merge_adj (xs # ys # zss))", "by auto"], ["proof (state)\nthis:\n  C_merge_adj (xs # ys # zss) + C_merge_all (merge_adj (xs # ys # zss))\n  \\<le> length (concat (xs # ys # zss)) +\n        C_merge_all (merge_adj (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "also"], ["proof (state)\nthis:\n  C_merge_adj (xs # ys # zss) + C_merge_all (merge_adj (xs # ys # zss))\n  \\<le> length (concat (xs # ys # zss)) +\n        C_merge_all (merge_adj (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"\\<dots> \\<le> ?m + length (concat (merge_adj ?xss)) * \\<lceil>log 2 (length (merge_adj ?xss))\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (length (concat (xs # ys # zss)) +\n         C_merge_all (merge_adj (xs # ys # zss)))\n    \\<le> int (length (concat (xs # ys # zss))) +\n          int (length (concat (merge_adj (xs # ys # zss)))) *\n          \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>", "using \"3.IH\""], ["proof (prove)\nusing this:\n  int (C_merge_all (merge_adj (xs # ys # zss)))\n  \\<le> int (length (concat (merge_adj (xs # ys # zss)))) *\n        \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (length (concat (xs # ys # zss)) +\n         C_merge_all (merge_adj (xs # ys # zss)))\n    \\<le> int (length (concat (xs # ys # zss))) +\n          int (length (concat (merge_adj (xs # ys # zss)))) *\n          \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>", "by simp"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss)) +\n       C_merge_all (merge_adj (xs # ys # zss)))\n  \\<le> int (length (concat (xs # ys # zss))) +\n        int (length (concat (merge_adj (xs # ys # zss)))) *\n        \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "also"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss)) +\n       C_merge_all (merge_adj (xs # ys # zss)))\n  \\<le> int (length (concat (xs # ys # zss))) +\n        int (length (concat (merge_adj (xs # ys # zss)))) *\n        \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"\\<dots> = ?m + ?m * \\<lceil>log 2 (length (merge_adj ?xss))\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (length (concat (xs # ys # zss))) +\n    int (length (concat (merge_adj (xs # ys # zss)))) *\n    \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil> =\n    int (length (concat (xs # ys # zss))) +\n    int (length (concat (xs # ys # zss))) *\n    \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>", "by (simp only: length_concat_merge_adj)"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss))) +\n  int (length (concat (merge_adj (xs # ys # zss)))) *\n  \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil> =\n  int (length (concat (xs # ys # zss))) +\n  int (length (concat (xs # ys # zss))) *\n  \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "also"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss))) +\n  int (length (concat (merge_adj (xs # ys # zss)))) *\n  \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil> =\n  int (length (concat (xs # ys # zss))) +\n  int (length (concat (xs # ys # zss))) *\n  \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"\\<dots> \\<le> ?m * \\<lceil>log 2 (length ?xss)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (length (concat (xs # ys # zss))) +\n    int (length (concat (xs # ys # zss))) *\n    \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n    \\<le> int (length (concat (xs # ys # zss))) *\n          \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>", "by (auto simp: * algebra_simps)"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss))) +\n  int (length (concat (xs # ys # zss))) *\n  \\<lceil>log 2 (real (length (merge_adj (xs # ys # zss))))\\<rceil>\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (C_merge_all (merge_adj (v # vb # vc)))\n       \\<le> int (length (concat (merge_adj (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_adj\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (C_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> int x \\<le> int y) \\<Longrightarrow>\n  int (C_merge_all (xs # ys # zss))\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> int x \\<le> int y) \\<Longrightarrow>\n  int (C_merge_all (xs # ys # zss))\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_merge_all (xs # ys # zss))\n    \\<le> int (length (concat (xs # ys # zss))) *\n          \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>", "by simp"], ["proof (state)\nthis:\n  int (C_merge_all (xs # ys # zss))\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>\n\ngoal (2 subgoals):\n 1. int (C_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>xs.\n       int (C_merge_all [xs])\n       \\<le> int (length (concat [xs])) *\n             \\<lceil>log 2 (real (length [xs]))\\<rceil>", "qed simp_all"], ["", "subsection \\<open>Definition of Natural Mergesort\\<close>"], ["", "text \\<open>\n  Partition input into ascending and descending subsequences.\n  (The latter are reverted on the fly.)\n\\<close>"], ["", "fun runs :: \"('a::linorder) list \\<Rightarrow> 'a list list\" and\n    asc :: \"'a \\<Rightarrow> ('a list \\<Rightarrow> 'a list) \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\" and\n    desc :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\"\n  where\n    \"runs (a # b # xs) = (if a > b then desc b [a] xs else asc b ((#) a) xs)\"\n  | \"runs [x] = [[x]]\"\n  | \"runs [] = []\"\n  | \"asc a as (b # bs) = (if \\<not> a > b then asc b (as \\<circ> (#) a) bs else as [a] # runs (b # bs))\"\n  | \"asc a as [] = [as [a]]\"\n  | \"desc a as (b # bs) = (if a > b then desc b (a # as) bs else (a # as) # runs (b # bs))\"\n  | \"desc a as [] = [a # as]\""], ["", "definition nmsort :: \"('a::linorder) list \\<Rightarrow> 'a list\"\n  where\n    \"nmsort xs = merge_all (runs xs)\""], ["", "subsection \\<open>Functional Correctness\\<close>"], ["", "definition \"ascP f = (\\<forall>xs ys. f (xs @ ys) = f xs @ ys)\""], ["", "lemma ascP_Cons [simp]: \"ascP ((#) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ascP ((#) x)", "by (simp add: ascP_def)"], ["", "lemma ascP_comp_Cons [simp]: \"ascP f \\<Longrightarrow> ascP (f \\<circ> (#) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ascP f \\<Longrightarrow> ascP (f \\<circ> (#) x)", "by (auto simp: ascP_def simp flip: append_Cons)"], ["", "lemma ascP_simp [simp]:\n  assumes \"ascP f\"\n  shows \"f [x] = f [] @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f [x] = f [] @ [x]", "using assms [unfolded ascP_def, THEN spec, THEN spec, of \"[]\" \"[x]\"]"], ["proof (prove)\nusing this:\n  f ([] @ [x]) = f [] @ [x]\n\ngoal (1 subgoal):\n 1. f [x] = f [] @ [x]", "by simp"], ["", "lemma\n  shows mset_runs: \"\\<Sum>\\<^sub># (image_mset mset (mset (runs xs))) = mset xs\"\n    and mset_asc: \"ascP f \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset mset (mset (asc x f ys))) = {#x#} + mset (f []) + mset ys\"\n    and mset_desc: \"\\<Sum>\\<^sub># (image_mset mset (mset (desc x xs ys))) = {#x#} + mset xs + mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_mset (runs xs) = mset xs &&&\n    (ascP f \\<Longrightarrow>\n     mset_mset (asc x f ys) = {#x#} + mset (f []) + mset ys) &&&\n    mset_mset (desc x xs ys) = {#x#} + mset xs + mset ys", "by (induct xs and x f ys and x xs ys rule: runs_asc_desc.induct) auto"], ["", "lemma mset_nmsort:\n  \"mset (nmsort xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (nmsort xs) = mset xs", "by (auto simp: mset_merge_all nmsort_def mset_runs)"], ["", "lemma\n  shows sorted_runs: \"\\<forall>x\\<in>set (runs xs). sorted x\"\n    and sorted_asc: \"ascP f \\<Longrightarrow> sorted (f []) \\<Longrightarrow> \\<forall>x\\<in>set (f []). x \\<le> a \\<Longrightarrow> \\<forall>x\\<in>set (asc a f ys). sorted x\"\n    and sorted_desc: \"sorted xs \\<Longrightarrow> \\<forall>x\\<in>set xs. a \\<le> x \\<Longrightarrow> \\<forall>x\\<in>set (desc a xs ys). sorted x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (runs xs). sorted x &&&\n    (\\<lbrakk>ascP f; sorted (f []);\n      \\<forall>x\\<in>set (f []). x \\<le> a\\<rbrakk>\n     \\<Longrightarrow> \\<forall>x\\<in>set (asc a f ys). sorted x) &&&\n    (\\<lbrakk>sorted xs; \\<forall>x\\<in>set xs. a \\<le> x\\<rbrakk>\n     \\<Longrightarrow> \\<forall>x\\<in>set (desc a xs ys). sorted x)", "by (induct xs and a f ys and a xs ys rule: runs_asc_desc.induct)\n    (auto simp: sorted_append not_less dest: order_trans, fastforce)"], ["", "lemma sorted_nmsort:\n  \"sorted (nmsort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (nmsort xs)", "by (auto intro: sorted_merge_all simp: nmsort_def sorted_runs)"], ["", "subsection \\<open>Running Time Analysis\\<close>"], ["", "fun C_runs :: \"('a::linorder) list \\<Rightarrow> nat\" and\n    C_asc :: \"('a::linorder) \\<Rightarrow> 'a list \\<Rightarrow> nat\" and\n    C_desc :: \"('a::linorder) \\<Rightarrow> 'a list \\<Rightarrow> nat\"\n  where\n    \"C_runs (a # b # xs) = 1 + (if a > b then C_desc b xs else C_asc b xs)\"\n  | \"C_runs xs = 0\"\n  | \"C_asc a (b # bs) = 1 + (if \\<not> a > b then C_asc b bs else C_runs (b # bs))\"\n  | \"C_asc a [] = 0\"\n  | \"C_desc a (b # bs) = 1 + (if a > b then C_desc b bs else C_runs (b # bs))\"\n  | \"C_desc a [] = 0\""], ["", "fun C_nmsort :: \"('a::linorder) list \\<Rightarrow> nat\"\n  where\n    \"C_nmsort xs = C_runs xs + C_merge_all (runs xs)\""], ["", "lemma\n  fixes a :: \"'a::linorder\" and xs ys :: \"'a list\"\n  shows C_runs: \"C_runs xs \\<le> length xs - 1\"\n    and C_asc: \"C_asc a ys \\<le> length ys\"\n    and C_desc: \"C_desc a ys \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_runs xs \\<le> length xs - 1 &&&\n    C_asc a ys \\<le> length ys &&& C_desc a ys \\<le> length ys", "by (induct xs and a ys and a ys rule: C_runs_C_asc_C_desc.induct) auto"], ["", "lemma\n  shows length_runs: \"length (runs xs) \\<le> length xs\"\n    and length_asc: \"ascP f \\<Longrightarrow> length (asc a f ys) \\<le> 1 + length ys\"\n    and length_desc: \"length (desc a xs ys) \\<le> 1 + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (runs xs) \\<le> length xs &&&\n    (ascP f \\<Longrightarrow> length (asc a f ys) \\<le> 1 + length ys) &&&\n    length (desc a xs ys) \\<le> 1 + length ys", "by (induct xs and a f ys and a xs ys rule: runs_asc_desc.induct) auto"], ["", "lemma\n  shows length_concat_runs [simp]: \"length (concat (runs xs)) = length xs\"\n    and length_concat_asc: \"ascP f \\<Longrightarrow> length (concat (asc a f ys)) = 1 + length (f []) + length ys\"\n    and length_concat_desc: \"length (concat (desc a xs ys)) = 1 + length xs + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (runs xs)) = length xs &&&\n    (ascP f \\<Longrightarrow>\n     length (concat (asc a f ys)) = 1 + length (f []) + length ys) &&&\n    length (concat (desc a xs ys)) = 1 + length xs + length ys", "by (induct xs and a f ys and a xs ys rule: runs_asc_desc.induct) auto"], ["", "lemma log2_mono:\n  \"x > 0 \\<Longrightarrow> x \\<le> y \\<Longrightarrow> log 2 x \\<le> log 2 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> log 2 x \\<le> log 2 y", "by auto"], ["", "lemma\n  shows runs_ne: \"xs \\<noteq> [] \\<Longrightarrow> runs xs \\<noteq> []\"\n    and \"ascP f \\<Longrightarrow> asc a f ys \\<noteq> []\"\n    and \"desc a xs ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> [] \\<Longrightarrow> runs xs \\<noteq> []) &&&\n    (ascP f \\<Longrightarrow> asc a f ys \\<noteq> []) &&&\n    desc a xs ys \\<noteq> []", "by (induct xs and a f ys and a xs ys rule: runs_asc_desc.induct) simp_all"], ["", "lemma C_nmsort:\n  assumes [simp]: \"length xs = n\"\n  shows \"C_nmsort xs \\<le> n + n * \\<lceil>log 2 n\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have [simp]: \"xs = [] \\<longleftrightarrow> length xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = []) = (length xs = 0)", "by blast"], ["proof (state)\nthis:\n  (xs = []) = (length xs = 0)\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (length (runs xs))\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (C_merge_all (runs xs))\n    \\<le> int n * \\<lceil>log 2 (real (length (runs xs)))\\<rceil>", "using C_merge_all' [of \"runs xs\"]"], ["proof (prove)\nusing this:\n  int (C_merge_all (runs xs))\n  \\<le> int (length (concat (runs xs))) *\n        \\<lceil>log 2 (real (length (runs xs)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_merge_all (runs xs))\n    \\<le> int n * \\<lceil>log 2 (real (length (runs xs)))\\<rceil>", "by simp"], ["proof (state)\nthis:\n  int (C_merge_all (runs xs))\n  \\<le> int n * \\<lceil>log 2 (real (length (runs xs)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "also"], ["proof (state)\nthis:\n  int (C_merge_all (runs xs))\n  \\<le> int n * \\<lceil>log 2 (real (length (runs xs)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"\\<dots> \\<le> int n * \\<lceil>log 2 n\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n * \\<lceil>log 2 (real (length (runs xs)))\\<rceil>\n    \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "using length_runs [of xs]"], ["proof (prove)\nusing this:\n  length (runs xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. int n * \\<lceil>log 2 (real (length (runs xs)))\\<rceil>\n    \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "by (cases n) (auto intro!: runs_ne mult_mono ceiling_mono log2_mono)"], ["proof (state)\nthis:\n  int n * \\<lceil>log 2 (real (length (runs xs)))\\<rceil>\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "finally"], ["proof (chain)\npicking this:\n  int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 n\\<rceil>\""], ["proof (prove)\nusing this:\n  int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "."], ["proof (state)\nthis:\n  int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "moreover"], ["proof (state)\nthis:\n  int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"C_runs xs \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_runs xs \\<le> n", "using C_runs [of xs]"], ["proof (prove)\nusing this:\n  C_runs xs \\<le> length xs - 1\n\ngoal (1 subgoal):\n 1. C_runs xs \\<le> n", "by auto"], ["proof (state)\nthis:\n  C_runs xs \\<le> n\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "ultimately"], ["proof (chain)\npicking this:\n  int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n  C_runs xs \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  int (C_merge_all (runs xs)) \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n  C_runs xs \\<le> n\n\ngoal (1 subgoal):\n 1. int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "by (auto intro: add_mono)"], ["proof (state)\nthis:\n  int (C_nmsort xs) \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}