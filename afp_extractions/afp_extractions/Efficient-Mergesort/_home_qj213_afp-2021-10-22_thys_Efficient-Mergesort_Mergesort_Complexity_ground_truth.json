{"file_name": "/home/qj213/afp-2021-10-22/thys/Efficient-Mergesort/Mergesort_Complexity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Efficient-Mergesort", "problem_names": ["lemma log2_mono:\n  \"x > 0 \\<Longrightarrow> x \\<le> y \\<Longrightarrow> log 2 x \\<le> log 2 y\"", "lemma c_merge:\n  \"c_merge xs ys \\<le> length xs + length ys\"", "lemma c_merge_pairs:\n  \"c_merge_pairs xss \\<le> length (concat xss)\"", "lemma c_merge_all:\n  \"c_merge_all xss \\<le> length (concat xss) * \\<lceil>log 2 (length xss)\\<rceil>\"", "lemma\n  shows c_sequences: \"c_sequences xs \\<le> length xs - 1\"\n    and c_asc: \"c_asc x ys \\<le> length ys\"\n    and c_desc: \"c_desc x ys \\<le> length ys\"", "lemma\n  shows length_concat_sequences [simp]: \"length (concat (sequences key xs)) = length xs\"\n    and length_concat_asc: \"ascP f \\<Longrightarrow> length (concat (asc key a f ys)) = 1 + length (f []) + length ys\"\n    and length_concat_desc: \"length (concat (desc key a xs ys)) = 1 + length xs + length ys\"", "lemma\n  shows sequences_ne: \"xs \\<noteq> [] \\<Longrightarrow> sequences key xs \\<noteq> []\"\n    and asc_ne: \"ascP f \\<Longrightarrow> asc key a f ys \\<noteq> []\"\n    and desc_ne: \"desc key a xs ys \\<noteq> []\"", "lemma c_msort:\n  assumes [simp]: \"length xs = n\"\n  shows \"c_msort xs \\<le> n + n * \\<lceil>log 2 n\\<rceil>\""], "translations": [["", "lemma log2_mono:\n  \"x > 0 \\<Longrightarrow> x \\<le> y \\<Longrightarrow> log 2 x \\<le> log 2 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> log 2 x \\<le> log 2 y", "by auto"], ["", "section \\<open>Counting the Number of Comparisons\\<close>"], ["", "context\n  fixes key :: \"'a \\<Rightarrow> 'k::linorder\"\nbegin"], ["", "fun c_merge :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> nat\"\n  where\n    \"c_merge (x # xs) (y # ys) =\n      1 + (if key y < key x then c_merge (x # xs) ys else c_merge xs (y # ys))\"\n  | \"c_merge [] ys = 0\"\n  | \"c_merge xs [] = 0\""], ["", "fun c_merge_pairs :: \"'a list list \\<Rightarrow> nat\"\n  where\n    \"c_merge_pairs (xs # ys # zss) = c_merge xs ys + c_merge_pairs zss\"\n  | \"c_merge_pairs [] = 0\"\n  | \"c_merge_pairs [x] = 0\""], ["", "fun c_merge_all :: \"'a list list \\<Rightarrow> nat\"\n  where\n    \"c_merge_all [] = 0\"\n  | \"c_merge_all [x] = 0\"\n  | \"c_merge_all xss = c_merge_pairs xss + c_merge_all (merge_pairs key xss)\""], ["", "fun c_sequences :: \"'a list \\<Rightarrow> nat\"\n  and c_asc :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> nat\"\n  and c_desc :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> nat\"\n  where\n    \"c_sequences (x # y # zs) = 1 + (if key y < key x then c_desc y zs else c_asc y zs)\"\n  | \"c_sequences [] = 0\"\n  | \"c_sequences [x] = 0\"\n  | \"c_asc x (y # ys) = 1 + (if \\<not> key y < key x then c_asc y ys else c_sequences (y # ys))\"\n  | \"c_asc x [] = 0\"\n  | \"c_desc x (y # ys) = 1 + (if key y < key x then c_desc y ys else c_sequences (y # ys))\"\n  | \"c_desc x [] = 0\""], ["", "fun c_msort :: \"'a list \\<Rightarrow> nat\"\n  where\n    \"c_msort xs = c_sequences xs + c_merge_all (sequences key xs)\""], ["", "lemma c_merge:\n  \"c_merge xs ys \\<le> length xs + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.c_merge xs ys \\<le> length xs + length ys", "by (induct xs ys rule: c_merge.induct) simp_all"], ["", "lemma c_merge_pairs:\n  \"c_merge_pairs xss \\<le> length (concat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.c_merge_pairs xss \\<le> length (concat xss)", "proof (induct xss rule: c_merge_pairs.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs ys zss.\n       local.c_merge_pairs zss \\<le> length (concat zss) \\<Longrightarrow>\n       local.c_merge_pairs (xs # ys # zss)\n       \\<le> length (concat (xs # ys # zss))\n 2. local.c_merge_pairs [] \\<le> length (concat [])\n 3. \\<And>x. local.c_merge_pairs [x] \\<le> length (concat [x])", "case (1 xs ys zss)"], ["proof (state)\nthis:\n  local.c_merge_pairs zss \\<le> length (concat zss)\n\ngoal (3 subgoals):\n 1. \\<And>xs ys zss.\n       local.c_merge_pairs zss \\<le> length (concat zss) \\<Longrightarrow>\n       local.c_merge_pairs (xs # ys # zss)\n       \\<le> length (concat (xs # ys # zss))\n 2. local.c_merge_pairs [] \\<le> length (concat [])\n 3. \\<And>x. local.c_merge_pairs [x] \\<le> length (concat [x])", "then"], ["proof (chain)\npicking this:\n  local.c_merge_pairs zss \\<le> length (concat zss)", "show ?case"], ["proof (prove)\nusing this:\n  local.c_merge_pairs zss \\<le> length (concat zss)\n\ngoal (1 subgoal):\n 1. local.c_merge_pairs (xs # ys # zss)\n    \\<le> length (concat (xs # ys # zss))", "using c_merge [of xs ys]"], ["proof (prove)\nusing this:\n  local.c_merge_pairs zss \\<le> length (concat zss)\n  local.c_merge xs ys \\<le> length xs + length ys\n\ngoal (1 subgoal):\n 1. local.c_merge_pairs (xs # ys # zss)\n    \\<le> length (concat (xs # ys # zss))", "by simp"], ["proof (state)\nthis:\n  local.c_merge_pairs (xs # ys # zss) \\<le> length (concat (xs # ys # zss))\n\ngoal (2 subgoals):\n 1. local.c_merge_pairs [] \\<le> length (concat [])\n 2. \\<And>x. local.c_merge_pairs [x] \\<le> length (concat [x])", "qed simp_all"], ["", "lemma c_merge_all:\n  \"c_merge_all xss \\<le> length (concat xss) * \\<lceil>log 2 (length xss)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (local.c_merge_all xss)\n    \\<le> int (length (concat xss)) *\n          \\<lceil>log 2 (real (length xss))\\<rceil>", "proof (induction xss rule: c_merge_all.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "case (3 xs ys zss)"], ["proof (state)\nthis:\n  int (local.c_merge_all (merge_pairs key (xs # ys # zss)))\n  \\<le> int (length (concat (merge_pairs key (xs # ys # zss)))) *\n        \\<lceil>log 2\n                 (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "let ?clen = \"\\<lambda>xs. length (concat xs)\""], ["proof (state)\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "let ?xss = \"xs # ys # zss\""], ["proof (state)\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "let ?xss2 = \"merge_pairs key ?xss\""], ["proof (state)\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have *: \"\\<lceil>log 2 (real n + 2)\\<rceil> = \\<lceil>log 2 (Suc n div 2 + 1)\\<rceil> + 1\" for n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>log 2 (real n + 2)\\<rceil> =\n    \\<lceil>log 2 (real (Suc n div 2 + 1))\\<rceil> + 1", "using ceiling_log2_div2 [of \"n + 2\"]"], ["proof (prove)\nusing this:\n  2 \\<le> n + 2 \\<Longrightarrow>\n  \\<lceil>log 2 (real (n + 2))\\<rceil> =\n  \\<lceil>log 2 (real ((n + 2 - 1) div 2 + 1))\\<rceil> + 1\n\ngoal (1 subgoal):\n 1. \\<lceil>log 2 (real n + 2)\\<rceil> =\n    \\<lceil>log 2 (real (Suc n div 2 + 1))\\<rceil> + 1", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<lceil>log 2 (real ?n1 + 2)\\<rceil> =\n  \\<lceil>log 2 (real (Suc ?n1 div 2 + 1))\\<rceil> + 1\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"c_merge_all ?xss = c_merge_pairs ?xss + c_merge_all ?xss2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.c_merge_all (xs # ys # zss) =\n    local.c_merge_pairs (xs # ys # zss) +\n    local.c_merge_all (merge_pairs key (xs # ys # zss))", "by simp"], ["proof (state)\nthis:\n  local.c_merge_all (xs # ys # zss) =\n  local.c_merge_pairs (xs # ys # zss) +\n  local.c_merge_all (merge_pairs key (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "also"], ["proof (state)\nthis:\n  local.c_merge_all (xs # ys # zss) =\n  local.c_merge_pairs (xs # ys # zss) +\n  local.c_merge_all (merge_pairs key (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"\\<dots> \\<le> ?clen ?xss + c_merge_all ?xss2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.c_merge_pairs (xs # ys # zss) +\n    local.c_merge_all (merge_pairs key (xs # ys # zss))\n    \\<le> length (concat (xs # ys # zss)) +\n          local.c_merge_all (merge_pairs key (xs # ys # zss))", "using c_merge [of xs ys] and c_merge_pairs [of ?xss]"], ["proof (prove)\nusing this:\n  local.c_merge xs ys \\<le> length xs + length ys\n  local.c_merge_pairs (xs # ys # zss) \\<le> length (concat (xs # ys # zss))\n\ngoal (1 subgoal):\n 1. local.c_merge_pairs (xs # ys # zss) +\n    local.c_merge_all (merge_pairs key (xs # ys # zss))\n    \\<le> length (concat (xs # ys # zss)) +\n          local.c_merge_all (merge_pairs key (xs # ys # zss))", "by auto"], ["proof (state)\nthis:\n  local.c_merge_pairs (xs # ys # zss) +\n  local.c_merge_all (merge_pairs key (xs # ys # zss))\n  \\<le> length (concat (xs # ys # zss)) +\n        local.c_merge_all (merge_pairs key (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "also"], ["proof (state)\nthis:\n  local.c_merge_pairs (xs # ys # zss) +\n  local.c_merge_all (merge_pairs key (xs # ys # zss))\n  \\<le> length (concat (xs # ys # zss)) +\n        local.c_merge_all (merge_pairs key (xs # ys # zss))\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"\\<dots> \\<le> ?clen ?xss + ?clen ?xss2 * \\<lceil>log 2 (length ?xss2)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (length (concat (xs # ys # zss)) +\n         local.c_merge_all (merge_pairs key (xs # ys # zss)))\n    \\<le> int (length (concat (xs # ys # zss))) +\n          int (length (concat (merge_pairs key (xs # ys # zss)))) *\n          \\<lceil>log 2\n                   (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>", "using \"3.IH\""], ["proof (prove)\nusing this:\n  int (local.c_merge_all (merge_pairs key (xs # ys # zss)))\n  \\<le> int (length (concat (merge_pairs key (xs # ys # zss)))) *\n        \\<lceil>log 2\n                 (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (length (concat (xs # ys # zss)) +\n         local.c_merge_all (merge_pairs key (xs # ys # zss)))\n    \\<le> int (length (concat (xs # ys # zss))) +\n          int (length (concat (merge_pairs key (xs # ys # zss)))) *\n          \\<lceil>log 2\n                   (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>", "by simp"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss)) +\n       local.c_merge_all (merge_pairs key (xs # ys # zss)))\n  \\<le> int (length (concat (xs # ys # zss))) +\n        int (length (concat (merge_pairs key (xs # ys # zss)))) *\n        \\<lceil>log 2\n                 (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "also"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss)) +\n       local.c_merge_all (merge_pairs key (xs # ys # zss)))\n  \\<le> int (length (concat (xs # ys # zss))) +\n        int (length (concat (merge_pairs key (xs # ys # zss)))) *\n        \\<lceil>log 2\n                 (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "have \"\\<dots> \\<le> ?clen ?xss * \\<lceil>log 2 (length ?xss)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (length (concat (xs # ys # zss))) +\n    int (length (concat (merge_pairs key (xs # ys # zss)))) *\n    \\<lceil>log 2 (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>\n    \\<le> int (length (concat (xs # ys # zss))) *\n          \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>", "by (auto simp: * algebra_simps)"], ["proof (state)\nthis:\n  int (length (concat (xs # ys # zss))) +\n  int (length (concat (merge_pairs key (xs # ys # zss)))) *\n  \\<lceil>log 2 (real (length (merge_pairs key (xs # ys # zss))))\\<rceil>\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>\n\ngoal (3 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>\n 3. \\<And>v vb vc.\n       int (local.c_merge_all (merge_pairs key (v # vb # vc)))\n       \\<le> int (length (concat (merge_pairs key (v # vb # vc)))) *\n             \\<lceil>log 2\n                      (real\n                        (length\n                          (merge_pairs key\n                            (v # vb # vc))))\\<rceil> \\<Longrightarrow>\n       int (local.c_merge_all (v # vb # vc))\n       \\<le> int (length (concat (v # vb # vc))) *\n             \\<lceil>log 2 (real (length (v # vb # vc)))\\<rceil>", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> int x \\<le> int y) \\<Longrightarrow>\n  int (local.c_merge_all (xs # ys # zss))\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> int x \\<le> int y) \\<Longrightarrow>\n  int (local.c_merge_all (xs # ys # zss))\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_merge_all (xs # ys # zss))\n    \\<le> int (length (concat (xs # ys # zss))) *\n          \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>", "by simp"], ["proof (state)\nthis:\n  int (local.c_merge_all (xs # ys # zss))\n  \\<le> int (length (concat (xs # ys # zss))) *\n        \\<lceil>log 2 (real (length (xs # ys # zss)))\\<rceil>\n\ngoal (2 subgoals):\n 1. int (local.c_merge_all [])\n    \\<le> int (length (concat [])) *\n          \\<lceil>log 2 (real (length []))\\<rceil>\n 2. \\<And>x.\n       int (local.c_merge_all [x])\n       \\<le> int (length (concat [x])) *\n             \\<lceil>log 2 (real (length [x]))\\<rceil>", "qed simp_all"], ["", "lemma\n  shows c_sequences: \"c_sequences xs \\<le> length xs - 1\"\n    and c_asc: \"c_asc x ys \\<le> length ys\"\n    and c_desc: \"c_desc x ys \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.c_sequences xs \\<le> length xs - 1 &&&\n    local.c_asc x ys \\<le> length ys &&& local.c_desc x ys \\<le> length ys", "by (induct xs and x ys and x ys rule: c_sequences_c_asc_c_desc.induct) simp_all"], ["", "lemma\n  shows length_concat_sequences [simp]: \"length (concat (sequences key xs)) = length xs\"\n    and length_concat_asc: \"ascP f \\<Longrightarrow> length (concat (asc key a f ys)) = 1 + length (f []) + length ys\"\n    and length_concat_desc: \"length (concat (desc key a xs ys)) = 1 + length xs + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (sequences key xs)) = length xs &&&\n    (ascP f \\<Longrightarrow>\n     length (concat (asc key a f ys)) = 1 + length (f []) + length ys) &&&\n    length (concat (desc key a xs ys)) = 1 + length xs + length ys", "by (induct xs and a f ys and a xs ys rule: sequences_asc_desc.induct)\n    (auto simp: ascP_f_singleton)"], ["", "lemma\n  shows sequences_ne: \"xs \\<noteq> [] \\<Longrightarrow> sequences key xs \\<noteq> []\"\n    and asc_ne: \"ascP f \\<Longrightarrow> asc key a f ys \\<noteq> []\"\n    and desc_ne: \"desc key a xs ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> [] \\<Longrightarrow> sequences key xs \\<noteq> []) &&&\n    (ascP f \\<Longrightarrow> asc key a f ys \\<noteq> []) &&&\n    desc key a xs ys \\<noteq> []", "by (induct xs and a f ys and a xs ys taking: key rule: sequences_asc_desc.induct) simp_all"], ["", "lemma c_msort:\n  assumes [simp]: \"length xs = n\"\n  shows \"c_msort xs \\<le> n + n * \\<lceil>log 2 n\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have [simp]: \"xs = [] \\<longleftrightarrow> length xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = []) = (length xs = 0)", "by blast"], ["proof (state)\nthis:\n  (xs = []) = (length xs = 0)\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"int (c_merge_all (sequences key xs)) \\<le> int n * \\<lceil>log 2 (length (sequences key xs))\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (local.c_merge_all (sequences key xs))\n    \\<le> int n * \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>", "using c_merge_all [of \"sequences key xs\"]"], ["proof (prove)\nusing this:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int (length (concat (sequences key xs))) *\n        \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_merge_all (sequences key xs))\n    \\<le> int n * \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>", "by simp"], ["proof (state)\nthis:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "also"], ["proof (state)\nthis:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"\\<dots> \\<le> int n * \\<lceil>log 2 n\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n * \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>\n    \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "using length_sequences [of key xs]"], ["proof (prove)\nusing this:\n  length (sequences key xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. int n * \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>\n    \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "by (cases n) (auto intro!: sequences_ne mult_mono ceiling_mono log2_mono)"], ["proof (state)\nthis:\n  int n * \\<lceil>log 2 (real (length (sequences key xs)))\\<rceil>\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "finally"], ["proof (chain)\npicking this:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"int (c_merge_all (sequences key xs)) \\<le> int n * \\<lceil>log 2 n\\<rceil>\""], ["proof (prove)\nusing this:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_merge_all (sequences key xs))\n    \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>", "."], ["proof (state)\nthis:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "moreover"], ["proof (state)\nthis:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "have \"c_sequences xs \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.c_sequences xs \\<le> n", "using c_sequences [of xs]"], ["proof (prove)\nusing this:\n  local.c_sequences xs \\<le> length xs - 1\n\ngoal (1 subgoal):\n 1. local.c_sequences xs \\<le> n", "by auto"], ["proof (state)\nthis:\n  local.c_sequences xs \\<le> n\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "ultimately"], ["proof (chain)\npicking this:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n  local.c_sequences xs \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  int (local.c_merge_all (sequences key xs))\n  \\<le> int n * \\<lceil>log 2 (real n)\\<rceil>\n  local.c_sequences xs \\<le> n\n\ngoal (1 subgoal):\n 1. int (local.c_msort xs)\n    \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>", "by (auto intro: add_mono)"], ["proof (state)\nthis:\n  int (local.c_msort xs)\n  \\<le> int n + int n * \\<lceil>log 2 (real n)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}