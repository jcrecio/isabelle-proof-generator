{"file_name": "/home/qj213/afp-2021-10-22/thys/Efficient-Mergesort/Efficient_Sort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Efficient-Mergesort", "problem_names": ["lemma length_merge [simp]:\n  \"length (merge xs ys) = length xs + length ys\"", "lemma length_merge_pairs [simp]:\n  \"length (merge_pairs xs) = (1 + length xs) div 2\"", "lemma ascP_Cons [simp]: \"ascP ((#) x)\"", "lemma ascP_comp_append_Cons [simp]:\n  \"ascP (\\<lambda>xs. f [] @ x # xs)\"", "lemma ascP_f_Cons:\n  assumes \"ascP f\"\n  shows \"f (x # xs) = f [] @ x # xs\"", "lemma ascP_comp_Cons [simp]:\n  assumes \"ascP f\"\n  shows \"ascP (\\<lambda>ys. f (x # ys))\"", "lemma ascP_f_singleton:\n  assumes \"ascP f\"\n  shows \"f [x] = f [] @ [x]\"", "lemma\n  shows length_sequences: \"length (sequences xs) \\<le> length xs\"\n    and length_asc: \"ascP f \\<Longrightarrow> length (asc a f ys) \\<le> 1 + length ys\"\n    and length_desc: \"length (desc a xs ys) \\<le> 1 + length ys\"", "lemma length_concat_merge_pairs [simp]:\n  \"length (concat (merge_pairs xss)) = length (concat xss)\"", "lemma mset_merge [simp]:\n  \"mset (merge xs ys) = mset xs + mset ys\"", "lemma set_merge [simp]:\n  \"set (merge xs ys) = set xs \\<union> set ys\"", "lemma mset_concat_merge_pairs [simp]:\n  \"mset (concat (merge_pairs xs)) = mset (concat xs)\"", "lemma set_concat_merge_pairs [simp]:\n  \"set (concat (merge_pairs xs)) = set (concat xs)\"", "lemma mset_merge_all [simp]:\n  \"mset (merge_all xs) = mset (concat xs)\"", "lemma set_merge_all [simp]:\n  \"set (merge_all xs) = set (concat xs)\"", "lemma\n  shows mset_seqeuences [simp]: \"mset (concat (sequences xs)) = mset xs\"\n    and mset_asc: \"ascP f \\<Longrightarrow> mset (concat (asc x f ys)) = {#x#} + mset (f []) + mset ys\"\n    and mset_desc: \"mset (concat (desc x xs ys)) = {#x#} + mset xs + mset ys\"", "lemma mset_msort_key:\n  \"mset (msort_key xs) = mset xs\"", "lemma sorted_merge [simp]:\n  assumes \"sorted (map key xs)\" and \"sorted (map key ys)\"\n  shows \"sorted (map key (merge xs ys))\"", "lemma sorted_merge_pairs [simp]:\n  assumes \"\\<forall>x\\<in>set xs. sorted (map key x)\"\n  shows \"\\<forall>x\\<in>set (merge_pairs xs). sorted (map key x)\"", "lemma sorted_merge_all:\n  assumes \"\\<forall>x\\<in>set xs. sorted (map key x)\"\n  shows \"sorted (map key (merge_all xs))\"", "lemma\n  shows sorted_sequences: \"\\<forall>x \\<in> set (sequences xs). sorted (map key x)\"\n    and sorted_asc: \"ascP f \\<Longrightarrow> sorted (map key (f [])) \\<Longrightarrow> \\<forall>x\\<in>set (f []). key x \\<le> key a \\<Longrightarrow> \\<forall>x\\<in>set (asc a f ys). sorted (map key x)\"\n    and sorted_desc: \"sorted (map key xs) \\<Longrightarrow> \\<forall>x\\<in>set xs. key a \\<le> key x \\<Longrightarrow> \\<forall>x\\<in>set (desc a xs ys). sorted (map key x)\"", "lemma sorted_msort_key:\n  \"sorted (map key (msort_key xs))\"", "lemma\n  shows filter_by_key_sequences [simp]: \"[y\\<leftarrow>concat (sequences xs). key y = k] = [y\\<leftarrow>xs. key y = k]\"\n    and filter_by_key_asc: \"ascP f \\<Longrightarrow> [y\\<leftarrow>concat (asc a f ys). key y = k] = [y\\<leftarrow>f [a] @ ys. key y = k]\"\n    and filter_by_key_desc: \"sorted (map key xs) \\<Longrightarrow> \\<forall>x\\<in>set xs. key a \\<le> key x \\<Longrightarrow> [y\\<leftarrow>concat (desc a xs ys). key y = k] = [y\\<leftarrow>a # xs @ ys. key y = k]\"", "lemma filter_by_key_merge_is_append [simp]:\n  assumes \"sorted (map key xs)\"\n  shows \"[y\\<leftarrow>merge xs ys. key y = k] = [y\\<leftarrow>xs. key y = k] @ [y\\<leftarrow>ys. key y = k]\"", "lemma filter_by_key_merge_pairs [simp]:\n  assumes \"\\<forall>xs\\<in>set xss. sorted (map key xs)\"\n  shows \"[y\\<leftarrow>concat (merge_pairs xss). key y = k] = [y\\<leftarrow>concat xss. key y = k]\"", "lemma filter_by_key_merge_all [simp]:\n  assumes \"\\<forall>xs\\<in>set xss. sorted (map key xs)\"\n  shows \"[y\\<leftarrow>merge_all xss. key y = k] = [y\\<leftarrow>concat xss. key y = k]\"", "lemma filter_by_key_merge_all_sequences [simp]:\n  \"[x\\<leftarrow>merge_all (sequences xs) . key x = k] = [x\\<leftarrow>xs . key x = k]\"", "lemma msort_key_stable:\n  \"[x\\<leftarrow>msort_key xs. key x = k] = [x\\<leftarrow>xs. key x = k]\"", "lemma sort_key_msort_key_conv:\n  \"sort_key key = msort_key\""], "translations": [["", "lemma length_merge [simp]:\n  \"length (merge xs ys) = length xs + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (local.merge xs ys) = length xs + length ys", "by (induct xs ys rule: merge.induct) simp_all"], ["", "lemma length_merge_pairs [simp]:\n  \"length (merge_pairs xs) = (1 + length xs) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (local.merge_pairs xs) = (1 + length xs) div 2", "by (induct xs rule: merge_pairs.induct) simp_all"], ["", "fun merge_all :: \"'a list list \\<Rightarrow> 'a list\"\n  where\n    \"merge_all [] = []\"\n  | \"merge_all [x] = x\"\n  | \"merge_all xs = merge_all (merge_pairs xs)\""], ["", "fun msort_key :: \"'a list \\<Rightarrow> 'a list\"\n  where\n    \"msort_key xs = merge_all (sequences xs)\""], ["", "subsection \\<open>The Functional Argument of @{const asc}\\<close>"], ["", "text \\<open>\\<open>f\\<close> is a function that only adds some prefix to a given list.\\<close>"], ["", "definition \"ascP f = (\\<forall>xs. f xs = f [] @ xs)\""], ["", "lemma ascP_Cons [simp]: \"ascP ((#) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ascP ((#) x)", "by (simp add: ascP_def)"], ["", "lemma ascP_comp_append_Cons [simp]:\n  \"ascP (\\<lambda>xs. f [] @ x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ascP (\\<lambda>xs. f [] @ x # xs)", "by (auto simp: ascP_def)"], ["", "lemma ascP_f_Cons:\n  assumes \"ascP f\"\n  shows \"f (x # xs) = f [] @ x # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x # xs) = f [] @ x # xs", "using \\<open>ascP f\\<close> [unfolded ascP_def, THEN spec, of \"x # xs\"]"], ["proof (prove)\nusing this:\n  f (x # xs) = f [] @ x # xs\n\ngoal (1 subgoal):\n 1. f (x # xs) = f [] @ x # xs", "."], ["", "lemma ascP_comp_Cons [simp]:\n  assumes \"ascP f\"\n  shows \"ascP (\\<lambda>ys. f (x # ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ascP (\\<lambda>ys. f (x # ys))", "proof (unfold ascP_def, intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. f (x # xs) = f [x] @ xs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. f (x # xs) = f [x] @ xs", "show \"f (x # xs) = f [x] @ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x # xs) = f [x] @ xs", "using assms"], ["proof (prove)\nusing this:\n  ascP f\n\ngoal (1 subgoal):\n 1. f (x # xs) = f [x] @ xs", "by (simp add: ascP_f_Cons)"], ["proof (state)\nthis:\n  f (x # xs) = f [x] @ xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ascP_f_singleton:\n  assumes \"ascP f\"\n  shows \"f [x] = f [] @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f [x] = f [] @ [x]", "by (rule ascP_f_Cons [OF assms])"], ["", "subsection \\<open>Facts about Lengths\\<close>"], ["", "lemma\n  shows length_sequences: \"length (sequences xs) \\<le> length xs\"\n    and length_asc: \"ascP f \\<Longrightarrow> length (asc a f ys) \\<le> 1 + length ys\"\n    and length_desc: \"length (desc a xs ys) \\<le> 1 + length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (local.sequences xs) \\<le> length xs &&&\n    (ascP f \\<Longrightarrow>\n     length (local.asc a f ys) \\<le> 1 + length ys) &&&\n    length (local.desc a xs ys) \\<le> 1 + length ys", "by (induct xs and a f ys and a xs ys rule: sequences_asc_desc.induct) auto"], ["", "lemma length_concat_merge_pairs [simp]:\n  \"length (concat (merge_pairs xss)) = length (concat xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (local.merge_pairs xss)) = length (concat xss)", "by (induct xss rule: merge_pairs.induct) simp_all"], ["", "subsection \\<open>Functional Correctness\\<close>"], ["", "lemma mset_merge [simp]:\n  \"mset (merge xs ys) = mset xs + mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (local.merge xs ys) = mset xs + mset ys", "by (induct xs ys rule: merge.induct) simp_all"], ["", "lemma set_merge [simp]:\n  \"set (merge xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.merge xs ys) = set xs \\<union> set ys", "by (simp flip: set_mset_mset)"], ["", "lemma mset_concat_merge_pairs [simp]:\n  \"mset (concat (merge_pairs xs)) = mset (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat (local.merge_pairs xs)) = mset (concat xs)", "by (induct xs rule: merge_pairs.induct) auto"], ["", "lemma set_concat_merge_pairs [simp]:\n  \"set (concat (merge_pairs xs)) = set (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat (local.merge_pairs xs)) = set (concat xs)", "by (simp flip: set_mset_mset)"], ["", "lemma mset_merge_all [simp]:\n  \"mset (merge_all xs) = mset (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (local.merge_all xs) = mset (concat xs)", "by (induct xs rule: merge_all.induct) simp_all"], ["", "lemma set_merge_all [simp]:\n  \"set (merge_all xs) = set (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.merge_all xs) = set (concat xs)", "by (simp flip: set_mset_mset)"], ["", "lemma\n  shows mset_seqeuences [simp]: \"mset (concat (sequences xs)) = mset xs\"\n    and mset_asc: \"ascP f \\<Longrightarrow> mset (concat (asc x f ys)) = {#x#} + mset (f []) + mset ys\"\n    and mset_desc: \"mset (concat (desc x xs ys)) = {#x#} + mset xs + mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat (local.sequences xs)) = mset xs &&&\n    (ascP f \\<Longrightarrow>\n     mset (concat (local.asc x f ys)) = {#x#} + mset (f []) + mset ys) &&&\n    mset (concat (local.desc x xs ys)) = {#x#} + mset xs + mset ys", "by (induct xs and x f ys and x xs ys rule: sequences_asc_desc.induct)\n    (auto simp: ascP_f_singleton)"], ["", "lemma mset_msort_key:\n  \"mset (msort_key xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (local.msort_key xs) = mset xs", "by (auto)"], ["", "lemma sorted_merge [simp]:\n  assumes \"sorted (map key xs)\" and \"sorted (map key ys)\"\n  shows \"sorted (map key (merge xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map key (local.merge xs ys))", "using assms"], ["proof (prove)\nusing this:\n  sorted (map key xs)\n  sorted (map key ys)\n\ngoal (1 subgoal):\n 1. sorted (map key (local.merge xs ys))", "by (induct xs ys rule: merge.induct) (auto)"], ["", "lemma sorted_merge_pairs [simp]:\n  assumes \"\\<forall>x\\<in>set xs. sorted (map key x)\"\n  shows \"\\<forall>x\\<in>set (merge_pairs xs). sorted (map key x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (local.merge_pairs xs). sorted (map key x)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. sorted (map key x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (local.merge_pairs xs). sorted (map key x)", "by (induct xs rule: merge_pairs.induct) simp_all"], ["", "lemma sorted_merge_all:\n  assumes \"\\<forall>x\\<in>set xs. sorted (map key x)\"\n  shows \"sorted (map key (merge_all xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map key (local.merge_all xs))", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. sorted (map key x)\n\ngoal (1 subgoal):\n 1. sorted (map key (local.merge_all xs))", "by (induct xs rule: merge_all.induct) simp_all"], ["", "lemma\n  shows sorted_sequences: \"\\<forall>x \\<in> set (sequences xs). sorted (map key x)\"\n    and sorted_asc: \"ascP f \\<Longrightarrow> sorted (map key (f [])) \\<Longrightarrow> \\<forall>x\\<in>set (f []). key x \\<le> key a \\<Longrightarrow> \\<forall>x\\<in>set (asc a f ys). sorted (map key x)\"\n    and sorted_desc: \"sorted (map key xs) \\<Longrightarrow> \\<forall>x\\<in>set xs. key a \\<le> key x \\<Longrightarrow> \\<forall>x\\<in>set (desc a xs ys). sorted (map key x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (local.sequences xs). sorted (map key x) &&&\n    (\\<lbrakk>ascP f; sorted (map key (f []));\n      \\<forall>x\\<in>set (f []). key x \\<le> key a\\<rbrakk>\n     \\<Longrightarrow> \\<forall>x\\<in>set (local.asc a f ys).\n                          sorted (map key x)) &&&\n    (\\<lbrakk>sorted (map key xs);\n      \\<forall>x\\<in>set xs. key a \\<le> key x\\<rbrakk>\n     \\<Longrightarrow> \\<forall>x\\<in>set (local.desc a xs ys).\n                          sorted (map key x))", "by (induct xs and a f ys and a xs ys rule: sequences_asc_desc.induct)\n    (auto simp: ascP_f_singleton sorted_append not_less dest: order_trans, fastforce)"], ["", "lemma sorted_msort_key:\n  \"sorted (map key (msort_key xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map key (local.msort_key xs))", "by (unfold msort_key.simps) (intro sorted_merge_all sorted_sequences)"], ["", "subsection \\<open>Stability\\<close>"], ["", "lemma\n  shows filter_by_key_sequences [simp]: \"[y\\<leftarrow>concat (sequences xs). key y = k] = [y\\<leftarrow>xs. key y = k]\"\n    and filter_by_key_asc: \"ascP f \\<Longrightarrow> [y\\<leftarrow>concat (asc a f ys). key y = k] = [y\\<leftarrow>f [a] @ ys. key y = k]\"\n    and filter_by_key_desc: \"sorted (map key xs) \\<Longrightarrow> \\<forall>x\\<in>set xs. key a \\<le> key x \\<Longrightarrow> [y\\<leftarrow>concat (desc a xs ys). key y = k] = [y\\<leftarrow>a # xs @ ys. key y = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.sequences xs)) =\n    filter (\\<lambda>y. key y = k) xs &&&\n    (ascP f \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.asc a f ys)) =\n     filter (\\<lambda>y. key y = k) (f [a] @ ys)) &&&\n    (\\<lbrakk>sorted (map key xs);\n      \\<forall>x\\<in>set xs. key a \\<le> key x\\<rbrakk>\n     \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                        (concat (local.desc a xs ys)) =\n                       filter (\\<lambda>y. key y = k) (a # xs @ ys))", "proof (induct xs and a f ys and a xs ys rule: sequences_asc_desc.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key [a]);\n                 \\<forall>x\\<in>set [a]. key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b [a] xs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # [a] @ xs);\n        \\<lbrakk>\\<not> key b < key a; ascP ((#) a)\\<rbrakk>\n        \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                           (concat (local.asc b ((#) a) xs)) =\n                          filter (\\<lambda>y. key y = k)\n                           ([a, b] @ xs)\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.sequences (a # b # xs))) =\n                         filter (\\<lambda>y. key y = k) (a # b # xs)\n 2. \\<And>x.\n       filter (\\<lambda>y. key y = k) (concat (local.sequences [x])) =\n       filter (\\<lambda>y. key y = k) [x]\n 3. filter (\\<lambda>y. key y = k) (concat (local.sequences [])) =\n    filter (\\<lambda>y. key y = k) []\n 4. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>key a \\<le> key b;\n                 ascP (\\<lambda>b. as (a # b))\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat\n                                     (local.asc b (\\<lambda>b. as (a # b))\n bs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (as [a, b] @ bs);\n        \\<not> key a \\<le> key b \\<Longrightarrow>\n        filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n        filter (\\<lambda>y. key y = k) (b # bs);\n        ascP as\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.asc a as (b # bs))) =\n                         filter (\\<lambda>y. key y = k) (as [a] @ b # bs)\n 5. \\<And>a as.\n       ascP as \\<Longrightarrow>\n       filter (\\<lambda>y. key y = k) (concat (local.asc a as [])) =\n       filter (\\<lambda>y. key y = k) (as [a] @ [])\n 6. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n                 \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b (a # as) bs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # (a # as) @ bs);\n        \\<not> key b < key a \\<Longrightarrow>\n        filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n        filter (\\<lambda>y. key y = k) (b # bs);\n        sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as (b # bs))) =\n                         filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 7. \\<And>a as.\n       \\<lbrakk>sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as [])) =\n                         filter (\\<lambda>y. key y = k) (a # as @ [])", "case (4 a f b bs)"], ["proof (state)\nthis:\n  \\<lbrakk>key a \\<le> key b; ascP (\\<lambda>a. f (a # a))\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.asc b (\\<lambda>a. f (a # a)) bs)) =\n                    filter (\\<lambda>y. key y = k) (f [a, b] @ bs)\n  \\<not> key a \\<le> key b \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  ascP f\n\ngoal (7 subgoals):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key [a]);\n                 \\<forall>x\\<in>set [a]. key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b [a] xs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # [a] @ xs);\n        \\<lbrakk>\\<not> key b < key a; ascP ((#) a)\\<rbrakk>\n        \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                           (concat (local.asc b ((#) a) xs)) =\n                          filter (\\<lambda>y. key y = k)\n                           ([a, b] @ xs)\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.sequences (a # b # xs))) =\n                         filter (\\<lambda>y. key y = k) (a # b # xs)\n 2. \\<And>x.\n       filter (\\<lambda>y. key y = k) (concat (local.sequences [x])) =\n       filter (\\<lambda>y. key y = k) [x]\n 3. filter (\\<lambda>y. key y = k) (concat (local.sequences [])) =\n    filter (\\<lambda>y. key y = k) []\n 4. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>key a \\<le> key b;\n                 ascP (\\<lambda>b. as (a # b))\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat\n                                     (local.asc b (\\<lambda>b. as (a # b))\n bs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (as [a, b] @ bs);\n        \\<not> key a \\<le> key b \\<Longrightarrow>\n        filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n        filter (\\<lambda>y. key y = k) (b # bs);\n        ascP as\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.asc a as (b # bs))) =\n                         filter (\\<lambda>y. key y = k) (as [a] @ b # bs)\n 5. \\<And>a as.\n       ascP as \\<Longrightarrow>\n       filter (\\<lambda>y. key y = k) (concat (local.asc a as [])) =\n       filter (\\<lambda>y. key y = k) (as [a] @ [])\n 6. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n                 \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b (a # as) bs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # (a # as) @ bs);\n        \\<not> key b < key a \\<Longrightarrow>\n        filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n        filter (\\<lambda>y. key y = k) (b # bs);\n        sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as (b # bs))) =\n                         filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 7. \\<And>a as.\n       \\<lbrakk>sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as [])) =\n                         filter (\\<lambda>y. key y = k) (a # as @ [])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>key a \\<le> key b; ascP (\\<lambda>a. f (a # a))\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.asc b (\\<lambda>a. f (a # a)) bs)) =\n                    filter (\\<lambda>y. key y = k) (f [a, b] @ bs)\n  \\<not> key a \\<le> key b \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  ascP f", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>key a \\<le> key b; ascP (\\<lambda>a. f (a # a))\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.asc b (\\<lambda>a. f (a # a)) bs)) =\n                    filter (\\<lambda>y. key y = k) (f [a, b] @ bs)\n  \\<not> key a \\<le> key b \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  ascP f\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.asc a f (b # bs))) =\n    filter (\\<lambda>y. key y = k) (f [a] @ b # bs)", "by (auto simp: o_def ascP_f_Cons [where f = f])"], ["proof (state)\nthis:\n  filter (\\<lambda>y. key y = k) (concat (local.asc a f (b # bs))) =\n  filter (\\<lambda>y. key y = k) (f [a] @ b # bs)\n\ngoal (6 subgoals):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key [a]);\n                 \\<forall>x\\<in>set [a]. key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b [a] xs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # [a] @ xs);\n        \\<lbrakk>\\<not> key b < key a; ascP ((#) a)\\<rbrakk>\n        \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                           (concat (local.asc b ((#) a) xs)) =\n                          filter (\\<lambda>y. key y = k)\n                           ([a, b] @ xs)\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.sequences (a # b # xs))) =\n                         filter (\\<lambda>y. key y = k) (a # b # xs)\n 2. \\<And>x.\n       filter (\\<lambda>y. key y = k) (concat (local.sequences [x])) =\n       filter (\\<lambda>y. key y = k) [x]\n 3. filter (\\<lambda>y. key y = k) (concat (local.sequences [])) =\n    filter (\\<lambda>y. key y = k) []\n 4. \\<And>a as.\n       ascP as \\<Longrightarrow>\n       filter (\\<lambda>y. key y = k) (concat (local.asc a as [])) =\n       filter (\\<lambda>y. key y = k) (as [a] @ [])\n 5. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n                 \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b (a # as) bs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # (a # as) @ bs);\n        \\<not> key b < key a \\<Longrightarrow>\n        filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n        filter (\\<lambda>y. key y = k) (b # bs);\n        sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as (b # bs))) =\n                         filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 6. \\<And>a as.\n       \\<lbrakk>sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as [])) =\n                         filter (\\<lambda>y. key y = k) (a # as @ [])", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key [a]);\n                 \\<forall>x\\<in>set [a]. key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b [a] xs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # [a] @ xs);\n        \\<lbrakk>\\<not> key b < key a; ascP ((#) a)\\<rbrakk>\n        \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                           (concat (local.asc b ((#) a) xs)) =\n                          filter (\\<lambda>y. key y = k)\n                           ([a, b] @ xs)\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.sequences (a # b # xs))) =\n                         filter (\\<lambda>y. key y = k) (a # b # xs)\n 2. \\<And>x.\n       filter (\\<lambda>y. key y = k) (concat (local.sequences [x])) =\n       filter (\\<lambda>y. key y = k) [x]\n 3. filter (\\<lambda>y. key y = k) (concat (local.sequences [])) =\n    filter (\\<lambda>y. key y = k) []\n 4. \\<And>a as.\n       ascP as \\<Longrightarrow>\n       filter (\\<lambda>y. key y = k) (concat (local.asc a as [])) =\n       filter (\\<lambda>y. key y = k) (as [a] @ [])\n 5. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n                 \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b (a # as) bs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # (a # as) @ bs);\n        \\<not> key b < key a \\<Longrightarrow>\n        filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n        filter (\\<lambda>y. key y = k) (b # bs);\n        sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as (b # bs))) =\n                         filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 6. \\<And>a as.\n       \\<lbrakk>sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as [])) =\n                         filter (\\<lambda>y. key y = k) (a # as @ [])", "case (6 a as b bs)"], ["proof (state)\nthis:\n  \\<lbrakk>key b < key a; sorted (map key (a # as));\n   \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.desc b (a # as) bs)) =\n                    filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n  \\<not> key b < key a \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  sorted (map key as)\n  \\<forall>x\\<in>set as. key a \\<le> key x\n\ngoal (6 subgoals):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key [a]);\n                 \\<forall>x\\<in>set [a]. key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b [a] xs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # [a] @ xs);\n        \\<lbrakk>\\<not> key b < key a; ascP ((#) a)\\<rbrakk>\n        \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                           (concat (local.asc b ((#) a) xs)) =\n                          filter (\\<lambda>y. key y = k)\n                           ([a, b] @ xs)\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.sequences (a # b # xs))) =\n                         filter (\\<lambda>y. key y = k) (a # b # xs)\n 2. \\<And>x.\n       filter (\\<lambda>y. key y = k) (concat (local.sequences [x])) =\n       filter (\\<lambda>y. key y = k) [x]\n 3. filter (\\<lambda>y. key y = k) (concat (local.sequences [])) =\n    filter (\\<lambda>y. key y = k) []\n 4. \\<And>a as.\n       ascP as \\<Longrightarrow>\n       filter (\\<lambda>y. key y = k) (concat (local.asc a as [])) =\n       filter (\\<lambda>y. key y = k) (as [a] @ [])\n 5. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n                 \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b (a # as) bs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # (a # as) @ bs);\n        \\<not> key b < key a \\<Longrightarrow>\n        filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n        filter (\\<lambda>y. key y = k) (b # bs);\n        sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as (b # bs))) =\n                         filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 6. \\<And>a as.\n       \\<lbrakk>sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as [])) =\n                         filter (\\<lambda>y. key y = k) (a # as @ [])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>key b < key a; sorted (map key (a # as));\n   \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.desc b (a # as) bs)) =\n                    filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n  \\<not> key b < key a \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  sorted (map key as)\n  \\<forall>x\\<in>set as. key a \\<le> key x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>key b < key a; sorted (map key (a # as));\n   \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.desc b (a # as) bs)) =\n                    filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n  \\<not> key b < key a \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  sorted (map key as)\n  \\<forall>x\\<in>set as. key a \\<le> key x\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.desc a as (b # bs))) =\n    filter (\\<lambda>y. key y = k) (a # as @ b # bs)", "proof (cases \"key b < key a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n              \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n             \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                (concat (local.desc b (a # as) bs)) =\n                               filter (\\<lambda>y. key y = k)\n                                (b # (a # as) @ bs);\n     \\<not> key b < key a \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n     filter (\\<lambda>y. key y = k) (b # bs);\n     sorted (map key as); \\<forall>x\\<in>set as. key a \\<le> key x;\n     key b < key a\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                       (concat (local.desc a as (b # bs))) =\n                      filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 2. \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n              \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n             \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                (concat (local.desc b (a # as) bs)) =\n                               filter (\\<lambda>y. key y = k)\n                                (b # (a # as) @ bs);\n     \\<not> key b < key a \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n     filter (\\<lambda>y. key y = k) (b # bs);\n     sorted (map key as); \\<forall>x\\<in>set as. key a \\<le> key x;\n     \\<not> key b < key a\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                       (concat (local.desc a as (b # bs))) =\n                      filter (\\<lambda>y. key y = k) (a # as @ b # bs)", "case True"], ["proof (state)\nthis:\n  key b < key a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n              \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n             \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                (concat (local.desc b (a # as) bs)) =\n                               filter (\\<lambda>y. key y = k)\n                                (b # (a # as) @ bs);\n     \\<not> key b < key a \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n     filter (\\<lambda>y. key y = k) (b # bs);\n     sorted (map key as); \\<forall>x\\<in>set as. key a \\<le> key x;\n     key b < key a\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                       (concat (local.desc a as (b # bs))) =\n                      filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 2. \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n              \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n             \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                (concat (local.desc b (a # as) bs)) =\n                               filter (\\<lambda>y. key y = k)\n                                (b # (a # as) @ bs);\n     \\<not> key b < key a \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n     filter (\\<lambda>y. key y = k) (b # bs);\n     sorted (map key as); \\<forall>x\\<in>set as. key a \\<le> key x;\n     \\<not> key b < key a\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                       (concat (local.desc a as (b # bs))) =\n                      filter (\\<lambda>y. key y = k) (a # as @ b # bs)", "with 6"], ["proof (chain)\npicking this:\n  \\<lbrakk>key b < key a; sorted (map key (a # as));\n   \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.desc b (a # as) bs)) =\n                    filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n  \\<not> key b < key a \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  sorted (map key as)\n  \\<forall>x\\<in>set as. key a \\<le> key x\n  key b < key a", "have \"[y\\<leftarrow>concat (desc b (a # as) bs). key y = k] = [y\\<leftarrow>b # (a # as) @ bs. key y = k]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>key b < key a; sorted (map key (a # as));\n   \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.desc b (a # as) bs)) =\n                    filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n  \\<not> key b < key a \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  sorted (map key as)\n  \\<forall>x\\<in>set as. key a \\<le> key x\n  key b < key a\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.desc b (a # as) bs)) =\n    filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)", "by (auto simp: less_le order_trans)"], ["proof (state)\nthis:\n  filter (\\<lambda>y. key y = k) (concat (local.desc b (a # as) bs)) =\n  filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n              \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n             \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                (concat (local.desc b (a # as) bs)) =\n                               filter (\\<lambda>y. key y = k)\n                                (b # (a # as) @ bs);\n     \\<not> key b < key a \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n     filter (\\<lambda>y. key y = k) (b # bs);\n     sorted (map key as); \\<forall>x\\<in>set as. key a \\<le> key x;\n     key b < key a\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                       (concat (local.desc a as (b # bs))) =\n                      filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n 2. \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n              \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n             \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                (concat (local.desc b (a # as) bs)) =\n                               filter (\\<lambda>y. key y = k)\n                                (b # (a # as) @ bs);\n     \\<not> key b < key a \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n     filter (\\<lambda>y. key y = k) (b # bs);\n     sorted (map key as); \\<forall>x\\<in>set as. key a \\<le> key x;\n     \\<not> key b < key a\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                       (concat (local.desc a as (b # bs))) =\n                      filter (\\<lambda>y. key y = k) (a # as @ b # bs)", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>y. key y = k) (concat (local.desc b (a # as) bs)) =\n  filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)", "show ?thesis"], ["proof (prove)\nusing this:\n  filter (\\<lambda>y. key y = k) (concat (local.desc b (a # as) bs)) =\n  filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.desc a as (b # bs))) =\n    filter (\\<lambda>y. key y = k) (a # as @ b # bs)", "using True and 6"], ["proof (prove)\nusing this:\n  filter (\\<lambda>y. key y = k) (concat (local.desc b (a # as) bs)) =\n  filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n  key b < key a\n  \\<lbrakk>key b < key a; sorted (map key (a # as));\n   \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n  \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                     (concat (local.desc b (a # as) bs)) =\n                    filter (\\<lambda>y. key y = k) (b # (a # as) @ bs)\n  \\<not> key b < key a \\<Longrightarrow>\n  filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n  filter (\\<lambda>y. key y = k) (b # bs)\n  sorted (map key as)\n  \\<forall>x\\<in>set as. key a \\<le> key x\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.desc a as (b # bs))) =\n    filter (\\<lambda>y. key y = k) (a # as @ b # bs)", "by (cases \"key a = k\", cases \"key b = k\")\n        (auto simp: Cons_eq_append_conv intro!: filter_False)"], ["proof (state)\nthis:\n  filter (\\<lambda>y. key y = k) (concat (local.desc a as (b # bs))) =\n  filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key (a # as));\n              \\<forall>x\\<in>set (a # as). key b \\<le> key x\\<rbrakk>\n             \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                (concat (local.desc b (a # as) bs)) =\n                               filter (\\<lambda>y. key y = k)\n                                (b # (a # as) @ bs);\n     \\<not> key b < key a \\<Longrightarrow>\n     filter (\\<lambda>y. key y = k) (concat (local.sequences (b # bs))) =\n     filter (\\<lambda>y. key y = k) (b # bs);\n     sorted (map key as); \\<forall>x\\<in>set as. key a \\<le> key x;\n     \\<not> key b < key a\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                       (concat (local.desc a as (b # bs))) =\n                      filter (\\<lambda>y. key y = k) (a # as @ b # bs)", "qed auto"], ["proof (state)\nthis:\n  filter (\\<lambda>y. key y = k) (concat (local.desc a as (b # bs))) =\n  filter (\\<lambda>y. key y = k) (a # as @ b # bs)\n\ngoal (5 subgoals):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<lbrakk>key b < key a; sorted (map key [a]);\n                 \\<forall>x\\<in>set [a]. key b \\<le> key x\\<rbrakk>\n                \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                                   (concat (local.desc b [a] xs)) =\n                                  filter (\\<lambda>y. key y = k)\n                                   (b # [a] @ xs);\n        \\<lbrakk>\\<not> key b < key a; ascP ((#) a)\\<rbrakk>\n        \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                           (concat (local.asc b ((#) a) xs)) =\n                          filter (\\<lambda>y. key y = k)\n                           ([a, b] @ xs)\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.sequences (a # b # xs))) =\n                         filter (\\<lambda>y. key y = k) (a # b # xs)\n 2. \\<And>x.\n       filter (\\<lambda>y. key y = k) (concat (local.sequences [x])) =\n       filter (\\<lambda>y. key y = k) [x]\n 3. filter (\\<lambda>y. key y = k) (concat (local.sequences [])) =\n    filter (\\<lambda>y. key y = k) []\n 4. \\<And>a as.\n       ascP as \\<Longrightarrow>\n       filter (\\<lambda>y. key y = k) (concat (local.asc a as [])) =\n       filter (\\<lambda>y. key y = k) (as [a] @ [])\n 5. \\<And>a as.\n       \\<lbrakk>sorted (map key as);\n        \\<forall>x\\<in>set as. key a \\<le> key x\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>y. key y = k)\n                          (concat (local.desc a as [])) =\n                         filter (\\<lambda>y. key y = k) (a # as @ [])", "qed auto"], ["", "lemma filter_by_key_merge_is_append [simp]:\n  assumes \"sorted (map key xs)\"\n  shows \"[y\\<leftarrow>merge xs ys. key y = k] = [y\\<leftarrow>xs. key y = k] @ [y\\<leftarrow>ys. key y = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (local.merge xs ys) =\n    filter (\\<lambda>y. key y = k) xs @ filter (\\<lambda>y. key y = k) ys", "using assms"], ["proof (prove)\nusing this:\n  sorted (map key xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (local.merge xs ys) =\n    filter (\\<lambda>y. key y = k) xs @ filter (\\<lambda>y. key y = k) ys", "by (induct xs ys rule: merge.induct) (auto simp: Cons_eq_append_conv leD intro!: filter_False)"], ["", "lemma filter_by_key_merge_pairs [simp]:\n  assumes \"\\<forall>xs\\<in>set xss. sorted (map key xs)\"\n  shows \"[y\\<leftarrow>concat (merge_pairs xss). key y = k] = [y\\<leftarrow>concat xss. key y = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.merge_pairs xss)) =\n    filter (\\<lambda>y. key y = k) (concat xss)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>set xss. sorted (map key xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (concat (local.merge_pairs xss)) =\n    filter (\\<lambda>y. key y = k) (concat xss)", "by (induct xss rule: merge_pairs.induct) simp_all"], ["", "lemma filter_by_key_merge_all [simp]:\n  assumes \"\\<forall>xs\\<in>set xss. sorted (map key xs)\"\n  shows \"[y\\<leftarrow>merge_all xss. key y = k] = [y\\<leftarrow>concat xss. key y = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (local.merge_all xss) =\n    filter (\\<lambda>y. key y = k) (concat xss)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>set xss. sorted (map key xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>y. key y = k) (local.merge_all xss) =\n    filter (\\<lambda>y. key y = k) (concat xss)", "by (induct xss rule: merge_all.induct) simp_all"], ["", "lemma filter_by_key_merge_all_sequences [simp]:\n  \"[x\\<leftarrow>merge_all (sequences xs) . key x = k] = [x\\<leftarrow>xs . key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (local.merge_all (local.sequences xs)) =\n    filter (\\<lambda>x. key x = k) xs", "using sorted_sequences [of xs]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (local.sequences xs). sorted (map key x)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (local.merge_all (local.sequences xs)) =\n    filter (\\<lambda>x. key x = k) xs", "by simp"], ["", "lemma msort_key_stable:\n  \"[x\\<leftarrow>msort_key xs. key x = k] = [x\\<leftarrow>xs. key x = k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. key x = k) (local.msort_key xs) =\n    filter (\\<lambda>x. key x = k) xs", "by auto"], ["", "lemma sort_key_msort_key_conv:\n  \"sort_key key = msort_key\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_key key = local.msort_key", "using msort_key_stable [of \"key x\" for x]"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. key x = key ?x3) (local.msort_key ?xs) =\n  filter (\\<lambda>x. key x = key ?x3) ?xs\n\ngoal (1 subgoal):\n 1. sort_key key = local.msort_key", "by (intro ext properties_for_sort_key mset_msort_key sorted_msort_key)\n    (metis (mono_tags, lifting) filter_cong)"], ["", "end"], ["", "text \\<open>\n  Replace existing code equations for \\<^const>\\<open>sort_key\\<close> by \\<^const>\\<open>msort_key\\<close>.\n\\<close>"], ["", "declare sort_key_by_quicksort_code [code del]"], ["", "declare sort_key_msort_key_conv [code]"], ["", "end"]]}