{"file_name": "/home/qj213/afp-2021-10-22/thys/Hood_Melville_Queue/Hood_Melville_Queue.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hood_Melville_Queue", "problem_names": ["lemma rev_steps_app:\n  assumes inv: \"st_inv (Rev ok f f' r r')\"\n  shows \"steps (length f + 1) (Rev ok f f' r r') = App (length f + ok) (rev f @ f') (rev r @ r')\"", "lemma st_inv_steps:\n  assumes inv      : \"st_inv s\"\n  assumes not_idle : \"s \\<noteq> Idle\"\n  shows              \"\\<exists>x. steps (rem_steps s) s = Done x\" (is \"?reach_done s\")", "lemma st_inv_exec:\n  assumes st_inv: \"st_inv s\"\n  shows \"st_inv (exec s)\"", "lemma st_inv_exec2:\n  assumes st_inv: \"st_inv s\"\n  shows \"st_inv (exec (exec s))\"", "lemma st_inv_invalidate:\n  assumes st_inv: \"st_inv s\"\n  shows \"st_inv (invalidate s)\"", "lemma invar_empty: \"invar empty\"", "lemma tl_rev_take: \"\\<lbrakk>0 < ok; ok \\<le> length f\\<rbrakk> \\<Longrightarrow> rev (take ok (x # f)) = tl (rev (take ok f)) @ [x]\"", "lemma tl_rev_take_Suc:\n  \"n + 1 \\<le> length l \\<Longrightarrow> rev (take n l) = tl (rev (take (Suc n) l))\"", "lemma invar_deq:\n  assumes inv: \"invar q\"\n  shows \"invar (deq q)\"", "lemma invar_enq:\n  assumes inv: \"invar q\"\n  shows \"invar (enq x q)\"", "lemma queue_correct_deq :\n  assumes inv: \"invar q\"\n  shows \"list (deq q) = tl (list q)\"", "lemma queue_correct_enq :\n  assumes inv: \"invar q\"\n  shows \"list (enq x q) = (list q) @ [x]\"", "lemma invar_qfa : \"invar (qfa l)\"", "lemma qfa_deq_correct: \"list (deq (qfa l)) = tl (list (qfa l))\"", "lemma qfa_enq_correct: \"list (enq x (qfa l)) = (list (qfa l)) @ [x]\"", "lemma first_correct :\n  assumes inv:      \"invar q\"\n  assumes not_nil : \"list q \\<noteq> []\"\n  shows             \"first q = hd (list q)\""], "translations": [["", "lemma rev_steps_app:\n  assumes inv: \"st_inv (Rev ok f f' r r')\"\n  shows \"steps (length f + 1) (Rev ok f f' r r') = App (length f + ok) (rev f @ f') (rev r @ r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (length f + 1) (Rev ok f f' r r') =\n    App (length f + ok) (rev f @ f') (rev r @ r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps (length f + 1) (Rev ok f f' r r') =\n    App (length f + ok) (rev f @ f') (rev r @ r')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (length f + 1) (Rev ok f f' r r') =\n    App (length f + ok) (rev f @ f') (rev r @ r')", "using inv"], ["proof (prove)\nusing this:\n  st_inv (Rev ok f f' r r')\n\ngoal (1 subgoal):\n 1. steps (length f + 1) (Rev ok f f' r r') =\n    App (length f + ok) (rev f @ f') (rev r @ r')", "proof (induction f arbitrary: ok f' r r')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ok f' r r'.\n       st_inv (Rev ok [] f' r r') \\<Longrightarrow>\n       steps (length [] + 1) (Rev ok [] f' r r') =\n       App (length [] + ok) (rev [] @ f') (rev r @ r')\n 2. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "case Nil"], ["proof (state)\nthis:\n  st_inv (Rev ok [] f' r r')\n\ngoal (2 subgoals):\n 1. \\<And>ok f' r r'.\n       st_inv (Rev ok [] f' r r') \\<Longrightarrow>\n       steps (length [] + 1) (Rev ok [] f' r r') =\n       App (length [] + ok) (rev [] @ f') (rev r @ r')\n 2. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "then"], ["proof (chain)\npicking this:\n  st_inv (Rev ok [] f' r r')", "obtain x where \"r = [x]\""], ["proof (prove)\nusing this:\n  st_inv (Rev ok [] f' r r')\n\ngoal (1 subgoal):\n 1. (\\<And>x. r = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis One_nat_def Suc_length_conv add.right_neutral add_Suc_right length_0_conv st_inv.simps(1))"], ["proof (state)\nthis:\n  r = [x]\n\ngoal (2 subgoals):\n 1. \\<And>ok f' r r'.\n       st_inv (Rev ok [] f' r r') \\<Longrightarrow>\n       steps (length [] + 1) (Rev ok [] f' r r') =\n       App (length [] + ok) (rev [] @ f') (rev r @ r')\n 2. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "then"], ["proof (chain)\npicking this:\n  r = [x]", "show ?case"], ["proof (prove)\nusing this:\n  r = [x]\n\ngoal (1 subgoal):\n 1. steps (length [] + 1) (Rev ok [] f' r r') =\n    App (length [] + ok) (rev [] @ f') (rev r @ r')", "using Nil"], ["proof (prove)\nusing this:\n  r = [x]\n  st_inv (Rev ok [] f' r r')\n\ngoal (1 subgoal):\n 1. steps (length [] + 1) (Rev ok [] f' r r') =\n    App (length [] + ok) (rev [] @ f') (rev r @ r')", "by simp"], ["proof (state)\nthis:\n  steps (length [] + 1) (Rev ok [] f' r r') =\n  App (length [] + ok) (rev [] @ f') (rev r @ r')\n\ngoal (1 subgoal):\n 1. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "case (Cons a f)"], ["proof (state)\nthis:\n  st_inv (Rev ?ok f ?f' ?r ?r') \\<Longrightarrow>\n  steps (length f + 1) (Rev ?ok f ?f' ?r ?r') =\n  App (length f + ?ok) (rev f @ ?f') (rev ?r @ ?r')\n  st_inv (Rev ok (a # f) f' r r')\n\ngoal (1 subgoal):\n 1. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "then"], ["proof (chain)\npicking this:\n  st_inv (Rev ?ok f ?f' ?r ?r') \\<Longrightarrow>\n  steps (length f + 1) (Rev ?ok f ?f' ?r ?r') =\n  App (length f + ?ok) (rev f @ ?f') (rev ?r @ ?r')\n  st_inv (Rev ok (a # f) f' r r')", "obtain x and xs where \"r = x # xs\""], ["proof (prove)\nusing this:\n  st_inv (Rev ?ok f ?f' ?r ?r') \\<Longrightarrow>\n  steps (length f + 1) (Rev ?ok f ?f' ?r ?r') =\n  App (length f + ?ok) (rev f @ ?f') (rev ?r @ ?r')\n  st_inv (Rev ok (a # f) f' r r')\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. r = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def Suc_length_conv add_Suc_right st_inv.simps(1))"], ["proof (state)\nthis:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "hence r_x: \"r = x # xs\""], ["proof (prove)\nusing this:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. r = x # xs", "by simp"], ["proof (state)\nthis:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a f ok f' r r'.\n       \\<lbrakk>\\<And>ok f' r r'.\n                   st_inv (Rev ok f f' r r') \\<Longrightarrow>\n                   steps (length f + 1) (Rev ok f f' r r') =\n                   App (length f + ok) (rev f @ f') (rev r @ r');\n        st_inv (Rev ok (a # f) f' r r')\\<rbrakk>\n       \\<Longrightarrow> steps (length (a # f) + 1)\n                          (Rev ok (a # f) f' r r') =\n                         App (length (a # f) + ok) (rev (a # f) @ f')\n                          (rev r @ r')", "then"], ["proof (chain)\npicking this:\n  r = x # xs", "show ?case"], ["proof (prove)\nusing this:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. steps (length (a # f) + 1) (Rev ok (a # f) f' r r') =\n    App (length (a # f) + ok) (rev (a # f) @ f') (rev r @ r')", "using Cons Nat.funpow_add"], ["proof (prove)\nusing this:\n  r = x # xs\n  st_inv (Rev ?ok f ?f' ?r ?r') \\<Longrightarrow>\n  steps (length f + 1) (Rev ?ok f ?f' ?r ?r') =\n  App (length f + ?ok) (rev f @ ?f') (rev ?r @ ?r')\n  st_inv (Rev ok (a # f) f' r r')\n  ?f ^^ (?m + ?n) = ?f ^^ ?m \\<circ> ?f ^^ ?n\n\ngoal (1 subgoal):\n 1. steps (length (a # f) + 1) (Rev ok (a # f) f' r r') =\n    App (length (a # f) + ok) (rev (a # f) @ f') (rev r @ r')", "by (simp add: Nat.funpow_swap1)"], ["proof (state)\nthis:\n  steps (length (a # f) + 1) (Rev ok (a # f) f' r r') =\n  App (length (a # f) + ok) (rev (a # f) @ f') (rev r @ r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  steps (length f + 1) (Rev ok f f' r r') =\n  App (length f + ok) (rev f @ f') (rev r @ r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma st_inv_steps:\n  assumes inv      : \"st_inv s\"\n  assumes not_idle : \"s \\<noteq> Idle\"\n  shows              \"\\<exists>x. steps (rem_steps s) s = Done x\" (is \"?reach_done s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "let ?steps = \"\\<lambda>x. steps (rem_steps x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "have app_inv: \"st_inv (App ok f r) \\<Longrightarrow> ?reach_done (App ok f r)\"\n    for ok f r"], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (App ok f r) \\<Longrightarrow>\n    \\<exists>x. steps (rem_steps (App ok f r)) (App ok f r) = Done x", "proof (induct f arbitrary: ok r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ok r.\n       st_inv (App ok [] r) \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps (App ok [] r)) (App ok [] r) = Done x\n 2. \\<And>a f ok r.\n       \\<lbrakk>\\<And>ok r.\n                   st_inv (App ok f r) \\<Longrightarrow>\n                   \\<exists>x.\n                      steps (rem_steps (App ok f r)) (App ok f r) = Done x;\n        st_inv (App ok (a # f) r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            steps (rem_steps (App ok (a # f) r))\n                             (App ok (a # f) r) =\n                            Done x", "case (Cons a f')"], ["proof (state)\nthis:\n  st_inv (App ?ok1 f' ?r1) \\<Longrightarrow>\n  \\<exists>x. steps (rem_steps (App ?ok1 f' ?r1)) (App ?ok1 f' ?r1) = Done x\n  st_inv (App ok (a # f') r)\n\ngoal (2 subgoals):\n 1. \\<And>ok r.\n       st_inv (App ok [] r) \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps (App ok [] r)) (App ok [] r) = Done x\n 2. \\<And>a f ok r.\n       \\<lbrakk>\\<And>ok r.\n                   st_inv (App ok f r) \\<Longrightarrow>\n                   \\<exists>x.\n                      steps (rem_steps (App ok f r)) (App ok f r) = Done x;\n        st_inv (App ok (a # f) r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            steps (rem_steps (App ok (a # f) r))\n                             (App ok (a # f) r) =\n                            Done x", "then"], ["proof (chain)\npicking this:\n  st_inv (App ?ok1 f' ?r1) \\<Longrightarrow>\n  \\<exists>x. steps (rem_steps (App ?ok1 f' ?r1)) (App ?ok1 f' ?r1) = Done x\n  st_inv (App ok (a # f') r)", "show ?case"], ["proof (prove)\nusing this:\n  st_inv (App ?ok1 f' ?r1) \\<Longrightarrow>\n  \\<exists>x. steps (rem_steps (App ?ok1 f' ?r1)) (App ?ok1 f' ?r1) = Done x\n  st_inv (App ok (a # f') r)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       steps (rem_steps (App ok (a # f') r)) (App ok (a # f') r) = Done x", "by (induct ok; simp add: Nat.funpow_swap1)"], ["proof (state)\nthis:\n  \\<exists>x.\n     steps (rem_steps (App ok (a # f') r)) (App ok (a # f') r) = Done x\n\ngoal (1 subgoal):\n 1. \\<And>ok r.\n       st_inv (App ok [] r) \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps (App ok [] r)) (App ok [] r) = Done x", "qed simp"], ["proof (state)\nthis:\n  st_inv (App ?ok1 ?f1 ?r1) \\<Longrightarrow>\n  \\<exists>x.\n     steps (rem_steps (App ?ok1 ?f1 ?r1)) (App ?ok1 ?f1 ?r1) = Done x\n\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "proof (cases s)"], ["proof (state)\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 4. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "case (App ok f' r')"], ["proof (state)\nthis:\n  s = App ok f' r'\n\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 4. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "then"], ["proof (chain)\npicking this:\n  s = App ok f' r'", "show ?thesis"], ["proof (prove)\nusing this:\n  s = App ok f' r'\n\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "using inv app_inv"], ["proof (prove)\nusing this:\n  s = App ok f' r'\n  st_inv s\n  st_inv (App ?ok1 ?f1 ?r1) \\<Longrightarrow>\n  \\<exists>x.\n     steps (rem_steps (App ?ok1 ?f1 ?r1)) (App ?ok1 ?f1 ?r1) = Done x\n\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "unfolding App"], ["proof (prove)\nusing this:\n  App ok f' r' = App ok f' r'\n  st_inv (App ok f' r')\n  st_inv (App ?ok1 ?f1 ?r1) \\<Longrightarrow>\n  \\<exists>x.\n     steps (rem_steps (App ?ok1 ?f1 ?r1)) (App ?ok1 ?f1 ?r1) = Done x\n\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps (App ok f' r')) (App ok f' r') = Done x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x. steps (rem_steps s) s = Done x\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "case (Rev ok f f' r r')"], ["proof (state)\nthis:\n  s = Rev ok f f' r r'\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "have rep_split: \"rem_steps (Rev ok f f' r r') = (length f + ok + 1) + (length f + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_steps (Rev ok f f' r r') = length f + ok + 1 + (length f + 1)", "by simp"], ["proof (state)\nthis:\n  rem_steps (Rev ok f f' r r') = length f + ok + 1 + (length f + 1)\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "then"], ["proof (chain)\npicking this:\n  rem_steps (Rev ok f f' r r') = length f + ok + 1 + (length f + 1)", "have split: \"\\<And>stp. ?steps (Rev ok f f' r r') stp = (steps (length f + ok + 1)) ((steps (length f + 1)) stp) \""], ["proof (prove)\nusing this:\n  rem_steps (Rev ok f f' r r') = length f + ok + 1 + (length f + 1)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       steps (rem_steps (Rev ok f f' r r')) stp =\n       steps (length f + ok + 1) (steps (length f + 1) stp)", "unfolding rep_split Nat.funpow_add steps.simps"], ["proof (prove)\nusing this:\n  length f + ok + 1 + (length f + 1) = length f + ok + 1 + (length f + 1)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       (exec ^^ length f \\<circ> exec ^^ ok \\<circ> exec ^^ 1 \\<circ>\n        (exec ^^ length f \\<circ> exec ^^ 1))\n        stp =\n       (exec ^^ length f \\<circ> exec ^^ ok \\<circ> exec ^^ 1)\n        ((exec ^^ length f \\<circ> exec ^^ 1) stp)", "by simp"], ["proof (state)\nthis:\n  steps (rem_steps (Rev ok f f' r r')) ?stp1 =\n  steps (length f + ok + 1) (steps (length f + 1) ?stp1)\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "also"], ["proof (state)\nthis:\n  steps (rem_steps (Rev ok f f' r r')) ?stp1 =\n  steps (length f + ok + 1) (steps (length f + 1) ?stp1)\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "have f: \"st_inv (App (length f + ok) (rev f @ f') (rev r @ r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (App (length f + ok) (rev f @ f') (rev r @ r'))", "using Rev inv"], ["proof (prove)\nusing this:\n  s = Rev ok f f' r r'\n  st_inv s\n\ngoal (1 subgoal):\n 1. st_inv (App (length f + ok) (rev f @ f') (rev r @ r'))", "by simp"], ["proof (state)\nthis:\n  st_inv (App (length f + ok) (rev f @ f') (rev r @ r'))\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x\n 3. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "thus ?thesis"], ["proof (prove)\nusing this:\n  st_inv (App (length f + ok) (rev f @ f') (rev r @ r'))\n\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "using inv f[THEN app_inv]"], ["proof (prove)\nusing this:\n  st_inv (App (length f + ok) (rev f @ f') (rev r @ r'))\n  st_inv s\n  \\<exists>x.\n     steps (rem_steps (App (length f + ok) (rev f @ f') (rev r @ r')))\n      (App (length f + ok) (rev f @ f') (rev r @ r')) =\n     Done x\n\ngoal (1 subgoal):\n 1. \\<exists>x. steps (rem_steps s) s = Done x", "unfolding Rev split inv[simplified Rev,THEN rev_steps_app]"], ["proof (prove)\nusing this:\n  st_inv (App (length f + ok) (rev f @ f') (rev r @ r'))\n  st_inv (Rev ok f f' r r')\n  \\<exists>x.\n     steps (rem_steps (App (length f + ok) (rev f @ f') (rev r @ r')))\n      (App (length f + ok) (rev f @ f') (rev r @ r')) =\n     Done x\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       steps (length f + ok + 1)\n        (App (length f + ok) (rev f @ f') (rev r @ r')) =\n       Done x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x. steps (rem_steps s) s = Done x\n\ngoal (2 subgoals):\n 1. s = Idle \\<Longrightarrow> \\<exists>x. steps (rem_steps s) s = Done x\n 2. \\<And>x4.\n       s = Done x4 \\<Longrightarrow>\n       \\<exists>x. steps (rem_steps s) s = Done x", "qed (auto simp add: not_idle)"], ["proof (state)\nthis:\n  \\<exists>x. steps (rem_steps s) s = Done x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Preservation of the status invariants by exec2 *)"], ["", "lemma st_inv_exec:\n  assumes st_inv: \"st_inv s\"\n  shows \"st_inv (exec s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (exec s)", "proof (cases s)"], ["proof (state)\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow> st_inv (exec s)\n 3. \\<And>x31 x32 x33. s = App x31 x32 x33 \\<Longrightarrow> st_inv (exec s)\n 4. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (exec s)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow> st_inv (exec s)\n 3. \\<And>x31 x32 x33. s = App x31 x32 x33 \\<Longrightarrow> st_inv (exec s)\n 4. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (exec s)", "case (Rev ok f f' r r')"], ["proof (state)\nthis:\n  s = Rev ok f f' r r'\n\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow> st_inv (exec s)\n 3. \\<And>x31 x32 x33. s = App x31 x32 x33 \\<Longrightarrow> st_inv (exec s)\n 4. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (exec s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (exec s)", "proof (cases f)"], ["proof (state)\ngoal (2 subgoals):\n 1. f = [] \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>a list. f = a # list \\<Longrightarrow> st_inv (exec s)", "case Nil"], ["proof (state)\nthis:\n  f = []\n\ngoal (2 subgoals):\n 1. f = [] \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>a list. f = a # list \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  f = []", "show ?thesis"], ["proof (prove)\nusing this:\n  f = []\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "using st_inv"], ["proof (prove)\nusing this:\n  f = []\n  st_inv s\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "unfolding Rev"], ["proof (prove)\nusing this:\n  f = []\n  st_inv (Rev ok f f' r r')\n\ngoal (1 subgoal):\n 1. st_inv (exec (Rev ok f f' r r'))", "by (simp; cases r;cases ok; cases f'; simp)"], ["proof (state)\nthis:\n  st_inv (exec s)\n\ngoal (1 subgoal):\n 1. \\<And>a list. f = a # list \\<Longrightarrow> st_inv (exec s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. f = a # list \\<Longrightarrow> st_inv (exec s)", "case C_a: (Cons a as)"], ["proof (state)\nthis:\n  f = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list. f = a # list \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  f = a # as", "obtain x xs where \"r = x # xs\""], ["proof (prove)\nusing this:\n  f = a # as\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. r = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using st_inv"], ["proof (prove)\nusing this:\n  f = a # as\n  st_inv s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. r = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Rev Cons"], ["proof (prove)\nusing this:\n  f = a # as\n  st_inv (Rev ok f f' r r')\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. r = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def length_Suc_conv list.size(4) st_inv.simps(1))"], ["proof (state)\nthis:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list. f = a # list \\<Longrightarrow> st_inv (exec s)", "hence r_x: \"r = x # xs\""], ["proof (prove)\nusing this:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. r = x # xs", "by simp"], ["proof (state)\nthis:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list. f = a # list \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  r = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  r = x # xs\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = x # xs; as = []\\<rbrakk> \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>a list.\n       \\<lbrakk>r = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>r = x # xs; as = []\\<rbrakk> \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>a list.\n       \\<lbrakk>r = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "using st_inv"], ["proof (prove)\nusing this:\n  as = []\n  st_inv s\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "unfolding Rev C_a Nil r_x"], ["proof (prove)\nusing this:\n  [] = []\n  st_inv (Rev ok [a] f' (x # xs) r')\n\ngoal (1 subgoal):\n 1. st_inv (exec (Rev ok [a] f' (x # xs) r'))", "by (simp; cases xs; simp)"], ["proof (state)\nthis:\n  st_inv (exec s)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>r = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>r = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "case (Cons b bs)"], ["proof (state)\nthis:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>r = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  as = b # bs", "show ?thesis"], ["proof (prove)\nusing this:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "using st_inv"], ["proof (prove)\nusing this:\n  as = b # bs\n  st_inv s\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "unfolding Rev C_a r_x"], ["proof (prove)\nusing this:\n  as = b # bs\n  st_inv (Rev ok (a # as) f' (x # xs) r')\n\ngoal (1 subgoal):\n 1. st_inv (exec (Rev ok (a # as) f' (x # xs) r'))", "by (simp; cases xs; simp)"], ["proof (state)\nthis:\n  st_inv (exec s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st_inv (exec s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st_inv (exec s)\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>x31 x32 x33. s = App x31 x32 x33 \\<Longrightarrow> st_inv (exec s)\n 3. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (exec s)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>x31 x32 x33. s = App x31 x32 x33 \\<Longrightarrow> st_inv (exec s)\n 3. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (exec s)", "case (App ok f r)"], ["proof (state)\nthis:\n  s = App ok f r\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>x31 x32 x33. s = App x31 x32 x33 \\<Longrightarrow> st_inv (exec s)\n 3. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  s = App ok f r", "show ?thesis"], ["proof (prove)\nusing this:\n  s = App ok f r\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "proof (cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = App ok f r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>nat.\n       \\<lbrakk>s = App ok f r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s = App ok f r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>nat.\n       \\<lbrakk>s = App ok f r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  ok = Suc ok'", "obtain x xs where \"f = x # xs\""], ["proof (prove)\nusing this:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. f = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using st_inv"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n  st_inv s\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. f = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding App Suc"], ["proof (prove)\nusing this:\n  Suc ok' = Suc ok'\n  st_inv (App (Suc ok') f r)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. f = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_le_D Zero_not_Suc list.exhaust list.size(3) st_inv.simps(2))"], ["proof (state)\nthis:\n  f = x # xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s = App ok f r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>nat.\n       \\<lbrakk>s = App ok f r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> st_inv (exec s)", "then"], ["proof (chain)\npicking this:\n  f = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  f = x # xs\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "using st_inv"], ["proof (prove)\nusing this:\n  f = x # xs\n  st_inv s\n\ngoal (1 subgoal):\n 1. st_inv (exec s)", "unfolding App Suc"], ["proof (prove)\nusing this:\n  f = x # xs\n  st_inv (App (Suc ok') f r)\n\ngoal (1 subgoal):\n 1. st_inv (exec (App (Suc ok') f r))", "by (cases ok'; cases xs; simp)"], ["proof (state)\nthis:\n  st_inv (exec s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s = App ok f r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> st_inv (exec s)", "qed simp"], ["proof (state)\nthis:\n  st_inv (exec s)\n\ngoal (2 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (exec s)\n 2. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (exec s)", "qed simp+"], ["", "(* Preservation of the status invariants by exec2 *)"], ["", "lemma st_inv_exec2:\n  assumes st_inv: \"st_inv s\"\n  shows \"st_inv (exec (exec s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (exec (exec s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. st_inv (exec (exec s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (exec (exec s))", "using st_inv st_inv_exec"], ["proof (prove)\nusing this:\n  st_inv s\n  st_inv ?s \\<Longrightarrow> st_inv (exec ?s)\n\ngoal (1 subgoal):\n 1. st_inv (exec (exec s))", "by auto"], ["proof (state)\nthis:\n  st_inv (exec (exec s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma st_inv_invalidate:\n  assumes st_inv: \"st_inv s\"\n  shows \"st_inv (invalidate s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (invalidate s)", "proof (cases s)"], ["proof (state)\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (invalidate s)\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow> st_inv (invalidate s)\n 3. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow> st_inv (invalidate s)\n 4. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (invalidate s)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (invalidate s)\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow> st_inv (invalidate s)\n 3. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow> st_inv (invalidate s)\n 4. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (invalidate s)", "case (Rev ok f f' r r')"], ["proof (state)\nthis:\n  s = Rev ok f f' r r'\n\ngoal (4 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (invalidate s)\n 2. \\<And>x21 x22 x23 x24 x25.\n       s = Rev x21 x22 x23 x24 x25 \\<Longrightarrow> st_inv (invalidate s)\n 3. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow> st_inv (invalidate s)\n 4. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (invalidate s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. st_inv (invalidate s)", "using st_inv"], ["proof (prove)\nusing this:\n  st_inv s\n\ngoal (1 subgoal):\n 1. st_inv (invalidate s)", "unfolding Rev"], ["proof (prove)\nusing this:\n  st_inv (Rev ok f f' r r')\n\ngoal (1 subgoal):\n 1. st_inv (invalidate (Rev ok f f' r r'))", "by auto"], ["proof (state)\nthis:\n  st_inv (invalidate s)\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (invalidate s)\n 2. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow> st_inv (invalidate s)\n 3. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (invalidate s)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (invalidate s)\n 2. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow> st_inv (invalidate s)\n 3. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (invalidate s)", "case (App ok f r)"], ["proof (state)\nthis:\n  s = App ok f r\n\ngoal (3 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (invalidate s)\n 2. \\<And>x31 x32 x33.\n       s = App x31 x32 x33 \\<Longrightarrow> st_inv (invalidate s)\n 3. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (invalidate s)", "then"], ["proof (chain)\npicking this:\n  s = App ok f r", "show ?thesis"], ["proof (prove)\nusing this:\n  s = App ok f r\n\ngoal (1 subgoal):\n 1. st_inv (invalidate s)", "using st_inv"], ["proof (prove)\nusing this:\n  s = App ok f r\n  st_inv s\n\ngoal (1 subgoal):\n 1. st_inv (invalidate s)", "unfolding App"], ["proof (prove)\nusing this:\n  App ok f r = App ok f r\n  st_inv (App ok f r)\n\ngoal (1 subgoal):\n 1. st_inv (invalidate (App ok f r))", "by (cases ok; cases r; simp)"], ["proof (state)\nthis:\n  st_inv (invalidate s)\n\ngoal (2 subgoals):\n 1. s = Idle \\<Longrightarrow> st_inv (invalidate s)\n 2. \\<And>x4. s = Done x4 \\<Longrightarrow> st_inv (invalidate s)", "qed simp+"], ["", "(* Queue invariants *)"], ["", "definition invar where\n  \"invar q = (lenf q = length (front_list q) \\<and>\n              lenr q = length (rear_list q)  \\<and>\n              lenr q \\<le> lenf q \\<and>\n              (case status q of\n                 Rev ok f f' r r' \\<Rightarrow> 2*lenr q  \\<le> length f' \\<and> ok \\<noteq> 0 \n               | App ok f r       \\<Rightarrow> 2*lenr q  \\<le> length r\n               | _ \\<Rightarrow> True) \\<and>\n              rem_steps (status q) \\<le> 2*length (front q) \\<and>\n              (\\<exists>rest. front_list q = front q @ rest) \\<and>\n              (\\<forall>x. status q \\<noteq> Done x) \\<and>\n              st_inv (status q))\""], ["", "(* The empty list satisfies the invariant *)"], ["", "lemma invar_empty: \"invar empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar Hood_Melville_Queue.empty", "by(simp add: invar_def empty_def make_def rear_list_def)"], ["", "(* List lemmas *)"], ["", "lemma tl_rev_take: \"\\<lbrakk>0 < ok; ok \\<le> length f\\<rbrakk> \\<Longrightarrow> rev (take ok (x # f)) = tl (rev (take ok f)) @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < ok; ok \\<le> length f\\<rbrakk>\n    \\<Longrightarrow> rev (take ok (x # f)) = tl (rev (take ok f)) @ [x]", "by(simp add: rev_take Suc_diff_le drop_Suc tl_drop)"], ["", "lemma tl_rev_take_Suc:\n  \"n + 1 \\<le> length l \\<Longrightarrow> rev (take n l) = tl (rev (take (Suc n) l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 \\<le> length l \\<Longrightarrow>\n    rev (take n l) = tl (rev (take (Suc n) l))", "by(simp add: rev_take tl_drop Suc_diff_Suc flip: drop_Suc)"], ["", "(* Dequeue operations preserve the invariants *)"], ["", "lemma invar_deq:\n  assumes inv: \"invar q\"\n  shows \"invar (deq q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deq q)", "proof (cases q)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       invar (deq q)", "case (fields lenf front status rear lenr)"], ["proof (state)\nthis:\n  q =\n  \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n     lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       invar (deq q)", "have pre_inv: \"\\<exists>rest. front @ rest = front_list q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rest. front @ rest = front_list q", "using inv"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. \\<exists>rest. front @ rest = front_list q", "unfolding fields"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       front @ rest =\n       front_list\n        \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n           lenr = lenr\\<rparr>", "by(simp add: invar_def check_def; cases status; auto simp add: invar_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  \\<exists>rest. front @ rest = front_list q\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       invar (deq q)", "have tl_app: \"status \\<noteq> Idle \\<Longrightarrow> \\<forall>l. tl front @ l = tl (front @ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. status \\<noteq> Idle \\<Longrightarrow>\n    \\<forall>l. tl front @ l = tl (front @ l)", "using inv"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. status \\<noteq> Idle \\<Longrightarrow>\n    \\<forall>l. tl front @ l = tl (front @ l)", "unfolding fields"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. status \\<noteq> Idle \\<Longrightarrow>\n    \\<forall>l. tl front @ l = tl (front @ l)", "by (simp add: invar_def check_def; cases status; cases front;auto simp add: invar_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  status \\<noteq> Idle \\<Longrightarrow>\n  \\<forall>l. tl front @ l = tl (front @ l)\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status \\<noteq> Idle \\<Longrightarrow>\n  \\<forall>l. tl front @ l = tl (front @ l)", "show ?thesis"], ["proof (prove)\nusing this:\n  status \\<noteq> Idle \\<Longrightarrow>\n  \\<forall>l. tl front @ l = tl (front @ l)\n\ngoal (1 subgoal):\n 1. invar (deq q)", "proof (cases status rule: exec.cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ok x f f' y r r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev ok (x # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 6. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 9. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 10. \\<And>v.\n        \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                 \\<forall>l. tl front @ l = tl (front @ l);\n         status = Done v\\<rbrakk>\n        \\<Longrightarrow> invar (deq q)", "case st: (1 ok x f f' y r r')"], ["proof (state)\nthis:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (10 subgoals):\n 1. \\<And>ok x f f' y r r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev ok (x # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 6. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 9. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 10. \\<And>v.\n        \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                 \\<forall>l. tl front @ l = tl (front @ l);\n         status = Done v\\<rbrakk>\n        \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = Rev ok (x # f) f' (y # r) r'", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (1 subgoal):\n 1. invar (deq q)", "proof (cases f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = []\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case Nil"], ["proof (state)\nthis:\n  f = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = []\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "have pre: \"\\<exists>rest. front_list (deq q) = tl front @ rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rest. front_list (deq q) = tl front @ rest", "using inv pre_inv"], ["proof (prove)\nusing this:\n  invar q\n  \\<exists>rest. front @ rest = front_list q\n\ngoal (1 subgoal):\n 1. \\<exists>rest. front_list (deq q) = tl front @ rest", "unfolding fields st Nil"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev ok [x] f' (y # r) r',\n      rear = rear, lenr = lenr\\<rparr>\n  \\<exists>rest.\n     front @ rest =\n     front_list\n      \\<lparr>lenf = lenf, front = front, status = Rev ok [x] f' (y # r) r',\n         rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>rest.\n       front_list\n        (deq \\<lparr>lenf = lenf, front = front,\n                status = Rev ok [x] f' (y # r) r', rear = rear,\n                lenr = lenr\\<rparr>) =\n       tl front @ rest", "apply (simp add: invar_def check_def; cases r; simp add: invar_def Let_def rear_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length f') ok + length r'))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc ok))) \\<le> 2 * length front \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        \\<exists>rest. front @ rest = rev (take ok f') @ x # a # y # r';\n        \\<exists>rest. rev (take ok f') @ x # a # y # r' = front @ rest;\n        r = [a]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rest.\n                            rev (take ok (x # f')) @ a # y # r' =\n                            tl front @ rest", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length f') ok + length r'))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc ok))) \\<le> 2 * length front \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        \\<exists>rest. rev (take ok f') @ x # a # y # r' = front @ rest;\n        r = [a]; front @ rest = rev (take ok f') @ x # a # y # r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rest.\n                            rev (take ok (x # f')) @ a # y # r' =\n                            tl front @ rest", "apply (rule_tac x=rest in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length f') ok + length r'))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc ok))) \\<le> 2 * length front \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        \\<exists>rest. rev (take ok f') @ x # a # y # r' = front @ rest;\n        r = [a]; front @ rest = rev (take ok f') @ x # a # y # r'\\<rbrakk>\n       \\<Longrightarrow> rev (take ok (x # f')) @ a # y # r' =\n                         tl front @ rest", "apply (simp add: tl_app st tl_rev_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length f') ok + length r'))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc ok))) \\<le> 2 * length front \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        \\<exists>rest. rev (take ok f') @ x # a # y # r' = front @ rest;\n        r = [a]; front @ rest = rev (take ok f') @ x # a # y # r'\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take ok f')) @ x # a # y # r' =\n                         tl (rev (take ok f') @ x # a # y # r')", "apply (cases f'; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>rest. front_list (deq q) = tl front @ rest\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = []\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  \\<exists>rest. front_list (deq q) = tl front @ rest", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>rest. front_list (deq q) = tl front @ rest\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  \\<exists>rest. front_list (deq q) = tl front @ rest\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st Nil"], ["proof (prove)\nusing this:\n  \\<exists>rest.\n     front_list\n      (deq \\<lparr>lenf = lenf, front = front,\n              status = Rev ok [x] f' (y # r) r', rear = rear,\n              lenr = lenr\\<rparr>) =\n     tl front @ rest\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev ok [x] f' (y # r) r',\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev ok [x] f' (y # r) r', rear = rear,\n             lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def; cases r; auto simp add: min_absorb2 invar_def rear_list_def Let_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case (Cons a list)"], ["proof (state)\nthis:\n  f = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  f = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  f = a # list\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using pre_inv inv"], ["proof (prove)\nusing this:\n  f = a # list\n  \\<exists>rest. front @ rest = front_list q\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st Nil"], ["proof (prove)\nusing this:\n  f = a # list\n  \\<exists>rest.\n     front @ rest =\n     front_list\n      \\<lparr>lenf = lenf, front = front,\n         status = Rev ok (x # f) f' (y # r) r', rear = rear,\n         lenr = lenr\\<rparr>\n  invar\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev ok (x # f) f' (y # r) r', rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev ok (x # f) f' (y # r) r', rear = rear,\n             lenr = lenr\\<rparr>)", "apply (simp add: invar_def check_def inv ; cases r; simp add: invar_def inv min_absorb2 rear_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa lista.\n       \\<lbrakk>\\<exists>rest.\n                   front @ rest =\n                   rev (take ok f') @\n                   x # a # list @ rev lista @ aa # y # r';\n        lenf =\n        Suc (Suc (Suc (Suc (min (length f') ok +\n                            (length list +\n                             (length lista + length r')))))) \\<and>\n        lenr = length rear \\<and>\n        lenr \\<le> lenf \\<and>\n        2 * lenr \\<le> length f' \\<and>\n        0 < ok \\<and>\n        Suc (Suc (Suc (Suc (Suc (Suc (2 * length list + ok))))))\n        \\<le> 2 * length front \\<and>\n        (\\<exists>rest.\n            rev (take ok f') @ x # a # list @ rev lista @ aa # y # r' =\n            front @ rest) \\<and>\n        Suc (length list) = length lista \\<and>\n        length f' = length r' \\<and> ok \\<le> length f';\n        r = aa # lista; f = a # list\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (Suc (2 * length list + ok)))\n                         \\<le> 2 * (length front - Suc 0) \\<and>\n                         (\\<exists>rest.\n                             rev (take ok (x # f')) @\n                             a # list @ rev lista @ aa # y # r' =\n                             tl front @ rest)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa lista rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (Suc (min (length f') ok +\n                                    (length list +\n                                     (length lista + length r')))))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc (Suc (Suc (2 * length list + ok))))))\n                \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take ok f') @\n                    x # a # list @ rev lista @ aa # y # r' =\n                    front @ rest) \\<and>\n                Suc (length list) = length lista \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        r = aa # lista; f = a # list;\n        front @ rest =\n        rev (take ok f') @ x # a # list @ rev lista @ aa # y # r'\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (Suc (2 * length list + ok)))\n                         \\<le> 2 * (length front - Suc 0) \\<and>\n                         (\\<exists>rest.\n                             rev (take ok (x # f')) @\n                             a # list @ rev lista @ aa # y # r' =\n                             tl front @ rest)", "apply (rule conjI, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa lista rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (Suc (min (length f') ok +\n                                    (length list +\n                                     (length lista + length r')))))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc (Suc (Suc (2 * length list + ok))))))\n                \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take ok f') @\n                    x # a # list @ rev lista @ aa # y # r' =\n                    front @ rest) \\<and>\n                Suc (length list) = length lista \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        r = aa # lista; f = a # list;\n        front @ rest =\n        rev (take ok f') @ x # a # list @ rev lista @ aa # y # r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rest.\n                            rev (take ok (x # f')) @\n                            a # list @ rev lista @ aa # y # r' =\n                            tl front @ rest", "apply (rule_tac x=rest in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa lista rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (Suc (min (length f') ok +\n                                    (length list +\n                                     (length lista + length r')))))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc (Suc (Suc (2 * length list + ok))))))\n                \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take ok f') @\n                    x # a # list @ rev lista @ aa # y # r' =\n                    front @ rest) \\<and>\n                Suc (length list) = length lista \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        r = aa # lista; f = a # list;\n        front @ rest =\n        rev (take ok f') @ x # a # list @ rev lista @ aa # y # r'\\<rbrakk>\n       \\<Longrightarrow> rev (take ok (x # f')) @\n                         a # list @ rev lista @ aa # y # r' =\n                         tl front @ rest", "apply (simp add: tl_app st tl_rev_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa lista rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (Suc (min (length f') ok +\n                                    (length list +\n                                     (length lista + length r')))))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc (Suc (Suc (2 * length list + ok))))))\n                \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take ok f') @\n                    x # a # list @ rev lista @ aa # y # r' =\n                    front @ rest) \\<and>\n                Suc (length list) = length lista \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        r = aa # lista; f = a # list;\n        front @ rest =\n        rev (take ok f') @ x # a # list @ rev lista @ aa # y # r'\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take ok f')) @\n                         x # a # list @ rev lista @ aa # y # r' =\n                         tl (rev (take ok f') @\n                             x # a # list @ rev lista @ aa # y # r')", "apply (cases f'; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 9. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 9. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: (2 ok f y r)"], ["proof (state)\nthis:\n  status = Rev ok [] f [y] r\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 9. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = Rev ok [] f [y] r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok [] f [y] r\n\ngoal (1 subgoal):\n 1. invar (deq q)", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case ok: 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  ok = 0\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n             rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "obtain fx fs where \"f = fx # fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fx fs. f = fx # fs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv lessI less_le_trans not_less_zero"], ["proof (prove)\nusing this:\n  invar q\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>fx fs. f = fx # fs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fields st Suc invar_def"], ["proof (prove)\nusing this:\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>fx fs. f = fx # fs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.exhaust list.size(3) select_convs(3) st_inv.simps(1))"], ["proof (state)\nthis:\n  f = fx # fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "hence f_x: \"f = fx # fs\""], ["proof (prove)\nusing this:\n  f = fx # fs\n\ngoal (1 subgoal):\n 1. f = fx # fs", "by simp"], ["proof (state)\nthis:\n  f = fx # fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "obtain rx rs where \"r = rx # rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rx rs. r = rx # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv lessI less_le_trans not_less_zero"], ["proof (prove)\nusing this:\n  invar q\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>rx rs. r = rx # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fields st Suc invar_def"], ["proof (prove)\nusing this:\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>rx rs. r = rx # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.exhaust list.size(3) select_convs(3) st_inv.simps(1))"], ["proof (state)\nthis:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "hence r_x: \"r = rx # rs\""], ["proof (prove)\nusing this:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. r = rx # rs", "by simp"], ["proof (state)\nthis:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  r = rx # rs", "show ?thesis"], ["proof (prove)\nusing this:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using pre_inv inv"], ["proof (prove)\nusing this:\n  r = rx # rs\n  \\<exists>rest. front @ rest = front_list q\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st Suc invar_def rear_list_def r_x f_x"], ["proof (prove)\nusing this:\n  rx # rs = rx # rs\n  \\<exists>rest.\n     front @ rest =\n     front_list\n      \\<lparr>lenf = lenf, front = front,\n         status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n         lenr = lenr\\<rparr>\n  lenf\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front,\n         status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n              rear = rear, lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. lenf\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n             lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n               rear = rear, lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n             lenr = lenr\\<rparr>) =\n    length\n     ((rev \\<circ> rear)\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n               rear = rear, lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n             lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                   rear = rear, lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                   rear = rear, lenr = lenr\\<rparr>) of\n     Rev ok f f' r r' \\<Rightarrow>\n       2 *\n       lenr\n        (deq \\<lparr>lenf = lenf, front = front,\n                status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                rear = rear, lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       ok \\<noteq> 0\n     | App ok f r \\<Rightarrow>\n         2 *\n         lenr\n          (deq \\<lparr>lenf = lenf, front = front,\n                  status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                  rear = rear, lenr = lenr\\<rparr>)\n         \\<le> length r\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n               rear = rear, lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (deq \\<lparr>lenf = lenf, front = front,\n                     status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                     rear = rear, lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                 rear = rear, lenr = lenr\\<rparr>) =\n        front\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                 rear = rear, lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>x.\n        status\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                 rear = rear, lenr = lenr\\<rparr>) \\<noteq>\n        Done x) \\<and>\n    st_inv\n     (status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n               rear = rear, lenr = lenr\\<rparr>))", "apply (simp add: check_def; cases ok'; simp add: check_def min_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<exists>rest.\n                   front @ rest =\n                   rev (take (Suc nat) fs) @ fx # y # rx # rs;\n        lenf =\n        Suc (Suc (Suc (min (length fs) (Suc nat) + length rs))) \\<and>\n        lenr = length rear \\<and>\n        lenr \\<le> lenf \\<and>\n        2 * lenr \\<le> Suc (length fs) \\<and>\n        Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n        (\\<exists>rest.\n            rev (take (Suc nat) fs) @ fx # y # rx # rs =\n            front @ rest) \\<and>\n        length fs = length rs \\<and> Suc nat \\<le> length fs;\n        ok' = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc nat \\<le> 2 * (length front - Suc 0) \\<and>\n                         (\\<exists>rest.\n                             rev (take nat fs) @ fx # y # rx # rs =\n                             tl front @ rest)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length fs) (Suc nat) +\n                               length rs))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> Suc (length fs) \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) fs) @ fx # y # rx # rs =\n                    front @ rest) \\<and>\n                length fs = length rs \\<and> Suc nat \\<le> length fs;\n        ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) fs) @ fx # y # rx # rs\\<rbrakk>\n       \\<Longrightarrow> Suc nat \\<le> 2 * (length front - Suc 0) \\<and>\n                         (\\<exists>rest.\n                             rev (take nat fs) @ fx # y # rx # rs =\n                             tl front @ rest)", "apply (rule conjI, arith)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length fs) (Suc nat) +\n                               length rs))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> Suc (length fs) \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) fs) @ fx # y # rx # rs =\n                    front @ rest) \\<and>\n                length fs = length rs \\<and> Suc nat \\<le> length fs;\n        ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) fs) @ fx # y # rx # rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rest.\n                            rev (take nat fs) @ fx # y # rx # rs =\n                            tl front @ rest", "apply (rule_tac x=rest in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length fs) (Suc nat) +\n                               length rs))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> Suc (length fs) \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) fs) @ fx # y # rx # rs =\n                    front @ rest) \\<and>\n                length fs = length rs \\<and> Suc nat \\<le> length fs;\n        ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) fs) @ fx # y # rx # rs\\<rbrakk>\n       \\<Longrightarrow> rev (take nat fs) @ fx # y # rx # rs =\n                         tl front @ rest", "apply (simp add: tl_app st tl_rev_take_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length fs) (Suc nat) +\n                               length rs))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> Suc (length fs) \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) fs) @ fx # y # rx # rs =\n                    front @ rest) \\<and>\n                length fs = length rs \\<and> Suc nat \\<le> length fs;\n        ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) fs) @ fx # y # rx # rs\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take (Suc nat) fs)) @ fx # y # rx # rs =\n                         tl (rev (take (Suc nat) fs) @ fx # y # rx # rs)", "by (metis Suc_le_length_iff length_take list.sel(3) min_absorb2 n_not_Suc_n rev_is_Nil_conv take_tl tl_Nil tl_append2)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: (3 f r)"], ["proof (state)\nthis:\n  status = App 0 f r\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 8. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front, status = App 0 f r,\n             rear = rear, lenr = lenr\\<rparr>)", "by(cases r; simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (7 subgoals):\n 1. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: (4 ok x f r)"], ["proof (state)\nthis:\n  status = App (Suc ok) (x # f) r\n\ngoal (7 subgoals):\n 1. \\<And>v x f' r'.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 7. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = App (Suc ok) (x # f) r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc ok) (x # f) r\n\ngoal (1 subgoal):\n 1. invar (deq q)", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st invar_def rear_list_def"], ["proof (prove)\nusing this:\n  ok = 0\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev oka fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     oka \\<noteq> 0\n   | App oka fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. lenf\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>) =\n    length\n     ((rev \\<circ> rear)\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = App (Suc ok) (x # f) r, rear = rear,\n                   lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = App (Suc ok) (x # f) r, rear = rear,\n                   lenr = lenr\\<rparr>) of\n     Rev oka fa f' ra r' \\<Rightarrow>\n       2 *\n       lenr\n        (deq \\<lparr>lenf = lenf, front = front,\n                status = App (Suc ok) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       oka \\<noteq> 0\n     | App oka fa ra \\<Rightarrow>\n         2 *\n         lenr\n          (deq \\<lparr>lenf = lenf, front = front,\n                  status = App (Suc ok) (x # f) r, rear = rear,\n                  lenr = lenr\\<rparr>)\n         \\<le> length ra\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (deq \\<lparr>lenf = lenf, front = front,\n                     status = App (Suc ok) (x # f) r, rear = rear,\n                     lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc ok) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) =\n        front\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc ok) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xa.\n        status\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc ok) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) \\<noteq>\n        Done xa) \\<and>\n    st_inv\n     (status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>))", "by (simp add: check_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  ok = Suc ok'", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using pre_inv inv"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n  \\<exists>rest. front @ rest = front_list q\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st invar_def rear_list_def Suc"], ["proof (prove)\nusing this:\n  Suc ok' = Suc ok'\n  \\<exists>rest.\n     front @ rest =\n     front_list\n      \\<lparr>lenf = lenf, front = front,\n         status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n         lenr = lenr\\<rparr>\n  lenf\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front,\n         status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. lenf\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>) =\n    length\n     ((rev \\<circ> rear)\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                   lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                   lenr = lenr\\<rparr>) of\n     Rev ok fa f' ra r' \\<Rightarrow>\n       2 *\n       lenr\n        (deq \\<lparr>lenf = lenf, front = front,\n                status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       ok \\<noteq> 0\n     | App ok fa ra \\<Rightarrow>\n         2 *\n         lenr\n          (deq \\<lparr>lenf = lenf, front = front,\n                  status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                  lenr = lenr\\<rparr>)\n         \\<le> length ra\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (deq \\<lparr>lenf = lenf, front = front,\n                     status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                     lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) =\n        front\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xa.\n        status\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) \\<noteq>\n        Done xa) \\<and>\n    st_inv\n     (status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>))", "apply (cases f; cases ok'; simp add: invar_def rear_list_def check_def min_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list nat.\n       \\<lbrakk>\\<exists>rest.\n                   front @ rest = rev (take (Suc nat) list) @ a # x # r;\n        lenf = Suc (Suc (min (length list) (Suc nat) + length r)) \\<and>\n        lenr = length rear \\<and>\n        lenr \\<le> lenf \\<and>\n        2 * lenr \\<le> length r \\<and>\n        Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n        (\\<exists>rest.\n            rev (take (Suc nat) list) @ a # x # r = front @ rest) \\<and>\n        Suc nat \\<le> length list \\<and> Suc (Suc (length list)) < length r;\n        f = a # list; ok' = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc nat \\<le> 2 * (length front - Suc 0) \\<and>\n                         (\\<exists>rest.\n                             rev (take nat list) @ a # x # r =\n                             tl front @ rest)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (min (length list) (Suc nat) + length r)) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length r \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) list) @ a # x # r =\n                    front @ rest) \\<and>\n                Suc nat \\<le> length list \\<and>\n                Suc (Suc (length list)) < length r;\n        f = a # list; ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) list) @ a # x # r\\<rbrakk>\n       \\<Longrightarrow> Suc nat \\<le> 2 * (length front - Suc 0) \\<and>\n                         (\\<exists>rest.\n                             rev (take nat list) @ a # x # r =\n                             tl front @ rest)", "apply (rule conjI, arith)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (min (length list) (Suc nat) + length r)) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length r \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) list) @ a # x # r =\n                    front @ rest) \\<and>\n                Suc nat \\<le> length list \\<and>\n                Suc (Suc (length list)) < length r;\n        f = a # list; ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) list) @ a # x # r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rest.\n                            rev (take nat list) @ a # x # r =\n                            tl front @ rest", "apply (rule_tac x=rest in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (min (length list) (Suc nat) + length r)) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length r \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) list) @ a # x # r =\n                    front @ rest) \\<and>\n                Suc nat \\<le> length list \\<and>\n                Suc (Suc (length list)) < length r;\n        f = a # list; ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) list) @ a # x # r\\<rbrakk>\n       \\<Longrightarrow> rev (take nat list) @ a # x # r = tl front @ rest", "apply (simp add: tl_app st tl_rev_take_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list nat rest.\n       \\<lbrakk>lenf =\n                Suc (Suc (min (length list) (Suc nat) + length r)) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length r \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) list) @ a # x # r =\n                    front @ rest) \\<and>\n                Suc nat \\<le> length list \\<and>\n                Suc (Suc (length list)) < length r;\n        f = a # list; ok' = Suc nat;\n        front @ rest = rev (take (Suc nat) list) @ a # x # r\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take (Suc nat) list)) @ a # x # r =\n                         tl (rev (take (Suc nat) list) @ a # x # r)", "by (metis length_take list.size(3) min.absorb2 nat.distinct(1) rev.simps(1) rev_rev_ident tl_append2)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: \"5_1\""], ["proof (state)\nthis:\n  status = Idle\n\ngoal (6 subgoals):\n 1. \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n             \\<forall>l. tl front @ l = tl (front @ l);\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 6. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = Idle", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Idle\n\ngoal (1 subgoal):\n 1. invar (deq q)", "proof (cases \"lenr \\<le> lenf - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)", "case True"], ["proof (state)\nthis:\n  lenr \\<le> lenf - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  lenr \\<le> lenf - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  lenr \\<le> lenf - 1\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  lenr \\<le> lenf - 1\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n             lenr = lenr\\<rparr>)", "by (simp add: check_def rear_list_def invar_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)", "case overflows: False"], ["proof (state)\nthis:\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  \\<not> lenr \\<le> lenf - 1", "have f_eq_r: \"length front = length rear\""], ["proof (prove)\nusing this:\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. length front = length rear", "using inv"], ["proof (prove)\nusing this:\n  \\<not> lenr \\<le> lenf - 1\n  invar q\n\ngoal (1 subgoal):\n 1. length front = length rear", "unfolding st fields"], ["proof (prove)\nusing this:\n  \\<not> lenr \\<le> lenf - 1\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. length front = length rear", "by (simp add: le_antisym rear_list_def invar_def)"], ["proof (state)\nthis:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  length front = length rear", "show ?thesis"], ["proof (prove)\nusing this:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. invar (deq q)", "proof (cases front)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case Nil"], ["proof (state)\nthis:\n  front = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> invar (deq q)\n 2. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv overflows"], ["proof (prove)\nusing this:\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding st fields Nil"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n             lenr = lenr\\<rparr>)", "by (cases rear; auto simp add: rear_list_def check_def Let_def invar_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case C_a : (Cons a as)"], ["proof (state)\nthis:\n  front = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  front = a # as", "obtain x xs where \"rear = x # xs\""], ["proof (prove)\nusing this:\n  front = a # as\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv overflows"], ["proof (prove)\nusing this:\n  front = a # as\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding st fields Cons invar_def"], ["proof (prove)\nusing this:\n  front = a # as\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis f_eq_r length_Suc_conv C_a)"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "hence rear_x: \"rear = x # xs\""], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. rear = x # xs", "by simp"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  rear = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. invar (deq q)", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk> \\<Longrightarrow> invar (deq q)\n 2. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk> \\<Longrightarrow> invar (deq q)\n 2. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv overflows"], ["proof (prove)\nusing this:\n  as = []\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding st fields Nil rear_x C_a"], ["proof (prove)\nusing this:\n  [] = []\n  invar\n   \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n             lenr = lenr\\<rparr>)", "by (cases xs; simp add: invar_def check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case (Cons b bs)"], ["proof (state)\nthis:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  as = b # bs", "show ?thesis"], ["proof (prove)\nusing this:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv overflows"], ["proof (prove)\nusing this:\n  as = b # bs\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding st fields Cons rear_x C_a invar_def"], ["proof (prove)\nusing this:\n  b # bs = b # bs\n  lenf\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n           rear = x # xs, lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n              rear = x # xs, lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. lenf\n     (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n             rear = x # xs, lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n               rear = x # xs, lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n             rear = x # xs, lenr = lenr\\<rparr>) =\n    length\n     (rear_list\n       (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n               rear = x # xs, lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n             rear = x # xs, lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                   rear = x # xs, lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                   rear = x # xs, lenr = lenr\\<rparr>) of\n     Rev ok f f' r r' \\<Rightarrow>\n       2 *\n       lenr\n        (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                rear = x # xs, lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       ok \\<noteq> 0\n     | App ok f r \\<Rightarrow>\n         2 *\n         lenr\n          (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                  rear = x # xs, lenr = lenr\\<rparr>)\n         \\<le> length r\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n               rear = x # xs, lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                     rear = x # xs, lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                 rear = x # xs, lenr = lenr\\<rparr>) =\n        front\n         (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                 rear = x # xs, lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xa.\n        status\n         (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                 rear = x # xs, lenr = lenr\\<rparr>) \\<noteq>\n        Done xa) \\<and>\n    st_inv\n     (status\n       (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n               rear = x # xs, lenr = lenr\\<rparr>))", "by (cases xs; cases bs; simp add: check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: \"5_2\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 5. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ [] vd_ = Rev v_ [] vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n             rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def inv fields st)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: \"5_3\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 4. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ (va_ # vf_ # vg_) vd_ = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n             lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: \"5_4\""], ["proof (state)\nthis:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 3. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ va_ vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Rev v_ va_ vb_ [] vd_ = Rev v_ va_ vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev v_ va_ vb_ [] vd_, rear = rear,\n             lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: \"5_5\""], ["proof (state)\nthis:\n  status = App (Suc vc_) [] vb_\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)\n 2. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = App (Suc vc_) [] vb_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  App (Suc vc_) [] vb_ = App (Suc vc_) [] vb_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n             rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "case st: (\"5_6\" v)"], ["proof (state)\nthis:\n  status = Done v\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>status \\<noteq> Idle \\<Longrightarrow>\n                \\<forall>l. tl front @ l = tl (front @ l);\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (deq q)", "then"], ["proof (chain)\npicking this:\n  status = Done v", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Done v\n\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv"], ["proof (prove)\nusing this:\n  status = Done v\n  invar q\n\ngoal (1 subgoal):\n 1. invar (deq q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Done v = Done v\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Done v, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (deq \\<lparr>lenf = lenf, front = front, status = Done v, rear = rear,\n             lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Enqueue operation preserv the invariants *)"], ["", "lemma invar_enq:\n  assumes inv: \"invar q\"\n  shows \"invar (enq x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof (cases q)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       invar (enq x q)", "case (fields lenf front status rear lenr)"], ["proof (state)\nthis:\n  q =\n  \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n     lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  q =\n  \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n     lenr = lenr\\<rparr>", "show ?thesis"], ["proof (prove)\nusing this:\n  q =\n  \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n     lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof(cases status rule: exec.cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ok xa f f' y r r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev ok (xa # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 9. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 10. \\<And>v.\n        \\<lbrakk>q =\n                 \\<lparr>lenf = lenf, front = front, status = status,\n                    rear = rear, lenr = lenr\\<rparr>;\n         status = Done v\\<rbrakk>\n        \\<Longrightarrow> invar (enq x q)", "case st: (1 ok x f f' y r r')"], ["proof (state)\nthis:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (10 subgoals):\n 1. \\<And>ok xa f f' y r r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev ok (xa # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 9. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 10. \\<And>v.\n        \\<lbrakk>q =\n                 \\<lparr>lenf = lenf, front = front, status = status,\n                    rear = rear, lenr = lenr\\<rparr>;\n         status = Done v\\<rbrakk>\n        \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = Rev ok (x # f) f' (y # r) r'", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof (cases f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case Nil"], ["proof (state)\nthis:\n  f = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  f = []", "show ?thesis"], ["proof (prove)\nusing this:\n  f = []\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  f = []\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st Nil"], ["proof (prove)\nusing this:\n  [] = []\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev ok [x] f' (y # r) r',\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok [x] f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def; cases r; auto simp add: min_absorb2 invar_def rear_list_def Let_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case (Cons a list)"], ["proof (state)\nthis:\n  f = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = Rev ok (x # f) f' (y # r) r'; f = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  f = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  f = a # list\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv check_def rear_list_def"], ["proof (prove)\nusing this:\n  f = a # list\n  invar q\n  check ?q =\n  (if lenr ?q \\<le> lenf ?q then exec2 ?q\n   else let newstate = Rev 0 (front ?q) [] (rear ?q) []\n        in exec2\n            (?q\\<lparr>lenf := lenf ?q + lenr ?q, status := newstate,\n                  rear := [], lenr := 0\\<rparr>))\n  rear_list = rev \\<circ> rear\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st Nil invar_def check_def rear_list_def"], ["proof (prove)\nusing this:\n  f = a # list\n  lenf\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev ok (x # f) f' (y # r) r', rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev ok (x # f) f' (y # r) r', rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev ok (x # f) f' (y # r) r', rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev ok (x # f) f' (y # r) r', rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev ok (x # f) f' (y # r) r', rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev ok (x # f) f' (y # r) r', rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev ok (x # f) f' (y # r) r', rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev oka fa f'a ra r'a \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front,\n         status = Rev ok (x # f) f' (y # r) r', rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f'a \\<and>\n     oka \\<noteq> 0\n   | App oka fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev ok (x # f) f' (y # r) r', rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev ok (x # f) f' (y # r) r', rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev ok (x # f) f' (y # r) r', rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok (x # f) f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok (x # f) f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok (x # f) f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev ok (x # f) f' (y # r) r', rear = rear,\n        lenr = lenr\\<rparr>)\n  (if lenr ?q \\<le> lenf ?q then exec2 ?q\n   else let newstate = Rev 0 (front ?q) [] (rear ?q) []\n        in exec2\n            (?q\\<lparr>lenf := lenf ?q + lenr ?q, status := newstate,\n                  rear := [], lenr := 0\\<rparr>)) =\n  (if lenr ?q \\<le> lenf ?q then exec2 ?q\n   else let newstate = Rev 0 (front ?q) [] (rear ?q) []\n        in exec2\n            (?q\\<lparr>lenf := lenf ?q + lenr ?q, status := newstate,\n                  rear := [], lenr := 0\\<rparr>))\n  rev \\<circ> rear = rev \\<circ> rear\n\ngoal (1 subgoal):\n 1. lenf\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok (x # f) f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev ok (x # f) f' (y # r) r', rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok (x # f) f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr>) =\n    length\n     ((rev \\<circ> rear)\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev ok (x # f) f' (y # r) r', rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok (x # f) f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = Rev ok (x # f) f' (y # r) r', rear = rear,\n                lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = Rev ok (x # f) f' (y # r) r', rear = rear,\n                lenr = lenr\\<rparr>) of\n     Rev oka fa f'a ra r'a \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = front,\n             status = Rev ok (x # f) f' (y # r) r', rear = rear,\n             lenr = lenr\\<rparr>)\n       \\<le> length f'a \\<and>\n       oka \\<noteq> 0\n     | App oka fa ra \\<Rightarrow>\n         2 *\n         lenr\n          (enq x\n            \\<lparr>lenf = lenf, front = front,\n               status = Rev ok (x # f) f' (y # r) r', rear = rear,\n               lenr = lenr\\<rparr>)\n         \\<le> length ra\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev ok (x # f) f' (y # r) r', rear = rear,\n            lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (enq x\n               \\<lparr>lenf = lenf, front = front,\n                  status = Rev ok (x # f) f' (y # r) r', rear = rear,\n                  lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev ok (x # f) f' (y # r) r', rear = rear,\n              lenr = lenr\\<rparr>) =\n        front\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev ok (x # f) f' (y # r) r', rear = rear,\n              lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xaa.\n        status\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev ok (x # f) f' (y # r) r', rear = rear,\n              lenr = lenr\\<rparr>) \\<noteq>\n        Done xaa) \\<and>\n    st_inv\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev ok (x # f) f' (y # r) r', rear = rear,\n            lenr = lenr\\<rparr>))", "by (simp; cases r; auto simp add: min_absorb2 check_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 9. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 9. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: (2 ok f y r)"], ["proof (state)\nthis:\n  status = Rev ok [] f [y] r\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 9. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = Rev ok [] f [y] r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok [] f [y] r\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case ok: 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  ok = 0\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n          rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "obtain fx fs where \"f = fx # fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fx fs. f = fx # fs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv lessI less_le_trans not_less_zero"], ["proof (prove)\nusing this:\n  invar q\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>fx fs. f = fx # fs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fields st Suc invar_def"], ["proof (prove)\nusing this:\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>fx fs. f = fx # fs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.exhaust list.size(3) select_convs(3) st_inv.simps(1))"], ["proof (state)\nthis:\n  f = fx # fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "hence f_x: \"f = fx # fs\""], ["proof (prove)\nusing this:\n  f = fx # fs\n\ngoal (1 subgoal):\n 1. f = fx # fs", "by simp"], ["proof (state)\nthis:\n  f = fx # fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "obtain rx rs where \"r = rx # rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rx rs. r = rx # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv lessI less_le_trans not_less_zero"], ["proof (prove)\nusing this:\n  invar q\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>rx rs. r = rx # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fields st Suc invar_def"], ["proof (prove)\nusing this:\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  ?n < Suc ?n\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  \\<not> ?n < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>rx rs. r = rx # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.exhaust list.size(3) select_convs(3) st_inv.simps(1))"], ["proof (state)\nthis:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "hence r_x: \"r = rx # rs\""], ["proof (prove)\nusing this:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. r = rx # rs", "by simp"], ["proof (state)\nthis:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  r = rx # rs", "show ?thesis"], ["proof (prove)\nusing this:\n  r = rx # rs\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  r = rx # rs\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st Suc invar_def rear_list_def r_x f_x"], ["proof (prove)\nusing this:\n  rx # rs = rx # rs\n  lenf\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front,\n         status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n              rear = rear, lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. lenf\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr>) =\n    length\n     ((rev \\<circ> rear)\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n          lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                rear = rear, lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                rear = rear, lenr = lenr\\<rparr>) of\n     Rev ok f f' r r' \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n             lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       ok \\<noteq> 0\n     | App ok f r \\<Rightarrow>\n         2 *\n         lenr\n          (enq x\n            \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n               rear = rear, lenr = lenr\\<rparr>)\n         \\<le> length r\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (enq x\n               \\<lparr>lenf = lenf, front = front,\n                  status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n                  rear = rear, lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n              rear = rear, lenr = lenr\\<rparr>) =\n        front\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n              rear = rear, lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xa.\n        status\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs),\n              rear = rear, lenr = lenr\\<rparr>) \\<noteq>\n        Done xa) \\<and>\n    st_inv\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] (fx # fs) [y] (rx # rs), rear = rear,\n            lenr = lenr\\<rparr>))", "by (simp add: check_def; cases ok'; simp add: check_def min_absorb2)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: (3 f r)"], ["proof (state)\nthis:\n  status = App 0 f r\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 8. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = App 0 f r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App 0 f r\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof(cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App 0 f r; r = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>status = App 0 f r; r = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case Nil"], ["proof (state)\nthis:\n  r = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App 0 f r; r = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>status = App 0 f r; r = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  r = []", "show ?thesis"], ["proof (prove)\nusing this:\n  r = []\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  r = []\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  r = []\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n          lenr = lenr\\<rparr>)", "by(simp add:  check_def rear_list_def Let_def invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = App 0 f r; r = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = App 0 f r; r = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case (Cons a list)"], ["proof (state)\nthis:\n  r = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>status = App 0 f r; r = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  r = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  r = a # list\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  r = a # list\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  r = a # list\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n          lenr = lenr\\<rparr>)", "by (simp add:  check_def rear_list_def Let_def invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (7 subgoals):\n 1. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: (4 ok x f r)"], ["proof (state)\nthis:\n  status = App (Suc ok) (x # f) r\n\ngoal (7 subgoals):\n 1. \\<And>v xa f' r'.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 7. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = App (Suc ok) (x # f) r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc ok) (x # f) r\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st invar_def rear_list_def"], ["proof (prove)\nusing this:\n  ok = 0\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev oka fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     oka \\<noteq> 0\n   | App oka fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. lenf\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>) =\n    length\n     ((rev \\<circ> rear)\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = App (Suc ok) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = App (Suc ok) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>) of\n     Rev oka fa f' ra r' \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       oka \\<noteq> 0\n     | App oka fa ra \\<Rightarrow>\n         2 *\n         lenr\n          (enq x\n            \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>)\n         \\<le> length ra\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (enq x\n               \\<lparr>lenf = lenf, front = front,\n                  status = App (Suc ok) (x # f) r, rear = rear,\n                  lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) =\n        front\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xaa.\n        status\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<noteq>\n        Done xaa) \\<and>\n    st_inv\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>))", "by (simp add: check_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  ok = Suc ok'", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st invar_def rear_list_def Suc"], ["proof (prove)\nusing this:\n  Suc ok' = Suc ok'\n  lenf\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front,\n         status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. lenf\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>) =\n    length\n     ((rev \\<circ> rear)\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>) of\n     Rev ok fa f' ra r' \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       ok \\<noteq> 0\n     | App ok fa ra \\<Rightarrow>\n         2 *\n         lenr\n          (enq x\n            \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>)\n         \\<le> length ra\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (enq x\n               \\<lparr>lenf = lenf, front = front,\n                  status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                  lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) =\n        front\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xaa.\n        status\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<noteq>\n        Done xaa) \\<and>\n    st_inv\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>))", "by (cases f; cases ok'; auto simp add: invar_def rear_list_def check_def min_absorb2)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: \"5_1\""], ["proof (state)\nthis:\n  status = Idle\n\ngoal (6 subgoals):\n 1. \\<lbrakk>q =\n             \\<lparr>lenf = lenf, front = front, status = status,\n                rear = rear, lenr = lenr\\<rparr>;\n     status = Idle\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 6. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = Idle", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Idle\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof (cases \"lenr + 1 \\<le> lenf\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)", "case True"], ["proof (state)\nthis:\n  lenr + 1 \\<le> lenf\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  lenr + 1 \\<le> lenf", "show ?thesis"], ["proof (prove)\nusing this:\n  lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  lenr + 1 \\<le> lenf\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  lenr + 1 \\<le> lenf\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr>)", "by (simp add: check_def rear_list_def invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)", "case overflows: False"], ["proof (state)\nthis:\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  \\<not> lenr + 1 \\<le> lenf", "have f_eq_r: \"length front = length rear\""], ["proof (prove)\nusing this:\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. length front = length rear", "using inv"], ["proof (prove)\nusing this:\n  \\<not> lenr + 1 \\<le> lenf\n  invar q\n\ngoal (1 subgoal):\n 1. length front = length rear", "unfolding st fields"], ["proof (prove)\nusing this:\n  \\<not> lenr + 1 \\<le> lenf\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. length front = length rear", "by (simp add: le_antisym rear_list_def invar_def)"], ["proof (state)\nthis:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  length front = length rear", "show ?thesis"], ["proof (prove)\nusing this:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof (cases front)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case Nil"], ["proof (state)\nthis:\n  front = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv overflows"], ["proof (prove)\nusing this:\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding st fields Nil"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n          lenr = lenr\\<rparr>)", "by (cases rear; auto simp add: rear_list_def check_def Let_def invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case C_a : (Cons a as)"], ["proof (state)\nthis:\n  front = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  front = a # as", "obtain x xs where \"rear = x # xs\""], ["proof (prove)\nusing this:\n  front = a # as\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv overflows"], ["proof (prove)\nusing this:\n  front = a # as\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding st fields Cons invar_def"], ["proof (prove)\nusing this:\n  front = a # as\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis f_eq_r length_Suc_conv C_a)"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "hence rear_x: \"rear = x # xs\""], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. rear = x # xs", "by simp"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length front = length rear; front = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  rear = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk>\n    \\<Longrightarrow> invar (enq x q)\n 2. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv overflows"], ["proof (prove)\nusing this:\n  as = []\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding st fields Nil rear_x C_a"], ["proof (prove)\nusing this:\n  [] = []\n  invar\n   \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n          lenr = lenr\\<rparr>)", "by (cases xs; simp add: invar_def check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case (Cons b bs)"], ["proof (state)\nthis:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>rear = x # xs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  as = b # bs", "show ?thesis"], ["proof (prove)\nusing this:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv overflows"], ["proof (prove)\nusing this:\n  as = b # bs\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding st fields Cons rear_x C_a invar_def"], ["proof (prove)\nusing this:\n  b # bs = b # bs\n  lenf\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n           rear = x # xs, lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n              rear = x # xs, lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. lenf\n     (enq x\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr>) =\n    length\n     (front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr>) =\n    length\n     (rear_list\n       (enq x\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr>)) \\<and>\n    lenr\n     (enq x\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr>)\n    \\<le> lenf\n           (enq x\n             \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                rear = x # xs, lenr = lenr\\<rparr>) \\<and>\n    (case status\n           (enq x\n             \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                rear = x # xs, lenr = lenr\\<rparr>) of\n     Rev ok f f' r r' \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n             rear = x # xs, lenr = lenr\\<rparr>)\n       \\<le> length f' \\<and>\n       ok \\<noteq> 0\n     | App ok f r \\<Rightarrow>\n         2 *\n         lenr\n          (enq x\n            \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n               rear = x # xs, lenr = lenr\\<rparr>)\n         \\<le> length r\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr>))\n    \\<le> 2 *\n          length\n           (front\n             (enq x\n               \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n                  rear = x # xs, lenr = lenr\\<rparr>)) \\<and>\n    (\\<exists>rest.\n        front_list\n         (enq x\n           \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n              rear = x # xs, lenr = lenr\\<rparr>) =\n        front\n         (enq x\n           \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n              rear = x # xs, lenr = lenr\\<rparr>) @\n        rest) \\<and>\n    (\\<forall>xaa.\n        status\n         (enq x\n           \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n              rear = x # xs, lenr = lenr\\<rparr>) \\<noteq>\n        Done xaa) \\<and>\n    st_inv\n     (status\n       (enq x\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr>))", "by (cases xs; cases bs; simp add: check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: \"5_2\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 5. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ [] vd_ = Rev v_ [] vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n          rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: \"5_3\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 4. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ (va_ # vf_ # vg_) vd_ = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n          lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: \"5_4\""], ["proof (state)\nthis:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 3. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ va_ vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Rev v_ va_ vb_ [] vd_ = Rev v_ va_ vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n          rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: \"5_5\""], ["proof (state)\nthis:\n  status = App (Suc vc_) [] vb_\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)\n 2. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = App (Suc vc_) [] vb_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  App (Suc vc_) [] vb_ = App (Suc vc_) [] vb_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n          rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "case st: \"5_6\""], ["proof (state)\nthis:\n  status = Done v_\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>q =\n                \\<lparr>lenf = lenf, front = front, status = status,\n                   rear = rear, lenr = lenr\\<rparr>;\n        status = Done v\\<rbrakk>\n       \\<Longrightarrow> invar (enq x q)", "then"], ["proof (chain)\npicking this:\n  status = Done v_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Done v_\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv"], ["proof (prove)\nusing this:\n  status = Done v_\n  invar q\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  Done v_ = Done v_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. invar\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n          lenr = lenr\\<rparr>)", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Correctness proof of the dequeue operation *)"], ["", "lemma queue_correct_deq :\n  assumes inv: \"invar q\"\n  shows \"list (deq q) = tl (list q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "proof (cases q)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       list (deq q) = tl (list q)", "case (fields lenf front status rear lenr)"], ["proof (state)\nthis:\n  q =\n  \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n     lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       list (deq q) = tl (list q)", "have inv_deq: \"invar (deq q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (deq q)", "using inv invar_deq"], ["proof (prove)\nusing this:\n  invar q\n  invar ?q \\<Longrightarrow> invar (deq ?q)\n\ngoal (1 subgoal):\n 1. invar (deq q)", "by simp"], ["proof (state)\nthis:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  invar (deq q)", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "proof (cases status rule: exec.cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ok x f f' y r r'.\n       \\<lbrakk>invar (deq q);\n        status = Rev ok (x # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>invar (deq q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 9. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 10. \\<And>v.\n        \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n        \\<Longrightarrow> list (deq q) = tl (list q)", "case st: (1 ok x f f' y r r')"], ["proof (state)\nthis:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (10 subgoals):\n 1. \\<And>ok x f f' y r r'.\n       \\<lbrakk>invar (deq q);\n        status = Rev ok (x # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>invar (deq q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 9. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 10. \\<And>v.\n        \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n        \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = Rev ok (x # f) f' (y # r) r'", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev ok (x # f) f' (y # r) r'\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev ok (x # f) f' (y # r) r' = Rev ok (x # f) f' (y # r) r'\n  invar\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev ok (x # f) f' (y # r) r', rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = Rev ok (x # f) f' (y # r) r', rear = rear,\n           lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev ok (x # f) f' (y # r) r', rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev ok (x # f) f' (y # r) r', rear = rear,\n            lenr = lenr\\<rparr>)", "apply (cases f; cases r; simp add: invar_def check_def rear_list_def min_absorb2 tl_rev_take)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length f') ok + length r'))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc ok))) \\<le> 2 * length front \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        Suc ok \\<le> 2 * (length front - Suc 0) \\<and>\n        (\\<exists>rest.\n            tl (rev (take ok f')) @ x # a # y # r' = tl front @ rest);\n        f = [];\n        \\<exists>rest. rev (take ok f') @ x # a # y # r' = front @ rest;\n        r = [a]\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take ok f')) @ x # a # y # r' @ rev rear =\n                         tl (rev (take ok f') @ x # a # y # r' @ rev rear)\n 2. \\<And>a list aa lista.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (Suc (min (length f') ok +\n                                    (length list +\n                                     (length lista + length r')))))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> length f' \\<and>\n                0 < ok \\<and>\n                Suc (Suc (Suc (Suc (Suc (Suc (2 * length list + ok))))))\n                \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take ok f') @\n                    x # a # list @ rev lista @ aa # y # r' =\n                    front @ rest) \\<and>\n                Suc (length list) = length lista \\<and>\n                length f' = length r' \\<and> ok \\<le> length f';\n        Suc (Suc (Suc (2 * length list + ok)))\n        \\<le> 2 * (length front - Suc 0) \\<and>\n        (\\<exists>rest.\n            tl (rev (take ok f')) @ x # a # list @ rev lista @ aa # y # r' =\n            tl front @ rest);\n        f = a # list; r = aa # lista\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take ok f')) @\n                         x # a # list @ rev lista @ aa # y # r' @ rev rear =\n                         tl (rev (take ok f') @\n                             x #\n                             a # list @ rev lista @ aa # y # r' @ rev rear)", "by (metis le_zero_eq length_take list.size(3) min.absorb2 not_le rev_is_Nil_conv tl_append2)+"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>invar (deq q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 9. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>invar (deq q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 9. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: (2 ok f y r)"], ["proof (state)\nthis:\n  status = Rev ok [] f [y] r\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>invar (deq q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 9. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = Rev ok [] f [y] r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok [] f [y] r\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case ok: 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding fields st"], ["proof (prove)\nusing this:\n  ok = 0\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n             rear = rear, lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n            rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  ok = Suc ok'", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding fields st Suc invar_def"], ["proof (prove)\nusing this:\n  Suc ok' = Suc ok'\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  lenf\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>) =\n  length\n   (front_list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] f [y] r, rear = rear,\n             lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>) =\n  length\n   (rear_list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] f [y] r, rear = rear,\n             lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>)\n  \\<le> lenf\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = Rev (Suc ok') [] f [y] r, rear = rear,\n                 lenr = lenr\\<rparr>) \\<and>\n  (case status\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = Rev (Suc ok') [] f [y] r, rear = rear,\n                 lenr = lenr\\<rparr>) of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      (deq \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>)\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        (deq \\<lparr>lenf = lenf, front = front,\n                status = Rev (Suc ok') [] f [y] r, rear = rear,\n                lenr = lenr\\<rparr>)\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] f [y] r, rear = rear,\n             lenr = lenr\\<rparr>))\n  \\<le> 2 *\n        length\n         (front\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = Rev (Suc ok') [] f [y] r, rear = rear,\n                   lenr = lenr\\<rparr>)) \\<and>\n  (\\<exists>rest.\n      front_list\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] f [y] r, rear = rear,\n               lenr = lenr\\<rparr>) =\n      front\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] f [y] r, rear = rear,\n               lenr = lenr\\<rparr>) @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = Rev (Suc ok') [] f [y] r, rear = rear,\n               lenr = lenr\\<rparr>) \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] f [y] r, rear = rear,\n             lenr = lenr\\<rparr>))\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] f [y] r, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr>)", "apply (cases f; cases r; cases ok'; simp add: check_def min_absorb2 rear_list_def tl_rev_take_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista nat.\n       \\<lbrakk>lenf =\n                Suc (Suc (Suc (min (length list) (Suc nat) +\n                               length lista))) \\<and>\n                lenr = length rear \\<and>\n                lenr \\<le> lenf \\<and>\n                2 * lenr \\<le> Suc (length list) \\<and>\n                Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front \\<and>\n                (\\<exists>rest.\n                    rev (take (Suc nat) list) @ a # y # aa # lista =\n                    front @ rest) \\<and>\n                length list = length lista \\<and> Suc nat \\<le> length list;\n        Suc nat \\<le> 2 * (length front - Suc 0) \\<and>\n        (\\<exists>rest.\n            tl (rev (take (Suc nat) list)) @ a # y # aa # lista =\n            tl front @ rest);\n        f = a # list; r = aa # lista; ok' = Suc nat\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take (Suc nat) list)) @\n                         a # y # aa # lista @ rev rear =\n                         tl (rev (take (Suc nat) list) @\n                             a # y # aa # lista @ rev rear)", "by (metis (no_types) length_greater_0_conv less_le_trans old.nat.distinct(2) rev_is_Nil_conv take_eq_Nil tl_append2 zero_less_Suc)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: (3 f r)"], ["proof (state)\nthis:\n  status = App 0 f r\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>invar (deq q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 8. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = App 0 f r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App 0 f r\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = App 0 f r\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  App 0 f r = App 0 f r\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n           lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front, status = App 0 f r,\n             rear = rear, lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front, status = App 0 f r,\n            rear = rear, lenr = lenr\\<rparr>)", "by (cases f; cases r; simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (7 subgoals):\n 1. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: (4 ok x f r)"], ["proof (state)\nthis:\n  status = App (Suc ok) (x # f) r\n\ngoal (7 subgoals):\n 1. \\<And>v x f' r'.\n       \\<lbrakk>invar (deq q); status = App (Suc v) (x # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 7. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = App (Suc ok) (x # f) r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc ok) (x # f) r\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding fields st invar_def rear_list_def"], ["proof (prove)\nusing this:\n  ok = 0\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev oka fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     oka \\<noteq> 0\n   | App oka fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n  lenf\n   (deq \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>) =\n  length\n   (front_list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (deq \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>) =\n  length\n   ((rev \\<circ> rear)\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (deq \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>)\n  \\<le> lenf\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc ok) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) \\<and>\n  (case status\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc ok) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) of\n   Rev oka fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      (deq \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>)\n     \\<le> length f' \\<and>\n     oka \\<noteq> 0\n   | App oka fa ra \\<Rightarrow>\n       2 *\n       lenr\n        (deq \\<lparr>lenf = lenf, front = front,\n                status = App (Suc ok) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>)\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>))\n  \\<le> 2 *\n        length\n         (front\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = App (Suc ok) (x # f) r, rear = rear,\n                   lenr = lenr\\<rparr>)) \\<and>\n  (\\<exists>rest.\n      front_list\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>) =\n      front\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>) @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc ok) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>) \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>))\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>)", "by (simp add: check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  ok = Suc ok'", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding fields st invar_def rear_list_def Suc"], ["proof (prove)\nusing this:\n  Suc ok' = Suc ok'\n  lenf\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front,\n         status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n  lenf\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>) =\n  length\n   (front_list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>) =\n  length\n   ((rev \\<circ> rear)\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>)\n  \\<le> lenf\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) \\<and>\n  (case status\n         (deq \\<lparr>lenf = lenf, front = front,\n                 status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                 lenr = lenr\\<rparr>) of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      (deq \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>)\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        (deq \\<lparr>lenf = lenf, front = front,\n                status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>)\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>))\n  \\<le> 2 *\n        length\n         (front\n           (deq \\<lparr>lenf = lenf, front = front,\n                   status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                   lenr = lenr\\<rparr>)) \\<and>\n  (\\<exists>rest.\n      front_list\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>) =\n      front\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>) @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       (deq \\<lparr>lenf = lenf, front = front,\n               status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n               lenr = lenr\\<rparr>) \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>))\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>)", "apply (cases f; cases ok'; auto simp add: rear_list_def check_def min_absorb2 tl_rev_take_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list nat rest resta.\n       \\<lbrakk>f = a # list; ok' = Suc nat;\n        lenf = Suc (Suc (Suc (nat + length r)));\n        Suc nat \\<le> 2 * (length front - Suc 0);\n        tl (rev (take (Suc nat) list)) @ a # x # r = tl front @ rest;\n        lenr = length rear; 2 * length rear \\<le> length r;\n        Suc (Suc (Suc (Suc nat))) \\<le> 2 * length front;\n        rev (take (Suc nat) list) @ a # x # r = front @ resta;\n        Suc nat \\<le> length list;\n        Suc (Suc (length list)) < length r\\<rbrakk>\n       \\<Longrightarrow> tl (rev (take (Suc nat) list)) @\n                         a # x # r @ rev rear =\n                         tl (rev (take (Suc nat) list) @\n                             a # x # r @ rev rear)", "by (metis Nitpick.size_list_simp(2) length_rev length_take min.absorb2 nat.simps(3) tl_append2)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: \"5_1\""], ["proof (state)\nthis:\n  status = Idle\n\ngoal (6 subgoals):\n 1. \\<lbrakk>invar (deq q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 6. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = Idle", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Idle\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "proof (cases \"lenr \\<le> lenf - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)", "case True"], ["proof (state)\nthis:\n  lenr \\<le> lenf - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  lenr \\<le> lenf - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq Nil_is_rev_conv append_Nil diff_is_0_eq diff_zero length_0_conv"], ["proof (prove)\nusing this:\n  lenr \\<le> lenf - 1\n  invar q\n  invar (deq q)\n  ([] = rev ?xs) = (?xs = [])\n  [] @ ?ys = ?ys\n  (?m - ?n = 0) = (?m \\<le> ?n)\n  ?a - (0::?'a) = ?a\n  (length ?xs = 0) = (?xs = [])\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  lenr \\<le> lenf - 1\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n           lenr = lenr\\<rparr>)\n  ([] = rev ?xs) = (?xs = [])\n  [] @ ?ys = ?ys\n  (?m - ?n = 0) = (?m \\<le> ?n)\n  ?a - (0::?'a) = ?a\n  (length ?xs = 0) = (?xs = [])\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr>)", "by (simp add: check_def rear_list_def invar_def; metis  list.sel(2) tl_append2)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)", "case overflows: False"], ["proof (state)\nthis:\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  \\<not> lenr \\<le> lenf - 1", "have f_eq_r: \"length front = length rear\""], ["proof (prove)\nusing this:\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. length front = length rear", "using inv"], ["proof (prove)\nusing this:\n  \\<not> lenr \\<le> lenf - 1\n  invar q\n\ngoal (1 subgoal):\n 1. length front = length rear", "unfolding st fields"], ["proof (prove)\nusing this:\n  \\<not> lenr \\<le> lenf - 1\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. length front = length rear", "by (simp add: le_antisym rear_list_def invar_def)"], ["proof (state)\nthis:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr \\<le> lenf - 1\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  length front = length rear", "show ?thesis"], ["proof (prove)\nusing this:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "proof (cases front)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case Nil"], ["proof (state)\nthis:\n  front = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv overflows inv_deq"], ["proof (prove)\nusing this:\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields Nil"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<not> lenr \\<le> lenf - 1\n  invar\n   (deq \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n           lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n            lenr = lenr\\<rparr>)", "by (cases rear; auto simp add: rear_list_def check_def Let_def invar_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case C_a : (Cons a as)"], ["proof (state)\nthis:\n  front = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  front = a # as", "obtain x xs where \"rear = x # xs\""], ["proof (prove)\nusing this:\n  front = a # as\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv overflows"], ["proof (prove)\nusing this:\n  front = a # as\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding st fields Cons invar_def"], ["proof (prove)\nusing this:\n  front = a # as\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis f_eq_r length_Suc_conv C_a)"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "hence rear_x: \"rear = x # xs\""], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. rear = x # xs", "by simp"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  rear = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk>\n    \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv overflows"], ["proof (prove)\nusing this:\n  as = []\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields Nil rear_x C_a"], ["proof (prove)\nusing this:\n  [] = []\n  invar\n   \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n            lenr = lenr\\<rparr>)", "by (cases xs; simp add: invar_def check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case (Cons b bs)"], ["proof (state)\nthis:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  as = b # bs", "show ?thesis"], ["proof (prove)\nusing this:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv overflows"], ["proof (prove)\nusing this:\n  as = b # bs\n  invar q\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields Cons rear_x C_a invar_def"], ["proof (prove)\nusing this:\n  b # bs = b # bs\n  lenf\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n           rear = x # xs, lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n              rear = x # xs, lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr \\<le> lenf - 1\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n             rear = x # xs, lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr>)", "by (cases xs; cases bs; simp add: check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: \"5_2\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 5. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ [] vd_ = Rev v_ [] vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n           rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n             rear = rear, lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n            rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: \"5_3\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (deq q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ (va_ # vf_ # vg_) vd_ = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front,\n           status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n           lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n            lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: \"5_4\""], ["proof (state)\nthis:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>invar (deq q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ va_ vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev v_ va_ vb_ [] vd_ = Rev v_ va_ vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n           rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front,\n             status = Rev v_ va_ vb_ [] vd_, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n            rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: \"5_5\""], ["proof (state)\nthis:\n  status = App (Suc vc_) [] vb_\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>invar (deq q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = App (Suc vc_) [] vb_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  App (Suc vc_) [] vb_ = App (Suc vc_) [] vb_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n      rear = rear, lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n           rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n             rear = rear, lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n            rear = rear, lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "case st: \"5_6\""], ["proof (state)\nthis:\n  status = Done v_\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>invar (deq q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (deq q) = tl (list q)", "then"], ["proof (chain)\npicking this:\n  status = Done v_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Done v_\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Done v_\n  invar q\n  invar (deq q)\n\ngoal (1 subgoal):\n 1. list (deq q) = tl (list q)", "unfolding st fields"], ["proof (prove)\nusing this:\n  Done v_ = Done v_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (deq \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n           lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (deq \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n             lenr = lenr\\<rparr>) =\n    tl (list\n         \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n            lenr = lenr\\<rparr>)", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (deq q) = tl (list q)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Correctness proof of the enqueue operation *)"], ["", "lemma queue_correct_enq :\n  assumes inv: \"invar q\"\n  shows \"list (enq x q) = (list q) @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "proof (cases q)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       list (enq x q) = list q @ [x]", "case (fields lenf front status rear lenr)"], ["proof (state)\nthis:\n  q =\n  \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n     lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       list (enq x q) = list q @ [x]", "have inv_deq: \"invar (enq x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (enq x q)", "using inv invar_enq"], ["proof (prove)\nusing this:\n  invar q\n  invar ?q \\<Longrightarrow> invar (enq ?x ?q)\n\ngoal (1 subgoal):\n 1. invar (enq x q)", "by simp"], ["proof (state)\nthis:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. \\<And>lenf front status rear lenr.\n       q =\n       \\<lparr>lenf = lenf, front = front, status = status, rear = rear,\n          lenr = lenr\\<rparr> \\<Longrightarrow>\n       list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  invar (enq x q)", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "proof (cases status rule: exec.cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>ok xa f f' y r r'.\n       \\<lbrakk>invar (enq x q);\n        status = Rev ok (xa # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>invar (enq x q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 9. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 10. \\<And>v.\n        \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n        \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: (1 ok x f f' y r r')"], ["proof (state)\nthis:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (10 subgoals):\n 1. \\<And>ok xa f f' y r r'.\n       \\<lbrakk>invar (enq x q);\n        status = Rev ok (xa # f) f' (y # r) r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>ok f' y r'.\n       \\<lbrakk>invar (enq x q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 9. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 10. \\<And>v.\n        \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n        \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = Rev ok (x # f) f' (y # r) r'", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok (x # f) f' (y # r) r'\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev ok (x # f) f' (y # r) r'\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev ok (x # f) f' (y # r) r' = Rev ok (x # f) f' (y # r) r'\n  invar\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev ok (x # f) f' (y # r) r', rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev ok (x # f) f' (y # r) r', rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev ok (x # f) f' (y # r) r', rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev ok (x # f) f' (y # r) r', rear = rear,\n        lenr = lenr\\<rparr> @\n    [x]", "by (cases f; cases r; simp add: invar_def check_def rear_list_def min_absorb2 tl_rev_take)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>invar (enq x q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 9. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>invar (enq x q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 9. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: (2 ok f y r)"], ["proof (state)\nthis:\n  status = Rev ok [] f [y] r\n\ngoal (9 subgoals):\n 1. \\<And>ok f' y r'.\n       \\<lbrakk>invar (enq x q); status = Rev ok [] f' [y] r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 9. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = Rev ok [] f [y] r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev ok [] f [y] r\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case ok: 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Rev ok [] f [y] r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding fields st"], ["proof (prove)\nusing this:\n  ok = 0\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n          rear = rear, lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = Rev ok [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr> @\n    [x]", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = Rev ok [] f [y] r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  ok = Suc ok'", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding fields st Suc invar_def"], ["proof (prove)\nusing this:\n  Suc ok' = Suc ok'\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  lenf\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) =\n  length\n   (front_list\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>) =\n  length\n   (rear_list\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> lenf\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (case status\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = Rev (Suc ok') [] f [y] r, rear = rear,\n              lenr = lenr\\<rparr>) of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      (enq x\n        \\<lparr>lenf = lenf, front = front,\n           status = Rev (Suc ok') [] f [y] r, rear = rear,\n           lenr = lenr\\<rparr>)\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = front,\n             status = Rev (Suc ok') [] f [y] r, rear = rear,\n             lenr = lenr\\<rparr>)\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr>))\n  \\<le> 2 *\n        length\n         (front\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = Rev (Suc ok') [] f [y] r, rear = rear,\n                lenr = lenr\\<rparr>)) \\<and>\n  (\\<exists>rest.\n      front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr>) =\n      front\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr>) @\n      rest) \\<and>\n  (\\<forall>xa.\n      status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = Rev (Suc ok') [] f [y] r, rear = rear,\n            lenr = lenr\\<rparr>) \\<noteq>\n      Done xa) \\<and>\n  st_inv\n   (status\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr>))\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev (Suc ok') [] f [y] r, rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = Rev (Suc ok') [] f [y] r,\n        rear = rear, lenr = lenr\\<rparr> @\n    [x]", "by (cases f; cases r; cases ok'; simp add: check_def min_absorb2 rear_list_def tl_rev_take_Suc)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: (3 f r)"], ["proof (state)\nthis:\n  status = App 0 f r\n\ngoal (8 subgoals):\n 1. \\<And>f' r'.\n       \\<lbrakk>invar (enq x q); status = App 0 f' r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 8. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = App 0 f r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App 0 f r\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = App 0 f r\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  App 0 f r = App 0 f r\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = App 0 f r, rear = rear,\n        lenr = lenr\\<rparr> @\n    [x]", "by (cases f; cases r; simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (7 subgoals):\n 1. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: (4 ok x f r)"], ["proof (state)\nthis:\n  status = App (Suc ok) (x # f) r\n\ngoal (7 subgoals):\n 1. \\<And>v xa f' r'.\n       \\<lbrakk>invar (enq x q); status = App (Suc v) (xa # f') r'\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 7. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = App (Suc ok) (x # f) r", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc ok) (x # f) r\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "proof(cases ok)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case 0"], ["proof (state)\nthis:\n  ok = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = App (Suc ok) (x # f) r; ok = 0\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  ok = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = 0\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  ok = 0\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding fields st invar_def rear_list_def"], ["proof (prove)\nusing this:\n  ok = 0\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n      rear = rear, lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev oka fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n         rear = rear, lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     oka \\<noteq> 0\n   | App oka fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n  lenf\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) =\n  length\n   (front_list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>) =\n  length\n   ((rev \\<circ> rear)\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr>)\n  \\<le> lenf\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (case status\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc ok) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) of\n   Rev oka fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      (enq x\n        \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n           rear = rear, lenr = lenr\\<rparr>)\n     \\<le> length f' \\<and>\n     oka \\<noteq> 0\n   | App oka fa ra \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = front,\n             status = App (Suc ok) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>))\n  \\<le> 2 *\n        length\n         (front\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = App (Suc ok) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>)) \\<and>\n  (\\<exists>rest.\n      front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>) =\n      front\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>) @\n      rest) \\<and>\n  (\\<forall>xaa.\n      status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc ok) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>) \\<noteq>\n      Done xaa) \\<and>\n  st_inv\n   (status\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>))\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n          rear = rear, lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = App (Suc ok) (x # f) r,\n        rear = rear, lenr = lenr\\<rparr> @\n    [x]", "by (simp add: check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case (Suc ok')"], ["proof (state)\nthis:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>status = App (Suc ok) (x # f) r; ok = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  ok = Suc ok'", "show ?thesis"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  ok = Suc ok'\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding fields st invar_def rear_list_def Suc"], ["proof (prove)\nusing this:\n  Suc ok' = Suc ok'\n  lenf\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   ((rev \\<circ> rear)\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front,\n      status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front,\n         status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n  lenf\n   (enq x\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) =\n  length\n   (front_list\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (enq x\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>) =\n  length\n   ((rev \\<circ> rear)\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>)) \\<and>\n  lenr\n   (enq x\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> lenf\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (case status\n         (enq x\n           \\<lparr>lenf = lenf, front = front,\n              status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n              lenr = lenr\\<rparr>) of\n   Rev ok fa f' ra r' \\<Rightarrow>\n     2 *\n     lenr\n      (enq x\n        \\<lparr>lenf = lenf, front = front,\n           status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n           lenr = lenr\\<rparr>)\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok fa ra \\<Rightarrow>\n       2 *\n       lenr\n        (enq x\n          \\<lparr>lenf = lenf, front = front,\n             status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n             lenr = lenr\\<rparr>)\n       \\<le> length ra\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>))\n  \\<le> 2 *\n        length\n         (front\n           (enq x\n             \\<lparr>lenf = lenf, front = front,\n                status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n                lenr = lenr\\<rparr>)) \\<and>\n  (\\<exists>rest.\n      front_list\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>) =\n      front\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>) @\n      rest) \\<and>\n  (\\<forall>xaa.\n      status\n       (enq x\n         \\<lparr>lenf = lenf, front = front,\n            status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n            lenr = lenr\\<rparr>) \\<noteq>\n      Done xaa) \\<and>\n  st_inv\n   (status\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>))\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front,\n        status = App (Suc (Suc ok')) (x # f) r, rear = rear,\n        lenr = lenr\\<rparr> @\n    [x]", "by (cases f; cases ok'; auto simp add: rear_list_def check_def min_absorb2 tl_rev_take_Suc)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (6 subgoals):\n 1. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: \"5_1\""], ["proof (state)\nthis:\n  status = Idle\n\ngoal (6 subgoals):\n 1. \\<lbrakk>invar (enq x q); status = Idle\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 6. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = Idle", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Idle\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "proof (cases \"lenr + 1 \\<le> lenf\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]", "case True"], ["proof (state)\nthis:\n  lenr + 1 \\<le> lenf\n\ngoal (2 subgoals):\n 1. \\<lbrakk>status = Idle; lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  lenr + 1 \\<le> lenf", "show ?thesis"], ["proof (prove)\nusing this:\n  lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq Nil_is_rev_conv append_Nil diff_is_0_eq diff_zero length_0_conv"], ["proof (prove)\nusing this:\n  lenr + 1 \\<le> lenf\n  invar q\n  invar (enq x q)\n  ([] = rev ?xs) = (?xs = [])\n  [] @ ?ys = ?ys\n  (?m - ?n = 0) = (?m \\<le> ?n)\n  ?a - (0::?'a) = ?a\n  (length ?xs = 0) = (?xs = [])\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  lenr + 1 \\<le> lenf\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  ([] = rev ?xs) = (?xs = [])\n  [] @ ?ys = ?ys\n  (?m - ?n = 0) = (?m \\<le> ?n)\n  ?a - (0::?'a) = ?a\n  (length ?xs = 0) = (?xs = [])\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr> @\n    [x]", "by (simp add: check_def rear_list_def invar_def; metis  list.sel(2) tl_append2)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]", "case overflows: False"], ["proof (state)\nthis:\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  \\<not> lenr + 1 \\<le> lenf", "have f_eq_r: \"length front = length rear\""], ["proof (prove)\nusing this:\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. length front = length rear", "using inv"], ["proof (prove)\nusing this:\n  \\<not> lenr + 1 \\<le> lenf\n  invar q\n\ngoal (1 subgoal):\n 1. length front = length rear", "unfolding st fields"], ["proof (prove)\nusing this:\n  \\<not> lenr + 1 \\<le> lenf\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n\ngoal (1 subgoal):\n 1. length front = length rear", "by (simp add: le_antisym rear_list_def invar_def)"], ["proof (state)\nthis:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. \\<lbrakk>status = Idle; \\<not> lenr + 1 \\<le> lenf\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  length front = length rear", "show ?thesis"], ["proof (prove)\nusing this:\n  length front = length rear\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "proof (cases front)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case Nil"], ["proof (state)\nthis:\n  front = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length front = length rear; front = []\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv overflows inv_deq"], ["proof (prove)\nusing this:\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields Nil"], ["proof (prove)\nusing this:\n  invar\n   \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<not> lenr + 1 \\<le> lenf\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = [], status = Idle, rear = rear,\n        lenr = lenr\\<rparr> @\n    [x]", "by (cases rear; auto simp add: rear_list_def check_def Let_def invar_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case C_a : (Cons a as)"], ["proof (state)\nthis:\n  front = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  front = a # as", "obtain x xs where \"rear = x # xs\""], ["proof (prove)\nusing this:\n  front = a # as\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inv overflows"], ["proof (prove)\nusing this:\n  front = a # as\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding st fields Cons invar_def"], ["proof (prove)\nusing this:\n  front = a # as\n  lenf\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n            lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n           lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n              lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n          lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = front, status = Idle, rear = rear,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. rear = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis f_eq_r length_Suc_conv C_a)"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "hence rear_x: \"rear = x # xs\""], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. rear = x # xs", "by simp"], ["proof (state)\nthis:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>length front = length rear; front = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  rear = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  rear = x # xs\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rear = x # xs; as = []\\<rbrakk>\n    \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv overflows"], ["proof (prove)\nusing this:\n  as = []\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields Nil rear_x C_a"], ["proof (prove)\nusing this:\n  [] = []\n  invar\n   \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = [a], status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr> @\n    [x]", "by (cases xs; simp add: invar_def check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case (Cons b bs)"], ["proof (state)\nthis:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>rear = x # xs; as = a # lista\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  as = b # bs", "show ?thesis"], ["proof (prove)\nusing this:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv overflows"], ["proof (prove)\nusing this:\n  as = b # bs\n  invar q\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields Cons rear_x C_a invar_def"], ["proof (prove)\nusing this:\n  b # bs = b # bs\n  lenf\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (front_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr> =\n  length\n   (rear_list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>) \\<and>\n  lenr\n   \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n      lenr = lenr\\<rparr>\n  \\<le> lenf\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> \\<and>\n  (case status\n         \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n            rear = x # xs, lenr = lenr\\<rparr> of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 *\n     lenr\n      \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n         lenr = lenr\\<rparr>\n     \\<le> length f' \\<and>\n     ok \\<noteq> 0\n   | App ok f r \\<Rightarrow>\n       2 *\n       lenr\n        \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n           rear = x # xs, lenr = lenr\\<rparr>\n       \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<le> 2 *\n        length\n         (front\n           \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n              rear = x # xs, lenr = lenr\\<rparr>) \\<and>\n  (\\<exists>rest.\n      front_list\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> =\n      front\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> @\n      rest) \\<and>\n  (\\<forall>x.\n      status\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr> \\<noteq>\n      Done x) \\<and>\n  st_inv\n   (status\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr>)\n  \\<not> lenr + 1 \\<le> lenf\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = a # b # bs, status = Idle,\n          rear = x # xs, lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = a # b # bs, status = Idle, rear = x # xs,\n        lenr = lenr\\<rparr> @\n    [x]", "by (cases xs; cases bs; simp add: check_def Let_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: \"5_2\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (5 subgoals):\n 1. \\<And>v vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v [] vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 5. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ [] vd_\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ [] vd_ = Rev v_ [] vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n        rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n          rear = rear, lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = Rev v_ [] vb_ [] vd_,\n        rear = rear, lenr = lenr\\<rparr> @\n    [x]", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: \"5_3\""], ["proof (state)\nthis:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (4 subgoals):\n 1. \\<And>v vb va vf vg vd.\n       \\<lbrakk>invar (enq x q);\n        status = Rev v [] vb (va # vf # vg) vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 4. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev v_ [] vb_ (va_ # vf_ # vg_) vd_ = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_\n  invar\n   \\<lparr>lenf = lenf, front = front,\n      status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front,\n          status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front,\n        status = Rev v_ [] vb_ (va_ # vf_ # vg_) vd_, rear = rear,\n        lenr = lenr\\<rparr> @\n    [x]", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: \"5_4\""], ["proof (state)\nthis:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vd.\n       \\<lbrakk>invar (enq x q); status = Rev v va vb [] vd\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = Rev v_ va_ vb_ [] vd_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Rev v_ va_ vb_ [] vd_\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  Rev v_ va_ vb_ [] vd_ = Rev v_ va_ vb_ [] vd_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n      rear = rear, lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n        rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n          rear = rear, lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = Rev v_ va_ vb_ [] vd_,\n        rear = rear, lenr = lenr\\<rparr> @\n    [x]", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: \"5_5\""], ["proof (state)\nthis:\n  status = App (Suc vc_) [] vb_\n\ngoal (2 subgoals):\n 1. \\<And>vc vb.\n       \\<lbrakk>invar (enq x q); status = App (Suc vc) [] vb\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = App (Suc vc_) [] vb_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = App (Suc vc_) [] vb_\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  App (Suc vc_) [] vb_ = App (Suc vc_) [] vb_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n      rear = rear, lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n        rear = rear, lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n          rear = rear, lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = App (Suc vc_) [] vb_,\n        rear = rear, lenr = lenr\\<rparr> @\n    [x]", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "case st: \"5_6\""], ["proof (state)\nthis:\n  status = Done v_\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>invar (enq x q); status = Done v\\<rbrakk>\n       \\<Longrightarrow> list (enq x q) = list q @ [x]", "then"], ["proof (chain)\npicking this:\n  status = Done v_", "show ?thesis"], ["proof (prove)\nusing this:\n  status = Done v_\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "using inv inv_deq"], ["proof (prove)\nusing this:\n  status = Done v_\n  invar q\n  invar (enq x q)\n\ngoal (1 subgoal):\n 1. list (enq x q) = list q @ [x]", "unfolding st fields"], ["proof (prove)\nusing this:\n  Done v_ = Done v_\n  invar\n   \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n      lenr = lenr\\<rparr>\n  invar\n   (enq x\n     \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n        lenr = lenr\\<rparr>)\n\ngoal (1 subgoal):\n 1. list\n     (enq x\n       \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n          lenr = lenr\\<rparr>) =\n    list\n     \\<lparr>lenf = lenf, front = front, status = Done v_, rear = rear,\n        lenr = lenr\\<rparr> @\n    [x]", "by (simp add: invar_def check_def rear_list_def)"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list (enq x q) = list q @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Constructive approach *)"], ["", "datatype 'a action = Deq | Enq 'a"], ["", "type_synonym 'a actions = \"'a action list\""], ["", "(* Perform a given action on the queue *)"], ["", "fun do_act :: \"'a action \\<Rightarrow> 'a queue \\<Rightarrow> 'a queue\" where\n  \"do_act Deq q     = deq q\"\n| \"do_act (Enq x) q = enq x q\""], ["", "(* Create a queue from a list of actions *)"], ["", "definition qfa :: \"'a actions \\<Rightarrow> 'a queue\" where\n  \"qfa = (\\<lambda>acts. foldr do_act acts empty)\""], ["", "(* Any queue created from list of actions satisfies the invariants *)"], ["", "lemma invar_qfa : \"invar (qfa l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (qfa l)", "proof(induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. invar (qfa [])\n 2. \\<And>a l. invar (qfa l) \\<Longrightarrow> invar (qfa (a # l))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. invar (qfa [])\n 2. \\<And>a l. invar (qfa l) \\<Longrightarrow> invar (qfa (a # l))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (qfa [])", "by (simp add: qfa_def invar_empty)"], ["proof (state)\nthis:\n  invar (qfa [])\n\ngoal (1 subgoal):\n 1. \\<And>a l. invar (qfa l) \\<Longrightarrow> invar (qfa (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l. invar (qfa l) \\<Longrightarrow> invar (qfa (a # l))", "case (Cons x xs)"], ["proof (state)\nthis:\n  invar (qfa xs)\n\ngoal (1 subgoal):\n 1. \\<And>a l. invar (qfa l) \\<Longrightarrow> invar (qfa (a # l))", "have qfa_cons: \"qfa (x#xs) = do_act x (qfa xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qfa (x # xs) = do_act x (qfa xs)", "by (simp add: qfa_def)"], ["proof (state)\nthis:\n  qfa (x # xs) = do_act x (qfa xs)\n\ngoal (1 subgoal):\n 1. \\<And>a l. invar (qfa l) \\<Longrightarrow> invar (qfa (a # l))", "then"], ["proof (chain)\npicking this:\n  qfa (x # xs) = do_act x (qfa xs)", "show ?case"], ["proof (prove)\nusing this:\n  qfa (x # xs) = do_act x (qfa xs)\n\ngoal (1 subgoal):\n 1. invar (qfa (x # xs))", "proof(cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>qfa (x # xs) = do_act x (qfa xs); x = Deq\\<rbrakk>\n    \\<Longrightarrow> invar (qfa (x # xs))\n 2. \\<And>x2.\n       \\<lbrakk>qfa (x # xs) = do_act x (qfa xs); x = Enq x2\\<rbrakk>\n       \\<Longrightarrow> invar (qfa (x # xs))", "case Deq"], ["proof (state)\nthis:\n  x = Deq\n\ngoal (2 subgoals):\n 1. \\<lbrakk>qfa (x # xs) = do_act x (qfa xs); x = Deq\\<rbrakk>\n    \\<Longrightarrow> invar (qfa (x # xs))\n 2. \\<And>x2.\n       \\<lbrakk>qfa (x # xs) = do_act x (qfa xs); x = Enq x2\\<rbrakk>\n       \\<Longrightarrow> invar (qfa (x # xs))", "then"], ["proof (chain)\npicking this:\n  x = Deq", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Deq\n\ngoal (1 subgoal):\n 1. invar (qfa (x # xs))", "using invar_deq[of \"qfa xs\"]"], ["proof (prove)\nusing this:\n  x = Deq\n  invar (qfa xs) \\<Longrightarrow> invar (deq (qfa xs))\n\ngoal (1 subgoal):\n 1. invar (qfa (x # xs))", "unfolding qfa_cons"], ["proof (prove)\nusing this:\n  x = Deq\n  invar (qfa xs) \\<Longrightarrow> invar (deq (qfa xs))\n\ngoal (1 subgoal):\n 1. invar (do_act x (qfa xs))", "by (simp add: Cons)"], ["proof (state)\nthis:\n  invar (qfa (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>qfa (x # xs) = do_act x (qfa xs); x = Enq x2\\<rbrakk>\n       \\<Longrightarrow> invar (qfa (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>qfa (x # xs) = do_act x (qfa xs); x = Enq x2\\<rbrakk>\n       \\<Longrightarrow> invar (qfa (x # xs))", "case (Enq a)"], ["proof (state)\nthis:\n  x = Enq a\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>qfa (x # xs) = do_act x (qfa xs); x = Enq x2\\<rbrakk>\n       \\<Longrightarrow> invar (qfa (x # xs))", "then"], ["proof (chain)\npicking this:\n  x = Enq a", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Enq a\n\ngoal (1 subgoal):\n 1. invar (qfa (x # xs))", "using invar_enq[of \"qfa xs\"]"], ["proof (prove)\nusing this:\n  x = Enq a\n  invar (qfa xs) \\<Longrightarrow> invar (enq ?x (qfa xs))\n\ngoal (1 subgoal):\n 1. invar (qfa (x # xs))", "unfolding qfa_cons"], ["proof (prove)\nusing this:\n  x = Enq a\n  invar (qfa xs) \\<Longrightarrow> invar (enq ?x (qfa xs))\n\ngoal (1 subgoal):\n 1. invar (do_act x (qfa xs))", "by (simp add: Cons)"], ["proof (state)\nthis:\n  invar (qfa (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (qfa (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Correctness proof *)"], ["", "lemma qfa_deq_correct: \"list (deq (qfa l)) = tl (list (qfa l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list (deq (qfa l)) = tl (list (qfa l))", "using invar_qfa queue_correct_deq"], ["proof (prove)\nusing this:\n  invar (qfa ?l)\n  invar ?q \\<Longrightarrow> list (deq ?q) = tl (list ?q)\n\ngoal (1 subgoal):\n 1. list (deq (qfa l)) = tl (list (qfa l))", "by blast"], ["", "lemma qfa_enq_correct: \"list (enq x (qfa l)) = (list (qfa l)) @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list (enq x (qfa l)) = list (qfa l) @ [x]", "by (meson invar_qfa queue_correct_enq)"], ["", "fun rev_steps :: \"('a list \\<times> 'a list) \\<Rightarrow> ('a list \\<times> 'a list)\" where\n  \"rev_steps ((x#xs),ys) = (xs,x#ys)\"\n| \"rev_steps l = l\""], ["", "lemma first_correct :\n  assumes inv:      \"invar q\"\n  assumes not_nil : \"list q \\<noteq> []\"\n  shows             \"first q = hd (list q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first q = hd (list q)", "proof (cases \"front q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. front q = [] \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "obtain rest where front_l: \"front_list q = front q @ rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        front_list q = front q @ rest \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inv"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. (\\<And>rest.\n        front_list q = front q @ rest \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: invar_def simp del: front_list.simps)"], ["proof (state)\nthis:\n  front_list q = front q @ rest\n\ngoal (2 subgoals):\n 1. front q = [] \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "case front_nil: Nil"], ["proof (state)\nthis:\n  front q = []\n\ngoal (2 subgoals):\n 1. front q = [] \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "have rear_nil: \"rear_list q = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rear_list q = []", "using inv"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. rear_list q = []", "unfolding invar_def rear_list_def front_nil"], ["proof (prove)\nusing this:\n  lenf q = length (front_list q) \\<and>\n  lenr q = length ((rev \\<circ> rear) q) \\<and>\n  lenr q \\<le> lenf q \\<and>\n  (case status q of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 * lenr q \\<le> length f' \\<and> ok \\<noteq> 0\n   | App ok f r \\<Rightarrow> 2 * lenr q \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps (status q) \\<le> 2 * length [] \\<and>\n  (\\<exists>rest. front_list q = [] @ rest) \\<and>\n  (\\<forall>x. status q \\<noteq> Done x) \\<and> st_inv (status q)\n\ngoal (1 subgoal):\n 1. (rev \\<circ> rear) q = []", "by (simp; cases \"status q\"; simp add: front_nil)"], ["proof (state)\nthis:\n  rear_list q = []\n\ngoal (2 subgoals):\n 1. front q = [] \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "have front_nil: \"front_list q = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. front_list q = []", "using inv"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. front_list q = []", "unfolding invar_def rear_list_def front_nil"], ["proof (prove)\nusing this:\n  lenf q = length (front_list q) \\<and>\n  lenr q = length ((rev \\<circ> rear) q) \\<and>\n  lenr q \\<le> lenf q \\<and>\n  (case status q of\n   Rev ok f f' r r' \\<Rightarrow>\n     2 * lenr q \\<le> length f' \\<and> ok \\<noteq> 0\n   | App ok f r \\<Rightarrow> 2 * lenr q \\<le> length r\n   | _ \\<Rightarrow> True) \\<and>\n  rem_steps (status q) \\<le> 2 * length [] \\<and>\n  (\\<exists>rest. front_list q = [] @ rest) \\<and>\n  (\\<forall>x. status q \\<noteq> Done x) \\<and> st_inv (status q)\n\ngoal (1 subgoal):\n 1. front_list q = []", "by (simp; cases \"status q\"; simp add: front_nil)"], ["proof (state)\nthis:\n  front_list q = []\n\ngoal (2 subgoals):\n 1. front q = [] \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. first q = hd (list q)", "using not_nil"], ["proof (prove)\nusing this:\n  list q \\<noteq> []\n\ngoal (1 subgoal):\n 1. first q = hd (list q)", "unfolding  list.simps rear_nil front_nil"], ["proof (prove)\nusing this:\n  [] @ [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. first q = hd ([] @ [])", "by simp"], ["proof (state)\nthis:\n  first q = hd (list q)\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "case front_cons: (Cons x xs)"], ["proof (state)\nthis:\n  front q = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       front q = a # lista \\<Longrightarrow> first q = hd (list q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. first q = hd (list q)", "using inv"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. first q = hd (list q)", "unfolding list.simps first.simps front_cons front_list.simps"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. hd (x # xs) =\n    hd ((case status q of Idle \\<Rightarrow> x # xs\n         | Rev ok f f' r r' \\<Rightarrow> rev (take ok f') @ f @ rev r @ r'\n         | App ok f' x \\<Rightarrow> rev (take ok f') @ x\n         | Done f \\<Rightarrow> f) @\n        rear_list q)", "apply (simp add: invar_def rear_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lenf q =\n    length\n     (case status q of Idle \\<Rightarrow> front q\n      | Rev ok f f' r r' \\<Rightarrow> rev (take ok f') @ f @ rev r @ r'\n      | App ok f' x \\<Rightarrow> rev (take ok f') @ x\n      | Done f \\<Rightarrow> f) \\<and>\n    lenr q = length (rear q) \\<and>\n    lenr q \\<le> lenf q \\<and>\n    (case status q of\n     Rev ok f f' r r' \\<Rightarrow>\n       2 * lenr q \\<le> length f' \\<and> ok \\<noteq> 0\n     | App ok f r \\<Rightarrow> 2 * lenr q \\<le> length r\n     | _ \\<Rightarrow> True) \\<and>\n    rem_steps (status q) \\<le> 2 * length (front q) \\<and>\n    (\\<exists>rest.\n        (case status q of Idle \\<Rightarrow> front q\n         | Rev ok f f' r r' \\<Rightarrow> rev (take ok f') @ f @ rev r @ r'\n         | App ok f' x \\<Rightarrow> rev (take ok f') @ x\n         | Done f \\<Rightarrow> f) =\n        front q @ rest) \\<and>\n    (\\<forall>x. status q \\<noteq> Done x) \\<and>\n    st_inv (status q) \\<Longrightarrow>\n    x =\n    hd ((case status q of Idle \\<Rightarrow> x # xs\n         | Rev ok f f' r r' \\<Rightarrow> rev (take ok f') @ f @ rev r @ r'\n         | App ok f' x \\<Rightarrow> rev (take ok f') @ x\n         | Done f \\<Rightarrow> f) @\n        rev (rear q))", "by (metis append_Cons front_cons list.sel(1))"], ["proof (state)\nthis:\n  first q = hd (list q)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun is_empty :: \"'a queue \\<Rightarrow> bool\" where\n  \"is_empty q = (list q = [])\""], ["", "interpretation HMQ: Queue where\n  empty    = empty    and\n  enq      = enq      and\n  first    = first    and\n  deq      = deq      and\n  is_empty = is_empty and\n  list     = list  and\n  invar    = invar"], ["proof (prove)\ngoal (1 subgoal):\n 1. Queue Hood_Melville_Queue.empty enq first deq is_empty list invar", "proof (standard, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. list Hood_Melville_Queue.empty = []\n 2. \\<And>q x. invar q \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 5. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 6. invar Hood_Melville_Queue.empty\n 7. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 8. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. list Hood_Melville_Queue.empty = []\n 2. \\<And>q x. invar q \\<Longrightarrow> list (enq x q) = list q @ [x]\n 3. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 4. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 5. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 6. invar Hood_Melville_Queue.empty\n 7. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 8. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list Hood_Melville_Queue.empty = []", "by (simp add: empty_def make_def rear_list_def)"], ["proof (state)\nthis:\n  list Hood_Melville_Queue.empty = []\n\ngoal (7 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 4. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 5. invar Hood_Melville_Queue.empty\n 6. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 7. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 4. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 5. invar Hood_Melville_Queue.empty\n 6. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 7. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 2"], ["proof (state)\nthis:\n  invar q_\n\ngoal (7 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> list (enq x q) = list q @ [x]\n 2. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 3. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 4. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 5. invar Hood_Melville_Queue.empty\n 6. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 7. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n\ngoal (1 subgoal):\n 1. list (enq x_ q_) = list q_ @ [x_]", "using queue_correct_enq"], ["proof (prove)\nusing this:\n  invar q_\n  invar ?q \\<Longrightarrow> list (enq ?x ?q) = list ?q @ [?x]\n\ngoal (1 subgoal):\n 1. list (enq x_ q_) = list q_ @ [x_]", "by simp"], ["proof (state)\nthis:\n  list (enq x_ q_) = list q_ @ [x_]\n\ngoal (6 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 3. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 4. invar Hood_Melville_Queue.empty\n 5. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 6. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 3. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 4. invar Hood_Melville_Queue.empty\n 5. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 6. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 3"], ["proof (state)\nthis:\n  invar q_\n\ngoal (6 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> list (deq q) = tl (list q)\n 2. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 3. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 4. invar Hood_Melville_Queue.empty\n 5. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 6. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n\ngoal (1 subgoal):\n 1. list (deq q_) = tl (list q_)", "using queue_correct_deq"], ["proof (prove)\nusing this:\n  invar q_\n  invar ?q \\<Longrightarrow> list (deq ?q) = tl (list ?q)\n\ngoal (1 subgoal):\n 1. list (deq q_) = tl (list q_)", "by simp"], ["proof (state)\nthis:\n  list (deq q_) = tl (list q_)\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 3. invar Hood_Melville_Queue.empty\n 4. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 5. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 3. invar Hood_Melville_Queue.empty\n 4. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 5. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 4"], ["proof (state)\nthis:\n  invar q_\n  list q_ \\<noteq> []\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; list q \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> first q = hd (list q)\n 2. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 3. invar Hood_Melville_Queue.empty\n 4. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 5. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n  list q_ \\<noteq> []\n\ngoal (1 subgoal):\n 1. first q_ = hd (list q_)", "using first_correct"], ["proof (prove)\nusing this:\n  invar q_\n  list q_ \\<noteq> []\n  \\<lbrakk>invar ?q; list ?q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> first ?q = hd (list ?q)\n\ngoal (1 subgoal):\n 1. first q_ = hd (list q_)", "by simp"], ["proof (state)\nthis:\n  first q_ = hd (list q_)\n\ngoal (4 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 2. invar Hood_Melville_Queue.empty\n 3. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 4. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 2. invar Hood_Melville_Queue.empty\n 3. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 4. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 5"], ["proof (state)\nthis:\n  invar q_\n\ngoal (4 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> is_empty q = (list q = [])\n 2. invar Hood_Melville_Queue.empty\n 3. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 4. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n\ngoal (1 subgoal):\n 1. is_empty q_ = (list q_ = [])", "by simp"], ["proof (state)\nthis:\n  is_empty q_ = (list q_ = [])\n\ngoal (3 subgoals):\n 1. invar Hood_Melville_Queue.empty\n 2. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 3. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. invar Hood_Melville_Queue.empty\n 2. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 3. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. invar Hood_Melville_Queue.empty\n 2. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 3. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar Hood_Melville_Queue.empty", "by (simp add: empty_def invar_def make_def rear_list_def)"], ["proof (state)\nthis:\n  invar Hood_Melville_Queue.empty\n\ngoal (2 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 2. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 2. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 7"], ["proof (state)\nthis:\n  invar q_\n\ngoal (2 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> invar (enq x q)\n 2. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n\ngoal (1 subgoal):\n 1. invar (enq x_ q_)", "using invar_enq"], ["proof (prove)\nusing this:\n  invar q_\n  invar ?q \\<Longrightarrow> invar (enq ?x ?q)\n\ngoal (1 subgoal):\n 1. invar (enq x_ q_)", "by simp"], ["proof (state)\nthis:\n  invar (enq x_ q_)\n\ngoal (1 subgoal):\n 1. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "case 8"], ["proof (state)\nthis:\n  invar q_\n\ngoal (1 subgoal):\n 1. \\<And>q. invar q \\<Longrightarrow> invar (deq q)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n\ngoal (1 subgoal):\n 1. invar (deq q_)", "using invar_deq"], ["proof (prove)\nusing this:\n  invar q_\n  invar ?q \\<Longrightarrow> invar (deq ?q)\n\ngoal (1 subgoal):\n 1. invar (deq q_)", "by simp"], ["proof (state)\nthis:\n  invar (deq q_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}