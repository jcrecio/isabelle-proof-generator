{"file_name": "/home/qj213/afp-2021-10-22/thys/KD_Tree/Build.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KD_Tree", "problem_names": ["lemma length_filter_mset_sorted_nth:\n  assumes \"distinct xs\" \"n < length xs\" \"sorted xs\"\n  shows \"{# x \\<in># mset xs. x \\<le> xs ! n #} = mset (take (n + 1) xs)\"", "lemma length_filter_sort_nth:\n  assumes \"distinct xs\" \"n < length xs\"\n  shows \"length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1\"", "lemma calc_spread_spec:\n  \"calc_spread k ps = spread k (set ps)\"", "lemma widest_spread_calc_spread:\n  \"ks \\<noteq> [] \\<Longrightarrow> (k, s) = widest_spread ks ps \\<Longrightarrow> s = calc_spread k ps\"", "lemma widest_spread_axis_Un:\n  shows \"widest_spread_axis k K P \\<Longrightarrow> spread k' P \\<le> spread k P \\<Longrightarrow> widest_spread_axis k (K \\<union> { k' }) P\"\n    and \"widest_spread_axis k K P \\<Longrightarrow> spread k P \\<le> spread k' P \\<Longrightarrow> widest_spread_axis k' (K \\<union> { k' }) P\"", "lemma widest_spread_spec:\n  \"(k, s) = widest_spread ks ps \\<Longrightarrow> widest_spread_axis k (set ks) (set ps)\"", "lemma length_filter_le_axis_median:\n  assumes \"0 < length ps\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\"\n  shows \"length (filter (\\<lambda>p. p$k \\<le> axis_median k ps) ps) = (length ps - 1) div 2 + 1\"", "lemma set_partition_by_median:\n  \"(l, m, r) = partition_by_median k ps \\<Longrightarrow> set ps = set l \\<union> set r\"", "lemma filter_partition_by_median:\n  assumes \"(l, m, r) = partition_by_median k ps\"\n  shows \"\\<forall>p \\<in> set l. p$k \\<le> m\"\n    and \"\\<forall>p \\<in> set r. \\<not>p$k \\<le> m\"", "lemma sum_length_partition_by_median:\n  assumes \"(l, m, r) = partition_by_median k ps\"\n  shows \"length ps = length l + length r\"", "lemma length_l_partition_by_median:\n  assumes \"0 < length ps\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\" \"(l, m, r) = partition_by_median k ps\"\n  shows \"length l = (length ps - 1) div 2 + 1\"", "lemmas length_partition_by_median =\n  sum_length_partition_by_median length_l_partition_by_median\n  lengths_partition_by_median_1 lengths_partition_by_median_2", "lemma build_domintros3:\n  assumes \"(k, s) = widest_spread ks (x # y # zs)\" \"(l, m, r) = partition_by_median k (x # y # zs)\"\n  assumes \"build_dom (ks, l)\" \"build_dom (ks, r)\"\n  shows \"build_dom (ks, x # y # zs)\"", "lemma build_termination:\n  assumes \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\"\n  shows \"build_dom (ks, ps)\"", "lemma build_psimp_1:\n  \"ps = [p] \\<Longrightarrow> build k ps = Leaf p\"", "lemma build_psimp_2:\n  assumes \"(k, s) = widest_spread ks (x # y # zs)\" \"(l, m, r) = partition_by_median k (x # y # zs)\"\n  assumes \"build_dom (ks, l)\" \"build_dom (ks, r)\"\n  shows \"build ks (x # y # zs) = Node k m (build ks l) (build ks r)\"", "lemma length_xs_gt_1:\n  \"1 < length xs \\<Longrightarrow> \\<exists>x y ys. xs = x # y # ys\"", "lemma build_psimp_3:\n  assumes \"1 < length ps\" \"(k, s) = widest_spread ks ps\" \"(l, m, r) = partition_by_median k ps\"\n  assumes \"build_dom (ks, l)\" \"build_dom (ks, r)\"\n  shows \"build ks ps = Node k m (build ks l) (build ks r)\"", "lemmas build_psimps[simp] = build_psimp_1 build_psimp_3", "theorem set_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> set ps = set_kdt (build ks ps)\"", "theorem invar_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> set ks = UNIV \\<Longrightarrow> invar (build ks ps)\"", "theorem size_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> size_kdt (build ks ps) = length ps\"", "theorem balanced_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> balanced (build ks ps)\"", "lemma complete_if_balanced_size_2powh:\n  assumes \"balanced kdt\" \"size_kdt kdt = 2 ^ h\"\n  shows \"complete kdt\"", "theorem complete_build:\n  \"length ps = 2 ^ h \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> complete (build k ps)\""], "translations": [["", "lemma length_filter_mset_sorted_nth:\n  assumes \"distinct xs\" \"n < length xs\" \"sorted xs\"\n  shows \"{# x \\<in># mset xs. x \\<le> xs ! n #} = mset (take (n + 1) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<in># mset xs. x \\<le> xs ! n#} = mset (take (n + 1) xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  n < length xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. {#x \\<in># mset xs. x \\<le> xs ! n#} = mset (take (n + 1) xs)", "proof (induction xs arbitrary: n rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>distinct []; n < length []; sorted []\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset []. x \\<le> [] ! n#} =\n                         mset (take (n + 1) [])\n 2. \\<And>x1 x2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct x2; n < length x2; sorted x2\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset x2. x \\<le> x2 ! n#} =\n                                     mset (take (n + 1) x2);\n        distinct (x1 # x2); n < length (x1 # x2); sorted (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset (x1 # x2).\n                          x \\<le> (x1 # x2) ! n#} =\n                         mset (take (n + 1) (x1 # x2))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; ?n < length xs; sorted xs\\<rbrakk>\n  \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! ?n#} =\n                    mset (take (?n + 1) xs)\n  distinct (x # xs)\n  n < length (x # xs)\n  sorted (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>distinct []; n < length []; sorted []\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset []. x \\<le> [] ! n#} =\n                         mset (take (n + 1) [])\n 2. \\<And>x1 x2 n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct x2; n < length x2; sorted x2\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset x2. x \\<le> x2 ! n#} =\n                                     mset (take (n + 1) x2);\n        distinct (x1 # x2); n < length (x1 # x2); sorted (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset (x1 # x2).\n                          x \\<le> (x1 # x2) ! n#} =\n                         mset (take (n + 1) (x1 # x2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs; ?n < length xs; sorted xs\\<rbrakk>\n  \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! ?n#} =\n                    mset (take (?n + 1) xs)\n  distinct (x # xs)\n  n < length (x # xs)\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n    mset (take (n + 1) (x # xs))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>distinct xs; n < length xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! n#} =\n                                  mset (take (n + 1) xs);\n     distinct (x # xs); n < length (x # xs); sorted (x # xs); n = 0\\<rbrakk>\n    \\<Longrightarrow> {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n                      mset (take (n + 1) (x # xs))\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs; sorted xs\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! n#} =\n                                     mset (take (n + 1) xs);\n        distinct (x # xs); n < length (x # xs); sorted (x # xs);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> {#xa \\<in># mset (x # xs).\n                          xa \\<le> (x # xs) ! n#} =\n                         mset (take (n + 1) (x # xs))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>distinct xs; n < length xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! n#} =\n                                  mset (take (n + 1) xs);\n     distinct (x # xs); n < length (x # xs); sorted (x # xs); n = 0\\<rbrakk>\n    \\<Longrightarrow> {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n                      mset (take (n + 1) (x # xs))\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs; sorted xs\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! n#} =\n                                     mset (take (n + 1) xs);\n        distinct (x # xs); n < length (x # xs); sorted (x # xs);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> {#xa \\<in># mset (x # xs).\n                          xa \\<le> (x # xs) ! n#} =\n                         mset (take (n + 1) (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n    mset (take (n + 1) (x # xs))", "using Cons.prems(1,3) filter_mset_is_empty_iff"], ["proof (prove)\nusing this:\n  n = 0\n  distinct (x # xs)\n  sorted (x # xs)\n  (filter_mset ?P ?A = {#}) =\n  (\\<forall>x. x \\<in># ?A \\<longrightarrow> \\<not> ?P x)\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n    mset (take (n + 1) (x # xs))", "by fastforce"], ["proof (state)\nthis:\n  {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n  mset (take (n + 1) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs; sorted xs\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! n#} =\n                                     mset (take (n + 1) xs);\n        distinct (x # xs); n < length (x # xs); sorted (x # xs);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> {#xa \\<in># mset (x # xs).\n                          xa \\<le> (x # xs) ! n#} =\n                         mset (take (n + 1) (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs; sorted xs\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! n#} =\n                                     mset (take (n + 1) xs);\n        distinct (x # xs); n < length (x # xs); sorted (x # xs);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> {#xa \\<in># mset (x # xs).\n                          xa \\<le> (x # xs) ! n#} =\n                         mset (take (n + 1) (x # xs))", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs; sorted xs\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! n#} =\n                                     mset (take (n + 1) xs);\n        distinct (x # xs); n < length (x # xs); sorted (x # xs);\n        n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> {#xa \\<in># mset (x # xs).\n                          xa \\<le> (x # xs) ! n#} =\n                         mset (take (n + 1) (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n    mset (take (n + 1) (x # xs))", "using Cons"], ["proof (prove)\nusing this:\n  n = Suc n'\n  \\<lbrakk>distinct xs; ?n < length xs; sorted xs\\<rbrakk>\n  \\<Longrightarrow> {#x \\<in># mset xs. x \\<le> xs ! ?n#} =\n                    mset (take (?n + 1) xs)\n  distinct (x # xs)\n  n < length (x # xs)\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n    mset (take (n + 1) (x # xs))", "by simp"], ["proof (state)\nthis:\n  {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n  mset (take (n + 1) (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#xa \\<in># mset (x # xs). xa \\<le> (x # xs) ! n#} =\n  mset (take (n + 1) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>distinct []; n < length []; sorted []\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset []. x \\<le> [] ! n#} =\n                         mset (take (n + 1) [])", "qed auto"], ["", "lemma length_filter_sort_nth:\n  assumes \"distinct xs\" \"n < length xs\"\n  shows \"length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "have \"length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) =\n    length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))", "by (simp add: filter_sort)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) =\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) =\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "have \"... = size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)) =\n    size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)))", "using size_mset"], ["proof (prove)\nusing this:\n  size (mset ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)) =\n    size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)))", "by metis"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)) =\n  size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)) =\n  size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs)))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "have \"... = size ({# x \\<in># mset (sort xs). x \\<le> sort xs ! n #})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))) =\n    size {#x \\<in># mset (sort xs). x \\<le> sort xs ! n#}", "using mset_filter"], ["proof (prove)\nusing this:\n  mset (filter ?P ?xs) = filter_mset ?P (mset ?xs)\n\ngoal (1 subgoal):\n 1. size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))) =\n    size {#x \\<in># mset (sort xs). x \\<le> sort xs ! n#}", "by simp"], ["proof (state)\nthis:\n  size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))) =\n  size {#x \\<in># mset (sort xs). x \\<le> sort xs ! n#}\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "also"], ["proof (state)\nthis:\n  size (mset (filter (\\<lambda>x. x \\<le> sort xs ! n) (sort xs))) =\n  size {#x \\<in># mset (sort xs). x \\<le> sort xs ! n#}\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "have \"... = size (mset (take (n + 1) (sort xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#x \\<in># mset (sort xs). x \\<le> sort xs ! n#} =\n    size (mset (take (n + 1) (sort xs)))", "using length_filter_mset_sorted_nth assms sorted_sort distinct_sort length_sort"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?xs; ?n < length ?xs; sorted ?xs\\<rbrakk>\n  \\<Longrightarrow> {#x \\<in># mset ?xs. x \\<le> ?xs ! ?n#} =\n                    mset (take (?n + 1) ?xs)\n  distinct xs\n  n < length xs\n  sorted (sort ?xs)\n  distinct (sort_key ?f ?xs) = distinct ?xs\n  length (sort_key ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. size {#x \\<in># mset (sort xs). x \\<le> sort xs ! n#} =\n    size (mset (take (n + 1) (sort xs)))", "by metis"], ["proof (state)\nthis:\n  size {#x \\<in># mset (sort xs). x \\<le> sort xs ! n#} =\n  size (mset (take (n + 1) (sort xs)))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "finally"], ["proof (chain)\npicking this:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) =\n  size (mset (take (n + 1) (sort xs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) =\n  size (mset (take (n + 1) (sort xs)))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "using assms(2)"], ["proof (prove)\nusing this:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) =\n  size (mset (take (n + 1) (sort xs)))\n  n < length xs\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1", "by auto"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x. x \\<le> sort xs ! n) xs) = n + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Widest Spread Axis\\<close>"], ["", "definition calc_spread :: \"('k::finite) \\<Rightarrow> 'k point list \\<Rightarrow> real\" where\n  \"calc_spread k ps = (case ps of [] \\<Rightarrow> 0 | ps \\<Rightarrow>\n    let ks = map (\\<lambda>p. p$k) (tl ps) in\n    fold max ks ((hd ps)$k) - fold min ks ((hd ps)$k)\n  )\""], ["", "fun widest_spread :: \"('k::finite) list \\<Rightarrow> 'k point list \\<Rightarrow> 'k \\<times> real\" where\n  \"widest_spread [] _ = undefined\"\n| \"widest_spread [k] ps = (k, calc_spread k ps)\"\n| \"widest_spread (k # ks) ps = (\n    let (k', s') = widest_spread ks ps in\n    let s = calc_spread k ps in\n    if s \\<le> s' then (k', s') else (k, s)\n  )\""], ["", "lemma calc_spread_spec:\n  \"calc_spread k ps = spread k (set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. calc_spread k ps = spread k (set ps)", "using Max.set_eq_fold[of \"(hd ps)$k\"] Min.set_eq_fold[of \"(hd ps)$k\"]"], ["proof (prove)\nusing this:\n  Max (set (hd ps $ k # ?xs)) = fold max ?xs (hd ps $ k)\n  Min (set (hd ps $ k # ?xs)) = fold min ?xs (hd ps $ k)\n\ngoal (1 subgoal):\n 1. calc_spread k ps = spread k (set ps)", "by (auto simp: Let_def spread_def calc_spread_def split: list.splits, metis set_map)"], ["", "lemma widest_spread_calc_spread:\n  \"ks \\<noteq> [] \\<Longrightarrow> (k, s) = widest_spread ks ps \\<Longrightarrow> s = calc_spread k ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ks \\<noteq> []; (k, s) = widest_spread ks ps\\<rbrakk>\n    \\<Longrightarrow> s = calc_spread k ps", "by (induction ks ps rule: widest_spread.induct) (auto simp: Let_def split: prod.splits if_splits)"], ["", "lemma widest_spread_axis_Un:\n  shows \"widest_spread_axis k K P \\<Longrightarrow> spread k' P \\<le> spread k P \\<Longrightarrow> widest_spread_axis k (K \\<union> { k' }) P\"\n    and \"widest_spread_axis k K P \\<Longrightarrow> spread k P \\<le> spread k' P \\<Longrightarrow> widest_spread_axis k' (K \\<union> { k' }) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>widest_spread_axis k K P;\n      spread k' P \\<le> spread k P\\<rbrakk>\n     \\<Longrightarrow> widest_spread_axis k (K \\<union> {k'}) P) &&&\n    (\\<lbrakk>widest_spread_axis k K P;\n      spread k P \\<le> spread k' P\\<rbrakk>\n     \\<Longrightarrow> widest_spread_axis k' (K \\<union> {k'}) P)", "unfolding widest_spread_axis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>k'\\<in>K. spread k' P \\<le> spread k P;\n      spread k' P \\<le> spread k P\\<rbrakk>\n     \\<Longrightarrow> \\<forall>k'\\<in>K \\<union> {k'}.\n                          spread k' P \\<le> spread k P) &&&\n    (\\<lbrakk>\\<forall>k'\\<in>K. spread k' P \\<le> spread k P;\n      spread k P \\<le> spread k' P\\<rbrakk>\n     \\<Longrightarrow> \\<forall>k'a\\<in>K \\<union> {k'}.\n                          spread k'a P \\<le> spread k' P)", "by auto"], ["", "lemma widest_spread_spec:\n  \"(k, s) = widest_spread ks ps \\<Longrightarrow> widest_spread_axis k (set ks) (set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, s) = widest_spread ks ps \\<Longrightarrow>\n    widest_spread_axis k (set ks) (set ps)", "proof (induction ks ps arbitrary: k s rule: widest_spread.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)\n 3. \\<And>k v va ps ka s.\n       \\<lbrakk>\\<And>k s.\n                   (k, s) = widest_spread (v # va) ps \\<Longrightarrow>\n                   widest_spread_axis k (set (v # va)) (set ps);\n        (ka, s) = widest_spread (k # v # va) ps\\<rbrakk>\n       \\<Longrightarrow> widest_spread_axis ka (set (k # v # va)) (set ps)", "case (3 k\\<^sub>0 k\\<^sub>1 ks ps)"], ["proof (state)\nthis:\n  (?k, ?s) = widest_spread (k\\<^sub>1 # ks) ps \\<Longrightarrow>\n  widest_spread_axis ?k (set (k\\<^sub>1 # ks)) (set ps)\n  (k, s) = widest_spread (k\\<^sub>0 # k\\<^sub>1 # ks) ps\n\ngoal (3 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)\n 3. \\<And>k v va ps ka s.\n       \\<lbrakk>\\<And>k s.\n                   (k, s) = widest_spread (v # va) ps \\<Longrightarrow>\n                   widest_spread_axis k (set (v # va)) (set ps);\n        (ka, s) = widest_spread (k # v # va) ps\\<rbrakk>\n       \\<Longrightarrow> widest_spread_axis ka (set (k # v # va)) (set ps)", "obtain K' S' where K'_def: \"(K', S') = widest_spread (k\\<^sub>1 # ks) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K' S'.\n        (K', S') = widest_spread (k\\<^sub>1 # ks) ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (K', S') = widest_spread (k\\<^sub>1 # ks) ps\n\ngoal (3 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)\n 3. \\<And>k v va ps ka s.\n       \\<lbrakk>\\<And>k s.\n                   (k, s) = widest_spread (v # va) ps \\<Longrightarrow>\n                   widest_spread_axis k (set (v # va)) (set ps);\n        (ka, s) = widest_spread (k # v # va) ps\\<rbrakk>\n       \\<Longrightarrow> widest_spread_axis ka (set (k # v # va)) (set ps)", "hence IH: \"widest_spread_axis K' (set (k\\<^sub>1 # ks)) (set ps)\""], ["proof (prove)\nusing this:\n  (K', S') = widest_spread (k\\<^sub>1 # ks) ps\n\ngoal (1 subgoal):\n 1. widest_spread_axis K' (set (k\\<^sub>1 # ks)) (set ps)", "using \"3.IH\""], ["proof (prove)\nusing this:\n  (K', S') = widest_spread (k\\<^sub>1 # ks) ps\n  (?k, ?s) = widest_spread (k\\<^sub>1 # ks) ps \\<Longrightarrow>\n  widest_spread_axis ?k (set (k\\<^sub>1 # ks)) (set ps)\n\ngoal (1 subgoal):\n 1. widest_spread_axis K' (set (k\\<^sub>1 # ks)) (set ps)", "by blast"], ["proof (state)\nthis:\n  widest_spread_axis K' (set (k\\<^sub>1 # ks)) (set ps)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)\n 3. \\<And>k v va ps ka s.\n       \\<lbrakk>\\<And>k s.\n                   (k, s) = widest_spread (v # va) ps \\<Longrightarrow>\n                   widest_spread_axis k (set (v # va)) (set ps);\n        (ka, s) = widest_spread (k # v # va) ps\\<rbrakk>\n       \\<Longrightarrow> widest_spread_axis ka (set (k # v # va)) (set ps)", "hence 0: \"S' = spread K' (set ps)\""], ["proof (prove)\nusing this:\n  widest_spread_axis K' (set (k\\<^sub>1 # ks)) (set ps)\n\ngoal (1 subgoal):\n 1. S' = spread K' (set ps)", "using K'_def widest_spread_calc_spread calc_spread_spec"], ["proof (prove)\nusing this:\n  widest_spread_axis K' (set (k\\<^sub>1 # ks)) (set ps)\n  (K', S') = widest_spread (k\\<^sub>1 # ks) ps\n  \\<lbrakk>?ks \\<noteq> []; (?k, ?s) = widest_spread ?ks ?ps\\<rbrakk>\n  \\<Longrightarrow> ?s = calc_spread ?k ?ps\n  calc_spread ?k ?ps = spread ?k (set ?ps)\n\ngoal (1 subgoal):\n 1. S' = spread K' (set ps)", "by blast"], ["proof (state)\nthis:\n  S' = spread K' (set ps)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)\n 3. \\<And>k v va ps ka s.\n       \\<lbrakk>\\<And>k s.\n                   (k, s) = widest_spread (v # va) ps \\<Longrightarrow>\n                   widest_spread_axis k (set (v # va)) (set ps);\n        (ka, s) = widest_spread (k # v # va) ps\\<rbrakk>\n       \\<Longrightarrow> widest_spread_axis ka (set (k # v # va)) (set ps)", "define S where \"S = calc_spread k\\<^sub>0 ps\""], ["proof (state)\nthis:\n  S = calc_spread k\\<^sub>0 ps\n\ngoal (3 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)\n 3. \\<And>k v va ps ka s.\n       \\<lbrakk>\\<And>k s.\n                   (k, s) = widest_spread (v # va) ps \\<Longrightarrow>\n                   widest_spread_axis k (set (v # va)) (set ps);\n        (ka, s) = widest_spread (k # v # va) ps\\<rbrakk>\n       \\<Longrightarrow> widest_spread_axis ka (set (k # v # va)) (set ps)", "hence 1: \"S = spread k\\<^sub>0 (set ps)\""], ["proof (prove)\nusing this:\n  S = calc_spread k\\<^sub>0 ps\n\ngoal (1 subgoal):\n 1. S = spread k\\<^sub>0 (set ps)", "using calc_spread_spec"], ["proof (prove)\nusing this:\n  S = calc_spread k\\<^sub>0 ps\n  calc_spread ?k ?ps = spread ?k (set ?ps)\n\ngoal (1 subgoal):\n 1. S = spread k\\<^sub>0 (set ps)", "by blast"], ["proof (state)\nthis:\n  S = spread k\\<^sub>0 (set ps)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)\n 3. \\<And>k v va ps ka s.\n       \\<lbrakk>\\<And>k s.\n                   (k, s) = widest_spread (v # va) ps \\<Longrightarrow>\n                   widest_spread_axis k (set (v # va)) (set ps);\n        (ka, s) = widest_spread (k # v # va) ps\\<rbrakk>\n       \\<Longrightarrow> widest_spread_axis ka (set (k # v # va)) (set ps)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "proof (cases \"S \\<le> S'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n 2. \\<not> S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "case True"], ["proof (state)\nthis:\n  S \\<le> S'\n\ngoal (2 subgoals):\n 1. S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n 2. \\<not> S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "hence \"widest_spread_axis K' (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\""], ["proof (prove)\nusing this:\n  S \\<le> S'\n\ngoal (1 subgoal):\n 1. widest_spread_axis K' (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "using 0 1 widest_spread_axis_Un(1)[OF IH, of k\\<^sub>0]"], ["proof (prove)\nusing this:\n  S \\<le> S'\n  S' = spread K' (set ps)\n  S = spread k\\<^sub>0 (set ps)\n  spread k\\<^sub>0 (set ps) \\<le> spread K' (set ps) \\<Longrightarrow>\n  widest_spread_axis K' (set (k\\<^sub>1 # ks) \\<union> {k\\<^sub>0}) (set ps)\n\ngoal (1 subgoal):\n 1. widest_spread_axis K' (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "by auto"], ["proof (state)\nthis:\n  widest_spread_axis K' (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n\ngoal (2 subgoals):\n 1. S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n 2. \\<not> S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  widest_spread_axis K' (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n\ngoal (1 subgoal):\n 1. widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "using True K'_def S_def \"3.prems\""], ["proof (prove)\nusing this:\n  widest_spread_axis K' (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n  S \\<le> S'\n  (K', S') = widest_spread (k\\<^sub>1 # ks) ps\n  S = calc_spread k\\<^sub>0 ps\n  (k, s) = widest_spread (k\\<^sub>0 # k\\<^sub>1 # ks) ps\n\ngoal (1 subgoal):\n 1. widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n\ngoal (1 subgoal):\n 1. \\<not> S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "case False"], ["proof (state)\nthis:\n  \\<not> S \\<le> S'\n\ngoal (1 subgoal):\n 1. \\<not> S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "hence \"widest_spread_axis k\\<^sub>0 (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\""], ["proof (prove)\nusing this:\n  \\<not> S \\<le> S'\n\ngoal (1 subgoal):\n 1. widest_spread_axis k\\<^sub>0 (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "using 0 1 widest_spread_axis_Un(2)[OF IH, of k\\<^sub>0] \"3.prems\"(1)"], ["proof (prove)\nusing this:\n  \\<not> S \\<le> S'\n  S' = spread K' (set ps)\n  S = spread k\\<^sub>0 (set ps)\n  spread K' (set ps) \\<le> spread k\\<^sub>0 (set ps) \\<Longrightarrow>\n  widest_spread_axis k\\<^sub>0 (set (k\\<^sub>1 # ks) \\<union> {k\\<^sub>0})\n   (set ps)\n  (k, s) = widest_spread (k\\<^sub>0 # k\\<^sub>1 # ks) ps\n\ngoal (1 subgoal):\n 1. widest_spread_axis k\\<^sub>0 (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "by auto"], ["proof (state)\nthis:\n  widest_spread_axis k\\<^sub>0 (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n\ngoal (1 subgoal):\n 1. \\<not> S \\<le> S' \\<Longrightarrow>\n    widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  widest_spread_axis k\\<^sub>0 (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n\ngoal (1 subgoal):\n 1. widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "using False K'_def S_def \"3.prems\""], ["proof (prove)\nusing this:\n  widest_spread_axis k\\<^sub>0 (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n  \\<not> S \\<le> S'\n  (K', S') = widest_spread (k\\<^sub>1 # ks) ps\n  S = calc_spread k\\<^sub>0 ps\n  (k, s) = widest_spread (k\\<^sub>0 # k\\<^sub>1 # ks) ps\n\ngoal (1 subgoal):\n 1. widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  widest_spread_axis k (set (k\\<^sub>0 # k\\<^sub>1 # ks)) (set ps)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ k s.\n       (k, s) = widest_spread [] uu_ \\<Longrightarrow>\n       widest_spread_axis k (set []) (set uu_)\n 2. \\<And>k ps ka s.\n       (ka, s) = widest_spread [k] ps \\<Longrightarrow>\n       widest_spread_axis ka (set [k]) (set ps)", "qed (auto simp: widest_spread_axis_def)"], ["", "subsection \\<open>Fast Axis Median\\<close>"], ["", "definition axis_median :: \"('k::finite) \\<Rightarrow> 'k point list \\<Rightarrow> real\" where\n  \"axis_median k ps = (let n = (length ps - 1) div 2 in fast_select n (map (\\<lambda>p. p$k) ps))\""], ["", "lemma length_filter_le_axis_median:\n  assumes \"0 < length ps\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\"\n  shows \"length (filter (\\<lambda>p. p$k \\<le> axis_median k ps) ps) = (length ps - 1) div 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "let ?n = \"(length ps - 1) div 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "let ?ps = \"map (\\<lambda>p. p$k) ps\""], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "let ?m = \"fast_select ?n ?ps\""], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "have 0: \"?n < length ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length ps - 1) div 2 < length (map (\\<lambda>p. p $ k) ps)", "using assms(1)"], ["proof (prove)\nusing this:\n  0 < length ps\n\ngoal (1 subgoal):\n 1. (length ps - 1) div 2 < length (map (\\<lambda>p. p $ k) ps)", "by (auto, linarith)"], ["proof (state)\nthis:\n  (length ps - 1) div 2 < length (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "have 1: \"distinct ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>p. p $ k) ps)", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>p. p $ k) ps)", "by blast"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "have \"?m = select ?n ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps) =\n    select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps)", "using fast_select_correct[OF 0]"], ["proof (prove)\nusing this:\n  fast_select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps) =\n  select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. fast_select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps) =\n    select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps)", "by blast"], ["proof (state)\nthis:\n  fast_select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps) =\n  select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "hence \"length (filter (\\<lambda>p. p$k \\<le> axis_median k ps) ps) =\n        length (filter (\\<lambda>p. p$k \\<le> sort ?ps ! ?n) ps)\""], ["proof (prove)\nusing this:\n  fast_select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps) =\n  select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    length\n     (filter\n       (\\<lambda>p.\n           p $ k\n           \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                 ((length ps - 1) div 2))\n       ps)", "unfolding axis_median_def"], ["proof (prove)\nusing this:\n  fast_select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps) =\n  select ((length ps - 1) div 2) (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>p.\n           p $ k\n           \\<le> (let n = (length ps - 1) div 2\n                  in fast_select n (map (\\<lambda>p. p $ k) ps)))\n       ps) =\n    length\n     (filter\n       (\\<lambda>p.\n           p $ k\n           \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                 ((length ps - 1) div 2))\n       ps)", "by (auto simp add: Let_def select_def simp del: fast_select.simps)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n  length\n   (filter\n     (\\<lambda>p.\n         p $ k\n         \\<le> sort (map (\\<lambda>p. p $ k) ps) ! ((length ps - 1) div 2))\n     ps)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n  length\n   (filter\n     (\\<lambda>p.\n         p $ k\n         \\<le> sort (map (\\<lambda>p. p $ k) ps) ! ((length ps - 1) div 2))\n     ps)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "have \"... = length (filter (\\<lambda>v. v \\<le> sort ?ps ! ?n) ?ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>p.\n           p $ k\n           \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                 ((length ps - 1) div 2))\n       ps) =\n    length\n     (filter\n       (\\<lambda>v.\n           v \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                   ((length ps - 1) div 2))\n       (map (\\<lambda>p. p $ k) ps))", "by (induction ps) (auto, metis comp_apply)"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>p.\n         p $ k\n         \\<le> sort (map (\\<lambda>p. p $ k) ps) ! ((length ps - 1) div 2))\n     ps) =\n  length\n   (filter\n     (\\<lambda>v.\n         v \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                 ((length ps - 1) div 2))\n     (map (\\<lambda>p. p $ k) ps))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "also"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>p.\n         p $ k\n         \\<le> sort (map (\\<lambda>p. p $ k) ps) ! ((length ps - 1) div 2))\n     ps) =\n  length\n   (filter\n     (\\<lambda>v.\n         v \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                 ((length ps - 1) div 2))\n     (map (\\<lambda>p. p $ k) ps))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "have \"... = ?n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>v.\n           v \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                   ((length ps - 1) div 2))\n       (map (\\<lambda>p. p $ k) ps)) =\n    (length ps - 1) div 2 + 1", "using length_filter_sort_nth[OF 1 0]"], ["proof (prove)\nusing this:\n  length\n   (filter\n     (\\<lambda>x.\n         x \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                 ((length ps - 1) div 2))\n     (map (\\<lambda>p. p $ k) ps)) =\n  (length ps - 1) div 2 + 1\n\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>v.\n           v \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                   ((length ps - 1) div 2))\n       (map (\\<lambda>p. p $ k) ps)) =\n    (length ps - 1) div 2 + 1", "by blast"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>v.\n         v \\<le> sort (map (\\<lambda>p. p $ k) ps) !\n                 ((length ps - 1) div 2))\n     (map (\\<lambda>p. p $ k) ps)) =\n  (length ps - 1) div 2 + 1\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "finally"], ["proof (chain)\npicking this:\n  length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n  (length ps - 1) div 2 + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n  (length ps - 1) div 2 + 1\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n    (length ps - 1) div 2 + 1", "."], ["proof (state)\nthis:\n  length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ps) =\n  (length ps - 1) div 2 + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition partition_by_median :: \"('k::finite) \\<Rightarrow> 'k point list \\<Rightarrow> 'k point list \\<times> real \\<times> 'k point list\" where\n  \"partition_by_median k ps = (\n     let m = axis_median k ps in\n     let (l, r) = partition (\\<lambda>p. p$k \\<le> m) ps in\n     (l, m, r)\n  )\""], ["", "lemma set_partition_by_median:\n  \"(l, m, r) = partition_by_median k ps \\<Longrightarrow> set ps = set l \\<union> set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, m, r) = partition_by_median k ps \\<Longrightarrow>\n    set ps = set l \\<union> set r", "unfolding partition_by_median_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, m, r) =\n    (let m = axis_median k ps;\n         (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n     in (l, m, r)) \\<Longrightarrow>\n    set ps = set l \\<union> set r", "by (auto simp: Let_def)"], ["", "lemma filter_partition_by_median:\n  assumes \"(l, m, r) = partition_by_median k ps\"\n  shows \"\\<forall>p \\<in> set l. p$k \\<le> m\"\n    and \"\\<forall>p \\<in> set r. \\<not>p$k \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set l. p $ k \\<le> m &&&\n    \\<forall>p\\<in>set r. \\<not> p $ k \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set l. p $ k \\<le> m &&&\n    \\<forall>p\\<in>set r. \\<not> p $ k \\<le> m", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set l. p $ k \\<le> m &&&\n    \\<forall>p\\<in>set r. \\<not> p $ k \\<le> m", "by (auto simp: Let_def)"], ["", "lemma sum_length_partition_by_median:\n  assumes \"(l, m, r) = partition_by_median k ps\"\n  shows \"length ps = length l + length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps = length l + length r", "using assms sum_length_filter_compl[of \"(\\<lambda>p. p $ k \\<le> axis_median k ps)\"]"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k ps\n  length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ?xs) +\n  length (filter (\\<lambda>x. \\<not> x $ k \\<le> axis_median k ps) ?xs) =\n  length ?xs\n\ngoal (1 subgoal):\n 1. length ps = length l + length r", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n  length (filter (\\<lambda>p. p $ k \\<le> axis_median k ps) ?xs) +\n  length (filter (\\<lambda>x. \\<not> x $ k \\<le> axis_median k ps) ?xs) =\n  length ?xs\n\ngoal (1 subgoal):\n 1. length ps = length l + length r", "by (simp add: Let_def o_def)"], ["", "lemma length_l_partition_by_median:\n  assumes \"0 < length ps\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\" \"(l, m, r) = partition_by_median k ps\"\n  shows \"length l = (length ps - 1) div 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = (length ps - 1) div 2 + 1", "using assms"], ["proof (prove)\nusing this:\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. length l = (length ps - 1) div 2 + 1", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. length l = (length ps - 1) div 2 + 1", "by (auto simp: Let_def length_filter_le_axis_median)"], ["", "corollary lengths_partition_by_median_1:\n  assumes \"0 < length ps\"  \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\" \"(l, m, r) = partition_by_median k ps\"\n  shows \"length l - length r \\<le> 1\"\n    and \"length r \\<le> length l\"\n    and \"0 < length l\"\n    and \"length r < length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l - length r \\<le> 1 &&& length r \\<le> length l) &&&\n    0 < length l &&& length r < length ps", "using length_l_partition_by_median[OF assms] sum_length_partition_by_median[OF assms(3)]"], ["proof (prove)\nusing this:\n  length l = (length ps - 1) div 2 + 1\n  length ps = length l + length r\n\ngoal (1 subgoal):\n 1. (length l - length r \\<le> 1 &&& length r \\<le> length l) &&&\n    0 < length l &&& length r < length ps", "by auto"], ["", "corollary lengths_partition_by_median_2:\n  assumes \"1 < length ps\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\" \"(l, m, r) = partition_by_median k ps\"\n  shows \"0 < length r\"\n    and \"length l < length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length r &&& length l < length ps", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length r\n 2. length l < length ps", "have *: \"0 < length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length ps", "using assms(1)"], ["proof (prove)\nusing this:\n  1 < length ps\n\ngoal (1 subgoal):\n 1. 0 < length ps", "by auto"], ["proof (state)\nthis:\n  0 < length ps\n\ngoal (2 subgoals):\n 1. 0 < length r\n 2. length l < length ps", "show \"0 < length r\" \"length l < length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length r &&& length l < length ps", "using length_l_partition_by_median[OF * assms(2,3)] sum_length_partition_by_median[OF assms(3)]"], ["proof (prove)\nusing this:\n  length l = (length ps - 1) div 2 + 1\n  length ps = length l + length r\n\ngoal (1 subgoal):\n 1. 0 < length r &&& length l < length ps", "using assms(1)"], ["proof (prove)\nusing this:\n  length l = (length ps - 1) div 2 + 1\n  length ps = length l + length r\n  1 < length ps\n\ngoal (1 subgoal):\n 1. 0 < length r &&& length l < length ps", "by linarith+"], ["proof (state)\nthis:\n  0 < length r\n  length l < length ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas length_partition_by_median =\n  sum_length_partition_by_median length_l_partition_by_median\n  lengths_partition_by_median_1 lengths_partition_by_median_2"], ["", "subsection \\<open>Building the Tree\\<close>"], ["", "function (domintros, sequential) build :: \"('k::finite) list \\<Rightarrow> 'k point list \\<Rightarrow> 'k kdt\" where\n  \"build _ [] = undefined\"\n| \"build _ [p] = Leaf p\"\n| \"build ks ps = (\n    let (k, _) = widest_spread ks ps in\n    let (l, m, r) = partition_by_median k ps in\n    Node k m (build ks l) (build ks r)\n  )\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_. x = (uu_, []) \\<Longrightarrow> P;\n        \\<And>uv_ p. x = (uv_, [p]) \\<Longrightarrow> P;\n        \\<And>ks v vb vc. x = (ks, v # vb # vc) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, []) = (uua_, []) \\<Longrightarrow> undefined = undefined\n 3. \\<And>uu_ uv_ p.\n       (uu_, []) = (uv_, [p]) \\<Longrightarrow> undefined = Leaf p\n 4. \\<And>uu_ ks v vb vc.\n       (uu_, []) = (ks, v # vb # vc) \\<Longrightarrow>\n       undefined =\n       (let (k, uu_) = widest_spread ks (v # vb # vc);\n            (l, m, r) = partition_by_median k (v # vb # vc)\n        in Node k m (build_sumC (ks, l)) (build_sumC (ks, r)))\n 5. \\<And>uv_ p uva_ pa.\n       (uv_, [p]) = (uva_, [pa]) \\<Longrightarrow> Leaf p = Leaf pa\n 6. \\<And>uv_ p ks v vb vc.\n       (uv_, [p]) = (ks, v # vb # vc) \\<Longrightarrow>\n       Leaf p =\n       (let (k, uu_) = widest_spread ks (v # vb # vc);\n            (l, m, r) = partition_by_median k (v # vb # vc)\n        in Node k m (build_sumC (ks, l)) (build_sumC (ks, r)))\n 7. \\<And>ks v vb vc ksa va vba vca.\n       (ks, v # vb # vc) = (ksa, va # vba # vca) \\<Longrightarrow>\n       (let (k, uu_) = widest_spread ks (v # vb # vc);\n            (l, m, r) = partition_by_median k (v # vb # vc)\n        in Node k m (build_sumC (ks, l)) (build_sumC (ks, r))) =\n       (let (k, uu_) = widest_spread ksa (va # vba # vca);\n            (l, m, r) = partition_by_median k (va # vba # vca)\n        in Node k m (build_sumC (ksa, l)) (build_sumC (ksa, r)))", "by pat_completeness auto"], ["", "lemma build_domintros3:\n  assumes \"(k, s) = widest_spread ks (x # y # zs)\" \"(l, m, r) = partition_by_median k (x # y # zs)\"\n  assumes \"build_dom (ks, l)\" \"build_dom (ks, r)\"\n  shows \"build_dom (ks, x # y # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "fix k s l m r"], ["proof (state)\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "assume \"(k, s) = widest_spread ks (x # y # zs)\" \"(l, m, r) = partition_by_median k (x # y # zs)\""], ["proof (state)\nthis:\n  (k, s) = widest_spread ks (x # y # zs)\n  (l, m, r) = partition_by_median k (x # y # zs)\n\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "hence \"build_dom (ks, l)\" \"build_dom (ks, r)\""], ["proof (prove)\nusing this:\n  (k, s) = widest_spread ks (x # y # zs)\n  (l, m, r) = partition_by_median k (x # y # zs)\n\ngoal (1 subgoal):\n 1. build_dom (ks, l) &&& build_dom (ks, r)", "using assms"], ["proof (prove)\nusing this:\n  (k, s) = widest_spread ks (x # y # zs)\n  (l, m, r) = partition_by_median k (x # y # zs)\n  (k, s) = widest_spread ks (x # y # zs)\n  (l, m, r) = partition_by_median k (x # y # zs)\n  build_dom (ks, l)\n  build_dom (ks, r)\n\ngoal (1 subgoal):\n 1. build_dom (ks, l) &&& build_dom (ks, r)", "by (metis Pair_inject)+"], ["proof (state)\nthis:\n  build_dom (ks, l)\n  build_dom (ks, r)\n\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?ka2, ?sa2) = widest_spread ks (x # y # zs);\n   (?la2, ?ma2, ?ra2) = partition_by_median ?ka2 (x # y # zs)\\<rbrakk>\n  \\<Longrightarrow> build_dom (ks, ?la2)\n  \\<lbrakk>(?ka2, ?sa2) = widest_spread ks (x # y # zs);\n   (?la2, ?ma2, ?ra2) = partition_by_median ?ka2 (x # y # zs)\\<rbrakk>\n  \\<Longrightarrow> build_dom (ks, ?ra2)\n\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ka2, ?sa2) = widest_spread ks (x # y # zs);\n   (?la2, ?ma2, ?ra2) = partition_by_median ?ka2 (x # y # zs)\\<rbrakk>\n  \\<Longrightarrow> build_dom (ks, ?la2)\n  \\<lbrakk>(?ka2, ?sa2) = widest_spread ks (x # y # zs);\n   (?la2, ?ma2, ?ra2) = partition_by_median ?ka2 (x # y # zs)\\<rbrakk>\n  \\<Longrightarrow> build_dom (ks, ?ra2)\n\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "by (simp add: build.domintros(3))"], ["proof (state)\nthis:\n  build_dom (ks, x # y # zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma build_termination:\n  assumes \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\"\n  shows \"build_dom (ks, ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build_dom (ks, ps)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. build_dom (ks, ps)", "proof (induction ps rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   build_dom (ks, ys);\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> build_dom (ks, xs)", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     build_dom (ks, ys)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   build_dom (ks, ys);\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> build_dom (ks, xs)", "consider (A) \"xs = []\" | (B) \"\\<exists>x. xs = [x]\" | (C) \"\\<exists>x y zs. xs = x # y # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = [] \\<Longrightarrow> thesis;\n     \\<exists>x. xs = [x] \\<Longrightarrow> thesis;\n     \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (induction xs rule: induct_list012) auto"], ["proof (state)\nthis:\n  \\<lbrakk>xs = [] \\<Longrightarrow> ?thesis;\n   \\<exists>x. xs = [x] \\<Longrightarrow> ?thesis;\n   \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   build_dom (ks, ys);\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> build_dom (ks, xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs = [] \\<Longrightarrow> ?thesis;\n   \\<exists>x. xs = [x] \\<Longrightarrow> ?thesis;\n   \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs = [] \\<Longrightarrow> ?thesis;\n   \\<exists>x. xs = [x] \\<Longrightarrow> ?thesis;\n   \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. build_dom (ks, xs)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "case C"], ["proof (state)\nthis:\n  \\<exists>x y zs. xs = x # y # zs\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x y zs. xs = x # y # zs", "obtain x y zs where xyzs_def: \"xs = x # y # zs\""], ["proof (prove)\nusing this:\n  \\<exists>x y zs. xs = x # y # zs\n\ngoal (1 subgoal):\n 1. (\\<And>x y zs.\n        xs = x # y # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = x # y # zs\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "obtain k s where ks_def: \"(k, s) = widest_spread ks xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        (k, s) = widest_spread ks xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (k, s) = widest_spread ks xs\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "obtain l m r where lmr_def: \"(l, m, r) = partition_by_median k xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l m r.\n        (l, m, r) = partition_by_median k xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (l, m, r) = partition_by_median k xs\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "note defs = xyzs_def ks_def lmr_def"], ["proof (state)\nthis:\n  xs = x # y # zs\n  (k, s) = widest_spread ks xs\n  (l, m, r) = partition_by_median k xs\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "have \"\\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\" \"\\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "using lmr_def"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k xs\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k xs;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) xs\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "by (auto simp: Let_def \"1.prems\" distinct_map_filter)"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "have \"length l < length xs\" \"length r < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l < length xs &&& length r < length xs", "using length_partition_by_median(8)[OF _ \"1.prems\"] length_partition_by_median(6)[OF _ \"1.prems\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length xs; (?l, ?m, ?r) = partition_by_median ?k xs\\<rbrakk>\n  \\<Longrightarrow> length ?l < length xs\n  \\<lbrakk>0 < length xs; (?l, ?m, ?r) = partition_by_median ?k xs\\<rbrakk>\n  \\<Longrightarrow> length ?r < length xs\n\ngoal (1 subgoal):\n 1. length l < length xs &&& length r < length xs", "using defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length xs; (?l, ?m, ?r) = partition_by_median ?k xs\\<rbrakk>\n  \\<Longrightarrow> length ?l < length xs\n  \\<lbrakk>0 < length xs; (?l, ?m, ?r) = partition_by_median ?k xs\\<rbrakk>\n  \\<Longrightarrow> length ?r < length xs\n  xs = x # y # zs\n  (k, s) = widest_spread ks xs\n  (l, m, r) = partition_by_median k xs\n\ngoal (1 subgoal):\n 1. length l < length xs &&& length r < length xs", "by auto"], ["proof (state)\nthis:\n  length l < length xs\n  length r < length xs\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length xs\n  length r < length xs", "have \"build_dom (ks, l)\" \"build_dom (ks, r)\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length xs\n  length r < length xs\n\ngoal (1 subgoal):\n 1. build_dom (ks, l) &&& build_dom (ks, r)", "using \"1.IH\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length xs\n  length r < length xs\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     build_dom (ks, ys)\n\ngoal (1 subgoal):\n 1. build_dom (ks, l) &&& build_dom (ks, r)", "by blast+"], ["proof (state)\nthis:\n  build_dom (ks, l)\n  build_dom (ks, r)\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)\n 3. \\<exists>x y zs. xs = x # y # zs \\<Longrightarrow> build_dom (ks, xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  build_dom (ks, l)\n  build_dom (ks, r)\n\ngoal (1 subgoal):\n 1. build_dom (ks, xs)", "using build_domintros3 defs"], ["proof (prove)\nusing this:\n  build_dom (ks, l)\n  build_dom (ks, r)\n  \\<lbrakk>(?k, ?s) = widest_spread ?ks (?x # ?y # ?zs);\n   (?l, ?m, ?r) = partition_by_median ?k (?x # ?y # ?zs);\n   build_dom (?ks, ?l); build_dom (?ks, ?r)\\<rbrakk>\n  \\<Longrightarrow> build_dom (?ks, ?x # ?y # ?zs)\n  xs = x # y # zs\n  (k, s) = widest_spread ks xs\n  (l, m, r) = partition_by_median k xs\n\ngoal (1 subgoal):\n 1. build_dom (ks, xs)", "by blast"], ["proof (state)\nthis:\n  build_dom (ks, xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> build_dom (ks, xs)\n 2. \\<exists>x. xs = [x] \\<Longrightarrow> build_dom (ks, xs)", "qed (auto intro: build.domintros)"], ["proof (state)\nthis:\n  build_dom (ks, xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma build_psimp_1:\n  \"ps = [p] \\<Longrightarrow> build k ps = Leaf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps = [p] \\<Longrightarrow> build k ps = Leaf p", "by (simp add: build.domintros(2) build.psimps(2))"], ["", "lemma build_psimp_2:\n  assumes \"(k, s) = widest_spread ks (x # y # zs)\" \"(l, m, r) = partition_by_median k (x # y # zs)\"\n  assumes \"build_dom (ks, l)\" \"build_dom (ks, r)\"\n  shows \"build ks (x # y # zs) = Node k m (build ks l) (build ks r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build ks (x # y # zs) = Node k m (build ks l) (build ks r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. build ks (x # y # zs) = Node k m (build ks l) (build ks r)", "have 0: \"build_dom (ks, x # y # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "using assms build_domintros3"], ["proof (prove)\nusing this:\n  (k, s) = widest_spread ks (x # y # zs)\n  (l, m, r) = partition_by_median k (x # y # zs)\n  build_dom (ks, l)\n  build_dom (ks, r)\n  \\<lbrakk>(?k, ?s) = widest_spread ?ks (?x # ?y # ?zs);\n   (?l, ?m, ?r) = partition_by_median ?k (?x # ?y # ?zs);\n   build_dom (?ks, ?l); build_dom (?ks, ?r)\\<rbrakk>\n  \\<Longrightarrow> build_dom (?ks, ?x # ?y # ?zs)\n\ngoal (1 subgoal):\n 1. build_dom (ks, x # y # zs)", "by blast"], ["proof (state)\nthis:\n  build_dom (ks, x # y # zs)\n\ngoal (1 subgoal):\n 1. build ks (x # y # zs) = Node k m (build ks l) (build ks r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  build_dom (ks, x # y # zs)\n\ngoal (1 subgoal):\n 1. build ks (x # y # zs) = Node k m (build ks l) (build ks r)", "using build.psimps(3)[OF 0] assms(1,2)"], ["proof (prove)\nusing this:\n  build_dom (ks, x # y # zs)\n  build ks (x # y # zs) =\n  (let (k, uu_) = widest_spread ks (x # y # zs);\n       (l, m, r) = partition_by_median k (x # y # zs)\n   in Node k m (build ks l) (build ks r))\n  (k, s) = widest_spread ks (x # y # zs)\n  (l, m, r) = partition_by_median k (x # y # zs)\n\ngoal (1 subgoal):\n 1. build ks (x # y # zs) = Node k m (build ks l) (build ks r)", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  build ks (x # y # zs) = Node k m (build ks l) (build ks r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_xs_gt_1:\n  \"1 < length xs \\<Longrightarrow> \\<exists>x y ys. xs = x # y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow> \\<exists>x y ys. xs = x # y # ys", "by (cases xs, auto simp: neq_Nil_conv)"], ["", "lemma build_psimp_3:\n  assumes \"1 < length ps\" \"(k, s) = widest_spread ks ps\" \"(l, m, r) = partition_by_median k ps\"\n  assumes \"build_dom (ks, l)\" \"build_dom (ks, r)\"\n  shows \"build ks ps = Node k m (build ks l) (build ks r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "using build_psimp_2 length_xs_gt_1 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?s) = widest_spread ?ks (?x # ?y # ?zs);\n   (?l, ?m, ?r) = partition_by_median ?k (?x # ?y # ?zs);\n   build_dom (?ks, ?l); build_dom (?ks, ?r)\\<rbrakk>\n  \\<Longrightarrow> build ?ks (?x # ?y # ?zs) =\n                    Node ?k ?m (build ?ks ?l) (build ?ks ?r)\n  1 < length ?xs \\<Longrightarrow> \\<exists>x y ys. ?xs = x # y # ys\n  1 < length ps\n  (k, s) = widest_spread ks ps\n  (l, m, r) = partition_by_median k ps\n  build_dom (ks, l)\n  build_dom (ks, r)\n\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "by blast"], ["", "lemmas build_psimps[simp] = build_psimp_1 build_psimp_3"], ["", "subsection \\<open>Main Theorems\\<close>"], ["", "theorem set_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> set ps = set_kdt (build ks ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length ps;\n     \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\\<rbrakk>\n    \\<Longrightarrow> set ps = set_kdt (build ks ps)", "proof (induction ps rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   set ys = set_kdt (build ks ys);\n        0 < length xs;\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> set xs = set_kdt (build ks xs)", "case (1 ps)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     set ys = set_kdt (build ks ys)\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   set ys = set_kdt (build ks ys);\n        0 < length xs;\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> set xs = set_kdt (build ks xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps = set_kdt (build ks ps)", "proof (cases \"1 < length ps\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "case True"], ["proof (state)\nthis:\n  1 < length ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "obtain k s where ks_def: \"(k, s) = widest_spread ks ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        (k, s) = widest_spread ks ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (k, s) = widest_spread ks ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "obtain l m r where lmr_def: \"(l, m, r) = partition_by_median k ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l m r.\n        (l, m, r) = partition_by_median k ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (l, m, r) = partition_by_median k ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "have D: \"\\<forall>k. distinct (map (\\<lambda>p. p$k) l)\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "using lmr_def"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "by (auto simp: \"1.prems\"(2) Let_def distinct_map_filter)"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "have \"length l < length ps\" \"0 < length l\"\n                  \"length r < length ps\" \"0 < length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "using length_partition_by_median(8)[OF True \"1.prems\"(2)]\n            length_partition_by_median(5)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(6)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(7)[OF True \"1.prems\"(2)]\n            lmr_def"], ["proof (prove)\nusing this:\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?l < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?l\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?r < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?r\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "by blast+"], ["proof (state)\nthis:\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r", "have \"set l = set_kdt (build ks l)\" \"set r = set_kdt (build ks r)\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (1 subgoal):\n 1. set l = set_kdt (build ks l) &&& set r = set_kdt (build ks r)", "using \"1.IH\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     set ys = set_kdt (build ks ys)\n\ngoal (1 subgoal):\n 1. set l = set_kdt (build ks l) &&& set r = set_kdt (build ks r)", "by blast+"], ["proof (state)\nthis:\n  set l = set_kdt (build ks l)\n  set r = set_kdt (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "moreover"], ["proof (state)\nthis:\n  set l = set_kdt (build ks l)\n  set r = set_kdt (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "have \"set ps = set l \\<union> set r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps = set l \\<union> set r", "using lmr_def"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. set ps = set l \\<union> set r", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. set ps = set l \\<union> set r", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  set ps = set l \\<union> set r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "moreover"], ["proof (state)\nthis:\n  set ps = set l \\<union> set r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "have \"build ks ps = Node k m (build ks l) (build ks r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "using build_psimp_3[OF True ks_def lmr_def] build_termination D"], ["proof (prove)\nusing this:\n  \\<lbrakk>build_dom (ks, l); build_dom (ks, r)\\<rbrakk>\n  \\<Longrightarrow> build ks ps = Node k m (build ks l) (build ks r)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ?ps) \\<Longrightarrow>\n  build_dom (?ks, ?ps)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "by blast"], ["proof (state)\nthis:\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "ultimately"], ["proof (chain)\npicking this:\n  set l = set_kdt (build ks l)\n  set r = set_kdt (build ks r)\n  set ps = set l \\<union> set r\n  build ks ps = Node k m (build ks l) (build ks r)", "show ?thesis"], ["proof (prove)\nusing this:\n  set l = set_kdt (build ks l)\n  set r = set_kdt (build ks r)\n  set ps = set l \\<union> set r\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (1 subgoal):\n 1. set ps = set_kdt (build ks ps)", "by simp"], ["proof (state)\nthis:\n  set ps = set_kdt (build ks ps)\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> set ps = set_kdt (build ks ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. set ps = set_kdt (build ks ps)", "using \"1.prems\""], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. set ps = set_kdt (build ks ps)", "by (cases ps) auto"], ["proof (state)\nthis:\n  set ps = set_kdt (build ks ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set ps = set_kdt (build ks ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem invar_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> set ks = UNIV \\<Longrightarrow> invar (build ks ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length ps;\n     \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps);\n     set ks = UNIV\\<rbrakk>\n    \\<Longrightarrow> invar (build ks ps)", "proof (induction ps rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   set ks = UNIV \\<longrightarrow> invar (build ks ys);\n        0 < length xs; \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs);\n        set ks = UNIV\\<rbrakk>\n       \\<Longrightarrow> invar (build ks xs)", "case (1 ps)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     set ks = UNIV \\<longrightarrow> invar (build ks ys)\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n  set ks = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   set ks = UNIV \\<longrightarrow> invar (build ks ys);\n        0 < length xs; \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs);\n        set ks = UNIV\\<rbrakk>\n       \\<Longrightarrow> invar (build ks xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (build ks ps)", "proof (cases \"1 < length ps\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "case True"], ["proof (state)\nthis:\n  1 < length ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "obtain k s where ks_def: \"(k, s) = widest_spread ks ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        (k, s) = widest_spread ks ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (k, s) = widest_spread ks ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "obtain l m r where lmr_def: \"(l, m, r) = partition_by_median k ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l m r.\n        (l, m, r) = partition_by_median k ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (l, m, r) = partition_by_median k ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "have D: \"\\<forall>k. distinct (map (\\<lambda>p. p$k) l)\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "using lmr_def"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "by (auto simp: \"1.prems\"(2) Let_def distinct_map_filter)"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "have \"length l < length ps\" \"0 < length l\"\n                  \"length r < length ps\" \"0 < length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "using length_partition_by_median(8)[OF True \"1.prems\"(2)]\n            length_partition_by_median(5)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(6)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(7)[OF True \"1.prems\"(2)]\n            lmr_def"], ["proof (prove)\nusing this:\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?l < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?l\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?r < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?r\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "by blast+"], ["proof (state)\nthis:\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r", "have \"invar (build ks l)\" \"invar (build ks r)\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (1 subgoal):\n 1. invar (build ks l) &&& invar (build ks r)", "using \"1.IH\" \"1.prems\"(3)"], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     set ks = UNIV \\<longrightarrow> invar (build ks ys)\n  set ks = UNIV\n\ngoal (1 subgoal):\n 1. invar (build ks l) &&& invar (build ks r)", "by blast+"], ["proof (state)\nthis:\n  invar (build ks l)\n  invar (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "moreover"], ["proof (state)\nthis:\n  invar (build ks l)\n  invar (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "have \"\\<forall>p \\<in> set l. p$k \\<le> m\" \"\\<forall>p \\<in> set r. m < p$k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set l. p $ k \\<le> m &&& \\<forall>p\\<in>set r. m < p $ k", "using filter_partition_by_median(1)[OF lmr_def]\n            filter_partition_by_median(2)[OF lmr_def]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set l. p $ k \\<le> m\n  \\<forall>p\\<in>set r. \\<not> p $ k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set l. p $ k \\<le> m &&& \\<forall>p\\<in>set r. m < p $ k", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set l. p $ k \\<le> m\n  \\<forall>p\\<in>set r. m < p $ k\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set l. p $ k \\<le> m\n  \\<forall>p\\<in>set r. m < p $ k\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "have \"widest_spread_axis k UNIV (set l \\<union> set r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. widest_spread_axis k UNIV (set l \\<union> set r)", "using widest_spread_spec[OF ks_def] \"1.prems\"(3) set_partition_by_median[OF lmr_def]"], ["proof (prove)\nusing this:\n  widest_spread_axis k (set ks) (set ps)\n  set ks = UNIV\n  set ps = set l \\<union> set r\n\ngoal (1 subgoal):\n 1. widest_spread_axis k UNIV (set l \\<union> set r)", "by simp"], ["proof (state)\nthis:\n  widest_spread_axis k UNIV (set l \\<union> set r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "moreover"], ["proof (state)\nthis:\n  widest_spread_axis k UNIV (set l \\<union> set r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "have \"build ks ps = Node k m (build ks l) (build ks r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "using build_psimp_3[OF True ks_def lmr_def] build_termination D"], ["proof (prove)\nusing this:\n  \\<lbrakk>build_dom (ks, l); build_dom (ks, r)\\<rbrakk>\n  \\<Longrightarrow> build ks ps = Node k m (build ks l) (build ks r)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ?ps) \\<Longrightarrow>\n  build_dom (?ks, ?ps)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "by blast"], ["proof (state)\nthis:\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> invar (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "ultimately"], ["proof (chain)\npicking this:\n  invar (build ks l)\n  invar (build ks r)\n  \\<forall>p\\<in>set l. p $ k \\<le> m\n  \\<forall>p\\<in>set r. m < p $ k\n  widest_spread_axis k UNIV (set l \\<union> set r)\n  build ks ps = Node k m (build ks l) (build ks r)", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (build ks l)\n  invar (build ks r)\n  \\<forall>p\\<in>set l. p $ k \\<le> m\n  \\<forall>p\\<in>set r. m < p $ k\n  widest_spread_axis k UNIV (set l \\<union> set r)\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (1 subgoal):\n 1. invar (build ks ps)", "using set_build[OF \\<open>0 < length l\\<close> D(1)] set_build[OF \\<open>0 < length r\\<close> D(2)]"], ["proof (prove)\nusing this:\n  invar (build ks l)\n  invar (build ks r)\n  \\<forall>p\\<in>set l. p $ k \\<le> m\n  \\<forall>p\\<in>set r. m < p $ k\n  widest_spread_axis k UNIV (set l \\<union> set r)\n  build ks ps = Node k m (build ks l) (build ks r)\n  set l = set_kdt (build ?ks l)\n  set r = set_kdt (build ?ks r)\n\ngoal (1 subgoal):\n 1. invar (build ks ps)", "by simp"], ["proof (state)\nthis:\n  invar (build ks ps)\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> invar (build ks ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. invar (build ks ps)", "using \"1.prems\""], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n  set ks = UNIV\n\ngoal (1 subgoal):\n 1. invar (build ks ps)", "by (cases ps) auto"], ["proof (state)\nthis:\n  invar (build ks ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (build ks ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem size_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> size_kdt (build ks ps) = length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length ps;\n     \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\\<rbrakk>\n    \\<Longrightarrow> KD_Tree.size_kdt (build ks ps) = length ps", "proof (induction ps rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   KD_Tree.size_kdt (build ks ys) = length ys;\n        0 < length xs;\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> KD_Tree.size_kdt (build ks xs) = length xs", "case (1 ps)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     KD_Tree.size_kdt (build ks ys) = length ys\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   KD_Tree.size_kdt (build ks ys) = length ys;\n        0 < length xs;\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> KD_Tree.size_kdt (build ks xs) = length xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. KD_Tree.size_kdt (build ks ps) = length ps", "proof (cases \"1 < length ps\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "case True"], ["proof (state)\nthis:\n  1 < length ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "obtain k s where ks_def: \"(k, s) = widest_spread ks ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        (k, s) = widest_spread ks ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (k, s) = widest_spread ks ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "obtain l m r where lmr_def: \"(l, m, r) = partition_by_median k ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l m r.\n        (l, m, r) = partition_by_median k ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (l, m, r) = partition_by_median k ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "have D: \"\\<forall>k. distinct (map (\\<lambda>p. p$k) l)\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "using lmr_def"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "by (auto simp: \"1.prems\"(2) Let_def distinct_map_filter)"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "moreover"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "have \"length l < length ps\" \"0 < length l\"\n                  \"length r < length ps\" \"0 < length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "using length_partition_by_median(8)[OF True \"1.prems\"(2)]\n            length_partition_by_median(5)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(6)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(7)[OF True \"1.prems\"(2)]\n            lmr_def"], ["proof (prove)\nusing this:\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?l < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?l\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?r < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?r\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "by blast+"], ["proof (state)\nthis:\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r", "have \"size_kdt (build ks l) = length l\" \"size_kdt (build ks r) = length r\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (1 subgoal):\n 1. KD_Tree.size_kdt (build ks l) = length l &&&\n    KD_Tree.size_kdt (build ks r) = length r", "using \"1.IH\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     KD_Tree.size_kdt (build ks ys) = length ys\n\ngoal (1 subgoal):\n 1. KD_Tree.size_kdt (build ks l) = length l &&&\n    KD_Tree.size_kdt (build ks r) = length r", "by blast+"], ["proof (state)\nthis:\n  KD_Tree.size_kdt (build ks l) = length l\n  KD_Tree.size_kdt (build ks r) = length r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "moreover"], ["proof (state)\nthis:\n  KD_Tree.size_kdt (build ks l) = length l\n  KD_Tree.size_kdt (build ks r) = length r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "have \"build ks ps = Node k m (build ks l) (build ks r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "using build_psimp_3[OF True ks_def lmr_def] build_termination D"], ["proof (prove)\nusing this:\n  \\<lbrakk>build_dom (ks, l); build_dom (ks, r)\\<rbrakk>\n  \\<Longrightarrow> build ks ps = Node k m (build ks l) (build ks r)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ?ps) \\<Longrightarrow>\n  build_dom (?ks, ?ps)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "by blast"], ["proof (state)\nthis:\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps\n 2. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "ultimately"], ["proof (chain)\npicking this:\n  KD_Tree.size_kdt (build ks l) = length l\n  KD_Tree.size_kdt (build ks r) = length r\n  build ks ps = Node k m (build ks l) (build ks r)", "show ?thesis"], ["proof (prove)\nusing this:\n  KD_Tree.size_kdt (build ks l) = length l\n  KD_Tree.size_kdt (build ks r) = length r\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (1 subgoal):\n 1. KD_Tree.size_kdt (build ks ps) = length ps", "using length_partition_by_median(1)[OF lmr_def]"], ["proof (prove)\nusing this:\n  KD_Tree.size_kdt (build ks l) = length l\n  KD_Tree.size_kdt (build ks r) = length r\n  build ks ps = Node k m (build ks l) (build ks r)\n  length ps = length l + length r\n\ngoal (1 subgoal):\n 1. KD_Tree.size_kdt (build ks ps) = length ps", "by simp"], ["proof (state)\nthis:\n  KD_Tree.size_kdt (build ks ps) = length ps\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow>\n    KD_Tree.size_kdt (build ks ps) = length ps", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. KD_Tree.size_kdt (build ks ps) = length ps", "using \"1.prems\""], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. KD_Tree.size_kdt (build ks ps) = length ps", "by (cases ps) auto"], ["proof (state)\nthis:\n  KD_Tree.size_kdt (build ks ps) = length ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  KD_Tree.size_kdt (build ks ps) = length ps\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem balanced_build:\n  \"0 < length ps \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> balanced (build ks ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length ps;\n     \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\\<rbrakk>\n    \\<Longrightarrow> balanced (build ks ps)", "proof (induction ps rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   balanced (build ks ys);\n        0 < length xs;\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> balanced (build ks xs)", "case (1 ps)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     balanced (build ks ys)\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   0 < length ys \\<longrightarrow>\n                   (\\<forall>k.\n                       distinct\n                        (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n                   balanced (build ks ys);\n        0 < length xs;\n        \\<forall>k. distinct (map (\\<lambda>p. p $ k) xs)\\<rbrakk>\n       \\<Longrightarrow> balanced (build ks xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. balanced (build ks ps)", "proof (cases \"1 < length ps\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "case True"], ["proof (state)\nthis:\n  1 < length ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "obtain k s where ks_def: \"(k, s) = widest_spread ks ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        (k, s) = widest_spread ks ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (k, s) = widest_spread ks ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "obtain l m r where lmr_def: \"(l, m, r) = partition_by_median k ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l m r.\n        (l, m, r) = partition_by_median k ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  (l, m, r) = partition_by_median k ps\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "have D: \"\\<forall>k. distinct (map (\\<lambda>p. p$k) l)\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "using lmr_def"], ["proof (prove)\nusing this:\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "unfolding partition_by_median_def"], ["proof (prove)\nusing this:\n  (l, m, r) =\n  (let m = axis_median k ps;\n       (l, r) = partition (\\<lambda>p. p $ k \\<le> m) ps\n   in (l, m, r))\n\ngoal (1 subgoal):\n 1. \\<forall>k. distinct (map (\\<lambda>p. p $ k) l) &&&\n    \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)", "by (auto simp: \"1.prems\"(2) Let_def distinct_map_filter)"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "moreover"], ["proof (state)\nthis:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "have \"length l < length ps\" \"0 < length l\"\n                  \"length r < length ps\" \"0 < length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "using length_partition_by_median(8)[OF True \"1.prems\"(2)]\n            length_partition_by_median(5)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(6)[OF \"1.prems\"(1) \"1.prems\"(2)]\n            length_partition_by_median(7)[OF True \"1.prems\"(2)]\n            lmr_def"], ["proof (prove)\nusing this:\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?l < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?l\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow>\n  length ?r < length ps\n  (?l, ?m, ?r) = partition_by_median ?k ps \\<Longrightarrow> 0 < length ?r\n  (l, m, r) = partition_by_median k ps\n\ngoal (1 subgoal):\n 1. (length l < length ps &&& 0 < length l) &&&\n    length r < length ps &&& 0 < length r", "by blast+"], ["proof (state)\nthis:\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r", "have IH: \"balanced (build ks l)\" \"balanced (build ks r)\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n\ngoal (1 subgoal):\n 1. balanced (build ks l) &&& balanced (build ks r)", "using \"1.IH\""], ["proof (prove)\nusing this:\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n  length l < length ps\n  0 < length l\n  length r < length ps\n  0 < length r\n  \\<forall>ys.\n     length ys < length ps \\<longrightarrow>\n     0 < length ys \\<longrightarrow>\n     (\\<forall>k. distinct (map (\\<lambda>p. p $ k) ys)) \\<longrightarrow>\n     balanced (build ks ys)\n\ngoal (1 subgoal):\n 1. balanced (build ks l) &&& balanced (build ks r)", "by blast+"], ["proof (state)\nthis:\n  balanced (build ks l)\n  balanced (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "have \"build ks ps = Node k m (build ks l) (build ks r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "using build_psimp_3[OF True ks_def lmr_def] build_termination D"], ["proof (prove)\nusing this:\n  \\<lbrakk>build_dom (ks, l); build_dom (ks, r)\\<rbrakk>\n  \\<Longrightarrow> build ks ps = Node k m (build ks l) (build ks r)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ?ps) \\<Longrightarrow>\n  build_dom (?ks, ?ps)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) l)\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) r)\n\ngoal (1 subgoal):\n 1. build ks ps = Node k m (build ks l) (build ks r)", "by blast"], ["proof (state)\nthis:\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "moreover"], ["proof (state)\nthis:\n  build ks ps = Node k m (build ks l) (build ks r)\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "have \"length r + 1 = length l \\<or> length r = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length r + 1 = length l \\<or> length r = length l", "using length_partition_by_median(1)[OF lmr_def]\n            length_partition_by_median(3)[OF \"1.prems\"(1) \"1.prems\"(2) lmr_def]\n            length_partition_by_median(4)[OF \"1.prems\"(1) \"1.prems\"(2) lmr_def]"], ["proof (prove)\nusing this:\n  length ps = length l + length r\n  length l - length r \\<le> 1\n  length r \\<le> length l\n\ngoal (1 subgoal):\n 1. length r + 1 = length l \\<or> length r = length l", "by linarith"], ["proof (state)\nthis:\n  length r + 1 = length l \\<or> length r = length l\n\ngoal (2 subgoals):\n 1. 1 < length ps \\<Longrightarrow> balanced (build ks ps)\n 2. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "ultimately"], ["proof (chain)\npicking this:\n  build ks ps = Node k m (build ks l) (build ks r)\n  length r + 1 = length l \\<or> length r = length l", "show ?thesis"], ["proof (prove)\nusing this:\n  build ks ps = Node k m (build ks l) (build ks r)\n  length r + 1 = length l \\<or> length r = length l\n\ngoal (1 subgoal):\n 1. balanced (build ks ps)", "using balanced_Node_if_wbal1[OF IH] balanced_Node_if_wbal2[OF IH]\n            size_build[OF \\<open>0 < length l\\<close> D(1)] size_build[OF \\<open>0 < length r\\<close> D(2)]"], ["proof (prove)\nusing this:\n  build ks ps = Node k m (build ks l) (build ks r)\n  length r + 1 = length l \\<or> length r = length l\n  KD_Tree.size_kdt (build ks l) =\n  KD_Tree.size_kdt (build ks r) + 1 \\<Longrightarrow>\n  balanced (Node ?k ?v (build ks l) (build ks r))\n  \\<bar>int (KD_Tree.size_kdt (build ks l)) -\n        int (KD_Tree.size_kdt (build ks r))\\<bar>\n  \\<le> 1 \\<Longrightarrow>\n  balanced (Node ?k ?v (build ks l) (build ks r))\n  KD_Tree.size_kdt (build ?ks l) = length l\n  KD_Tree.size_kdt (build ?ks r) = length r\n\ngoal (1 subgoal):\n 1. balanced (build ks ps)", "by auto"], ["proof (state)\nthis:\n  balanced (build ks ps)\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "case False"], ["proof (state)\nthis:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. \\<not> 1 < length ps \\<Longrightarrow> balanced (build ks ps)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n\ngoal (1 subgoal):\n 1. balanced (build ks ps)", "using \"1.prems\""], ["proof (prove)\nusing this:\n  \\<not> 1 < length ps\n  0 < length ps\n  \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\n\ngoal (1 subgoal):\n 1. balanced (build ks ps)", "by (cases ps) (auto simp: balanced_def)"], ["proof (state)\nthis:\n  balanced (build ks ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  balanced (build ks ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complete_if_balanced_size_2powh:\n  assumes \"balanced kdt\" \"size_kdt kdt = 2 ^ h\"\n  shows \"complete kdt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KD_Tree.complete kdt", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> KD_Tree.complete kdt \\<Longrightarrow> False", "assume \"\\<not> complete kdt\""], ["proof (state)\nthis:\n  \\<not> KD_Tree.complete kdt\n\ngoal (1 subgoal):\n 1. \\<not> KD_Tree.complete kdt \\<Longrightarrow> False", "hence \"2 ^ (min_height kdt) < size_kdt kdt\" \"size_kdt kdt < 2 ^ height kdt\""], ["proof (prove)\nusing this:\n  \\<not> KD_Tree.complete kdt\n\ngoal (1 subgoal):\n 1. 2 ^ min_height kdt < KD_Tree.size_kdt kdt &&&\n    KD_Tree.size_kdt kdt < 2 ^ height kdt", "by (simp_all add: min_height_size_if_incomplete size_height_if_incomplete)"], ["proof (state)\nthis:\n  2 ^ min_height kdt < KD_Tree.size_kdt kdt\n  KD_Tree.size_kdt kdt < 2 ^ height kdt\n\ngoal (1 subgoal):\n 1. \\<not> KD_Tree.complete kdt \\<Longrightarrow> False", "hence \"height kdt - min_height kdt > 1\""], ["proof (prove)\nusing this:\n  2 ^ min_height kdt < KD_Tree.size_kdt kdt\n  KD_Tree.size_kdt kdt < 2 ^ height kdt\n\ngoal (1 subgoal):\n 1. 1 < height kdt - min_height kdt", "using assms(2)"], ["proof (prove)\nusing this:\n  2 ^ min_height kdt < KD_Tree.size_kdt kdt\n  KD_Tree.size_kdt kdt < 2 ^ height kdt\n  KD_Tree.size_kdt kdt = 2 ^ h\n\ngoal (1 subgoal):\n 1. 1 < height kdt - min_height kdt", "by simp"], ["proof (state)\nthis:\n  1 < height kdt - min_height kdt\n\ngoal (1 subgoal):\n 1. \\<not> KD_Tree.complete kdt \\<Longrightarrow> False", "hence \"\\<not> balanced kdt\""], ["proof (prove)\nusing this:\n  1 < height kdt - min_height kdt\n\ngoal (1 subgoal):\n 1. \\<not> balanced kdt", "using balanced_def"], ["proof (prove)\nusing this:\n  1 < height kdt - min_height kdt\n  balanced ?kdt = (height ?kdt - min_height ?kdt \\<le> 1)\n\ngoal (1 subgoal):\n 1. \\<not> balanced kdt", "by force"], ["proof (state)\nthis:\n  \\<not> balanced kdt\n\ngoal (1 subgoal):\n 1. \\<not> KD_Tree.complete kdt \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<not> balanced kdt\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<not> balanced kdt\n  balanced kdt\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem complete_build:\n  \"length ps = 2 ^ h \\<Longrightarrow> \\<forall>k. distinct (map (\\<lambda>p. p$k) ps) \\<Longrightarrow> complete (build k ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ps = 2 ^ h;\n     \\<forall>k. distinct (map (\\<lambda>p. p $ k) ps)\\<rbrakk>\n    \\<Longrightarrow> KD_Tree.complete (build k ps)", "by (simp add: balanced_build complete_if_balanced_size_2powh size_build)"], ["", "corollary height_build:\n  assumes \"length ps = 2 ^ h\" \"\\<forall>k. distinct (map (\\<lambda>p. p$k) ps)\"\n  shows \"h = height (build k ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = height (build k ps)", "using complete_build[OF assms] size_build[OF _ assms(2)]"], ["proof (prove)\nusing this:\n  KD_Tree.complete (build ?k ps)\n  0 < length ps \\<Longrightarrow>\n  KD_Tree.size_kdt (build ?ks ps) = length ps\n\ngoal (1 subgoal):\n 1. h = height (build k ps)", "by (simp add: assms(1) complete_iff_size)"], ["", "end"]]}