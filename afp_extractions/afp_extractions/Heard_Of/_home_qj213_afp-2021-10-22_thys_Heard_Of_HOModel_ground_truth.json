{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/HOModel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma consensus_then_weak_consensus:\n  assumes \"consensus vals dec rho\"\n  shows \"weak_consensus vals dec rho\"", "lemma binary_weak_consensus_then_consensus:\n  assumes bc: \"weak_consensus (vals::'proc \\<Rightarrow> bool) dec rho\"\n  shows \"consensus vals dec rho\"", "lemma HOinitConfig_eq:\n  \"HOinitConfig A cfg = (\\<forall>p. initState A p (cfg p))\"", "lemma SHOnextConfig_eq:\n  \"SHOnextConfig A r cfg HO SHO cfg' =\n   (\\<forall>p. \\<exists>\\<mu> \\<in> SHOmsgVectors A r p cfg (HO p) (SHO p).\n             nextState A r p (cfg p) \\<mu> (cfg' p))\"", "lemma SHORun_eq:\n  \"SHORun A rho HOs SHOs =\n     (HOinitConfig A (rho 0)\n   \\<and> (\\<forall>r. SHOnextConfig A r (rho r) (HOs r) (SHOs r) (rho (Suc r))))\"", "lemma SHOmsgVectors_HO:\n  \"SHOmsgVectors A r p cfg HO HO = {HOrcvdMsgs A r p HO cfg}\"", "lemma CHOnextConfig_eq:\n  \"CHOnextConfig A r cfg HO coord cfg' =\n   (\\<forall>p. CnextState A r p (cfg p) (HOrcvdMsgs A r p (HO p) cfg) \n                   (coord p) (cfg' p))\"", "lemma CHORun_eq:\n  \"CHORun A rho HOs coords = \n     (CHOinitConfig A (rho 0) (coords 0)\n      \\<and> (\\<forall>r. CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))))\"", "lemma HOnextConfig_eq:\n  \"HOnextConfig A r cfg HO cfg' =\n   (\\<forall>p. nextState A r p (cfg p) (HOrcvdMsgs A r p (HO p) cfg) (cfg' p))\"", "lemma HORun_eq:\n  \"HORun A rho HOs = \n   (  HOinitConfig A (rho 0)\n    \\<and> (\\<forall>r. HOnextConfig A r (rho r) (HOs r) (rho (Suc r))))\"", "lemma CHORun_0:\n  assumes \"CHORun A rho HOs coords\" \n      and \"\\<And>cfg. CHOinitConfig A cfg (coords 0) \\<Longrightarrow> P cfg\"\n  shows \"P (rho 0)\"", "lemma CHORun_Suc:\n  assumes \"CHORun A rho HOs coords\"\n  and \"\\<And>r. CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n            \\<Longrightarrow> P r\"\n  shows \"P n\"", "lemma CHORun_induct:\n  assumes run: \"CHORun A rho HOs coords\"\n  and init: \"CHOinitConfig A (rho 0) (coords 0) \\<Longrightarrow> P 0\"\n  and step: \"\\<And>r. \\<lbrakk> P r; CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) \n                                      (rho (Suc r)) \\<rbrakk> \\<Longrightarrow> P (Suc r)\"\n  shows \"P n\""], "translations": [["", "lemma consensus_then_weak_consensus:\n  assumes \"consensus vals dec rho\"\n  shows \"weak_consensus vals dec rho\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_consensus vals dec rho", "using assms"], ["proof (prove)\nusing this:\n  consensus vals dec rho\n\ngoal (1 subgoal):\n 1. weak_consensus vals dec rho", "by (auto simp: consensus_def weak_consensus_def image_def)"], ["", "text \\<open>\n  Over Boolean values (``binary Consensus''), \\<open>weak_consensus\\<close>\n  implies \\<open>consensus\\<close>, hence the two problems are equivalent.\n  In fact, this theorem holds more generally whenever at most two\n  different values are proposed initially (i.e., \\<open>card (range vals) \\<le> 2\\<close>).\n\\<close>"], ["", "lemma binary_weak_consensus_then_consensus:\n  assumes bc: \"weak_consensus (vals::'proc \\<Rightarrow> bool) dec rho\"\n  shows \"consensus vals dec rho\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consensus vals dec rho", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consensus vals dec rho", "{ \\<comment> \\<open>Show the Integrity property, the other conjuncts are the same.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. consensus vals dec rho", "fix n p v"], ["proof (state)\ngoal (1 subgoal):\n 1. consensus vals dec rho", "assume dec: \"dec (rho n p) = Some v\""], ["proof (state)\nthis:\n  dec (rho n p) = Some v\n\ngoal (1 subgoal):\n 1. consensus vals dec rho", "have \"v \\<in> range vals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> range vals", "proof (cases \"\\<exists>w. \\<forall>p. vals p = w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals\n 2. \\<nexists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals", "case True"], ["proof (state)\nthis:\n  \\<exists>w. \\<forall>p. vals p = w\n\ngoal (2 subgoals):\n 1. \\<exists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals\n 2. \\<nexists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals", "then"], ["proof (chain)\npicking this:\n  \\<exists>w. \\<forall>p. vals p = w", "obtain w where w: \"\\<forall>p. vals p = w\""], ["proof (prove)\nusing this:\n  \\<exists>w. \\<forall>p. vals p = w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>p. vals p = w \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>p. vals p = w\n\ngoal (2 subgoals):\n 1. \\<exists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals\n 2. \\<nexists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals", "with bc"], ["proof (chain)\npicking this:\n  weak_consensus vals dec rho\n  \\<forall>p. vals p = w", "have \"dec (rho n p) \\<in> {Some w, None}\""], ["proof (prove)\nusing this:\n  weak_consensus vals dec rho\n  \\<forall>p. vals p = w\n\ngoal (1 subgoal):\n 1. dec (rho n p) \\<in> {Some w, None}", "by (auto simp: weak_consensus_def)"], ["proof (state)\nthis:\n  dec (rho n p) \\<in> {Some w, None}\n\ngoal (2 subgoals):\n 1. \\<exists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals\n 2. \\<nexists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals", "with dec w"], ["proof (chain)\npicking this:\n  dec (rho n p) = Some v\n  \\<forall>p. vals p = w\n  dec (rho n p) \\<in> {Some w, None}", "show ?thesis"], ["proof (prove)\nusing this:\n  dec (rho n p) = Some v\n  \\<forall>p. vals p = w\n  dec (rho n p) \\<in> {Some w, None}\n\ngoal (1 subgoal):\n 1. v \\<in> range vals", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  v \\<in> range vals\n\ngoal (1 subgoal):\n 1. \\<nexists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals", "case False\n      \\<comment> \\<open>In this case both possible values occur in @{text \"vals\"}, and the result is trivial.\\<close>"], ["proof (state)\nthis:\n  \\<nexists>w. \\<forall>p. vals p = w\n\ngoal (1 subgoal):\n 1. \\<nexists>w. \\<forall>p. vals p = w \\<Longrightarrow> v \\<in> range vals", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>w. \\<forall>p. vals p = w\n\ngoal (1 subgoal):\n 1. v \\<in> range vals", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  v \\<in> range vals\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> range vals\n\ngoal (1 subgoal):\n 1. consensus vals dec rho", "}"], ["proof (state)\nthis:\n  dec (rho ?n2 ?p2) = Some ?v2 \\<Longrightarrow> ?v2 \\<in> range vals\n\ngoal (1 subgoal):\n 1. consensus vals dec rho", "note integrity = this"], ["proof (state)\nthis:\n  dec (rho ?n2 ?p2) = Some ?v2 \\<Longrightarrow> ?v2 \\<in> range vals\n\ngoal (1 subgoal):\n 1. consensus vals dec rho", "from bc"], ["proof (chain)\npicking this:\n  weak_consensus vals dec rho", "show ?thesis"], ["proof (prove)\nusing this:\n  weak_consensus vals dec rho\n\ngoal (1 subgoal):\n 1. consensus vals dec rho", "unfolding consensus_def weak_consensus_def"], ["proof (prove)\nusing this:\n  (\\<forall>v.\n      (\\<forall>p. vals p = v) \\<longrightarrow>\n      (\\<forall>n p w.\n          dec (rho n p) = Some w \\<longrightarrow> w = v)) \\<and>\n  (\\<forall>m n p q v w.\n      dec (rho m p) = Some v \\<and> dec (rho n q) = Some w \\<longrightarrow>\n      v = w) \\<and>\n  (\\<forall>p. \\<exists>n. dec (rho n p) \\<noteq> None)\n\ngoal (1 subgoal):\n 1. (\\<forall>n p v.\n        dec (rho n p) = Some v \\<longrightarrow> v \\<in> range vals) \\<and>\n    (\\<forall>m n p q v w.\n        dec (rho m p) = Some v \\<and>\n        dec (rho n q) = Some w \\<longrightarrow>\n        v = w) \\<and>\n    (\\<forall>p. \\<exists>n. dec (rho n p) \\<noteq> None)", "by (auto elim!: integrity)"], ["proof (state)\nthis:\n  consensus vals dec rho\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The algorithms that we are going to verify solve the Consensus or weak Consensus\n  problem, under different hypotheses about the kinds and number of faults.\n\\<close>"], ["", "subsection \\<open>A Generic Representation of Heard-Of Algorithms\\<close>"], ["", "text \\<open>\n  Charron-Bost and Schiper~\\cite{charron:heardof} introduce\n  the Heard-Of (HO) model for representing fault-tolerant\n  distributed algorithms. In this model, algorithms execute in communication-closed\n  rounds: at any round~$r$, processes only receive messages that were sent for\n  that round. For every process~$p$ and round~$r$, the ``heard-of set'' $HO(p,r)$\n  denotes the set of processes from which~$p$ receives a message in round~$r$.\n  Since every process is assumed to send a message to all processes in each round,\n  the complement of $HO(p,r)$ represents the set of faults that may affect~$p$ in\n  round~$r$ (messages that were not received, e.g. because the sender crashed,\n  because of a network problem etc.).\n\n  The HO model expresses hypotheses on the faults tolerated by an algorithm\n  through ``communication predicates'' that constrain the sets $HO(p,r)$\n  that may occur during an execution. Charron-Bost and Schiper show that\n  standard fault models can be represented in this form.\n\n  The original HO model is sufficient for representing algorithms\n  tolerating benign failures such as process crashes or message loss. A later\n  extension for algorithms tolerating Byzantine (or value) failures~\\cite{biely:tolerating} \n  adds a second collection of sets $SHO(p,r) \\subseteq HO(p,r)$ that contain those\n  processes $q$ from which process $p$ receives the message that $q$ was indeed\n  supposed to send for round $r$ according to the algorithm. In other words, \n  messages from processes in $HO(p,r) \\setminus SHO(p,r)$ were corrupted, be it\n  due to errors during message transmission or because of the sender was faulty or\n  lied deliberately. For both benign and Byzantine errors, the HO model registers\n  the fault but does not try to identify the faulty component (i.e., designate the\n  sending or receiving process, or the communication channel as the ``culprit'').\n\n  Executions of HO algorithms are defined with respect to collections\n  $HO(p,r)$ and $SHO(p,r)$. However, the code of a process does not have\n  access to these sets. In particular, process $p$ has no way of determining\n  if a message it received from another process $q$ corresponds to what $q$\n  should have sent or if it has been corrupted.\n\n  Certain algorithms rely on the assignment of ``coordinator'' processes for\n  each round. Just as the collections $HO(p,r)$, the definitions assume an\n  external coordinator assignment such that $coord(p,r)$ denotes the coordinator\n  of process $p$ and round $r$. Again, the correctness of algorithms may depend\n  on hypotheses about coordinator assignments -- e.g., it may be assumed that\n  processes agree sufficiently often on who the current coordinator is.\n\n  The following definitions provide a generic representation of HO and SHO algorithms\n  in Isabelle/HOL. A (coordinated) HO algorithm is described by the following parameters:\n  \\begin{itemize}\n  \\item a finite type \\<open>'proc\\<close> of processes,\n  \\item a type \\<open>'pst\\<close> of local process states,\n  \\item a type \\<open>'msg\\<close> of messages sent in the course of the algorithm,\n  \\item a predicate \\<open>CinitState\\<close> such that \\<open>CinitState p st crd\\<close> is\n    true precisely of the initial states \\<open>st\\<close> of process \\<open>p\\<close>, assuming\n    that \\<open>crd\\<close> is the initial coordinator of \\<open>p\\<close>,\n  \\item a function \\<open>sendMsg\\<close> where \\<open>sendMsg r p q st\\<close> yields\n    the message that process \\<open>p\\<close> sends to process \\<open>q\\<close> at round\n    \\<open>r\\<close>, given its local state \\<open>st\\<close>, and\n  \\item a predicate \\<open>CnextState\\<close> where \\<open>CnextState r p st msgs crd st'\\<close>\n    characterizes the successor states \\<open>st'\\<close> of process \\<open>p\\<close> at round\n    \\<open>r\\<close>, given current state \\<open>st\\<close>, the vector\n    \\<open>msgs :: 'proc \\<Rightarrow> 'msg option\\<close> of messages that \\<open>p\\<close> received at\n    round \\<open>r\\<close> (\\<open>msgs q = None\\<close> indicates that no message has been\n    received from process \\<open>q\\<close>),\n    and process \\<open>crd\\<close> as the coordinator for the following round.\n  \\end{itemize}\n  Note that every process can store the coordinator for the current round in its\n  local state, and it is therefore not necessary to make the coordinator a parameter\n  of the message sending function \\<open>sendMsg\\<close>.\n\n  We represent an algorithm by a record as follows.\n\\<close>"], ["", "record ('proc, 'pst, 'msg) CHOAlgorithm =\n  CinitState ::  \"'proc \\<Rightarrow> 'pst \\<Rightarrow> 'proc \\<Rightarrow> bool\"\n  sendMsg ::   \"nat \\<Rightarrow> 'proc \\<Rightarrow> 'proc \\<Rightarrow> 'pst \\<Rightarrow> 'msg\"\n  CnextState :: \"nat \\<Rightarrow> 'proc \\<Rightarrow> 'pst \\<Rightarrow> ('proc \\<Rightarrow> 'msg option) \\<Rightarrow> 'proc \\<Rightarrow> 'pst \\<Rightarrow> bool\""], ["", "text \\<open>\n  For non-coordinated HO algorithms, the coordinator argument of functions\n  \\<open>CinitState\\<close> and \\<open>CnextState\\<close> is irrelevant, and we\n  define utility functions that omit that argument.\n\\<close>"], ["", "definition isNCAlgorithm where\n  \"isNCAlgorithm alg \\<equiv> \n      (\\<forall>p st crd crd'. CinitState alg p st crd = CinitState alg p st crd')\n   \\<and> (\\<forall>r p st msgs crd crd' st'. CnextState alg r p st msgs crd st'\n                               = CnextState alg r p st msgs crd' st')\""], ["", "definition initState where\n  \"initState alg p st \\<equiv> CinitState alg p st undefined\""], ["", "definition nextState where\n  \"nextState alg r p st msgs st' \\<equiv> CnextState alg r p st msgs undefined st'\""], ["", "text \\<open>\n  A \\emph{heard-of assignment} associates a set of processes with each\n  process. The following type is used to represent the collections $HO(p,r)$\n  and $SHO(p,r)$ for fixed round $r$.\n%\n  Similarly, a \\emph{coordinator assignment} associates a process (its coordinator)\n  to each process.\n\\<close>"], ["", "type_synonym\n  'proc HO = \"'proc \\<Rightarrow> 'proc set\""], ["", "type_synonym\n  'proc coord = \"'proc \\<Rightarrow> 'proc\""], ["", "text \\<open>\n  An execution of an HO algorithm is defined with respect to HO and SHO\n  assignments that indicate, for every round \\<open>r\\<close> and every process \\<open>p\\<close>,\n  from which sender processes \\<open>p\\<close> receives messages (resp., uncorrupted\n  messages) at round \\<open>r\\<close>.\n\n%% That's the intention, but we don't enforce this in the definitions.\n%  Obviously, SHO sets are always included in HO sets, for the same process and round.\n\n  The following definitions formalize this idea. We define ``coarse-grained''\n  executions whose unit of atomicity is the round of execution. At each round,\n  the entire collection of processes performs a transition according to the\n  \\<open>CnextState\\<close> function of the algorithm. Consequently, a system state is\n  simply described by a configuration, i.e. a function assigning a process state\n  to every process. This definition of executions may appear surprising for an\n  asynchronous distributed system, but it simplifies system verification,\n  compared to a ``fine-grained'' execution model that records individual events\n  such as message sending and reception or local transitions. We will justify\n  later why the ``coarse-grained'' model is sufficient for verifying interesting\n  correctness properties of HO algorithms.\n\n  The predicate \\<open>CSHOinitConfig\\<close> describes the possible initial configurations\n  for algorithm \\<open>A\\<close> (remember that a configuration is a function that assigns\n  local states to every process).\n\\<close>"], ["", "definition CHOinitConfig where\n  \"CHOinitConfig A cfg (coord::'proc coord) \\<equiv> \\<forall>p. CinitState A p (cfg p) (coord p)\""], ["", "text \\<open>\n  Given the current configuration \\<open>cfg\\<close> and the HO and SHO sets \\<open>HOp\\<close>\n  and \\<open>SHOp\\<close> for process \\<open>p\\<close> at round \\<open>r\\<close>, the function\n  \\<open>SHOmsgVectors\\<close> computes the set of possible vectors of messages that\n  process \\<open>p\\<close> may receive. For processes \\<open>q \\<notin> HOp\\<close>, \\<open>p\\<close> \n  receives no message (represented as value \\<open>None\\<close>). For processes\n  \\<open>q \\<in> SHOp\\<close>, \\<open>p\\<close> receives the message that \\<open>q\\<close> computed\n  according to the \\<open>sendMsg\\<close> function of the algorithm. For the remaining\n  processes \\<open>q \\<in> HOp - SHOp\\<close>, \\<open>p\\<close> may receive some arbitrary value.\n\\<close>"], ["", "definition SHOmsgVectors where\n  \"SHOmsgVectors A r p cfg HOp SHOp \\<equiv>\n   {\\<mu>. (\\<forall>q. q \\<in> HOp \\<longleftrightarrow> \\<mu> q \\<noteq> None)\n     \\<and> (\\<forall>q. q \\<in> SHOp \\<inter> HOp \\<longrightarrow> \\<mu> q = Some (sendMsg A r q p (cfg q)))}\""], ["", "text \\<open>\n  Predicate \\<open>CSHOnextConfig\\<close> uses the preceding function and the algorithm's\n  \\<open>CnextState\\<close> function to characterize the possible successor configurations\n  in a coarse-grained step, and predicate \\<open>CSHORun\\<close> defines (coarse-grained)\n  executions \\<open>rho\\<close> of an HO algorithm.\n\\<close>"], ["", "definition CSHOnextConfig where\n  \"CSHOnextConfig A r cfg HO SHO coord cfg' \\<equiv>\n   \\<forall>p. \\<exists>\\<mu> \\<in> SHOmsgVectors A r p cfg (HO p) (SHO p).\n          CnextState A r p (cfg p) \\<mu> (coord p) (cfg' p)\""], ["", "definition CSHORun where\n  \"CSHORun A rho HOs SHOs coords \\<equiv>\n     CHOinitConfig A (rho 0) (coords 0)\n   \\<and> (\\<forall>r. CSHOnextConfig A r (rho r) (HOs r) (SHOs r) (coords (Suc r))\n                             (rho (Suc r)))\""], ["", "text \\<open>\n  For non-coordinated algorithms. the \\<open>coord\\<close> arguments of the above functions\n  are irrelevant. We define similar functions that omit that argument, and relate\n  them to the above utility functions for these algorithms.\n\\<close>"], ["", "definition HOinitConfig where\n  \"HOinitConfig A cfg \\<equiv> CHOinitConfig A cfg (\\<lambda>q. undefined)\""], ["", "lemma HOinitConfig_eq:\n  \"HOinitConfig A cfg = (\\<forall>p. initState A p (cfg p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOinitConfig A cfg = (\\<forall>p. initState A p (cfg p))", "by (auto simp: HOinitConfig_def CHOinitConfig_def initState_def)"], ["", "definition SHOnextConfig where\n  \"SHOnextConfig A r cfg HO SHO cfg' \\<equiv>\n   CSHOnextConfig A r cfg HO SHO (\\<lambda>q. undefined) cfg'\""], ["", "lemma SHOnextConfig_eq:\n  \"SHOnextConfig A r cfg HO SHO cfg' =\n   (\\<forall>p. \\<exists>\\<mu> \\<in> SHOmsgVectors A r p cfg (HO p) (SHO p).\n             nextState A r p (cfg p) \\<mu> (cfg' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SHOnextConfig A r cfg HO SHO cfg' =\n    (\\<forall>p.\n        \\<exists>\\<mu>\\<in>SHOmsgVectors A r p cfg (HO p) (SHO p).\n           nextState A r p (cfg p) \\<mu> (cfg' p))", "by (auto simp: SHOnextConfig_def CSHOnextConfig_def SHOmsgVectors_def nextState_def)"], ["", "definition SHORun where\n  \"SHORun A rho HOs SHOs \\<equiv>\n   CSHORun A rho HOs SHOs (\\<lambda>r q. undefined)\""], ["", "lemma SHORun_eq:\n  \"SHORun A rho HOs SHOs =\n     (HOinitConfig A (rho 0)\n   \\<and> (\\<forall>r. SHOnextConfig A r (rho r) (HOs r) (SHOs r) (rho (Suc r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SHORun A rho HOs SHOs =\n    (HOinitConfig A (rho 0) \\<and>\n     (\\<forall>r. SHOnextConfig A r (rho r) (HOs r) (SHOs r) (rho (Suc r))))", "by (auto simp: SHORun_def CSHORun_def HOinitConfig_def SHOnextConfig_def)"], ["", "text \\<open>\n  Algorithms designed to tolerate benign failures are not subject to\n  message corruption, and therefore the SHO sets are irrelevant (more formally,\n  each SHO set equals the corresponding HO set). We define corresponding\n  special cases of the definitions of successor configurations and of runs,\n  and prove that these are equivalent to simpler definitions that will be more\n  useful in proofs. In particular, the vector of messages received by a process\n  in a benign execution is uniquely determined from the current configuration\n  and the HO sets.\n\\<close>"], ["", "definition HOrcvdMsgs where\n  \"HOrcvdMsgs A r p HO cfg \\<equiv>\n   \\<lambda>q. if q \\<in> HO then Some (sendMsg A r q p (cfg q)) else None\""], ["", "lemma SHOmsgVectors_HO:\n  \"SHOmsgVectors A r p cfg HO HO = {HOrcvdMsgs A r p HO cfg}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SHOmsgVectors A r p cfg HO HO = {HOrcvdMsgs A r p HO cfg}", "unfolding SHOmsgVectors_def HOrcvdMsgs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<mu>.\n     (\\<forall>q. (q \\<in> HO) = (\\<mu> q \\<noteq> None)) \\<and>\n     (\\<forall>q.\n         q \\<in> HO \\<inter> HO \\<longrightarrow>\n         \\<mu> q = Some (sendMsg A r q p (cfg q)))} =\n    {\\<lambda>q.\n        if q \\<in> HO then Some (sendMsg A r q p (cfg q)) else None}", "by auto"], ["", "text \\<open>With coordinators\\<close>"], ["", "definition CHOnextConfig where\n  \"CHOnextConfig A r cfg HO coord cfg' \\<equiv> \n   CSHOnextConfig A r cfg HO HO coord cfg'\""], ["", "lemma CHOnextConfig_eq:\n  \"CHOnextConfig A r cfg HO coord cfg' =\n   (\\<forall>p. CnextState A r p (cfg p) (HOrcvdMsgs A r p (HO p) cfg) \n                   (coord p) (cfg' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHOnextConfig A r cfg HO coord cfg' =\n    (\\<forall>p.\n        CnextState A r p (cfg p) (HOrcvdMsgs A r p (HO p) cfg) (coord p)\n         (cfg' p))", "by (auto simp: CHOnextConfig_def CSHOnextConfig_def SHOmsgVectors_HO)"], ["", "definition CHORun where\n  \"CHORun A rho HOs coords \\<equiv> CSHORun A rho HOs HOs coords\""], ["", "lemma CHORun_eq:\n  \"CHORun A rho HOs coords = \n     (CHOinitConfig A (rho 0) (coords 0)\n      \\<and> (\\<forall>r. CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CHORun A rho HOs coords =\n    (CHOinitConfig A (rho 0) (coords 0) \\<and>\n     (\\<forall>r.\n         CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))))", "by (auto simp: CHORun_def CSHORun_def CHOinitConfig_def CHOnextConfig_def)"], ["", "text \\<open>Without coordinators\\<close>"], ["", "definition HOnextConfig where\n  \"HOnextConfig A r cfg HO cfg' \\<equiv> SHOnextConfig A r cfg HO HO cfg'\""], ["", "lemma HOnextConfig_eq:\n  \"HOnextConfig A r cfg HO cfg' =\n   (\\<forall>p. nextState A r p (cfg p) (HOrcvdMsgs A r p (HO p) cfg) (cfg' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOnextConfig A r cfg HO cfg' =\n    (\\<forall>p.\n        nextState A r p (cfg p) (HOrcvdMsgs A r p (HO p) cfg) (cfg' p))", "by (auto simp: HOnextConfig_def SHOnextConfig_eq SHOmsgVectors_HO)"], ["", "definition HORun where\n  \"HORun A rho HOs \\<equiv> SHORun A rho HOs HOs\""], ["", "lemma HORun_eq:\n  \"HORun A rho HOs = \n   (  HOinitConfig A (rho 0)\n    \\<and> (\\<forall>r. HOnextConfig A r (rho r) (HOs r) (rho (Suc r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HORun A rho HOs =\n    (HOinitConfig A (rho 0) \\<and>\n     (\\<forall>r. HOnextConfig A r (rho r) (HOs r) (rho (Suc r))))", "by (auto simp: HORun_def SHORun_eq HOnextConfig_def)"], ["", "text \\<open>\n  The following derived proof rules are immediate consequences of\n  the definition of \\<open>CHORun\\<close>; they simplify automatic reasoning.\n\\<close>"], ["", "lemma CHORun_0:\n  assumes \"CHORun A rho HOs coords\" \n      and \"\\<And>cfg. CHOinitConfig A cfg (coords 0) \\<Longrightarrow> P cfg\"\n  shows \"P (rho 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (rho 0)", "using assms"], ["proof (prove)\nusing this:\n  CHORun A rho HOs coords\n  CHOinitConfig A ?cfg (coords 0) \\<Longrightarrow> P ?cfg\n\ngoal (1 subgoal):\n 1. P (rho 0)", "unfolding CHORun_eq"], ["proof (prove)\nusing this:\n  CHOinitConfig A (rho 0) (coords 0) \\<and>\n  (\\<forall>r.\n      CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r)))\n  CHOinitConfig A ?cfg (coords 0) \\<Longrightarrow> P ?cfg\n\ngoal (1 subgoal):\n 1. P (rho 0)", "by blast"], ["", "lemma CHORun_Suc:\n  assumes \"CHORun A rho HOs coords\"\n  and \"\\<And>r. CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n            \\<Longrightarrow> P r\"\n  shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "using assms"], ["proof (prove)\nusing this:\n  CHORun A rho HOs coords\n  CHOnextConfig A ?r (rho ?r) (HOs ?r) (coords (Suc ?r))\n   (rho (Suc ?r)) \\<Longrightarrow>\n  P ?r\n\ngoal (1 subgoal):\n 1. P n", "unfolding CHORun_eq"], ["proof (prove)\nusing this:\n  CHOinitConfig A (rho 0) (coords 0) \\<and>\n  (\\<forall>r.\n      CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r)))\n  CHOnextConfig A ?r (rho ?r) (HOs ?r) (coords (Suc ?r))\n   (rho (Suc ?r)) \\<Longrightarrow>\n  P ?r\n\ngoal (1 subgoal):\n 1. P n", "by blast"], ["", "lemma CHORun_induct:\n  assumes run: \"CHORun A rho HOs coords\"\n  and init: \"CHOinitConfig A (rho 0) (coords 0) \\<Longrightarrow> P 0\"\n  and step: \"\\<And>r. \\<lbrakk> P r; CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) \n                                      (rho (Suc r)) \\<rbrakk> \\<Longrightarrow> P (Suc r)\"\n  shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "using run"], ["proof (prove)\nusing this:\n  CHORun A rho HOs coords\n\ngoal (1 subgoal):\n 1. P n", "unfolding CHORun_eq"], ["proof (prove)\nusing this:\n  CHOinitConfig A (rho 0) (coords 0) \\<and>\n  (\\<forall>r.\n      CHOnextConfig A r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r)))\n\ngoal (1 subgoal):\n 1. P n", "by (induct n, auto elim: init step)"], ["", "text \\<open>\n  Because algorithms will not operate for arbitrary HO, SHO, and coordinator\n  assignments, these are constrained by a \\emph{communication predicate}.\n  For convenience, we split this predicate into a \\emph{per Round} part that\n  is expected to hold at every round and a \\emph{global} part that must hold\n  of the sequence of (S)HO assignments and may thus express liveness assumptions.\n\n  In the parlance of~\\cite{charron:heardof}, a \\emph{HO machine} is an HO algorithm\n  augmented with a communication predicate. We therefore define (C)(S)HO machines as\n  the corresponding extensions of the record defining an HO algorithm.\n\\<close>"], ["", "record ('proc, 'pst, 'msg) HOMachine = \"('proc, 'pst, 'msg) CHOAlgorithm\" +\n  HOcommPerRd::\"'proc HO \\<Rightarrow> bool\"\n  HOcommGlobal::\"(nat \\<Rightarrow> 'proc HO) \\<Rightarrow> bool\""], ["", "record ('proc, 'pst, 'msg) CHOMachine = \"('proc, 'pst, 'msg) CHOAlgorithm\" +\n  CHOcommPerRd::\"nat \\<Rightarrow> 'proc HO \\<Rightarrow> 'proc coord \\<Rightarrow> bool\"\n  CHOcommGlobal::\"(nat \\<Rightarrow> 'proc HO) \\<Rightarrow> (nat \\<Rightarrow> 'proc coord) \\<Rightarrow> bool\""], ["", "record ('proc, 'pst, 'msg) SHOMachine = \"('proc, 'pst, 'msg) CHOAlgorithm\" +\n  SHOcommPerRd::\"('proc HO) \\<Rightarrow> ('proc HO) \\<Rightarrow> bool\"\n  SHOcommGlobal::\"(nat \\<Rightarrow> 'proc HO) \\<Rightarrow> (nat \\<Rightarrow> 'proc HO) \\<Rightarrow> bool\""], ["", "record ('proc, 'pst, 'msg) CSHOMachine = \"('proc, 'pst, 'msg) CHOAlgorithm\" +\n  CSHOcommPerRd::\"('proc HO) \\<Rightarrow> ('proc HO) \\<Rightarrow> 'proc coord \\<Rightarrow> bool\"\n  CSHOcommGlobal::\"(nat \\<Rightarrow> 'proc HO) \\<Rightarrow> (nat \\<Rightarrow> 'proc HO)\n                                     \\<Rightarrow> (nat \\<Rightarrow> 'proc coord) \\<Rightarrow> bool\""], ["", "end \\<comment> \\<open>theory HOModel\\<close>"]]}