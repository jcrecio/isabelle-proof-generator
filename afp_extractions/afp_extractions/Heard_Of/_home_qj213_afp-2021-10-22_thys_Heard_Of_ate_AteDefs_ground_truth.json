{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/ate/AteDefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma majE: \"2 * (E - \\<alpha>) \\<ge> N\"", "lemma Egta: \"E > \\<alpha>\"", "lemma Tge2a: \"T \\<ge> 2 * \\<alpha>\""], "translations": [["", "lemma majE: \"2 * (E - \\<alpha>) \\<ge> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<le> 2 * (E - \\<alpha>)", "using TNaE TltN"], ["proof (prove)\nusing this:\n  2 * (N + 2 * \\<alpha> - E) \\<le> T\n  T < N\n\ngoal (1 subgoal):\n 1. N \\<le> 2 * (E - \\<alpha>)", "by auto"], ["", "lemma Egta: \"E > \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < E", "using majE EltN"], ["proof (prove)\nusing this:\n  N \\<le> 2 * (E - \\<alpha>)\n  E < N\n\ngoal (1 subgoal):\n 1. \\<alpha> < E", "by auto"], ["", "lemma Tge2a: \"T \\<ge> 2 * \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * \\<alpha> \\<le> T", "using TNaE EltN"], ["proof (prove)\nusing this:\n  2 * (N + 2 * \\<alpha> - E) \\<le> T\n  E < N\n\ngoal (1 subgoal):\n 1. 2 * \\<alpha> \\<le> T", "by auto"], ["", "text \\<open>\n  At every round, each process sends its current \\<open>x\\<close>.\n  If it received more than \\<open>T\\<close> messages, it selects the smallest value\n  and store it in \\<open>x\\<close>. As in algorithm \\emph{OneThirdRule}, we\n  therefore require values to be linearly ordered.\n\n  If more than \\<open>E\\<close> messages holding the same value are received,\n  the process decides that value.\n\\<close>"], ["", "definition mostOftenRcvd where\n  \"mostOftenRcvd (msgs::Proc \\<Rightarrow> 'val option) \\<equiv>\n   {v. \\<forall>w. card {qq. msgs qq = Some w} \\<le> card {qq. msgs qq = Some v}}\""], ["", "definition \n  Ate_sendMsg :: \"nat \\<Rightarrow> Proc \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> 'val\"\nwhere\n  \"Ate_sendMsg r p q st \\<equiv> x st\""], ["", "definition\n  Ate_nextState :: \"nat \\<Rightarrow> Proc \\<Rightarrow> ('val::linorder) pstate \\<Rightarrow> (Proc \\<Rightarrow> 'val option)\n                        \\<Rightarrow> 'val pstate \\<Rightarrow> bool\"\nwhere\n  \"Ate_nextState r p st msgs st' \\<equiv>\n     (if card {q. msgs q \\<noteq> None} > T\n      then x st' = Min (mostOftenRcvd msgs)\n      else x st' = x st)\n   \\<and> (   (\\<exists>v. card {q. msgs q = Some v} > E  \\<and> decide st' = Some v)\n       \\<or> \\<not> (\\<exists>v. card {q. msgs q = Some v} > E) \n         \\<and> decide st' = decide st)\""], ["", "subsection \\<open>Communication Predicate for \\ate{}\\<close>"], ["", "text \\<open>\n  Following~\\cite{biely:tolerating}, we now define the communication\n  predicate for the \\ate{} algorithm. The round-by-round predicate\n  requires that no process may receive more than \\<open>\\<alpha>\\<close> corrupted\n  messages at any round.\n\\<close>"], ["", "definition Ate_commPerRd where\n  \"Ate_commPerRd HOrs SHOrs \\<equiv>\n   \\<forall>p. card (HOrs p - SHOrs p) \\<le> \\<alpha>\""], ["", "text \\<open>\n  The global communication predicate stipulates the three following\n  conditions:\n  \\begin{itemize}\n  \\item for every process \\<open>p\\<close> there are infinitely many rounds \n    where \\<open>p\\<close> receives more than \\<open>T\\<close> messages,\n  \\item for every process \\<open>p\\<close> there are infinitely many rounds \n    where \\<open>p\\<close> receives more than \\<open>E\\<close> uncorrupted messages,\n  \\item and there are infinitely many rounds in which more than\n    \\<open>E - \\<alpha>\\<close> processes receive uncorrupted messages from the\n    same set of processes, which contains more than \\<open>T\\<close> processes.\n  \\end{itemize}\n\\<close>"], ["", "definition\n  Ate_commGlobal where\n  \"Ate_commGlobal HOs SHOs \\<equiv>\n     (\\<forall>r p. \\<exists>r' > r. card (HOs r' p) > T)\n   \\<and> (\\<forall>r p.  \\<exists>r' > r. card (SHOs r' p \\<inter> HOs r' p) > E)\n   \\<and> (\\<forall>r. \\<exists>r' > r. \\<exists>\\<pi>1 \\<pi>2.\n        card \\<pi>1 > E - \\<alpha>\n      \\<and> card \\<pi>2 > T\n      \\<and> (\\<forall>p \\<in> \\<pi>1. HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2))\""], ["", "subsection \\<open>The \\ate{} Heard-Of Machine\\<close>"], ["", "text \\<open>\n  We now define the non-coordinated SHO machine for the \\ate{} algorithm\n  by assembling the algorithm definition and its communication-predicate.\n\\<close>"], ["", "definition Ate_SHOMachine where\n  \"Ate_SHOMachine = \\<lparr> \n    CinitState =  (\\<lambda> p st crd. Ate_initState p (st::('val::linorder) pstate)),\n    sendMsg =  Ate_sendMsg,\n    CnextState = (\\<lambda> r p st msgs crd st'. Ate_nextState r p st msgs st'),\n    SHOcommPerRd = (Ate_commPerRd:: Proc HO \\<Rightarrow> Proc HO \\<Rightarrow> bool),\n    SHOcommGlobal = Ate_commGlobal\n   \\<rparr>\""], ["", "abbreviation\n  \"Ate_M \\<equiv> (Ate_SHOMachine::(Proc, 'val::linorder pstate, 'val) SHOMachine)\""], ["", "end   \\<comment> \\<open>locale @{text \"ate_parameters\"}\\<close>"], ["", "end"], ["", "(* theory AteDefs *)"]]}