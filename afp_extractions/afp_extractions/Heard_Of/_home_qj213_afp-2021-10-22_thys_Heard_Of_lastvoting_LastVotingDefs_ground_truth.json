{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/lastvoting/LastVotingDefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma phase_zero [simp]: \"phase 0 = 0\"", "lemma step_zero [simp]: \"step 0 = 0\"", "lemma phase_step: \"(phase r * 4) + step r = r\""], "translations": [["", "lemma phase_zero [simp]: \"phase 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phase 0 = 0", "by (simp add: phase_def)"], ["", "lemma step_zero [simp]: \"step 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step 0 = 0", "by (simp add: step_def)"], ["", "lemma phase_step: \"(phase r * 4) + step r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phase r * 4 + step r = r", "by (auto simp add: phase_def step_def)"], ["", "text \\<open>\n  The following record models the local state of a process.\n\\<close>"], ["", "record 'val pstate =\n  x :: 'val                \\<comment> \\<open>current value held by process\\<close>\n  vote :: \"'val option\"    \\<comment> \\<open>value the process voted for, if any\\<close>\n  commt :: bool            \\<comment> \\<open>did the process commit to the vote?\\<close>\n  ready :: bool            \\<comment> \\<open>for coordinators: did the round finish successfully?\\<close>\n  timestamp :: nat         \\<comment> \\<open>time stamp of current value\\<close>\n  decide :: \"'val option\"  \\<comment> \\<open>value the process has decided on, if any\\<close>\n  coord\\<Phi> :: Proc           \\<comment> \\<open>coordinator for current phase\\<close>"], ["", "text \\<open>\n  Possible messages sent during the execution of the algorithm.\n\\<close>"], ["", "datatype 'val msg =\n  ValStamp \"'val\" \"nat\"\n| Vote \"'val\"\n| Ack\n| Null  \\<comment> \\<open>dummy message in case nothing needs to be sent\\<close>"], ["", "text \\<open>\n  Characteristic predicates on messages.\n\\<close>"], ["", "definition isValStamp where \"isValStamp m \\<equiv> \\<exists>v ts. m = ValStamp v ts\""], ["", "definition isVote where \"isVote m \\<equiv> \\<exists>v. m = Vote v\""], ["", "definition isAck where \"isAck m \\<equiv> m = Ack\""], ["", "text \\<open>\n  Selector functions to retrieve components of messages. These functions\n  have a meaningful result only when the message is of an appropriate kind.\n\\<close>"], ["", "fun val where\n  \"val (ValStamp v ts) = v\"\n| \"val (Vote v) = v\""], ["", "fun stamp where\n  \"stamp (ValStamp v ts) = ts\""], ["", "text \\<open>\n  The \\<open>x\\<close> field of the initial state is unconstrained, all other\n  fields are initialized appropriately.\n\\<close>"], ["", "definition LV_initState where\n  \"LV_initState p st crd \\<equiv>\n     vote st = None\n   \\<and> \\<not>(commt st)\n   \\<and> \\<not>(ready st)\n   \\<and> timestamp st = 0\n   \\<and> decide st = None\n   \\<and> coord\\<Phi> st = crd\""], ["", "text \\<open>\n  We separately define the transition predicates and the send functions\n  for each step and later combine them to define the overall next-state relation.\n\\<close>\n\n\\<comment> \\<open>processes from which values and timestamps were received\\<close>"], ["", "definition valStampsRcvd where\n  \"valStampsRcvd (msgs :: Proc \\<rightharpoonup> 'val msg) \\<equiv>\n   {q . \\<exists>v ts. msgs q = Some (ValStamp v ts)}\""], ["", "definition highestStampRcvd where\n  \"highestStampRcvd msgs \\<equiv> \n   Max {ts . \\<exists>q v. (msgs::Proc \\<rightharpoonup> 'val msg) q = Some (ValStamp v ts)}\""], ["", "text \\<open>\n  In step 0, each process sends its current \\<open>x\\<close> and \\<open>timestamp\\<close>\n  values to its coordinator.\n\n  A process that considers itself to be a coordinator updates its\n  \\<open>vote\\<close> field if it has received messages from a majority of processes.\n  It then sets its \\<open>commt\\<close> field to true.\n\\<close>"], ["", "definition send0 where\n  \"send0 r p q st \\<equiv>\n   if q = coord\\<Phi> st then ValStamp (x st) (timestamp st) else Null\""], ["", "definition next0 where\n  \"next0 r p st msgs crd st' \\<equiv>\n      if p = coord\\<Phi> st \\<and> card (valStampsRcvd msgs) > N div 2\n      then (\\<exists>p v. msgs p = Some (ValStamp v (highestStampRcvd msgs))\n                \\<and> st' = st \\<lparr> vote := Some v, commt := True \\<rparr> )\n      else st' = st\""], ["", "text \\<open>\n  In step 1, coordinators that have committed send their vote to all\n  processes.\n\n  Processes update their \\<open>x\\<close> and \\<open>timestamp\\<close> fields if they\n  have received a vote from their coordinator.\n\\<close>"], ["", "definition send1 where\n  \"send1 r p q st \\<equiv>\n   if p = coord\\<Phi> st \\<and> commt st then Vote (the (vote st)) else Null\""], ["", "definition next1 where\n  \"next1 r p st msgs crd st' \\<equiv>\n   if msgs (coord\\<Phi> st) \\<noteq> None \\<and> isVote (the (msgs (coord\\<Phi> st)))\n   then st' = st \\<lparr> x := val (the (msgs (coord\\<Phi> st))), timestamp := Suc(phase r) \\<rparr>\n   else st' = st\""], ["", "text \\<open>\n  In step 2, processes that have current timestamps send an acknowledgement\n  to their coordinator.\n\n  A coordinator sets its \\<open>ready\\<close> field to true if it receives a majority\n  of acknowledgements.\n\\<close>"], ["", "definition send2 where\n  \"send2 r p q st \\<equiv>\n   if timestamp st = Suc(phase r) \\<and> q = coord\\<Phi> st then Ack else Null\"\n\n\\<comment> \\<open>processes from which an acknowledgement was received\\<close>"], ["", "definition acksRcvd where\n  \"acksRcvd (msgs :: Proc \\<rightharpoonup> 'val msg) \\<equiv>\n   { q . msgs q \\<noteq> None \\<and> isAck (the (msgs q)) }\""], ["", "definition next2 where\n  \"next2 r p st msgs crd st' \\<equiv>\n   if p = coord\\<Phi> st \\<and> card (acksRcvd msgs) > N div 2\n   then st' = st \\<lparr> ready := True \\<rparr>\n   else st' = st\""], ["", "text \\<open>\n  In step 3, coordinators that are ready send their vote to all processes.\n\n  Processes that received a vote from their coordinator decide on that value.\n  Coordinators reset their \\<open>ready\\<close> and \\<open>commt\\<close> fields to false.\n  All processes reset the coordinators as indicated by the parameter of\n  the operator.\n\\<close>"], ["", "definition send3 where\n  \"send3 r p q st \\<equiv>\n   if p = coord\\<Phi> st \\<and> ready st then Vote (the (vote st)) else Null\""], ["", "definition next3 where\n  \"next3 r p st msgs crd st' \\<equiv>\n      (if msgs (coord\\<Phi> st) \\<noteq> None \\<and> isVote (the (msgs (coord\\<Phi> st)))\n       then decide st' = Some (val (the (msgs (coord\\<Phi> st))))\n       else decide st' = decide st)\n   \\<and> (if p = coord\\<Phi> st\n      then \\<not>(ready st') \\<and> \\<not>(commt st')\n      else ready st' = ready st \\<and> commt st' = commt st)\n   \\<and> x st' = x st\n   \\<and> vote st' = vote st\n   \\<and> timestamp st' = timestamp st\n   \\<and> coord\\<Phi> st' = crd\""], ["", "text \\<open>\n  The overall send function and next-state relation are simply obtained as\n  the composition of the individual relations defined above.\n\\<close>"], ["", "definition LV_sendMsg :: \"nat \\<Rightarrow> Proc \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> 'val msg\" where\n  \"LV_sendMsg (r::nat) \\<equiv>\n   if step r = 0 then send0 r\n   else if step r = 1 then send1 r\n   else if step r = 2 then send2 r\n   else send3 r\""], ["", "definition\n  LV_nextState :: \"nat \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> (Proc \\<rightharpoonup> 'val msg) \n                       \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> bool\"\n  where\n  \"LV_nextState r \\<equiv>\n   if step r = 0 then next0 r\n   else if step r = 1 then next1 r\n   else if step r = 2 then next2 r\n   else next3 r\""], ["", "subsection \\<open>Communication Predicate for \\emph{LastVoting}\\<close>"], ["", "text \\<open>\n  We now define the communication predicate that will be assumed for the\n  correctness proof of the \\emph{LastVoting} algorithm.\n  The ``per-round'' part is trivial: integrity and agreement are always ensured.\n\n  For the ``global'' part, Charron-Bost and Schiper propose a predicate\n  that requires the existence of infinitely many phases \\<open>ph\\<close> such that:\n  \\begin{itemize}\n  \\item all processes agree on the same coordinator \\<open>c\\<close>,\n  \\item \\<open>c\\<close> hears from a strict majority of processes in steps 0 and 2\n    of phase \\<open>ph\\<close>, and\n  \\item every process hears from \\<open>c\\<close> in steps 1 and 3 (this is slightly\n    weaker than the predicate that appears in~\\cite{charron:heardof}, but\n    obviously sufficient).\n  \\end{itemize}\n\n  Instead of requiring infinitely many such phases, we only assume the\n  existence of one such phase (Charron-Bost and Schiper note that this is enough.)\n\\<close>"], ["", "definition\n  LV_commPerRd where\n  \"LV_commPerRd r (HO::Proc HO) (coord::Proc coord) \\<equiv> True\""], ["", "definition\n  LV_commGlobal where\n  \"LV_commGlobal HOs coords \\<equiv>\n      \\<exists>ph::nat. \\<exists>c::Proc.\n           (\\<forall>p. coords (4*ph) p = c)\n         \\<and> card (HOs (4*ph) c) > N div 2\n         \\<and> card (HOs (4*ph+2) c) > N div 2\n         \\<and> (\\<forall>p. c \\<in> HOs (4*ph+1) p \\<inter> HOs (4*ph+3) p)\""], ["", "subsection \\<open>The \\emph{LastVoting} Heard-Of Machine\\<close>"], ["", "text \\<open>\n  We now define the coordinated HO machine for the \\emph{LastVoting} algorithm\n  by assembling the algorithm definition and its communication-predicate.\n\\<close>"], ["", "definition LV_CHOMachine where\n  \"LV_CHOMachine \\<equiv>\n    \\<lparr> CinitState = LV_initState,\n      sendMsg = LV_sendMsg,\n      CnextState = LV_nextState,\n      CHOcommPerRd = LV_commPerRd,\n      CHOcommGlobal = LV_commGlobal \\<rparr>\""], ["", "abbreviation \n  \"LV_M \\<equiv> (LV_CHOMachine::(Proc, 'val pstate, 'val msg) CHOMachine)\""], ["", "end"]]}