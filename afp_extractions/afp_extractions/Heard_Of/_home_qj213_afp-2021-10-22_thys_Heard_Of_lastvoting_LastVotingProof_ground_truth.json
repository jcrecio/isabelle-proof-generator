{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/lastvoting/LastVotingProof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma timeStampsRcvdFinite:\n  \"finite {ts . \\<exists>q v. (msgs::Proc \\<rightharpoonup> 'val msg) q = Some (ValStamp v ts)}\"\n  (is \"finite ?ts\")", "lemma highestStampRcvd_exists:\n  assumes nempty: \"valStampsRcvd msgs \\<noteq> {}\"\n  obtains p v where \"msgs p = Some (ValStamp v (highestStampRcvd msgs))\"", "lemma highestStampRcvd_max:\n  assumes \"msgs p = Some (ValStamp v ts)\"\n  shows \"ts \\<le> highestStampRcvd msgs\"", "lemma phase_Suc:\n  \"phase (Suc r) = (if step r = 3 then Suc (phase r)\n                   else phase r)\"", "lemma LV_induct:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and init: \"\\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow> P 0\"\n  and step0: \"\\<And>r.\n                  \\<lbrakk> step r = 0; P r; phase (Suc r) = phase r; step (Suc r) = 1;\n                    \\<forall>p. next0 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  and step1: \"\\<And>r.\n                  \\<lbrakk> step r = 1; P r; phase (Suc r) = phase r; step (Suc r) = 2;\n                    \\<forall>p. next1 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  and step2: \"\\<And>r.\n                  \\<lbrakk> step r = 2; P r; phase (Suc r) = phase r; step (Suc r) = 3;\n                    \\<forall>p. next2 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  and step3: \"\\<And>r.\n                  \\<lbrakk> step r = 3; P r; phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n                    \\<forall>p. next3 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  shows \"P n\"", "lemma LV_Suc:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and step0: \"\\<lbrakk> step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n                \\<forall>p. next0 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  and step1: \"\\<lbrakk> step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n                \\<forall>p. next1 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  and step2: \"\\<lbrakk> step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n                \\<forall>p. next2 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  and step3: \"\\<lbrakk> step r = 3; step (Suc r) = 0; phase (Suc r) = Suc (phase r);\n                \\<forall>p. next3 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  shows \"P r\"", "lemma LV_induct':\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and init: \"CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow> P p 0\"\n  and step0: \"\\<And>r. \\<lbrakk> step r = 0; P p r; phase (Suc r) = phase r; step (Suc r) = 1;\n                     next0 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  and step1: \"\\<And>r. \\<lbrakk> step r = 1; P p r; phase (Suc r) = phase r; step (Suc r) = 2;\n                     next1 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  and step2: \"\\<And>r. \\<lbrakk> step r = 2; P p r; phase (Suc r) = phase r; step (Suc r) = 3;\n                     next2 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  and step3: \"\\<And>r. \\<lbrakk> step r = 3; P p r; phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n                     next3 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  shows \"P p n\"", "lemma LV_Suc':\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and step0: \"\\<lbrakk> step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n                next0 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  and step1: \"\\<lbrakk> step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n                next1 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  and step2: \"\\<lbrakk> step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n                next2 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  and step3: \"\\<lbrakk> step r = 3; step (Suc r) = 0; phase (Suc r) = Suc (phase r);\n                next3 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  shows \"P p r\"", "lemma LV_timestamp_bounded:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"timestamp (rho n p) \\<le> (if step n < 2 then phase n else Suc (phase n))\"\n        (is \"?P p n\")", "lemma LV_timestamp_increasing:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\"\n    (is \"?P p n\" is \"?ts \\<le> _\")", "lemma LV_timestamp_monotonic:\n  assumes run: \"CHORun LV_M rho HOs coords\" and le: \"m \\<le> n\"\n  shows \"timestamp (rho m p) \\<le> timestamp (rho n p)\"\n    (is \"?ts m \\<le> _\")", "lemma procsBeyondTS_monotonic:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and p: \"p \\<in> procsBeyondTS ts (rho m)\" and le: \"m \\<le> n\"\n  shows \"p \\<in> procsBeyondTS ts (rho n)\"", "lemma notStep3EqualCoord:\n  assumes run: \"CHORun LV_M rho HOs coords\" and stp:\"step r \\<noteq> 3\"\n  shows \"coord\\<Phi> (rho (Suc r) p) = coord\\<Phi> (rho r p)\" (is \"?P p r\")", "lemma coordinators:\nassumes run: \"CHORun LV_M rho HOs coords\"\nshows \"coord\\<Phi> (rho r p) = coords (4*(phase r)) p\"", "lemma notStep0EqualVote [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 0 \\<longrightarrow> vote (rho (Suc r) p) = vote (rho r p)\" (is \"?P p r\")", "lemma notStep03EqualCommit [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 0 \\<and> step r \\<noteq> 3 \\<longrightarrow> commt (rho (Suc r) p) = commt (rho r p)\"\n        (is \"?P p r\")", "lemma notStep1EqualTimestamp [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 1 \\<longrightarrow> timestamp (rho (Suc r) p) = timestamp (rho r p)\"\n        (is \"?P p r\")", "lemma notStep1EqualX [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 1 \\<longrightarrow> x (rho (Suc r) p) = x (rho r p)\" (is \"?P p r\")", "lemma commitE:\n  assumes run: \"CHORun LV_M rho HOs coords\" and cmt: \"commt (rho r p)\"\n  and conds: \"\\<lbrakk> 1 \\<le> step r; coord\\<Phi> (rho r p) = p; vote (rho r p) \\<noteq> None;\n                card {q . coord\\<Phi> (rho r q) = p} > N div 2\n              \\<rbrakk> \\<Longrightarrow> A\"\n  shows \"A\"", "lemma currentTimestampE:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and ts: \"timestamp (rho r p) = Suc (phase r)\"\n  and conds: \"\\<lbrakk> 2 \\<le> step r;\n                commt (rho r (coord\\<Phi> (rho r p)));\n                x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))))\n              \\<rbrakk> \\<Longrightarrow> A\"\n  shows \"A\"", "lemma readyE:\n  assumes run: \"CHORun LV_M rho HOs coords\" and rdy: \"ready (rho r p)\"\n  and conds: \"\\<lbrakk> step r = 3; coord\\<Phi> (rho r p) = p;\n                card { q . coord\\<Phi> (rho r q) = p \n                         \\<and> timestamp (rho r q) = Suc (phase r) } > N div 2\n              \\<rbrakk> \\<Longrightarrow> P\"\n  shows P", "lemma decisionE:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and dec: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  and conds: \"\\<lbrakk> \n        step r = 3; \n        decide (rho (Suc r) p) = Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n        ready (rho r (coord\\<Phi> (rho r p))); commt (rho r (coord\\<Phi> (rho r p)))\n      \\<rbrakk> \\<Longrightarrow> P\"\n  shows P", "lemma lv_integrityInvariant:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and inv: \"\\<lbrakk> range (x \\<circ> (rho n)) \\<subseteq> range (x \\<circ> (rho 0));\n              range (vote \\<circ> (rho n)) \\<subseteq> {None} \\<union> Some ` range (x \\<circ> (rho 0));\n              range (decide \\<circ> (rho n)) \\<subseteq> {None} \\<union> Some ` range (x \\<circ> (rho 0))\n       \\<rbrakk> \\<Longrightarrow> A\"\n  shows \"A\"", "theorem lv_integrity:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and dec: \"decide (rho n p) = Some v\"\n  shows \"\\<exists>q. v = x (rho 0 q)\"", "lemma decisionThenMajorityBeyondTS:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and dec: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  shows \"card (procsBeyondTS (Suc (phase r)) (rho r)) > N div 2\"", "lemma committedProcsEqual:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and cmt: \"commt (rho r p)\" and cmt': \"commt (rho r p')\"\n  shows \"p = p'\"", "lemma readyProcsEqual:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and rdy: \"ready (rho r p)\" and rdy': \"ready (rho r p')\"\n  shows \"p = p'\"", "lemma commitThenVoteRecent:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and maj: \"card (procsBeyondTS ts (rho r)) > N div 2\"\n  and cmt: \"commt (rho r p)\"\n  shows \"\\<exists>q \\<in> procsBeyondTS ts (rho r). vote (rho r p) = Some (x (rho r q))\"\n        (is \"?Q r\")", "lemma XOfTimestampBeyondDecision:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and dec: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  shows \"\\<forall>q \\<in> procsBeyondTS (Suc (phase r)) (rho (r+k)).\n              x (rho (r+k) q) = the (decide (rho (Suc r) p))\"\n  (is \"\\<forall>q \\<in> ?bynd k. _ = ?v\" is \"?P p k\")", "lemma laterProcessDecidesSameValue:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and p: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  and q: \"decide (rho (Suc (r+k)) q) \\<noteq> decide (rho (r+k) q)\"\n  shows \"decide (rho (Suc (r+k)) q) = decide (rho (Suc r) p)\"", "lemma decisionNonNullThenDecided:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and dec: \"decide (rho n p) = Some v\"\n  shows \"\\<exists>m<n. decide (rho (Suc m) p) \\<noteq> decide (rho m p) \n             \\<and> decide (rho (Suc m) p) = Some v\"", "theorem lv_irrevocability:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and p: \"decide (rho m p) = Some v\"\n  shows \"decide (rho (m+k) p) = Some v\"", "theorem lv_agreement:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and p: \"decide (rho m p) = Some v\"\n      and q: \"decide (rho n q) = Some w\"\n  shows \"v = w\"", "theorem lv_termination:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and commG:\"CHOcommGlobal LV_M HOs coords\" \n  shows \"\\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None\"", "theorem lv_consensus:\n  assumes run: \"CHORun LV_M rho HOs coords\" \n      and commG: \"CHOcommGlobal LV_M HOs coords\"\n  shows \"consensus (x \\<circ> (rho 0)) decide rho\"", "theorem lv_consensus_fg:\n  assumes run: \"fg_run LV_M rho HOs HOs coords\"\n      and commG: \"CHOcommGlobal LV_M HOs coords\"\n  shows \"consensus (\\<lambda>p. x (state (rho 0) p)) decide (state \\<circ> rho)\"\n    (is \"consensus ?inits _ _\")"], "translations": [["", "lemma timeStampsRcvdFinite:\n  \"finite {ts . \\<exists>q v. (msgs::Proc \\<rightharpoonup> 'val msg) q = Some (ValStamp v ts)}\"\n  (is \"finite ?ts\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "have \"?ts = stamp ` the ` msgs ` (valStampsRcvd msgs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} =\n    stamp ` the ` msgs ` valStampsRcvd msgs", "by (force simp add: valStampsRcvd_def image_def)"], ["proof (state)\nthis:\n  {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} =\n  stamp ` the ` msgs ` valStampsRcvd msgs\n\ngoal (1 subgoal):\n 1. finite {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} =\n  stamp ` the ` msgs ` valStampsRcvd msgs\n\ngoal (1 subgoal):\n 1. finite {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "by auto"], ["proof (state)\nthis:\n  finite {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma highestStampRcvd_exists:\n  assumes nempty: \"valStampsRcvd msgs \\<noteq> {}\"\n  obtains p v where \"msgs p = Some (ValStamp v (highestStampRcvd msgs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        msgs p = Some (ValStamp v (highestStampRcvd msgs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        msgs p = Some (ValStamp v (highestStampRcvd msgs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?ts = \"{ts . \\<exists>q v. msgs q = Some (ValStamp v ts)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        msgs p = Some (ValStamp v (highestStampRcvd msgs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from nempty"], ["proof (chain)\npicking this:\n  valStampsRcvd msgs \\<noteq> {}", "have \"?ts \\<noteq> {}\""], ["proof (prove)\nusing this:\n  valStampsRcvd msgs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} \\<noteq> {}", "by (auto simp add: valStampsRcvd_def)"], ["proof (state)\nthis:\n  {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        msgs p = Some (ValStamp v (highestStampRcvd msgs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with timeStampsRcvdFinite"], ["proof (chain)\npicking this:\n  finite {ts. \\<exists>q v. ?msgs q = Some (ValStamp v ts)}\n  {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} \\<noteq> {}", "have \"highestStampRcvd msgs \\<in> ?ts\""], ["proof (prove)\nusing this:\n  finite {ts. \\<exists>q v. ?msgs q = Some (ValStamp v ts)}\n  {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. highestStampRcvd msgs\n    \\<in> {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "unfolding highestStampRcvd_def"], ["proof (prove)\nusing this:\n  finite {ts. \\<exists>q v. ?msgs q = Some (ValStamp v ts)}\n  {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}\n    \\<in> {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "by (rule Max_in)"], ["proof (state)\nthis:\n  highestStampRcvd msgs\n  \\<in> {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        msgs p = Some (ValStamp v (highestStampRcvd msgs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  highestStampRcvd msgs\n  \\<in> {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "obtain p v where \"msgs p = Some (ValStamp v (highestStampRcvd msgs))\""], ["proof (prove)\nusing this:\n  highestStampRcvd msgs\n  \\<in> {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        msgs p = Some (ValStamp v (highestStampRcvd msgs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: highestStampRcvd_def)"], ["proof (state)\nthis:\n  msgs p = Some (ValStamp v (highestStampRcvd msgs))\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        msgs p = Some (ValStamp v (highestStampRcvd msgs)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  msgs ?p = Some (ValStamp ?v (highestStampRcvd msgs)) \\<Longrightarrow>\n  thesis\n  msgs p = Some (ValStamp v (highestStampRcvd msgs))", "show thesis"], ["proof (prove)\nusing this:\n  msgs ?p = Some (ValStamp ?v (highestStampRcvd msgs)) \\<Longrightarrow>\n  thesis\n  msgs p = Some (ValStamp v (highestStampRcvd msgs))\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma highestStampRcvd_max:\n  assumes \"msgs p = Some (ValStamp v ts)\"\n  shows \"ts \\<le> highestStampRcvd msgs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<le> highestStampRcvd msgs", "using assms"], ["proof (prove)\nusing this:\n  msgs p = Some (ValStamp v ts)\n\ngoal (1 subgoal):\n 1. ts \\<le> highestStampRcvd msgs", "unfolding highestStampRcvd_def"], ["proof (prove)\nusing this:\n  msgs p = Some (ValStamp v ts)\n\ngoal (1 subgoal):\n 1. ts \\<le> Max {ts. \\<exists>q v. msgs q = Some (ValStamp v ts)}", "by (blast intro: Max_ge timeStampsRcvdFinite)"], ["", "lemma phase_Suc:\n  \"phase (Suc r) = (if step r = 3 then Suc (phase r)\n                   else phase r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phase (Suc r) = (if step r = 3 then Suc (phase r) else phase r)", "unfolding step_def phase_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc r div 4 = (if r mod 4 = 3 then Suc (r div 4) else r div 4)", "by presburger"], ["", "text \\<open>\n  Many proofs are by induction on runs of the LastVoting algorithm, and\n  we derive a specific induction rule to support these proofs.\n\\<close>"], ["", "lemma LV_induct:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and init: \"\\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow> P 0\"\n  and step0: \"\\<And>r.\n                  \\<lbrakk> step r = 0; P r; phase (Suc r) = phase r; step (Suc r) = 1;\n                    \\<forall>p. next0 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  and step1: \"\\<And>r.\n                  \\<lbrakk> step r = 1; P r; phase (Suc r) = phase r; step (Suc r) = 2;\n                    \\<forall>p. next1 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  and step2: \"\\<And>r.\n                  \\<lbrakk> step r = 2; P r; phase (Suc r) = phase r; step (Suc r) = 3;\n                    \\<forall>p. next2 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  and step3: \"\\<And>r.\n                  \\<lbrakk> step r = 3; P r; phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n                    \\<forall>p. next3 r p (rho r p)\n                              (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                              (coords (Suc r) p)\n                              (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P (Suc r)\"\n  shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof (rule CHORun_induct[OF run])"], ["proof (state)\ngoal (2 subgoals):\n 1. CHOinitConfig LV_M (rho 0) (coords 0) \\<Longrightarrow> P 0\n 2. \\<And>r.\n       \\<lbrakk>P r;\n        CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r))\n         (rho (Suc r))\\<rbrakk>\n       \\<Longrightarrow> P (Suc r)", "assume \"CHOinitConfig LV_M (rho 0) (coords 0)\""], ["proof (state)\nthis:\n  CHOinitConfig LV_M (rho 0) (coords 0)\n\ngoal (2 subgoals):\n 1. CHOinitConfig LV_M (rho 0) (coords 0) \\<Longrightarrow> P 0\n 2. \\<And>r.\n       \\<lbrakk>P r;\n        CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r))\n         (rho (Suc r))\\<rbrakk>\n       \\<Longrightarrow> P (Suc r)", "thus \"P 0\""], ["proof (prove)\nusing this:\n  CHOinitConfig LV_M (rho 0) (coords 0)\n\ngoal (1 subgoal):\n 1. P 0", "by (auto simp add: CHOinitConfig_def init)"], ["proof (state)\nthis:\n  P 0\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>P r;\n        CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r))\n         (rho (Suc r))\\<rbrakk>\n       \\<Longrightarrow> P (Suc r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>P r;\n        CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r))\n         (rho (Suc r))\\<rbrakk>\n       \\<Longrightarrow> P (Suc r)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>P r;\n        CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r))\n         (rho (Suc r))\\<rbrakk>\n       \\<Longrightarrow> P (Suc r)", "assume ih: \"P r\" \n    and nxt: \"CHOnextConfig LV_M r (rho r) (HOs r) \n                                 (coords (Suc r)) (rho (Suc r))\""], ["proof (state)\nthis:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>P r;\n        CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r))\n         (rho (Suc r))\\<rbrakk>\n       \\<Longrightarrow> P (Suc r)", "have \"step r \\<in> {0,1,2,3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step r \\<in> {0, 1, 2, 3}", "by (auto simp add: step_def)"], ["proof (state)\nthis:\n  step r \\<in> {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>P r;\n        CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r))\n         (rho (Suc r))\\<rbrakk>\n       \\<Longrightarrow> P (Suc r)", "thus \"P (Suc r)\""], ["proof (prove)\nusing this:\n  step r \\<in> {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. P (Suc r)", "proof auto"], ["proof (state)\ngoal (4 subgoals):\n 1. step r = 0 \\<Longrightarrow> P (Suc r)\n 2. step r = Suc 0 \\<Longrightarrow> P (Suc r)\n 3. step r = 2 \\<Longrightarrow> P (Suc r)\n 4. step r = 3 \\<Longrightarrow> P (Suc r)", "assume stp: \"step r = 0\""], ["proof (state)\nthis:\n  step r = 0\n\ngoal (4 subgoals):\n 1. step r = 0 \\<Longrightarrow> P (Suc r)\n 2. step r = Suc 0 \\<Longrightarrow> P (Suc r)\n 3. step r = 2 \\<Longrightarrow> P (Suc r)\n 4. step r = 3 \\<Longrightarrow> P (Suc r)", "hence \"step (Suc r) = 1\""], ["proof (prove)\nusing this:\n  step r = 0\n\ngoal (1 subgoal):\n 1. step (Suc r) = 1", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 1\n\ngoal (4 subgoals):\n 1. step r = 0 \\<Longrightarrow> P (Suc r)\n 2. step r = Suc 0 \\<Longrightarrow> P (Suc r)\n 3. step r = 2 \\<Longrightarrow> P (Suc r)\n 4. step r = 3 \\<Longrightarrow> P (Suc r)", "with ih nxt stp"], ["proof (chain)\npicking this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 0\n  step (Suc r) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 0\n  step (Suc r) = 1\n\ngoal (1 subgoal):\n 1. P (Suc r)", "by (intro step0)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P (Suc r)\n\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P (Suc r)\n 2. step r = 2 \\<Longrightarrow> P (Suc r)\n 3. step r = 3 \\<Longrightarrow> P (Suc r)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P (Suc r)\n 2. step r = 2 \\<Longrightarrow> P (Suc r)\n 3. step r = 3 \\<Longrightarrow> P (Suc r)", "assume stp: \"step r = Suc 0\""], ["proof (state)\nthis:\n  step r = Suc 0\n\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P (Suc r)\n 2. step r = 2 \\<Longrightarrow> P (Suc r)\n 3. step r = 3 \\<Longrightarrow> P (Suc r)", "hence \"step (Suc r) = 2\""], ["proof (prove)\nusing this:\n  step r = Suc 0\n\ngoal (1 subgoal):\n 1. step (Suc r) = 2", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 2\n\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P (Suc r)\n 2. step r = 2 \\<Longrightarrow> P (Suc r)\n 3. step r = 3 \\<Longrightarrow> P (Suc r)", "with ih nxt stp"], ["proof (chain)\npicking this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = Suc 0\n  step (Suc r) = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = Suc 0\n  step (Suc r) = 2\n\ngoal (1 subgoal):\n 1. P (Suc r)", "by (intro step1)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P (Suc r)\n\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P (Suc r)\n 2. step r = 3 \\<Longrightarrow> P (Suc r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P (Suc r)\n 2. step r = 3 \\<Longrightarrow> P (Suc r)", "assume stp: \"step r = 2\""], ["proof (state)\nthis:\n  step r = 2\n\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P (Suc r)\n 2. step r = 3 \\<Longrightarrow> P (Suc r)", "hence \"step (Suc r) = 3\""], ["proof (prove)\nusing this:\n  step r = 2\n\ngoal (1 subgoal):\n 1. step (Suc r) = 3", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 3\n\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P (Suc r)\n 2. step r = 3 \\<Longrightarrow> P (Suc r)", "with ih nxt stp"], ["proof (chain)\npicking this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 2\n  step (Suc r) = 3", "show ?thesis"], ["proof (prove)\nusing this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 2\n  step (Suc r) = 3\n\ngoal (1 subgoal):\n 1. P (Suc r)", "by (intro step2)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P (Suc r)\n\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P (Suc r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P (Suc r)", "assume stp: \"step r = 3\""], ["proof (state)\nthis:\n  step r = 3\n\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P (Suc r)", "hence \"step (Suc r) = 0\""], ["proof (prove)\nusing this:\n  step r = 3\n\ngoal (1 subgoal):\n 1. step (Suc r) = 0", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 0\n\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P (Suc r)", "with ih nxt stp"], ["proof (chain)\npicking this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 3\n  step (Suc r) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  P r\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 3\n  step (Suc r) = 0\n\ngoal (1 subgoal):\n 1. P (Suc r)", "by (intro step3)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P (Suc r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (Suc r)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following rule similarly establishes a property of two successive\n  configurations of a run by case distinction on the step that was executed.\n\\<close>"], ["", "lemma LV_Suc:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and step0: \"\\<lbrakk> step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n                \\<forall>p. next0 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  and step1: \"\\<lbrakk> step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n                \\<forall>p. next1 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  and step2: \"\\<lbrakk> step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n                \\<forall>p. next2 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  and step3: \"\\<lbrakk> step r = 3; step (Suc r) = 0; phase (Suc r) = Suc (phase r);\n                \\<forall>p. next3 r p (rho r p)\n                          (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                          (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P r\"\n  shows \"P r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P r", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have nxt: \"CHOnextConfig LV_M r (rho r) (HOs r) \n                                  (coords (Suc r)) (rho (Suc r))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))", "by (auto simp add: CHORun_eq)"], ["proof (state)\nthis:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n\ngoal (1 subgoal):\n 1. P r", "have \"step r \\<in> {0,1,2,3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step r \\<in> {0, 1, 2, 3}", "by (auto simp add: step_def)"], ["proof (state)\nthis:\n  step r \\<in> {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. P r", "thus \"P r\""], ["proof (prove)\nusing this:\n  step r \\<in> {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. P r", "proof (auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. step r = 0 \\<Longrightarrow> P r\n 2. step r = Suc 0 \\<Longrightarrow> P r\n 3. step r = 2 \\<Longrightarrow> P r\n 4. step r = 3 \\<Longrightarrow> P r", "assume stp: \"step r = 0\""], ["proof (state)\nthis:\n  step r = 0\n\ngoal (4 subgoals):\n 1. step r = 0 \\<Longrightarrow> P r\n 2. step r = Suc 0 \\<Longrightarrow> P r\n 3. step r = 2 \\<Longrightarrow> P r\n 4. step r = 3 \\<Longrightarrow> P r", "hence \"step (Suc r) = 1\""], ["proof (prove)\nusing this:\n  step r = 0\n\ngoal (1 subgoal):\n 1. step (Suc r) = 1", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 1\n\ngoal (4 subgoals):\n 1. step r = 0 \\<Longrightarrow> P r\n 2. step r = Suc 0 \\<Longrightarrow> P r\n 3. step r = 2 \\<Longrightarrow> P r\n 4. step r = 3 \\<Longrightarrow> P r", "with nxt stp"], ["proof (chain)\npicking this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 0\n  step (Suc r) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 0\n  step (Suc r) = 1\n\ngoal (1 subgoal):\n 1. P r", "by (intro step0)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P r\n\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P r\n 2. step r = 2 \\<Longrightarrow> P r\n 3. step r = 3 \\<Longrightarrow> P r", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P r\n 2. step r = 2 \\<Longrightarrow> P r\n 3. step r = 3 \\<Longrightarrow> P r", "assume stp: \"step r = Suc 0\""], ["proof (state)\nthis:\n  step r = Suc 0\n\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P r\n 2. step r = 2 \\<Longrightarrow> P r\n 3. step r = 3 \\<Longrightarrow> P r", "hence \"step (Suc r) = 2\""], ["proof (prove)\nusing this:\n  step r = Suc 0\n\ngoal (1 subgoal):\n 1. step (Suc r) = 2", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 2\n\ngoal (3 subgoals):\n 1. step r = Suc 0 \\<Longrightarrow> P r\n 2. step r = 2 \\<Longrightarrow> P r\n 3. step r = 3 \\<Longrightarrow> P r", "with nxt stp"], ["proof (chain)\npicking this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = Suc 0\n  step (Suc r) = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = Suc 0\n  step (Suc r) = 2\n\ngoal (1 subgoal):\n 1. P r", "by (intro step1)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P r\n\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P r\n 2. step r = 3 \\<Longrightarrow> P r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P r\n 2. step r = 3 \\<Longrightarrow> P r", "assume stp: \"step r = 2\""], ["proof (state)\nthis:\n  step r = 2\n\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P r\n 2. step r = 3 \\<Longrightarrow> P r", "hence \"step (Suc r) = 3\""], ["proof (prove)\nusing this:\n  step r = 2\n\ngoal (1 subgoal):\n 1. step (Suc r) = 3", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 3\n\ngoal (2 subgoals):\n 1. step r = 2 \\<Longrightarrow> P r\n 2. step r = 3 \\<Longrightarrow> P r", "with nxt stp"], ["proof (chain)\npicking this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 2\n  step (Suc r) = 3", "show ?thesis"], ["proof (prove)\nusing this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 2\n  step (Suc r) = 3\n\ngoal (1 subgoal):\n 1. P r", "by (intro step2)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P r\n\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P r", "assume stp: \"step r = 3\""], ["proof (state)\nthis:\n  step r = 3\n\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P r", "hence \"step (Suc r) = 0\""], ["proof (prove)\nusing this:\n  step r = 3\n\ngoal (1 subgoal):\n 1. step (Suc r) = 0", "by (auto simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc r) = 0\n\ngoal (1 subgoal):\n 1. step r = 3 \\<Longrightarrow> P r", "with nxt stp"], ["proof (chain)\npicking this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 3\n  step (Suc r) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  CHOnextConfig LV_M r (rho r) (HOs r) (coords (Suc r)) (rho (Suc r))\n  step r = 3\n  step (Suc r) = 0\n\ngoal (1 subgoal):\n 1. P r", "by (intro step3)\n         (auto simp: LV_CHOMachine_def CHOnextConfig_eq \n                     LV_nextState_def LV_sendMsg_def phase_Suc)"], ["proof (state)\nthis:\n  P r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Sometimes the assertion to prove talks about a specific process and follows\n  from the next-state relation of that particular process. We prove corresponding \n  variants of the induction and case-distinction rules. When these variants are\n  applicable, they help automating the Isabelle proof.\n\\<close>"], ["", "lemma LV_induct':\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and init: \"CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow> P p 0\"\n  and step0: \"\\<And>r. \\<lbrakk> step r = 0; P p r; phase (Suc r) = phase r; step (Suc r) = 1;\n                     next0 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  and step1: \"\\<And>r. \\<lbrakk> step r = 1; P p r; phase (Suc r) = phase r; step (Suc r) = 2;\n                     next1 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  and step2: \"\\<And>r. \\<lbrakk> step r = 2; P p r; phase (Suc r) = phase r; step (Suc r) = 3;\n                     next2 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  and step3: \"\\<And>r. \\<lbrakk> step r = 3; P p r; phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n                     next3 r p (rho r p)\n                           (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                           (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n                  \\<Longrightarrow> P p (Suc r)\"\n  shows \"P p n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p n", "by (rule LV_induct[OF run])\n     (auto intro: init step0 step1 step2 step3)"], ["", "lemma LV_Suc':\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and step0: \"\\<lbrakk> step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n                next0 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  and step1: \"\\<lbrakk> step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n                next1 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  and step2: \"\\<lbrakk> step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n                next2 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  and step3: \"\\<lbrakk> step r = 3; step (Suc r) = 0; phase (Suc r) = Suc (phase r);\n                next3 r p (rho r p)\n                      (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n                      (coords (Suc r) p) (rho (Suc r) p) \\<rbrakk>\n              \\<Longrightarrow> P p r\"\n  shows \"P p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p r", "by (rule LV_Suc[OF run])\n     (auto intro: step0 step1 step2 step3)"], ["", "subsection \\<open>Boundedness and Monotonicity of Timestamps\\<close>"], ["", "text \\<open>\n  The timestamp of any process is bounded by the current phase.\n\\<close>"], ["", "lemma LV_timestamp_bounded:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"timestamp (rho n p) \\<le> (if step n < 2 then phase n else Suc (phase n))\"\n        (is \"?P p n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho n p)\n    \\<le> (if step n < 2 then phase n else Suc (phase n))", "by (rule LV_induct' [OF run, where P=\"?P\"])\n     (auto simp: LV_CHOMachine_def LV_initState_def \n                 next0_def next1_def next2_def next3_def)"], ["", "text \\<open>\n  Moreover, timestamps can only grow over time.\n\\<close>"], ["", "lemma LV_timestamp_increasing:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\"\n    (is \"?P p n\" is \"?ts \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)", "proof (rule LV_Suc'[OF run, where P=\"?P\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)", "txt \\<open>The case of \\<open>next1\\<close> is the only interesting one because the\n    timestamp may change: here we use the previously established fact that\n    the timestamp is bounded by the phase number.\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)", "assume stp: \"step n = 1\"\n     and nxt: \"next1 n p (rho n p)\n                     (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n                     (coords (Suc n) p) (rho (Suc n) p)\""], ["proof (state)\nthis:\n  step n = 1\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)", "from stp"], ["proof (chain)\npicking this:\n  step n = 1", "have \"?ts \\<le> phase n\""], ["proof (prove)\nusing this:\n  step n = 1\n\ngoal (1 subgoal):\n 1. timestamp (rho n p) \\<le> phase n", "using LV_timestamp_bounded[OF run, where n=n, where p=p]"], ["proof (prove)\nusing this:\n  step n = 1\n  timestamp (rho n p) \\<le> (if step n < 2 then phase n else Suc (phase n))\n\ngoal (1 subgoal):\n 1. timestamp (rho n p) \\<le> phase n", "by auto"], ["proof (state)\nthis:\n  timestamp (rho n p) \\<le> phase n\n\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)", "with nxt"], ["proof (chain)\npicking this:\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  timestamp (rho n p) \\<le> phase n", "show ?thesis"], ["proof (prove)\nusing this:\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  timestamp (rho n p) \\<le> phase n\n\ngoal (1 subgoal):\n 1. timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)", "by (auto simp add: next1_def)"], ["proof (state)\nthis:\n  timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho n p) \\<le> timestamp (rho (Suc n) p)", "qed (auto simp add: next0_def next2_def next3_def)"], ["", "lemma LV_timestamp_monotonic:\n  assumes run: \"CHORun LV_M rho HOs coords\" and le: \"m \\<le> n\"\n  shows \"timestamp (rho m p) \\<le> timestamp (rho n p)\"\n    (is \"?ts m \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho n p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho n p)", "from le"], ["proof (chain)\npicking this:\n  m \\<le> n", "obtain k where k: \"n = m+k\""], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>k. n = m + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: le_iff_add)"], ["proof (state)\nthis:\n  n = m + k\n\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho n p)", "have \"?ts m \\<le> ?ts (m+k)\" (is \"?P k\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho (m + k) p)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. timestamp (rho m p) \\<le> timestamp (rho (m + 0) p)\n 2. \\<And>k.\n       timestamp (rho m p) \\<le> timestamp (rho (m + k) p) \\<Longrightarrow>\n       timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. timestamp (rho m p) \\<le> timestamp (rho (m + 0) p)\n 2. \\<And>k.\n       timestamp (rho m p) \\<le> timestamp (rho (m + k) p) \\<Longrightarrow>\n       timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "show \"?P 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho (m + 0) p)", "by simp"], ["proof (state)\nthis:\n  timestamp (rho m p) \\<le> timestamp (rho (m + 0) p)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       timestamp (rho m p) \\<le> timestamp (rho (m + k) p) \\<Longrightarrow>\n       timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       timestamp (rho m p) \\<le> timestamp (rho (m + k) p) \\<Longrightarrow>\n       timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       timestamp (rho m p) \\<le> timestamp (rho (m + k) p) \\<Longrightarrow>\n       timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "assume ih: \"?P k\""], ["proof (state)\nthis:\n  timestamp (rho m p) \\<le> timestamp (rho (m + k) p)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       timestamp (rho m p) \\<le> timestamp (rho (m + k) p) \\<Longrightarrow>\n       timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have \"?ts (m+k) \\<le> ?ts (m + Suc k)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. timestamp (rho (m + k) p) \\<le> timestamp (rho (m + Suc k) p)", "by (auto simp add: LV_timestamp_increasing)"], ["proof (state)\nthis:\n  timestamp (rho (m + k) p) \\<le> timestamp (rho (m + Suc k) p)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       timestamp (rho m p) \\<le> timestamp (rho (m + k) p) \\<Longrightarrow>\n       timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "with ih"], ["proof (chain)\npicking this:\n  timestamp (rho m p) \\<le> timestamp (rho (m + k) p)\n  timestamp (rho (m + k) p) \\<le> timestamp (rho (m + Suc k) p)", "show \"?P (Suc k)\""], ["proof (prove)\nusing this:\n  timestamp (rho m p) \\<le> timestamp (rho (m + k) p)\n  timestamp (rho (m + k) p) \\<le> timestamp (rho (m + Suc k) p)\n\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)", "by simp"], ["proof (state)\nthis:\n  timestamp (rho m p) \\<le> timestamp (rho (m + Suc k) p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  timestamp (rho m p) \\<le> timestamp (rho (m + k) p)\n\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho n p)", "with k"], ["proof (chain)\npicking this:\n  n = m + k\n  timestamp (rho m p) \\<le> timestamp (rho (m + k) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = m + k\n  timestamp (rho m p) \\<le> timestamp (rho (m + k) p)\n\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho n p)", "by simp"], ["proof (state)\nthis:\n  timestamp (rho m p) \\<le> timestamp (rho n p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following definition collects the set of processes whose timestamp\n  is beyond a given bound at a system state.\n\\<close>"], ["", "definition procsBeyondTS where\n  \"procsBeyondTS ts cfg \\<equiv> { p . ts \\<le> timestamp (cfg p) }\""], ["", "text \\<open>\n  Since timestamps grow monotonically, so does the set of processes\n  that are beyond a certain bound.\n\\<close>"], ["", "lemma procsBeyondTS_monotonic:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and p: \"p \\<in> procsBeyondTS ts (rho m)\" and le: \"m \\<le> n\"\n  shows \"p \\<in> procsBeyondTS ts (rho n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> procsBeyondTS ts (rho n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> procsBeyondTS ts (rho n)", "from p"], ["proof (chain)\npicking this:\n  p \\<in> procsBeyondTS ts (rho m)", "have \"ts \\<le> timestamp (rho m p)\" (is \"_ \\<le> ?ts m\")"], ["proof (prove)\nusing this:\n  p \\<in> procsBeyondTS ts (rho m)\n\ngoal (1 subgoal):\n 1. ts \\<le> timestamp (rho m p)", "by (simp add: procsBeyondTS_def)"], ["proof (state)\nthis:\n  ts \\<le> timestamp (rho m p)\n\ngoal (1 subgoal):\n 1. p \\<in> procsBeyondTS ts (rho n)", "moreover"], ["proof (state)\nthis:\n  ts \\<le> timestamp (rho m p)\n\ngoal (1 subgoal):\n 1. p \\<in> procsBeyondTS ts (rho n)", "from run le"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  m \\<le> n", "have \"?ts m \\<le> ?ts n\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. timestamp (rho m p) \\<le> timestamp (rho n p)", "by (rule LV_timestamp_monotonic)"], ["proof (state)\nthis:\n  timestamp (rho m p) \\<le> timestamp (rho n p)\n\ngoal (1 subgoal):\n 1. p \\<in> procsBeyondTS ts (rho n)", "ultimately"], ["proof (chain)\npicking this:\n  ts \\<le> timestamp (rho m p)\n  timestamp (rho m p) \\<le> timestamp (rho n p)", "show ?thesis"], ["proof (prove)\nusing this:\n  ts \\<le> timestamp (rho m p)\n  timestamp (rho m p) \\<le> timestamp (rho n p)\n\ngoal (1 subgoal):\n 1. p \\<in> procsBeyondTS ts (rho n)", "by (simp add: procsBeyondTS_def)"], ["proof (state)\nthis:\n  p \\<in> procsBeyondTS ts (rho n)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Obvious Facts About the Algorithm\\<close>"], ["", "text \\<open>\n  The following lemmas state some very obvious facts that follow\n  ``immediately'' from the definition of the algorithm. We could\n  prove them in one fell swoop by defining a big invariant, but it\n  appears more readable to prove them separately.\n\\<close>"], ["", "text \\<open>\n  Coordinators change only at step 3.\n\\<close>"], ["", "lemma notStep3EqualCoord:\n  assumes run: \"CHORun LV_M rho HOs coords\" and stp:\"step r \\<noteq> 3\"\n  shows \"coord\\<Phi> (rho (Suc r) p) = coord\\<Phi> (rho r p)\" (is \"?P p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (Suc r) p) = coord\\<Phi> (rho r p)", "by (rule LV_Suc'[OF run, where P=\"?P\"])\n     (auto simp: stp next0_def next1_def next2_def)"], ["", "lemma coordinators:\nassumes run: \"CHORun LV_M rho HOs coords\"\nshows \"coord\\<Phi> (rho r p) = coords (4*(phase r)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "let ?r0 = \"(4*(phase r) - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "let ?r1 = \"(4*(phase r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "have \"coord\\<Phi> (rho ?r1 p) = coords ?r1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "proof (cases \"phase r > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n 2. \\<not> 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < phase r\n\ngoal (2 subgoals):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n 2. \\<not> 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "hence \"phase r = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < phase r\n\ngoal (1 subgoal):\n 1. phase r = 0", "by auto"], ["proof (state)\nthis:\n  phase r = 0\n\ngoal (2 subgoals):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n 2. \\<not> 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  phase r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  phase r = 0\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "by (auto simp: LV_CHOMachine_def CHORun_eq CHOinitConfig_def\n                     LV_initState_def)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "case True"], ["proof (state)\nthis:\n  0 < phase r\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "hence \"step (Suc ?r0) = 0\""], ["proof (prove)\nusing this:\n  0 < phase r\n\ngoal (1 subgoal):\n 1. step (Suc (4 * phase r - 1)) = 0", "by (auto simp: step_def)"], ["proof (state)\nthis:\n  step (Suc (4 * phase r - 1)) = 0\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "hence \"step ?r0 = 3\""], ["proof (prove)\nusing this:\n  step (Suc (4 * phase r - 1)) = 0\n\ngoal (1 subgoal):\n 1. step (4 * phase r - 1) = 3", "by (auto simp: mod_Suc step_def)"], ["proof (state)\nthis:\n  step (4 * phase r - 1) = 3\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "moreover"], ["proof (state)\nthis:\n  step (4 * phase r - 1) = 3\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have \"LV_nextState ?r0 p (rho ?r0 p)\n                  (HOrcvdMsgs LV_M ?r0 p (HOs ?r0 p) (rho ?r0))\n                  (coords (Suc ?r0) p) (rho (Suc ?r0) p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. LV_nextState (4 * phase r - 1) p (rho (4 * phase r - 1) p)\n     (HOrcvdMsgs LV_M (4 * phase r - 1) p (HOs (4 * phase r - 1) p)\n       (rho (4 * phase r - 1)))\n     (coords (Suc (4 * phase r - 1)) p) (rho (Suc (4 * phase r - 1)) p)", "by (auto simp: LV_CHOMachine_def CHORun_eq CHOnextConfig_eq)"], ["proof (state)\nthis:\n  LV_nextState (4 * phase r - 1) p (rho (4 * phase r - 1) p)\n   (HOrcvdMsgs LV_M (4 * phase r - 1) p (HOs (4 * phase r - 1) p)\n     (rho (4 * phase r - 1)))\n   (coords (Suc (4 * phase r - 1)) p) (rho (Suc (4 * phase r - 1)) p)\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "ultimately"], ["proof (chain)\npicking this:\n  step (4 * phase r - 1) = 3\n  LV_nextState (4 * phase r - 1) p (rho (4 * phase r - 1) p)\n   (HOrcvdMsgs LV_M (4 * phase r - 1) p (HOs (4 * phase r - 1) p)\n     (rho (4 * phase r - 1)))\n   (coords (Suc (4 * phase r - 1)) p) (rho (Suc (4 * phase r - 1)) p)", "have nxt: \"next3 ?r0 p (rho ?r0 p)\n                      (HOrcvdMsgs LV_M ?r0 p (HOs ?r0 p) (rho ?r0))\n                      (coords (Suc ?r0) p) (rho (Suc ?r0) p)\""], ["proof (prove)\nusing this:\n  step (4 * phase r - 1) = 3\n  LV_nextState (4 * phase r - 1) p (rho (4 * phase r - 1) p)\n   (HOrcvdMsgs LV_M (4 * phase r - 1) p (HOs (4 * phase r - 1) p)\n     (rho (4 * phase r - 1)))\n   (coords (Suc (4 * phase r - 1)) p) (rho (Suc (4 * phase r - 1)) p)\n\ngoal (1 subgoal):\n 1. next3 (4 * phase r - 1) p (rho (4 * phase r - 1) p)\n     (HOrcvdMsgs LV_M (4 * phase r - 1) p (HOs (4 * phase r - 1) p)\n       (rho (4 * phase r - 1)))\n     (coords (Suc (4 * phase r - 1)) p) (rho (Suc (4 * phase r - 1)) p)", "by (auto simp: LV_nextState_def)"], ["proof (state)\nthis:\n  next3 (4 * phase r - 1) p (rho (4 * phase r - 1) p)\n   (HOrcvdMsgs LV_M (4 * phase r - 1) p (HOs (4 * phase r - 1) p)\n     (rho (4 * phase r - 1)))\n   (coords (Suc (4 * phase r - 1)) p) (rho (Suc (4 * phase r - 1)) p)\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "hence \"coord\\<Phi> (rho (Suc ?r0) p) = coords (Suc ?r0) p\""], ["proof (prove)\nusing this:\n  next3 (4 * phase r - 1) p (rho (4 * phase r - 1) p)\n   (HOrcvdMsgs LV_M (4 * phase r - 1) p (HOs (4 * phase r - 1) p)\n     (rho (4 * phase r - 1)))\n   (coords (Suc (4 * phase r - 1)) p) (rho (Suc (4 * phase r - 1)) p)\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (Suc (4 * phase r - 1)) p) =\n    coords (Suc (4 * phase r - 1)) p", "by (auto simp: next3_def)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (Suc (4 * phase r - 1)) p) =\n  coords (Suc (4 * phase r - 1)) p\n\ngoal (1 subgoal):\n 1. 0 < phase r \\<Longrightarrow>\n    coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "with True"], ["proof (chain)\npicking this:\n  0 < phase r\n  coord\\<Phi> (rho (Suc (4 * phase r - 1)) p) =\n  coords (Suc (4 * phase r - 1)) p", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < phase r\n  coord\\<Phi> (rho (Suc (4 * phase r - 1)) p) =\n  coords (Suc (4 * phase r - 1)) p\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p", "by auto"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "moreover"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have \"coord\\<Phi> (rho (Suc (Suc (Suc ?r1))) p) = coord\\<Phi> (rho ?r1 p)\n        \\<and> coord\\<Phi> (rho (Suc (Suc ?r1)) p) = coord\\<Phi> (rho ?r1 p)\n        \\<and> coord\\<Phi> (rho (Suc ?r1) p) = coord\\<Phi> (rho ?r1 p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (Suc (Suc (Suc (4 * phase r)))) p) =\n    coord\\<Phi> (rho (4 * phase r) p) \\<and>\n    coord\\<Phi> (rho (Suc (Suc (4 * phase r))) p) =\n    coord\\<Phi> (rho (4 * phase r) p) \\<and>\n    coord\\<Phi> (rho (Suc (4 * phase r)) p) =\n    coord\\<Phi> (rho (4 * phase r) p)", "by (auto simp: notStep3EqualCoord step_def phase_def mod_Suc)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (Suc (Suc (Suc (4 * phase r)))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (Suc (4 * phase r))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (4 * phase r)) p) =\n  coord\\<Phi> (rho (4 * phase r) p)\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "moreover"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (Suc (Suc (Suc (4 * phase r)))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (Suc (4 * phase r))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (4 * phase r)) p) =\n  coord\\<Phi> (rho (4 * phase r) p)\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "have \"r \\<in> {?r1, Suc ?r1, Suc (Suc ?r1), Suc (Suc (Suc ?r1))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> {4 * phase r, Suc (4 * phase r), Suc (Suc (4 * phase r)),\n             Suc (Suc (Suc (4 * phase r)))}", "by (auto simp: step_def phase_def mod_Suc)"], ["proof (state)\nthis:\n  r \\<in> {4 * phase r, Suc (4 * phase r), Suc (Suc (4 * phase r)),\n           Suc (Suc (Suc (4 * phase r)))}\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "ultimately"], ["proof (chain)\npicking this:\n  coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n  coord\\<Phi> (rho (Suc (Suc (Suc (4 * phase r)))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (Suc (4 * phase r))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (4 * phase r)) p) =\n  coord\\<Phi> (rho (4 * phase r) p)\n  r \\<in> {4 * phase r, Suc (4 * phase r), Suc (Suc (4 * phase r)),\n           Suc (Suc (Suc (4 * phase r)))}", "show ?thesis"], ["proof (prove)\nusing this:\n  coord\\<Phi> (rho (4 * phase r) p) = coords (4 * phase r) p\n  coord\\<Phi> (rho (Suc (Suc (Suc (4 * phase r)))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (Suc (4 * phase r))) p) =\n  coord\\<Phi> (rho (4 * phase r) p) \\<and>\n  coord\\<Phi> (rho (Suc (4 * phase r)) p) =\n  coord\\<Phi> (rho (4 * phase r) p)\n  r \\<in> {4 * phase r, Suc (4 * phase r), Suc (Suc (4 * phase r)),\n           Suc (Suc (Suc (4 * phase r)))}\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coords (4 * phase r) p", "by auto"], ["proof (state)\nthis:\n  coord\\<Phi> (rho r p) = coords (4 * phase r) p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Votes only change at step 0.\n\\<close>"], ["", "lemma notStep0EqualVote [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 0 \\<longrightarrow> vote (rho (Suc r) p) = vote (rho r p)\" (is \"?P p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step r \\<noteq> 0 \\<longrightarrow>\n    vote (rho (Suc r) p) = vote (rho r p)", "by (rule LV_Suc'[OF run, where P=\"?P\"])\n     (auto simp: next0_def next1_def next2_def next3_def)"], ["", "text \\<open>\n  Commit status only changes at steps 0 and 3.\n\\<close>"], ["", "lemma notStep03EqualCommit [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 0 \\<and> step r \\<noteq> 3 \\<longrightarrow> commt (rho (Suc r) p) = commt (rho r p)\"\n        (is \"?P p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step r \\<noteq> 0 \\<and> step r \\<noteq> 3 \\<longrightarrow>\n    commt (rho (Suc r) p) = commt (rho r p)", "by (rule LV_Suc'[OF run, where P=\"?P\"])\n     (auto simp: next0_def next1_def next2_def next3_def)"], ["", "text \\<open>\n  Timestamps only change at step 1.\n\\<close>"], ["", "lemma notStep1EqualTimestamp [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 1 \\<longrightarrow> timestamp (rho (Suc r) p) = timestamp (rho r p)\"\n        (is \"?P p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step r \\<noteq> 1 \\<longrightarrow>\n    timestamp (rho (Suc r) p) = timestamp (rho r p)", "by (rule LV_Suc'[OF run, where P=\"?P\"])\n     (auto simp: next0_def next1_def next2_def next3_def)"], ["", "text \\<open>\n  The \\<open>x\\<close> field only changes at step 1.\n\\<close>"], ["", "lemma notStep1EqualX [rule_format]:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  shows \"step r \\<noteq> 1 \\<longrightarrow> x (rho (Suc r) p) = x (rho r p)\" (is \"?P p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step r \\<noteq> 1 \\<longrightarrow> x (rho (Suc r) p) = x (rho r p)", "by (rule LV_Suc'[OF run, where P=\"?P\"])\n     (auto simp: next0_def next1_def next2_def next3_def)"], ["", "text \\<open>\n  A process $p$ has its \\<open>commt\\<close> flag set only if the following conditions hold:\n  \\begin{itemize}\n  \\item the step number is at least $1$,\n  \\item $p$ considers itself to be the coordinator,\n  \\item $p$ has a non-null \\<open>vote\\<close>,\n  \\item a majority of processes consider $p$ as their coordinator.\n  \\end{itemize}\n\\<close>"], ["", "lemma commitE:\n  assumes run: \"CHORun LV_M rho HOs coords\" and cmt: \"commt (rho r p)\"\n  and conds: \"\\<lbrakk> 1 \\<le> step r; coord\\<Phi> (rho r p) = p; vote (rho r p) \\<noteq> None;\n                card {q . coord\\<Phi> (rho r q) = p} > N div 2\n              \\<rbrakk> \\<Longrightarrow> A\"\n  shows \"A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A", "have \"commt (rho r p) \\<longrightarrow> \n          1 \\<le> step r\n        \\<and> coord\\<Phi> (rho r p) = p\n        \\<and> vote (rho r p) \\<noteq> None\n        \\<and> card {q . coord\\<Phi> (rho r q) = p} > N div 2\"\n    (is \"?P p r\" is \"_ \\<longrightarrow> ?R r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. commt (rho r p) \\<longrightarrow>\n    1 \\<le> step r \\<and>\n    coord\\<Phi> (rho r p) = p \\<and>\n    vote (rho r p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho r q) = p}", "proof (rule LV_induct'[OF run, where P=\"?P\"])\n    \\<comment> \\<open>the only interesting step is step 0\\<close>"], ["proof (state)\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    commt (rho 0 p) \\<longrightarrow>\n    1 \\<le> step 0 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    vote (rho 0 p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho 0 q) = p}\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}", "fix n"], ["proof (state)\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    commt (rho 0 p) \\<longrightarrow>\n    1 \\<le> step 0 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    vote (rho 0 p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho 0 q) = p}\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}", "assume nxt: \"next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n                           (coords (Suc n) p) (rho (Suc n) p)\"\n       and ph: \"phase (Suc n) = phase n\" \n       and stp: \"step n = 0\" and stp': \"step (Suc n) = 1\"\n       and ih: \"?P p n\""], ["proof (state)\nthis:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  phase (Suc n) = phase n\n  step n = 0\n  step (Suc n) = 1\n  commt (rho n p) \\<longrightarrow>\n  1 \\<le> step n \\<and>\n  coord\\<Phi> (rho n p) = p \\<and>\n  vote (rho n p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho n q) = p}\n\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    commt (rho 0 p) \\<longrightarrow>\n    1 \\<le> step 0 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    vote (rho 0 p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho 0 q) = p}\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}", "show \"?P p (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "assume cm': \"commt (rho (Suc n) p)\""], ["proof (state)\nthis:\n  commt (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "from stp ih"], ["proof (chain)\npicking this:\n  step n = 0\n  commt (rho n p) \\<longrightarrow>\n  1 \\<le> step n \\<and>\n  coord\\<Phi> (rho n p) = p \\<and>\n  vote (rho n p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho n q) = p}", "have cm: \"\\<not> commt (rho n p)\""], ["proof (prove)\nusing this:\n  step n = 0\n  commt (rho n p) \\<longrightarrow>\n  1 \\<le> step n \\<and>\n  coord\\<Phi> (rho n p) = p \\<and>\n  vote (rho n p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho n q) = p}\n\ngoal (1 subgoal):\n 1. \\<not> commt (rho n p)", "by simp"], ["proof (state)\nthis:\n  \\<not> commt (rho n p)\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "with nxt cm'"], ["proof (chain)\npicking this:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  commt (rho (Suc n) p)\n  \\<not> commt (rho n p)", "have \"coord\\<Phi> (rho n p) = p\n            \\<and> vote (rho (Suc n) p) \\<noteq> None \n            \\<and> card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n                 > N div 2\""], ["proof (prove)\nusing this:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  commt (rho (Suc n) p)\n  \\<not> commt (rho n p)\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho n p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))", "by (auto simp add: next0_def)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho n p) = p \\<and>\n  vote (rho (Suc n) p) \\<noteq> None \\<and>\n  N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "moreover"], ["proof (state)\nthis:\n  coord\\<Phi> (rho n p) = p \\<and>\n  vote (rho (Suc n) p) \\<noteq> None \\<and>\n  N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "from stp"], ["proof (chain)\npicking this:\n  step n = 0", "have \"valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n             \\<subseteq> {q . coord\\<Phi> (rho n q) = p}\""], ["proof (prove)\nusing this:\n  step n = 0\n\ngoal (1 subgoal):\n 1. valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n    \\<subseteq> {q. coord\\<Phi> (rho n q) = p}", "by (auto simp: valStampsRcvd_def LV_CHOMachine_def\n                       HOrcvdMsgs_def  LV_sendMsg_def send0_def)"], ["proof (state)\nthis:\n  valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n  \\<subseteq> {q. coord\\<Phi> (rho n q) = p}\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "hence \"card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p)  (rho n)))\n              \\<le> card {q . coord\\<Phi> (rho n q) = p}\""], ["proof (prove)\nusing this:\n  valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n  \\<subseteq> {q. coord\\<Phi> (rho n q) = p}\n\ngoal (1 subgoal):\n 1. card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n    \\<le> card {q. coord\\<Phi> (rho n q) = p}", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  \\<le> card {q. coord\\<Phi> (rho n q) = p}\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "moreover"], ["proof (state)\nthis:\n  card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  \\<le> card {q. coord\\<Phi> (rho n q) = p}\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "note stp stp' run"], ["proof (state)\nthis:\n  step n = 0\n  step (Suc n) = 1\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) p) \\<Longrightarrow>\n    1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "ultimately"], ["proof (chain)\npicking this:\n  coord\\<Phi> (rho n p) = p \\<and>\n  vote (rho (Suc n) p) \\<noteq> None \\<and>\n  N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  \\<le> card {q. coord\\<Phi> (rho n q) = p}\n  step n = 0\n  step (Suc n) = 1\n  CHORun LV_M rho HOs coords", "show \"?R (Suc n)\""], ["proof (prove)\nusing this:\n  coord\\<Phi> (rho n p) = p \\<and>\n  vote (rho (Suc n) p) \\<noteq> None \\<and>\n  N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  \\<le> card {q. coord\\<Phi> (rho n q) = p}\n  step n = 0\n  step (Suc n) = 1\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. 1 \\<le> step (Suc n) \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    vote (rho (Suc n) p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}", "by (auto simp: notStep3EqualCoord)"], ["proof (state)\nthis:\n  1 \\<le> step (Suc n) \\<and>\n  coord\\<Phi> (rho (Suc n) p) = p \\<and>\n  vote (rho (Suc n) p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}\n\ngoal:\nNo subgoals!", "qed\n  \\<comment> \\<open>the remaining cases are all solved by expanding the definitions\\<close>"], ["proof (state)\nthis:\n  commt (rho (Suc n) p) \\<longrightarrow>\n  1 \\<le> step (Suc n) \\<and>\n  coord\\<Phi> (rho (Suc n) p) = p \\<and>\n  vote (rho (Suc n) p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho (Suc n) q) = p}\n\ngoal (4 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    commt (rho 0 p) \\<longrightarrow>\n    1 \\<le> step 0 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    vote (rho 0 p) \\<noteq> None \\<and>\n    N div 2 < card {q. coord\\<Phi> (rho 0 q) = p}\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        commt (rho r p) \\<longrightarrow>\n        1 \\<le> step r \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        vote (rho r p) \\<noteq> None \\<and>\n        N div 2 < card {q. coord\\<Phi> (rho r q) = p};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> commt (rho (Suc r) p) \\<longrightarrow>\n                         1 \\<le> step (Suc r) \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         vote (rho (Suc r) p) \\<noteq> None \\<and>\n                         N div 2 < card {q. coord\\<Phi> (rho (Suc r) q) = p}", "qed (auto simp: LV_CHOMachine_def LV_initState_def next1_def next2_def\n                  next3_def notStep3EqualCoord[OF run])"], ["proof (state)\nthis:\n  commt (rho r p) \\<longrightarrow>\n  1 \\<le> step r \\<and>\n  coord\\<Phi> (rho r p) = p \\<and>\n  vote (rho r p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p}\n\ngoal (1 subgoal):\n 1. A", "with cmt"], ["proof (chain)\npicking this:\n  commt (rho r p)\n  commt (rho r p) \\<longrightarrow>\n  1 \\<le> step r \\<and>\n  coord\\<Phi> (rho r p) = p \\<and>\n  vote (rho r p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p}", "show ?thesis"], ["proof (prove)\nusing this:\n  commt (rho r p)\n  commt (rho r p) \\<longrightarrow>\n  1 \\<le> step r \\<and>\n  coord\\<Phi> (rho r p) = p \\<and>\n  vote (rho r p) \\<noteq> None \\<and>\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p}\n\ngoal (1 subgoal):\n 1. A", "by (intro conds, auto)"], ["proof (state)\nthis:\n  A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A process has a current timestamp only if:\n  \\begin{itemize}\n  \\item it is at step 2 or beyond,\n  \\item its coordinator has committed,\n  \\item its \\<open>x\\<close> value is the \\<open>vote\\<close> of its coordinator.\n  \\end{itemize}\n\\<close>"], ["", "lemma currentTimestampE:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and ts: \"timestamp (rho r p) = Suc (phase r)\"\n  and conds: \"\\<lbrakk> 2 \\<le> step r;\n                commt (rho r (coord\\<Phi> (rho r p)));\n                x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))))\n              \\<rbrakk> \\<Longrightarrow> A\"\n  shows \"A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A", "let \"?ts n\" = \"timestamp (rho n p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. A", "let \"?crd n\" = \"coord\\<Phi> (rho n p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. A", "have \"?ts r = Suc (phase r) \\<longrightarrow> \n           2 \\<le> step r \n         \\<and> commt (rho r (?crd r))\n         \\<and> x (rho r p) = the (vote (rho r (?crd r)))\"\n    (is \"?Q p r\" is \"_ \\<longrightarrow> ?R r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n    2 \\<le> step r \\<and>\n    commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n    x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))))", "proof (rule LV_induct'[OF run, where P=\"?Q\"])\n    \\<comment> \\<open>The assertion is trivially true initially because the timestamp is 0.\\<close>"], ["proof (state)\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    timestamp (rho 0 p) = Suc (phase 0) \\<longrightarrow>\n    2 \\<le> step 0 \\<and>\n    commt (rho 0 (coord\\<Phi> (rho 0 p))) \\<and>\n    x (rho 0 p) = the (vote (rho 0 (coord\\<Phi> (rho 0 p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "assume \"CinitState LV_M p (rho 0 p) (coords 0 p)\""], ["proof (state)\nthis:\n  CinitState LV_M p (rho 0 p) (coords 0 p)\n\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    timestamp (rho 0 p) = Suc (phase 0) \\<longrightarrow>\n    2 \\<le> step 0 \\<and>\n    commt (rho 0 (coord\\<Phi> (rho 0 p))) \\<and>\n    x (rho 0 p) = the (vote (rho 0 (coord\\<Phi> (rho 0 p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "thus \"?Q p 0\""], ["proof (prove)\nusing this:\n  CinitState LV_M p (rho 0 p) (coords 0 p)\n\ngoal (1 subgoal):\n 1. timestamp (rho 0 p) = Suc (phase 0) \\<longrightarrow>\n    2 \\<le> step 0 \\<and>\n    commt (rho 0 (coord\\<Phi> (rho 0 p))) \\<and>\n    x (rho 0 p) = the (vote (rho 0 (coord\\<Phi> (rho 0 p))))", "by (auto simp: LV_CHOMachine_def LV_initState_def)"], ["proof (state)\nthis:\n  timestamp (rho 0 p) = Suc (phase 0) \\<longrightarrow>\n  2 \\<le> step 0 \\<and>\n  commt (rho 0 (coord\\<Phi> (rho 0 p))) \\<and>\n  x (rho 0 p) = the (vote (rho 0 (coord\\<Phi> (rho 0 p))))\n\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "txt \\<open>The assertion is trivially preserved by step 0 because the timestamp in the\n          post-state cannot be current (cf. lemma \\<open>LV_timestamp_bounded\\<close>).\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "fix n"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "assume stp': \"step (Suc n) = 1\""], ["proof (state)\nthis:\n  step (Suc n) = 1\n\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "with run LV_timestamp_bounded[where n=\"Suc n\"]"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  CHORun LV_M ?rho ?HOs ?coords \\<Longrightarrow>\n  timestamp (?rho (Suc n) ?p)\n  \\<le> (if step (Suc n) < 2 then phase (Suc n) else Suc (phase (Suc n)))\n  step (Suc n) = 1", "have \"?ts (Suc n) \\<le> phase (Suc n)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  CHORun LV_M ?rho ?HOs ?coords \\<Longrightarrow>\n  timestamp (?rho (Suc n) ?p)\n  \\<le> (if step (Suc n) < 2 then phase (Suc n) else Suc (phase (Suc n)))\n  step (Suc n) = 1\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) \\<le> phase (Suc n)", "by auto"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) \\<le> phase (Suc n)\n\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 0;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "thus \"?Q p (Suc n)\""], ["proof (prove)\nusing this:\n  timestamp (rho (Suc n) p) \\<le> phase (Suc n)\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "by simp"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n  2 \\<le> step (Suc n) \\<and>\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n  x (rho (Suc n) p) = the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "txt \\<open>Step 1 establishes the assertion by definition of the transition relation.\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "assume stp: \"step n = 1\" and stp':\"step (Suc n) = 2\"\n       and ph: \"phase (Suc n) = phase n\"\n       and nxt: \"next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n)) \n                           (coords (Suc n) p) (rho (Suc n) p)\""], ["proof (state)\nthis:\n  step n = 1\n  step (Suc n) = 2\n  phase (Suc n) = phase n\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 1;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "show \"?Q p (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "assume ts: \"?ts (Suc n) = Suc (phase (Suc n))\""], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "from run stp LV_timestamp_bounded[where n=n]"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n  CHORun LV_M ?rho ?HOs ?coords \\<Longrightarrow>\n  timestamp (?rho n ?p)\n  \\<le> (if step n < 2 then phase n else Suc (phase n))", "have \"?ts n \\<le> phase n\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n  CHORun LV_M ?rho ?HOs ?coords \\<Longrightarrow>\n  timestamp (?rho n ?p)\n  \\<le> (if step n < 2 then phase n else Suc (phase n))\n\ngoal (1 subgoal):\n 1. timestamp (rho n p) \\<le> phase n", "by auto"], ["proof (state)\nthis:\n  timestamp (rho n p) \\<le> phase n\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "moreover"], ["proof (state)\nthis:\n  timestamp (rho n p) \\<le> phase n\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 1", "have \"vote (rho (Suc n) (?crd (Suc n))) = vote (rho n (?crd n))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n    vote (rho n (coord\\<Phi> (rho n p)))", "by (auto simp: notStep3EqualCoord notStep0EqualVote)"], ["proof (state)\nthis:\n  vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  vote (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  vote (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 1", "have \"commt (rho (Suc n) (?crd (Suc n))) = commt (rho n (?crd n))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n    commt (rho n (coord\\<Phi> (rho n p)))", "by (auto simp: notStep3EqualCoord notStep03EqualCommit)"], ["proof (state)\nthis:\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  commt (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "moreover"], ["proof (state)\nthis:\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  commt (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "note ts nxt stp stp' ph"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n))\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  step n = 1\n  step (Suc n) = 2\n  phase (Suc n) = phase n\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "ultimately"], ["proof (chain)\npicking this:\n  timestamp (rho n p) \\<le> phase n\n  vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  vote (rho n (coord\\<Phi> (rho n p)))\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  commt (rho n (coord\\<Phi> (rho n p)))\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n))\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  step n = 1\n  step (Suc n) = 2\n  phase (Suc n) = phase n", "show \"?R (Suc n)\""], ["proof (prove)\nusing this:\n  timestamp (rho n p) \\<le> phase n\n  vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  vote (rho n (coord\\<Phi> (rho n p)))\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  commt (rho n (coord\\<Phi> (rho n p)))\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n))\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  step n = 1\n  step (Suc n) = 2\n  phase (Suc n) = phase n\n\ngoal (1 subgoal):\n 1. 2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "by (auto simp: LV_CHOMachine_def HOrcvdMsgs_def LV_sendMsg_def\n                       next1_def send1_def isVote_def)"], ["proof (state)\nthis:\n  2 \\<le> step (Suc n) \\<and>\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n  x (rho (Suc n) p) = the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n  2 \\<le> step (Suc n) \\<and>\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n  x (rho (Suc n) p) = the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "txt \\<open>For step 2, the assertion follows from the induction hypothesis,\n          observing that none of the relevant state components change.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "assume stp: \"step n = 2\" and stp': \"step (Suc n) = 3\"\n       and ph: \"phase (Suc n) = phase n\"\n       and ih: \"?Q p n\"\n       and nxt: \"next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n                           (coords (Suc n) p) (rho (Suc n) p)\""], ["proof (state)\nthis:\n  step n = 2\n  step (Suc n) = 3\n  phase (Suc n) = phase n\n  timestamp (rho n p) = Suc (phase n) \\<longrightarrow>\n  2 \\<le> step n \\<and>\n  commt (rho n (coord\\<Phi> (rho n p))) \\<and>\n  x (rho n p) = the (vote (rho n (coord\\<Phi> (rho n p))))\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>step r = 2;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))\n 2. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "show \"?Q p (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "assume ts: \"?ts (Suc n) = Suc (phase (Suc n))\""], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2", "have vt: \"vote (rho (Suc n) (?crd (Suc n))) = vote (rho n (?crd n))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n    vote (rho n (coord\\<Phi> (rho n p)))", "by (auto simp add: notStep3EqualCoord notStep0EqualVote)"], ["proof (state)\nthis:\n  vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  vote (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2", "have cmt: \"commt (rho (Suc n) (?crd (Suc n))) = commt (rho n (?crd n))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n\ngoal (1 subgoal):\n 1. commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n    commt (rho n (coord\\<Phi> (rho n p)))", "by (auto simp add: notStep3EqualCoord notStep03EqualCommit)"], ["proof (state)\nthis:\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  commt (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<Longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "with vt ts ph stp stp' ih nxt"], ["proof (chain)\npicking this:\n  vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  vote (rho n (coord\\<Phi> (rho n p)))\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n))\n  phase (Suc n) = phase n\n  step n = 2\n  step (Suc n) = 3\n  timestamp (rho n p) = Suc (phase n) \\<longrightarrow>\n  2 \\<le> step n \\<and>\n  commt (rho n (coord\\<Phi> (rho n p))) \\<and>\n  x (rho n p) = the (vote (rho n (coord\\<Phi> (rho n p))))\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  commt (rho n (coord\\<Phi> (rho n p)))", "show \"?R (Suc n)\""], ["proof (prove)\nusing this:\n  vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  vote (rho n (coord\\<Phi> (rho n p)))\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n))\n  phase (Suc n) = phase n\n  step n = 2\n  step (Suc n) = 3\n  timestamp (rho n p) = Suc (phase n) \\<longrightarrow>\n  2 \\<le> step n \\<and>\n  commt (rho n (coord\\<Phi> (rho n p))) \\<and>\n  x (rho n p) = the (vote (rho n (coord\\<Phi> (rho n p))))\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) =\n  commt (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "by (auto simp add: next2_def)"], ["proof (state)\nthis:\n  2 \\<le> step (Suc n) \\<and>\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n  x (rho (Suc n) p) = the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n  2 \\<le> step (Suc n) \\<and>\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n  x (rho (Suc n) p) = the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "txt \\<open>The assertion is trivially preserved by step 3 because the timestamp in the\n          post-state cannot be current (cf. lemma \\<open>LV_timestamp_bounded\\<close>).\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "assume stp': \"step (Suc n) = 0\""], ["proof (state)\nthis:\n  step (Suc n) = 0\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "with run LV_timestamp_bounded[where n=\"Suc n\"]"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  CHORun LV_M ?rho ?HOs ?coords \\<Longrightarrow>\n  timestamp (?rho (Suc n) ?p)\n  \\<le> (if step (Suc n) < 2 then phase (Suc n) else Suc (phase (Suc n)))\n  step (Suc n) = 0", "have \"?ts (Suc n) \\<le> phase (Suc n)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  CHORun LV_M ?rho ?HOs ?coords \\<Longrightarrow>\n  timestamp (?rho (Suc n) ?p)\n  \\<le> (if step (Suc n) < 2 then phase (Suc n) else Suc (phase (Suc n)))\n  step (Suc n) = 0\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) \\<le> phase (Suc n)", "by auto"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) \\<le> phase (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>step r = 3;\n        timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n        2 \\<le> step r \\<and>\n        commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n        x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> timestamp (rho (Suc r) p) =\n                         Suc (phase (Suc r)) \\<longrightarrow>\n                         2 \\<le> step (Suc r) \\<and>\n                         commt\n                          (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))) \\<and>\n                         x (rho (Suc r) p) =\n                         the (vote\n                               (rho (Suc r) (coord\\<Phi> (rho (Suc r) p))))", "thus \"?Q p (Suc n)\""], ["proof (prove)\nusing this:\n  timestamp (rho (Suc n) p) \\<le> phase (Suc n)\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n    2 \\<le> step (Suc n) \\<and>\n    commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n    x (rho (Suc n) p) =\n    the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))", "by simp"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) p) = Suc (phase (Suc n)) \\<longrightarrow>\n  2 \\<le> step (Suc n) \\<and>\n  commt (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))) \\<and>\n  x (rho (Suc n) p) = the (vote (rho (Suc n) (coord\\<Phi> (rho (Suc n) p))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n  2 \\<le> step r \\<and>\n  commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n  x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))))\n\ngoal (1 subgoal):\n 1. A", "with ts"], ["proof (chain)\npicking this:\n  timestamp (rho r p) = Suc (phase r)\n  timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n  2 \\<le> step r \\<and>\n  commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n  x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))))", "show ?thesis"], ["proof (prove)\nusing this:\n  timestamp (rho r p) = Suc (phase r)\n  timestamp (rho r p) = Suc (phase r) \\<longrightarrow>\n  2 \\<le> step r \\<and>\n  commt (rho r (coord\\<Phi> (rho r p))) \\<and>\n  x (rho r p) = the (vote (rho r (coord\\<Phi> (rho r p))))\n\ngoal (1 subgoal):\n 1. A", "by (intro conds) auto"], ["proof (state)\nthis:\n  A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If a process \\<open>p\\<close> has its \\<open>ready\\<close> bit set then:\n  \\begin{itemize}\n  \\item it is at step 3,\n  \\item it considers itself to be the coordinator of that phase and\n  \\item a majority of processes considers \\<open>p\\<close> to be the coordinator\n    and has a current timestamp.\n  \\end{itemize}\n\\<close>"], ["", "lemma readyE:\n  assumes run: \"CHORun LV_M rho HOs coords\" and rdy: \"ready (rho r p)\"\n  and conds: \"\\<lbrakk> step r = 3; coord\\<Phi> (rho r p) = p;\n                card { q . coord\\<Phi> (rho r q) = p \n                         \\<and> timestamp (rho r q) = Suc (phase r) } > N div 2\n              \\<rbrakk> \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "let \"?qs n\" = \"{ q . coord\\<Phi> (rho n q) = p \n                     \\<and> timestamp (rho n q) = Suc (phase n) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"ready (rho r p) \\<longrightarrow> \n          step r = 3\n        \\<and> coord\\<Phi> (rho r p) = p\n        \\<and> card (?qs r) > N div 2\"\n    (is \"?Q p r\"  is \"_ \\<longrightarrow> ?R p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ready (rho r p) \\<longrightarrow>\n    step r = 3 \\<and>\n    coord\\<Phi> (rho r p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho r q) = p \\<and>\n           timestamp (rho r q) = Suc (phase r)}", "proof (rule LV_induct'[OF run, where P=\"?Q\"])\n    \\<comment> \\<open>the interesting case is step 2\\<close>"], ["proof (state)\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    ready (rho 0 p) \\<longrightarrow>\n    step 0 = 3 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho 0 q) = p \\<and>\n           timestamp (rho 0 q) = Suc (phase 0)}\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}", "fix n"], ["proof (state)\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    ready (rho 0 p) \\<longrightarrow>\n    step 0 = 3 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho 0 q) = p \\<and>\n           timestamp (rho 0 q) = Suc (phase 0)}\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}", "assume stp: \"step n = 2\" and stp': \"step (Suc n) = 3\"\n       and ih: \"?Q p n\" and ph: \"phase (Suc n) = phase n\"\n       and nxt: \"next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n                           (coords (Suc n) p) (rho (Suc n) p)\""], ["proof (state)\nthis:\n  step n = 2\n  step (Suc n) = 3\n  ready (rho n p) \\<longrightarrow>\n  step n = 3 \\<and>\n  coord\\<Phi> (rho n p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho n q) = p \\<and>\n         timestamp (rho n q) = Suc (phase n)}\n  phase (Suc n) = phase n\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (5 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    ready (rho 0 p) \\<longrightarrow>\n    step 0 = 3 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho 0 q) = p \\<and>\n           timestamp (rho 0 q) = Suc (phase 0)}\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}", "show \"?Q p (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "assume rdy: \"ready (rho (Suc n) p)\""], ["proof (state)\nthis:\n  ready (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "from stp ih"], ["proof (chain)\npicking this:\n  step n = 2\n  ready (rho n p) \\<longrightarrow>\n  step n = 3 \\<and>\n  coord\\<Phi> (rho n p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho n q) = p \\<and>\n         timestamp (rho n q) = Suc (phase n)}", "have nrdy: \"\\<not> ready (rho n p)\""], ["proof (prove)\nusing this:\n  step n = 2\n  ready (rho n p) \\<longrightarrow>\n  step n = 3 \\<and>\n  coord\\<Phi> (rho n p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho n q) = p \\<and>\n         timestamp (rho n q) = Suc (phase n)}\n\ngoal (1 subgoal):\n 1. \\<not> ready (rho n p)", "by simp"], ["proof (state)\nthis:\n  \\<not> ready (rho n p)\n\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "with rdy nxt"], ["proof (chain)\npicking this:\n  ready (rho (Suc n) p)\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  \\<not> ready (rho n p)", "have \"coord\\<Phi> (rho n p) = p\""], ["proof (prove)\nusing this:\n  ready (rho (Suc n) p)\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  \\<not> ready (rho n p)\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho n p) = p", "by (auto simp: next2_def)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho n p) = p\n\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "with run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n  coord\\<Phi> (rho n p) = p", "have coord: \"coord\\<Phi> (rho (Suc n) p) = p\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n  coord\\<Phi> (rho n p) = p\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (Suc n) p) = p", "by (simp add: notStep3EqualCoord)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (Suc n) p) = p\n\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "let ?acks = \"acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "from nrdy rdy nxt"], ["proof (chain)\npicking this:\n  \\<not> ready (rho n p)\n  ready (rho (Suc n) p)\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)", "have aRcvd: \"card ?acks > N div 2\""], ["proof (prove)\nusing this:\n  \\<not> ready (rho n p)\n  ready (rho (Suc n) p)\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. N div 2 < card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))", "by (auto simp: next2_def)"], ["proof (state)\nthis:\n  N div 2 < card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "have \"?acks \\<subseteq> ?qs (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n    \\<subseteq> {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n                    timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> acksRcvd\n                (HOrcvdMsgs LV_M n p (HOs n p) (rho n)) \\<Longrightarrow>\n       coord\\<Phi> (rho (Suc n) x) = p \\<and>\n       timestamp (rho (Suc n) x) = Suc (phase (Suc n))", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> acksRcvd\n                (HOrcvdMsgs LV_M n p (HOs n p) (rho n)) \\<Longrightarrow>\n       coord\\<Phi> (rho (Suc n) x) = p \\<and>\n       timestamp (rho (Suc n) x) = Suc (phase (Suc n))", "assume q: \"q \\<in> ?acks\""], ["proof (state)\nthis:\n  q \\<in> acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> acksRcvd\n                (HOrcvdMsgs LV_M n p (HOs n p) (rho n)) \\<Longrightarrow>\n       coord\\<Phi> (rho (Suc n) x) = p \\<and>\n       timestamp (rho (Suc n) x) = Suc (phase (Suc n))", "with stp"], ["proof (chain)\npicking this:\n  step n = 2\n  q \\<in> acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))", "have n: \"coord\\<Phi> (rho n q) = p \\<and> timestamp (rho n q) = Suc (phase n)\""], ["proof (prove)\nusing this:\n  step n = 2\n  q \\<in> acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho n q) = p \\<and> timestamp (rho n q) = Suc (phase n)", "by (auto simp: LV_CHOMachine_def HOrcvdMsgs_def LV_sendMsg_def \n                         acksRcvd_def send2_def isAck_def)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho n q) = p \\<and> timestamp (rho n q) = Suc (phase n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> acksRcvd\n                (HOrcvdMsgs LV_M n p (HOs n p) (rho n)) \\<Longrightarrow>\n       coord\\<Phi> (rho (Suc n) x) = p \\<and>\n       timestamp (rho (Suc n) x) = Suc (phase (Suc n))", "with run stp ph"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n  phase (Suc n) = phase n\n  coord\\<Phi> (rho n q) = p \\<and> timestamp (rho n q) = Suc (phase n)", "show \"coord\\<Phi> (rho (Suc n) q) = p\n              \\<and> timestamp (rho (Suc n) q) = Suc (phase (Suc n))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n  phase (Suc n) = phase n\n  coord\\<Phi> (rho n q) = p \\<and> timestamp (rho n q) = Suc (phase n)\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n    timestamp (rho (Suc n) q) = Suc (phase (Suc n))", "by (simp add: notStep3EqualCoord notStep1EqualTimestamp)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho (Suc n) q) = p \\<and>\n  timestamp (rho (Suc n) q) = Suc (phase (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n  \\<subseteq> {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n                  timestamp (rho (Suc n) q) = Suc (phase (Suc n))}\n\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "hence \"card ?acks \\<le> card (?qs (Suc n))\""], ["proof (prove)\nusing this:\n  acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n  \\<subseteq> {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n                  timestamp (rho (Suc n) q) = Suc (phase (Suc n))}\n\ngoal (1 subgoal):\n 1. card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n    \\<le> card\n           {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n               timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  \\<le> card\n         {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n             timestamp (rho (Suc n) q) = Suc (phase (Suc n))}\n\ngoal (1 subgoal):\n 1. ready (rho (Suc n) p) \\<Longrightarrow>\n    step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "with stp' coord aRcvd"], ["proof (chain)\npicking this:\n  step (Suc n) = 3\n  coord\\<Phi> (rho (Suc n) p) = p\n  N div 2 < card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  \\<le> card\n         {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n             timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "show \"?R p (Suc n)\""], ["proof (prove)\nusing this:\n  step (Suc n) = 3\n  coord\\<Phi> (rho (Suc n) p) = p\n  N div 2 < card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  card (acksRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n  \\<le> card\n         {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n             timestamp (rho (Suc n) q) = Suc (phase (Suc n))}\n\ngoal (1 subgoal):\n 1. step (Suc n) = 3 \\<and>\n    coord\\<Phi> (rho (Suc n) p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n           timestamp (rho (Suc n) q) = Suc (phase (Suc n))}", "by auto"], ["proof (state)\nthis:\n  step (Suc n) = 3 \\<and>\n  coord\\<Phi> (rho (Suc n) p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n         timestamp (rho (Suc n) q) = Suc (phase (Suc n))}\n\ngoal:\nNo subgoals!", "qed\n    \\<comment> \\<open>the remaining steps are all solved trivially\\<close>"], ["proof (state)\nthis:\n  ready (rho (Suc n) p) \\<longrightarrow>\n  step (Suc n) = 3 \\<and>\n  coord\\<Phi> (rho (Suc n) p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho (Suc n) q) = p \\<and>\n         timestamp (rho (Suc n) q) = Suc (phase (Suc n))}\n\ngoal (4 subgoals):\n 1. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    ready (rho 0 p) \\<longrightarrow>\n    step 0 = 3 \\<and>\n    coord\\<Phi> (rho 0 p) = p \\<and>\n    N div 2\n    < card\n       {q. coord\\<Phi> (rho 0 q) = p \\<and>\n           timestamp (rho 0 q) = Suc (phase 0)}\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        ready (rho r p) \\<longrightarrow>\n        step r = 3 \\<and>\n        coord\\<Phi> (rho r p) = p \\<and>\n        N div 2\n        < card\n           {q. coord\\<Phi> (rho r q) = p \\<and>\n               timestamp (rho r q) = Suc (phase r)};\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n         (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> ready (rho (Suc r) p) \\<longrightarrow>\n                         step (Suc r) = 3 \\<and>\n                         coord\\<Phi> (rho (Suc r) p) = p \\<and>\n                         N div 2\n                         < card\n                            {q. coord\\<Phi> (rho (Suc r) q) = p \\<and>\n                                timestamp (rho (Suc r) q) =\n                                Suc (phase (Suc r))}", "qed (auto simp: LV_CHOMachine_def LV_initState_def\n                  next0_def next1_def next3_def)"], ["proof (state)\nthis:\n  ready (rho r p) \\<longrightarrow>\n  step r = 3 \\<and>\n  coord\\<Phi> (rho r p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. P", "with rdy"], ["proof (chain)\npicking this:\n  ready (rho r p)\n  ready (rho r p) \\<longrightarrow>\n  step r = 3 \\<and>\n  coord\\<Phi> (rho r p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p \\<and>\n         timestamp (rho r q) = Suc (phase r)}", "show ?thesis"], ["proof (prove)\nusing this:\n  ready (rho r p)\n  ready (rho r p) \\<longrightarrow>\n  step r = 3 \\<and>\n  coord\\<Phi> (rho r p) = p \\<and>\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. P", "by (blast intro: conds)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A process decides only if the following conditions hold:\n  \\begin{itemize}\n  \\item it is at step 3,\n  \\item its coordinator votes for the value the process decides on,\n  \\item the coordinator has its \\<open>ready\\<close> and \\<open>commt\\<close> bits set.\n  \\end{itemize}\n\\<close>"], ["", "lemma decisionE:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and dec: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  and conds: \"\\<lbrakk> \n        step r = 3; \n        decide (rho (Suc r) p) = Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n        ready (rho r (coord\\<Phi> (rho r p))); commt (rho r (coord\\<Phi> (rho r p)))\n      \\<rbrakk> \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "let ?cfg = \"rho r\""], ["proof (state)\ngoal (1 subgoal):\n 1. P", "let ?cfg' = \"rho (Suc r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P", "let \"?crd p\" = \"coord\\<Phi> (?cfg p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P", "let ?dec' = \"decide (?cfg' p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P", "txt \\<open>Except for the assertion about the \\<open>commt\\<close> field, the assertion can be\n         proved directly from the next-state relation.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have 1: \"step r = 3\n           \\<and> ?dec' = Some (the (vote (?cfg (?crd p))))\n           \\<and> ready (?cfg (?crd p))\"\n    (is \"?Q p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step r = 3 \\<and>\n    decide (rho (Suc r) p) =\n    Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n    ready (rho r (coord\\<Phi> (rho r p)))", "proof (rule LV_Suc'[OF run, where P=\"?Q\"])\n    \\<comment> \\<open>for step 3, we prove the thesis by expanding the relevant definitions\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n     next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 3. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 4. \\<lbrakk>step r = 3; step (Suc r) = 0; phase (Suc r) = Suc (phase r);\n     next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "assume \"next3 r p (?cfg p) (HOrcvdMsgs LV_M r p (HOs r p) ?cfg) \n                      (coords (Suc r) p) (?cfg' p)\"\n       and \"step r = 3\""], ["proof (state)\nthis:\n  next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n  step r = 3\n\ngoal (4 subgoals):\n 1. \\<lbrakk>step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n     next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 3. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 4. \\<lbrakk>step r = 3; step (Suc r) = 0; phase (Suc r) = Suc (phase r);\n     next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "with dec"], ["proof (chain)\npicking this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n  step r = 3", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n  step r = 3\n\ngoal (1 subgoal):\n 1. step r = 3 \\<and>\n    decide (rho (Suc r) p) =\n    Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n    ready (rho r (coord\\<Phi> (rho r p)))", "by (auto simp: next3_def send3_def isVote_def LV_CHOMachine_def \n                     HOrcvdMsgs_def LV_sendMsg_def)"], ["proof (state)\nthis:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n     next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 3. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "next\n    \\<comment> \\<open>the other steps don't change the decision\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n     next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 3. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "assume \"next0 r p (?cfg p) (HOrcvdMsgs LV_M r p (HOs r p) ?cfg)\n                      (coords (Suc r) p) (?cfg' p)\""], ["proof (state)\nthis:\n  next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step r = 0; step (Suc r) = 1; phase (Suc r) = phase r;\n     next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 3. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "with dec"], ["proof (chain)\npicking this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. step r = 3 \\<and>\n    decide (rho (Suc r) p) =\n    Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n    ready (rho r (coord\\<Phi> (rho r p)))", "by (auto simp: next0_def)"], ["proof (state)\nthis:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "assume \"next1 r p (?cfg p) (HOrcvdMsgs LV_M r p (HOs r p) ?cfg)\n                      (coords (Suc r) p) (?cfg' p)\""], ["proof (state)\nthis:\n  next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step r = 1; step (Suc r) = 2; phase (Suc r) = phase r;\n     next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))\n 2. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "with dec"], ["proof (chain)\npicking this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. step r = 3 \\<and>\n    decide (rho (Suc r) p) =\n    Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n    ready (rho r (coord\\<Phi> (rho r p)))", "by (auto simp: next1_def)"], ["proof (state)\nthis:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "assume \"next2 r p (?cfg p) (HOrcvdMsgs LV_M r p (HOs r p) ?cfg)\n                      (coords (Suc r) p) (?cfg' p)\""], ["proof (state)\nthis:\n  next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 2; step (Suc r) = 3; phase (Suc r) = phase r;\n     next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n      (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n    \\<Longrightarrow> step r = 3 \\<and>\n                      decide (rho (Suc r) p) =\n                      Some\n                       (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n                      ready (rho r (coord\\<Phi> (rho r p)))", "with dec"], ["proof (chain)\npicking this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n   (coords (Suc r) p) (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. step r = 3 \\<and>\n    decide (rho (Suc r) p) =\n    Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n    ready (rho r (coord\\<Phi> (rho r p)))", "by (auto simp: next2_def)"], ["proof (state)\nthis:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. P", "hence \"ready (?cfg (?crd p))\""], ["proof (prove)\nusing this:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. ready (rho r (coord\\<Phi> (rho r p)))", "by blast"], ["proof (state)\nthis:\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. P", "txt \\<open>Because the coordinator is ready, there is a majority of processes that\n         consider it to be the coordinator and that have a current timestamp.\\<close>"], ["proof (state)\nthis:\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. P", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  ready (rho r (coord\\<Phi> (rho r p)))", "have \"card {q . ?crd q = ?crd p \\<and> timestamp (?cfg q) = Suc (phase r)} \n          > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. N div 2\n    < card\n       {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n           timestamp (rho r q) = Suc (phase r)}", "by (rule readyE)\n  \\<comment> \\<open>Hence there is at least one such process \\ldots\\<close>"], ["proof (state)\nthis:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. P", "hence \"card {q . ?crd q = ?crd p \\<and> timestamp (?cfg q) = Suc (phase r)} \\<noteq> 0\""], ["proof (prove)\nusing this:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)} \\<noteq>\n    0", "by arith"], ["proof (state)\nthis:\n  card\n   {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n       timestamp (rho r q) = Suc (phase r)} \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. P", "(** auto simplifies too much **)"], ["proof (state)\nthis:\n  card\n   {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n       timestamp (rho r q) = Suc (phase r)} \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. P", "then"], ["proof (chain)\npicking this:\n  card\n   {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n       timestamp (rho r q) = Suc (phase r)} \\<noteq>\n  0", "obtain q where \"?crd q = ?crd p\" and \"timestamp (?cfg q) = Suc (phase r)\""], ["proof (prove)\nusing this:\n  card\n   {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n       timestamp (rho r q) = Suc (phase r)} \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p);\n         timestamp (rho r q) = Suc (phase r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto\n  \\<comment> \\<open>\\ldots\\ and by a previous lemma the coordinator must have committed.\\<close>"], ["proof (state)\nthis:\n  coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p)\n  timestamp (rho r q) = Suc (phase r)\n\ngoal (1 subgoal):\n 1. P", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p)\n  timestamp (rho r q) = Suc (phase r)", "have \"commt (?cfg (?crd p))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p)\n  timestamp (rho r q) = Suc (phase r)\n\ngoal (1 subgoal):\n 1. commt (rho r (coord\\<Phi> (rho r p)))", "by (auto elim: currentTimestampE)"], ["proof (state)\nthis:\n  commt (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. P", "with 1"], ["proof (chain)\npicking this:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n  commt (rho r (coord\\<Phi> (rho r p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  step r = 3 \\<and>\n  decide (rho (Suc r) p) =\n  Some (the (vote (rho r (coord\\<Phi> (rho r p))))) \\<and>\n  ready (rho r (coord\\<Phi> (rho r p)))\n  commt (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. P", "by (blast intro: conds)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Integrity\\<close>"], ["", "text \\<open>\n  Integrity is proved using a standard invariance argument that asserts\n  that only values present in the initial state appear in the relevant\n  fields.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text notStep1EqualX},\n  @{text notStep0EqualVote}, @{text commitE} and @{text decisionE}.\n*)"], ["", "lemma lv_integrityInvariant:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and inv: \"\\<lbrakk> range (x \\<circ> (rho n)) \\<subseteq> range (x \\<circ> (rho 0));\n              range (vote \\<circ> (rho n)) \\<subseteq> {None} \\<union> Some ` range (x \\<circ> (rho 0));\n              range (decide \\<circ> (rho n)) \\<subseteq> {None} \\<union> Some ` range (x \\<circ> (rho 0))\n       \\<rbrakk> \\<Longrightarrow> A\"\n  shows \"A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A", "let ?x0 = \"range (x \\<circ> rho 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. A", "let ?x0opt = \"{None} \\<union> Some ` ?x0\""], ["proof (state)\ngoal (1 subgoal):\n 1. A", "have \"range (x \\<circ> rho n) \\<subseteq> ?x0\n        \\<and> range (vote \\<circ> rho n) \\<subseteq> ?x0opt\n        \\<and> range (decide \\<circ> rho n) \\<subseteq> ?x0opt\"\n    (is \"?Inv n\" is \"?X n \\<and> ?Vote n \\<and> ?Decide n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n    range (vote \\<circ> rho n)\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n    range (decide \\<circ> rho n)\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. range (x \\<circ> rho 0) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n    range (vote \\<circ> rho 0)\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n    range (decide \\<circ> rho 0)\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n 2. \\<And>n.\n       range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho n)\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho n)\n       \\<subseteq> {None} \\<union>\n                   Some ` range (x \\<circ> rho 0) \\<Longrightarrow>\n       range (x \\<circ> rho (Suc n))\n       \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "show \"?Inv 0\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. range (x \\<circ> rho 0) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n    range (vote \\<circ> rho 0)\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n    range (decide \\<circ> rho 0)\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (auto simp: CHORun_eq CHOinitConfig_def LV_CHOMachine_def\n                     LV_initState_def)"], ["proof (state)\nthis:\n  range (x \\<circ> rho 0) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho 0)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho 0)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho n)\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho n)\n       \\<subseteq> {None} \\<union>\n                   Some ` range (x \\<circ> rho 0) \\<Longrightarrow>\n       range (x \\<circ> rho (Suc n))\n       \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho n)\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho n)\n       \\<subseteq> {None} \\<union>\n                   Some ` range (x \\<circ> rho 0) \\<Longrightarrow>\n       range (x \\<circ> rho (Suc n))\n       \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho n)\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho n)\n       \\<subseteq> {None} \\<union>\n                   Some ` range (x \\<circ> rho 0) \\<Longrightarrow>\n       range (x \\<circ> rho (Suc n))\n       \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "assume ih: \"?Inv n\""], ["proof (state)\nthis:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho n)\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho n)\n       \\<subseteq> {None} \\<union>\n                   Some ` range (x \\<circ> rho 0) \\<Longrightarrow>\n       range (x \\<circ> rho (Suc n))\n       \\<subseteq> range (x \\<circ> rho 0) \\<and>\n       range (vote \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n       range (decide \\<circ> rho (Suc n))\n       \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "thus \"?Inv (Suc n)\""], ["proof (prove)\nusing this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n    range (vote \\<circ> rho (Suc n))\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n    range (decide \\<circ> rho (Suc n))\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "assume x: \"?X n\" and vt: \"?Vote n\" and dec: \"?Decide n\""], ["proof (state)\nthis:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "txt \\<open>Proof of first conjunct\\<close>"], ["proof (state)\nthis:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "have x': \"?X (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0)", "proof (clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. x (rho (Suc n) xa) \\<in> range (\\<lambda>xa. x (rho 0 xa))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. x (rho (Suc n) xa) \\<in> range (\\<lambda>xa. x (rho 0 xa))", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "show \"x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\" (is \"?P p n\")"], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "proof (rule LV_Suc'[where P=\"?P\"])\n          \\<comment> \\<open>only @{text step1} is of interest\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "assume stp: \"step n = 1\"\n             and nxt: \"next1 n p (rho n p)\n                             (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n                             (coords (Suc n) p) (rho (Suc n) p)\""], ["proof (state)\nthis:\n  step n = 1\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "proof (cases \"rho (Suc n) p = rho n p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rho (Suc n) p = rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "case True"], ["proof (state)\nthis:\n  rho (Suc n) p = rho n p\n\ngoal (2 subgoals):\n 1. rho (Suc n) p = rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "with x"], ["proof (chain)\npicking this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  rho (Suc n) p = rho n p", "show ?thesis"], ["proof (prove)\nusing this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  rho (Suc n) p = rho n p\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "case False"], ["proof (state)\nthis:\n  rho (Suc n) p \\<noteq> rho n p\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "with stp nxt"], ["proof (chain)\npicking this:\n  step n = 1\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  rho (Suc n) p \\<noteq> rho n p", "have cmt: \"commt (rho n (coord\\<Phi> (rho n p)))\"\n              and xp: \"x (rho (Suc n) p) = the (vote (rho n (coord\\<Phi> (rho n p))))\""], ["proof (prove)\nusing this:\n  step n = 1\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  rho (Suc n) p \\<noteq> rho n p\n\ngoal (1 subgoal):\n 1. commt (rho n (coord\\<Phi> (rho n p))) &&&\n    x (rho (Suc n) p) = the (vote (rho n (coord\\<Phi> (rho n p))))", "by (auto simp: next1_def LV_CHOMachine_def HOrcvdMsgs_def \n                           LV_sendMsg_def send1_def isVote_def)"], ["proof (state)\nthis:\n  commt (rho n (coord\\<Phi> (rho n p)))\n  x (rho (Suc n) p) = the (vote (rho n (coord\\<Phi> (rho n p))))\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "from run cmt"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho n (coord\\<Phi> (rho n p)))", "have \"vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None", "by (rule commitE)"], ["proof (state)\nthis:\n  vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "moreover"], ["proof (state)\nthis:\n  vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "from vt"], ["proof (chain)\npicking this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "have \"vote (rho n (coord\\<Phi> (rho n p))) \\<in> ?x0opt\""], ["proof (prove)\nusing this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho n (coord\\<Phi> (rho n p)))\n    \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (auto simp add: image_def)"], ["proof (state)\nthis:\n  vote (rho n (coord\\<Phi> (rho n p)))\n  \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "moreover"], ["proof (state)\nthis:\n  vote (rho n (coord\\<Phi> (rho n p)))\n  \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "note xp"], ["proof (state)\nthis:\n  x (rho (Suc n) p) = the (vote (rho n (coord\\<Phi> (rho n p))))\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "ultimately"], ["proof (chain)\npicking this:\n  vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None\n  vote (rho n (coord\\<Phi> (rho n p)))\n  \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = the (vote (rho n (coord\\<Phi> (rho n p))))", "show ?thesis"], ["proof (prove)\nusing this:\n  vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None\n  vote (rho n (coord\\<Phi> (rho n p)))\n  \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = the (vote (rho n (coord\\<Phi> (rho n p))))\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "by (force simp add: image_def)"], ["proof (state)\nthis:\n  x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n\ngoal:\nNo subgoals!", "qed\n          \\<comment> \\<open>the other steps don't change @{text x}\\<close>"], ["proof (state)\nthis:\n  x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "assume \"step n = 0\""], ["proof (state)\nthis:\n  step n = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 0", "have \"x (rho (Suc n) p) = x (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 0\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) = x (rho n p)", "by (simp add: notStep1EqualX)"], ["proof (state)\nthis:\n  x (rho (Suc n) p) = x (rho n p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "with x"], ["proof (chain)\npicking this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = x (rho n p)", "show ?thesis"], ["proof (prove)\nusing this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = x (rho n p)\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "assume \"step n = 2\""], ["proof (state)\nthis:\n  step n = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2", "have \"x (rho (Suc n) p) = x (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) = x (rho n p)", "by (simp add: notStep1EqualX)"], ["proof (state)\nthis:\n  x (rho (Suc n) p) = x (rho n p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "with x"], ["proof (chain)\npicking this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = x (rho n p)", "show ?thesis"], ["proof (prove)\nusing this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = x (rho n p)\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "assume \"step n = 3\""], ["proof (state)\nthis:\n  step n = 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 3", "have \"x (rho (Suc n) p) = x (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 3\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) = x (rho n p)", "by (simp add: notStep1EqualX)"], ["proof (state)\nthis:\n  x (rho (Suc n) p) = x (rho n p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc n) p)\n                      \\<in> range (\\<lambda>q. x (rho 0 q))", "with x"], ["proof (chain)\npicking this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = x (rho n p)", "show ?thesis"], ["proof (prove)\nusing this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  x (rho (Suc n) p) = x (rho n p)\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc n) p) \\<in> range (\\<lambda>q. x (rho 0 q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "txt \\<open>Proof of second conjunct\\<close>"], ["proof (state)\nthis:\n  range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "have vt': \"?Vote (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (vote \\<circ> rho (Suc n))\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "proof (clarsimp simp: image_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       vote (rho (Suc n) xa) = Some y \\<Longrightarrow>\n       \\<exists>xa. y = x (rho 0 xa)", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       vote (rho (Suc n) xa) = Some y \\<Longrightarrow>\n       \\<exists>xa. y = x (rho 0 xa)", "assume v: \"vote (rho (Suc n) p) = Some v\""], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       vote (rho (Suc n) xa) = Some y \\<Longrightarrow>\n       \\<exists>xa. y = x (rho 0 xa)", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have \"vote (rho (Suc n) p) = Some v \\<longrightarrow> v \\<in> ?x0\" (is \"?P p n\")"], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "proof (rule LV_Suc'[where P=\"?P\"])\n          \\<comment> \\<open>here only @{text step0} is of interest\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "assume stp: \"step n = 0\"\n             and nxt: \"next0 n p (rho n p)\n                             (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n                             (coords (Suc n) p) (rho (Suc n) p)\""], ["proof (state)\nthis:\n  step n = 0\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>step n = 0; step (Suc n) = 1; phase (Suc n) = phase n;\n     next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 4. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "proof  (cases \"rho (Suc n) p = rho n p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rho (Suc n) p = rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)\n 2. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "case True"], ["proof (state)\nthis:\n  rho (Suc n) p = rho n p\n\ngoal (2 subgoals):\n 1. rho (Suc n) p = rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)\n 2. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "from vt"], ["proof (chain)\npicking this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "have \"vote (rho n p) \\<in> ?x0opt\""], ["proof (prove)\nusing this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (2 subgoals):\n 1. rho (Suc n) p = rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)\n 2. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "with True"], ["proof (chain)\npicking this:\n  rho (Suc n) p = rho n p\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  rho (Suc n) p = rho n p\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "by auto"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "case False"], ["proof (state)\nthis:\n  rho (Suc n) p \\<noteq> rho n p\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "from nxt stp False v"], ["proof (chain)\npicking this:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  step n = 0\n  rho (Suc n) p \\<noteq> rho n p\n  vote (rho (Suc n) p) = Some v", "obtain q where \"v = x (rho n q)\""], ["proof (prove)\nusing this:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  step n = 0\n  rho (Suc n) p \\<noteq> rho n p\n  vote (rho (Suc n) p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>q. v = x (rho n q) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: next0_def send0_def LV_CHOMachine_def \n                             HOrcvdMsgs_def LV_sendMsg_def)"], ["proof (state)\nthis:\n  v = x (rho n q)\n\ngoal (1 subgoal):\n 1. rho (Suc n) p \\<noteq> rho n p \\<Longrightarrow>\n    vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "with x"], ["proof (chain)\npicking this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  v = x (rho n q)", "show ?thesis"], ["proof (prove)\nusing this:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0)\n  v = x (rho n q)\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal:\nNo subgoals!", "qed\n          \\<comment> \\<open>the other cases don't change the vote\\<close>"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "assume \"step n = 1\""], ["proof (state)\nthis:\n  step n = 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 1", "have \"vote (rho (Suc n) p) = vote (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = vote (rho n p)", "by (simp add: notStep0EqualVote)"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "from vt"], ["proof (chain)\npicking this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "have \"vote (rho n p) \\<in> ?x0opt\""], ["proof (prove)\nusing this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step n = 1; step (Suc n) = 2; phase (Suc n) = phase n;\n     next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 3. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "ultimately"], ["proof (chain)\npicking this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "by auto"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "assume \"step n = 2\""], ["proof (state)\nthis:\n  step n = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2", "have \"vote (rho (Suc n) p) = vote (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = vote (rho n p)", "by (simp add: notStep0EqualVote)"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "from vt"], ["proof (chain)\npicking this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "have \"vote (rho n p) \\<in> ?x0opt\""], ["proof (prove)\nusing this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step n = 2; step (Suc n) = 3; phase (Suc n) = phase n;\n     next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)\n 2. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "ultimately"], ["proof (chain)\npicking this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "by auto"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "assume \"step n = 3\""], ["proof (state)\nthis:\n  step n = 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 3", "have \"vote (rho (Suc n) p) = vote (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 3\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = vote (rho n p)", "by (simp add: notStep0EqualVote)"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "from vt"], ["proof (chain)\npicking this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "have \"vote (rho n p) \\<in> ?x0opt\""], ["proof (prove)\nusing this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step n = 3; step (Suc n) = 0; phase (Suc n) = Suc (phase n);\n     next3 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n      (coords (Suc n) p) (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> vote (rho (Suc n) p) = Some v \\<longrightarrow>\n                      v \\<in> range (x \\<circ> rho 0)", "ultimately"], ["proof (chain)\npicking this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  vote (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some v \\<longrightarrow>\n    v \\<in> range (x \\<circ> rho 0)", "by auto"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       vote (rho (Suc n) xa) = Some y \\<Longrightarrow>\n       \\<exists>xa. y = x (rho 0 xa)", "with v"], ["proof (chain)\npicking this:\n  vote (rho (Suc n) p) = Some v\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)", "show \"\\<exists>q. v = x (rho 0 q)\""], ["proof (prove)\nusing this:\n  vote (rho (Suc n) p) = Some v\n  vote (rho (Suc n) p) = Some v \\<longrightarrow>\n  v \\<in> range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. v = x (rho 0 q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (vote \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "txt \\<open>Proof of third conjunct\\<close>"], ["proof (state)\nthis:\n  range (vote \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "have dec': \"?Decide (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (decide \\<circ> rho (Suc n))\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "proof (clarsimp simp: image_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       decide (rho (Suc n) xa) = Some y \\<Longrightarrow>\n       \\<exists>xa. y = x (rho 0 xa)", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       decide (rho (Suc n) xa) = Some y \\<Longrightarrow>\n       \\<exists>xa. y = x (rho 0 xa)", "assume v: \"decide (rho (Suc n) p) = Some v\""], ["proof (state)\nthis:\n  decide (rho (Suc n) p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       decide (rho (Suc n) xa) = Some y \\<Longrightarrow>\n       \\<exists>xa. y = x (rho 0 xa)", "show \"\\<exists>q. v = x (rho 0 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "proof (cases \"decide (rho (Suc n) p) = decide (rho n p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. decide (rho (Suc n) p) = decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)\n 2. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "case True"], ["proof (state)\nthis:\n  decide (rho (Suc n) p) = decide (rho n p)\n\ngoal (2 subgoals):\n 1. decide (rho (Suc n) p) = decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)\n 2. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "with dec True v"], ["proof (chain)\npicking this:\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  decide (rho (Suc n) p) = decide (rho n p)\n  decide (rho (Suc n) p) = Some v\n  decide (rho (Suc n) p) = decide (rho n p)", "show ?thesis"], ["proof (prove)\nusing this:\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  decide (rho (Suc n) p) = decide (rho n p)\n  decide (rho (Suc n) p) = Some v\n  decide (rho (Suc n) p) = decide (rho n p)\n\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  \\<exists>q. v = x (rho 0 q)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "case False"], ["proof (state)\nthis:\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "let ?crd = \"coord\\<Phi> (rho n p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "from False run"], ["proof (chain)\npicking this:\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p)\n  CHORun LV_M rho HOs coords", "have d': \"decide (rho (Suc n) p) = Some (the (vote (rho n ?crd)))\" \n            and cmt: \"commt (rho n ?crd)\""], ["proof (prove)\nusing this:\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p)\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) =\n    Some (the (vote (rho n (coord\\<Phi> (rho n p))))) &&&\n    commt (rho n (coord\\<Phi> (rho n p)))", "by (auto elim: decisionE)"], ["proof (state)\nthis:\n  decide (rho (Suc n) p) = Some (the (vote (rho n (coord\\<Phi> (rho n p)))))\n  commt (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "from vt"], ["proof (chain)\npicking this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "have vtc: \"vote (rho n ?crd) \\<in> ?x0opt\""], ["proof (prove)\nusing this:\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. vote (rho n (coord\\<Phi> (rho n p)))\n    \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  vote (rho n (coord\\<Phi> (rho n p)))\n  \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "from run cmt"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho n (coord\\<Phi> (rho n p)))", "have \"vote (rho n ?crd) \\<noteq> None\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho n (coord\\<Phi> (rho n p)))\n\ngoal (1 subgoal):\n 1. vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None", "by (rule commitE)"], ["proof (state)\nthis:\n  vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<Longrightarrow>\n    \\<exists>q. v = x (rho 0 q)", "with d' v vtc"], ["proof (chain)\npicking this:\n  decide (rho (Suc n) p) = Some (the (vote (rho n (coord\\<Phi> (rho n p)))))\n  decide (rho (Suc n) p) = Some v\n  vote (rho n (coord\\<Phi> (rho n p)))\n  \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc n) p) = Some (the (vote (rho n (coord\\<Phi> (rho n p)))))\n  decide (rho (Suc n) p) = Some v\n  vote (rho n (coord\\<Phi> (rho n p)))\n  \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  vote (rho n (coord\\<Phi> (rho n p))) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. v = x (rho 0 q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q. v = x (rho 0 q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (decide \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n     range (vote \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n     range (decide \\<circ> rho n)\n     \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n    \\<Longrightarrow> range (x \\<circ> rho (Suc n))\n                      \\<subseteq> range (x \\<circ> rho 0) \\<and>\n                      range (vote \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0) \\<and>\n                      range (decide \\<circ> rho (Suc n))\n                      \\<subseteq> {None} \\<union>\n                                  Some ` range (x \\<circ> rho 0)", "from x' vt' dec'"], ["proof (chain)\npicking this:\n  range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0)\n  range (vote \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  range (decide \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0)\n  range (vote \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n  range (decide \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n    range (vote \\<circ> rho (Suc n))\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n    range (decide \\<circ> rho (Suc n))\n    \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by simp"], ["proof (state)\nthis:\n  range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (x \\<circ> rho (Suc n)) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho (Suc n))\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. A", "with inv"], ["proof (chain)\npicking this:\n  \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n   range (vote \\<circ> rho n)\n   \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n   range (decide \\<circ> rho n)\n   \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n  \\<Longrightarrow> A\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0);\n   range (vote \\<circ> rho n)\n   \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0);\n   range (decide \\<circ> rho n)\n   \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\\<rbrakk>\n  \\<Longrightarrow> A\n  range (x \\<circ> rho n) \\<subseteq> range (x \\<circ> rho 0) \\<and>\n  range (vote \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0) \\<and>\n  range (decide \\<circ> rho n)\n  \\<subseteq> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. A", "by simp"], ["proof (state)\nthis:\n  A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Integrity now follows immediately.\n\\<close>"], ["", "theorem lv_integrity:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and dec: \"decide (rho n p) = Some v\"\n  shows \"\\<exists>q. v = x (rho 0 q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have \"decide (rho n p) \\<in> {None} \\<union> Some ` (range (x \\<circ> (rho 0)))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. decide (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "by (rule lv_integrityInvariant) (auto simp: image_def)"], ["proof (state)\nthis:\n  decide (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "with dec"], ["proof (chain)\npicking this:\n  decide (rho n p) = Some v\n  decide (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho n p) = Some v\n  decide (rho n p) \\<in> {None} \\<union> Some ` range (x \\<circ> rho 0)\n\ngoal (1 subgoal):\n 1. \\<exists>q. v = x (rho 0 q)", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  \\<exists>q. v = x (rho 0 q)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Agreement and Irrevocability\\<close>"], ["", "text \\<open>\n  The following lemmas closely follow a hand proof provided by\n  Bernadette Charron-Bost.\n\n  If a process decides, then a majority of processes have a current\n  timestamp.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text decisionE}, @{text readyE}\n  and @{text LV_timestamp_bounded}. \n*)"], ["", "lemma decisionThenMajorityBeyondTS:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and dec: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  shows \"card (procsBeyondTS (Suc (phase r)) (rho r)) > N div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "using run dec"], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "proof (rule decisionE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "txt \\<open>Lemma \\<open>decisionE\\<close> tells us that we are at step 3 and\n    that the coordinator is ready.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "let ?crd = \"coord\\<Phi> (rho r p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "let ?qs = \"{ q . coord\\<Phi> (rho r q) = ?crd\n                 \\<and> timestamp (rho r q) = Suc (phase r) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "assume stp: \"step r = 3\" and rdy: \"ready (rho r ?crd)\""], ["proof (state)\nthis:\n  step r = 3\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "txt \\<open>Now, lemma \\<open>readyE\\<close> implies that a majority of processes\n    have a recent timestamp.\\<close>"], ["proof (state)\nthis:\n  step r = 3\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "from run rdy"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  ready (rho r (coord\\<Phi> (rho r p)))", "have \"card ?qs > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  ready (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. N div 2\n    < card\n       {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n           timestamp (rho r q) = Suc (phase r)}", "by (rule readyE)"], ["proof (state)\nthis:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "moreover"], ["proof (state)\nthis:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "from stp LV_timestamp_bounded[OF run, where n=r]"], ["proof (chain)\npicking this:\n  step r = 3\n  timestamp (rho r ?p) \\<le> (if step r < 2 then phase r else Suc (phase r))", "have \"\\<forall>q. timestamp (rho r q) \\<le> Suc (phase r)\""], ["proof (prove)\nusing this:\n  step r = 3\n  timestamp (rho r ?p) \\<le> (if step r < 2 then phase r else Suc (phase r))\n\ngoal (1 subgoal):\n 1. \\<forall>q. timestamp (rho r q) \\<le> Suc (phase r)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q. timestamp (rho r q) \\<le> Suc (phase r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "hence \"?qs \\<subseteq> procsBeyondTS (Suc (phase r)) (rho r)\""], ["proof (prove)\nusing this:\n  \\<forall>q. timestamp (rho r q) \\<le> Suc (phase r)\n\ngoal (1 subgoal):\n 1. {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n        timestamp (rho r q) = Suc (phase r)}\n    \\<subseteq> procsBeyondTS (Suc (phase r)) (rho r)", "by (auto simp: procsBeyondTS_def)"], ["proof (state)\nthis:\n  {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n      timestamp (rho r q) = Suc (phase r)}\n  \\<subseteq> procsBeyondTS (Suc (phase r)) (rho r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "hence \"card ?qs \\<le> card (procsBeyondTS (Suc (phase r)) (rho r))\""], ["proof (prove)\nusing this:\n  {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n      timestamp (rho r q) = Suc (phase r)}\n  \\<subseteq> procsBeyondTS (Suc (phase r)) (rho r)\n\ngoal (1 subgoal):\n 1. card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n    \\<le> card (procsBeyondTS (Suc (phase r)) (rho r))", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card\n   {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n       timestamp (rho r q) = Suc (phase r)}\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step r = 3;\n     decide (rho (Suc r) p) =\n     Some (the (vote (rho r (coord\\<Phi> (rho r p)))));\n     ready (rho r (coord\\<Phi> (rho r p)));\n     commt (rho r (coord\\<Phi> (rho r p)))\\<rbrakk>\n    \\<Longrightarrow> N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "ultimately"], ["proof (chain)\npicking this:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n  card\n   {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n       timestamp (rho r q) = Suc (phase r)}\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho r))", "show ?thesis"], ["proof (prove)\nusing this:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n  card\n   {q. coord\\<Phi> (rho r q) = coord\\<Phi> (rho r p) \\<and>\n       timestamp (rho r q) = Suc (phase r)}\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho r))\n\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))", "by simp"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho r))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  No two different processes have their \\emph{commit} flag set at any state.\n\\<close>"], ["", "lemma committedProcsEqual:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and cmt: \"commt (rho r p)\" and cmt': \"commt (rho r p')\"\n  shows \"p = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = p'", "from run cmt"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho r p)", "have \"card {q . coord\\<Phi> (rho r q) = p} > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho r p)\n\ngoal (1 subgoal):\n 1. N div 2 < card {q. coord\\<Phi> (rho r q) = p}", "by (blast elim: commitE)"], ["proof (state)\nthis:\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p}\n\ngoal (1 subgoal):\n 1. p = p'", "moreover"], ["proof (state)\nthis:\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p}\n\ngoal (1 subgoal):\n 1. p = p'", "from run cmt'"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho r p')", "have \"card {q . coord\\<Phi> (rho r q) = p'} > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho r p')\n\ngoal (1 subgoal):\n 1. N div 2 < card {q. coord\\<Phi> (rho r q) = p'}", "by (blast elim: commitE)"], ["proof (state)\nthis:\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p'}\n\ngoal (1 subgoal):\n 1. p = p'", "ultimately"], ["proof (chain)\npicking this:\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p}\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p'}", "obtain q where \"coord\\<Phi> (rho r q) = p\" and \"p' = coord\\<Phi> (rho r q)\""], ["proof (prove)\nusing this:\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p}\n  N div 2 < card {q. coord\\<Phi> (rho r q) = p'}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>coord\\<Phi> (rho r q) = p;\n         p' = coord\\<Phi> (rho r q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: majoritiesE')"], ["proof (state)\nthis:\n  coord\\<Phi> (rho r q) = p\n  p' = coord\\<Phi> (rho r q)\n\ngoal (1 subgoal):\n 1. p = p'", "thus ?thesis"], ["proof (prove)\nusing this:\n  coord\\<Phi> (rho r q) = p\n  p' = coord\\<Phi> (rho r q)\n\ngoal (1 subgoal):\n 1. p = p'", "by simp"], ["proof (state)\nthis:\n  p = p'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  No two different processes have their \\emph{ready} flag set at any state.\n\\<close>"], ["", "lemma readyProcsEqual:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and rdy: \"ready (rho r p)\" and rdy': \"ready (rho r p')\"\n  shows \"p = p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = p'", "let \"?C p\" = \"{q . coord\\<Phi> (rho r q) = p \\<and> timestamp (rho r q) = Suc (phase r)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = p'", "from run rdy"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  ready (rho r p)", "have \"card (?C p) > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  ready (rho r p)\n\ngoal (1 subgoal):\n 1. N div 2\n    < card\n       {q. coord\\<Phi> (rho r q) = p \\<and>\n           timestamp (rho r q) = Suc (phase r)}", "by (blast elim: readyE)"], ["proof (state)\nthis:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. p = p'", "moreover"], ["proof (state)\nthis:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. p = p'", "from run rdy'"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  ready (rho r p')", "have \"card (?C p') > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  ready (rho r p')\n\ngoal (1 subgoal):\n 1. N div 2\n    < card\n       {q. coord\\<Phi> (rho r q) = p' \\<and>\n           timestamp (rho r q) = Suc (phase r)}", "by (blast elim: readyE)"], ["proof (state)\nthis:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p' \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. p = p'", "ultimately"], ["proof (chain)\npicking this:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p' \\<and>\n         timestamp (rho r q) = Suc (phase r)}", "obtain q where \"coord\\<Phi> (rho r q) = p\" and \"p' = coord\\<Phi> (rho r q)\""], ["proof (prove)\nusing this:\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n  N div 2\n  < card\n     {q. coord\\<Phi> (rho r q) = p' \\<and>\n         timestamp (rho r q) = Suc (phase r)}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>coord\\<Phi> (rho r q) = p;\n         p' = coord\\<Phi> (rho r q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: majoritiesE')"], ["proof (state)\nthis:\n  coord\\<Phi> (rho r q) = p\n  p' = coord\\<Phi> (rho r q)\n\ngoal (1 subgoal):\n 1. p = p'", "thus ?thesis"], ["proof (prove)\nusing this:\n  coord\\<Phi> (rho r q) = p\n  p' = coord\\<Phi> (rho r q)\n\ngoal (1 subgoal):\n 1. p = p'", "by simp"], ["proof (state)\nthis:\n  p = p'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following lemma asserts that whenever a process \\<open>p\\<close> commits\n  at a state where a majority of processes have a timestamp beyond \\<open>ts\\<close>,\n  then \\<open>p\\<close> votes for a value held by some process whose timestamp is\n  beyond \\<open>ts\\<close>.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text commitE}, @{text highestStampRcvd_max},\n  @{text notStep1EqualTimestamp}, @{text notStep1EqualX} and then on\n  lemmas @{text notStep03EqualCommit}, @{text notStep0EqualVote}, @{text commitE},\n  @{text committedProcsEqual} and @{text LV_timestamp_monotonic}.\n*)"], ["", "lemma commitThenVoteRecent:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and maj: \"card (procsBeyondTS ts (rho r)) > N div 2\"\n  and cmt: \"commt (rho r p)\"\n  shows \"\\<exists>q \\<in> procsBeyondTS ts (rho r). vote (rho r p) = Some (x (rho r q))\"\n        (is \"?Q r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho r).\n       vote (rho r p) = Some (x (rho r q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho r).\n       vote (rho r p) = Some (x (rho r q))", "let \"?bynd n\" = \"procsBeyondTS ts (rho n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho r).\n       vote (rho r p) = Some (x (rho r q))", "have \"card (?bynd r) > N div 2 \\<and> commt (rho r p) \\<longrightarrow> ?Q r\" (is \"?P p r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n    commt (rho r p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n        vote (rho r p) = Some (x (rho r q)))", "proof (rule LV_induct[OF run])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        \\<forall>p.\n           next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "txt \\<open>\\<open>next0\\<close> establishes the property\\<close>"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        \\<forall>p.\n           next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "fix n"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        \\<forall>p.\n           next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "assume stp: \"step n = 0\"\n       and nxt: \"\\<forall>q. next0 n q (rho n q) \n                             (HOrcvdMsgs LV_M n q (HOs n q) (rho n)) \n                             (coords (Suc n) q) \n                             (rho (Suc n) q)\"\n              (is \"\\<forall>q. ?nxt q\")"], ["proof (state)\nthis:\n  step n = 0\n  \\<forall>q.\n     next0 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)\n\ngoal (5 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        \\<forall>p.\n           next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "from nxt"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     next0 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)", "have nxp: \"?nxt p\""], ["proof (prove)\nusing this:\n  \\<forall>q.\n     next0 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)\n\ngoal (1 subgoal):\n 1. next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n     (coords (Suc n) p) (rho (Suc n) p)", ".."], ["proof (state)\nthis:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (5 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 0;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 1;\n        \\<forall>p.\n           next0 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 5. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "show \"?P p (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS ts (rho (Suc n))) \\<and>\n    commt (rho (Suc n) p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n        vote (rho (Suc n) p) = Some (x (rho (Suc n) q)))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "assume mj: \"card (?bynd (Suc n)) > N div 2\"\n         and ct: \"commt (rho (Suc n) p)\""], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  commt (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "show \"?Q (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "let ?msgs = \"HOrcvdMsgs LV_M n p (HOs n p) (rho n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from stp run"], ["proof (chain)\npicking this:\n  step n = 0\n  CHORun LV_M rho HOs coords", "have \"\\<not> commt (rho n p)\""], ["proof (prove)\nusing this:\n  step n = 0\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. \\<not> commt (rho n p)", "by (auto elim: commitE)"], ["proof (state)\nthis:\n  \\<not> commt (rho n p)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "with nxp ct"], ["proof (chain)\npicking this:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  commt (rho (Suc n) p)\n  \\<not> commt (rho n p)", "obtain q v where\n          v: \"?msgs q = Some (ValStamp v (highestStampRcvd ?msgs))\" and\n          vote: \"vote (rho (Suc n) p) = Some v\" and\n          rcvd: \"card (valStampsRcvd ?msgs) > N div 2\""], ["proof (prove)\nusing this:\n  next0 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n  commt (rho (Suc n) p)\n  \\<not> commt (rho n p)\n\ngoal (1 subgoal):\n 1. (\\<And>q v.\n        \\<lbrakk>HOrcvdMsgs LV_M n p (HOs n p) (rho n) q =\n                 Some\n                  (ValStamp v\n                    (highestStampRcvd\n                      (HOrcvdMsgs LV_M n p (HOs n p) (rho n))));\n         vote (rho (Suc n) p) = Some v;\n         N div 2\n         < card\n            (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: next0_def)"], ["proof (state)\nthis:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q =\n  Some\n   (ValStamp v (highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))))\n  vote (rho (Suc n) p) = Some v\n  N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from mj rcvd"], ["proof (chain)\npicking this:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))", "obtain q' where \n          q1': \"q' \\<in> ?bynd (Suc n)\" and q2': \"q' \\<in> valStampsRcvd ?msgs\""], ["proof (prove)\nusing this:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  N div 2 < card (valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n)))\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> procsBeyondTS ts (rho (Suc n));\n         q' \\<in> valStampsRcvd\n                   (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule majoritiesE')"], ["proof (state)\nthis:\n  q' \\<in> procsBeyondTS ts (rho (Suc n))\n  q' \\<in> valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "have \"timestamp (rho n q') \\<le> timestamp (rho n q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "from q2'"], ["proof (chain)\npicking this:\n  q' \\<in> valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))", "obtain v' ts'\n            where ts': \"?msgs q' = Some (ValStamp v' ts')\""], ["proof (prove)\nusing this:\n  q' \\<in> valStampsRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. (\\<And>v' ts'.\n        HOrcvdMsgs LV_M n p (HOs n p) (rho n) q' =\n        Some (ValStamp v' ts') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: valStampsRcvd_def)"], ["proof (state)\nthis:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q' = Some (ValStamp v' ts')\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "hence \"ts' \\<le> highestStampRcvd ?msgs\""], ["proof (prove)\nusing this:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q' = Some (ValStamp v' ts')\n\ngoal (1 subgoal):\n 1. ts' \\<le> highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))", "by (rule highestStampRcvd_max)"], ["proof (state)\nthis:\n  ts' \\<le> highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "moreover"], ["proof (state)\nthis:\n  ts' \\<le> highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "from ts' stp"], ["proof (chain)\npicking this:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q' = Some (ValStamp v' ts')\n  step n = 0", "have \"timestamp (rho n q') = ts'\""], ["proof (prove)\nusing this:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q' = Some (ValStamp v' ts')\n  step n = 0\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') = ts'", "by (auto simp: LV_CHOMachine_def HOrcvdMsgs_def \n                           LV_sendMsg_def send0_def)"], ["proof (state)\nthis:\n  timestamp (rho n q') = ts'\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "moreover"], ["proof (state)\nthis:\n  timestamp (rho n q') = ts'\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "from v stp"], ["proof (chain)\npicking this:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q =\n  Some\n   (ValStamp v (highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))))\n  step n = 0", "have \"timestamp (rho n q) = highestStampRcvd ?msgs\""], ["proof (prove)\nusing this:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q =\n  Some\n   (ValStamp v (highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))))\n  step n = 0\n\ngoal (1 subgoal):\n 1. timestamp (rho n q) =\n    highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))", "by (auto simp: LV_CHOMachine_def HOrcvdMsgs_def\n                           LV_sendMsg_def send0_def)"], ["proof (state)\nthis:\n  timestamp (rho n q) =\n  highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "ultimately"], ["proof (chain)\npicking this:\n  ts' \\<le> highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n  timestamp (rho n q') = ts'\n  timestamp (rho n q) =\n  highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))", "show ?thesis"], ["proof (prove)\nusing this:\n  ts' \\<le> highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n  timestamp (rho n q') = ts'\n  timestamp (rho n q) =\n  highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n\ngoal (1 subgoal):\n 1. timestamp (rho n q') \\<le> timestamp (rho n q)", "by simp"], ["proof (state)\nthis:\n  timestamp (rho n q') \\<le> timestamp (rho n q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  timestamp (rho n q') \\<le> timestamp (rho n q)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "moreover"], ["proof (state)\nthis:\n  timestamp (rho n q') \\<le> timestamp (rho n q)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 0", "have \"timestamp (rho (Suc n) q') = timestamp (rho n q')\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 0\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) q') = timestamp (rho n q')", "by (simp add: notStep1EqualTimestamp)"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) q') = timestamp (rho n q')\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "moreover"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) q') = timestamp (rho n q')\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 0", "have \"timestamp (rho (Suc n) q) = timestamp (rho n q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 0\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc n) q) = timestamp (rho n q)", "by (simp add: notStep1EqualTimestamp)"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) q) = timestamp (rho n q)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "moreover"], ["proof (state)\nthis:\n  timestamp (rho (Suc n) q) = timestamp (rho n q)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "note q1'"], ["proof (state)\nthis:\n  q' \\<in> procsBeyondTS ts (rho (Suc n))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "ultimately"], ["proof (chain)\npicking this:\n  timestamp (rho n q') \\<le> timestamp (rho n q)\n  timestamp (rho (Suc n) q') = timestamp (rho n q')\n  timestamp (rho (Suc n) q) = timestamp (rho n q)\n  q' \\<in> procsBeyondTS ts (rho (Suc n))", "have \"q \\<in> ?bynd (Suc n)\""], ["proof (prove)\nusing this:\n  timestamp (rho n q') \\<le> timestamp (rho n q)\n  timestamp (rho (Suc n) q') = timestamp (rho n q')\n  timestamp (rho (Suc n) q) = timestamp (rho n q)\n  q' \\<in> procsBeyondTS ts (rho (Suc n))\n\ngoal (1 subgoal):\n 1. q \\<in> procsBeyondTS ts (rho (Suc n))", "by (simp add: procsBeyondTS_def)"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS ts (rho (Suc n))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "moreover"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS ts (rho (Suc n))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from v vote stp"], ["proof (chain)\npicking this:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q =\n  Some\n   (ValStamp v (highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))))\n  vote (rho (Suc n) p) = Some v\n  step n = 0", "have \"vote (rho (Suc n) p) = Some (x (rho n q))\""], ["proof (prove)\nusing this:\n  HOrcvdMsgs LV_M n p (HOs n p) (rho n) q =\n  Some\n   (ValStamp v (highestStampRcvd (HOrcvdMsgs LV_M n p (HOs n p) (rho n))))\n  vote (rho (Suc n) p) = Some v\n  step n = 0\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = Some (x (rho n q))", "by (auto simp: LV_CHOMachine_def HOrcvdMsgs_def\n                         LV_sendMsg_def send0_def)"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some (x (rho n q))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = Some (x (rho n q))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 0", "have \"x (rho (Suc n) q) = x (rho n q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 0\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) q) = x (rho n q)", "by (simp add: notStep1EqualX)"], ["proof (state)\nthis:\n  x (rho (Suc n) q) = x (rho n q)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> procsBeyondTS ts (rho (Suc n))\n  vote (rho (Suc n) p) = Some (x (rho n q))\n  x (rho (Suc n) q) = x (rho n q)", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> procsBeyondTS ts (rho (Suc n))\n  vote (rho (Suc n) p) = Some (x (rho n q))\n  x (rho (Suc n) q) = x (rho n q)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "by force"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n))) \\<and>\n  commt (rho (Suc n) p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n      vote (rho (Suc n) p) = Some (x (rho (Suc n) q)))\n\ngoal (4 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "txt \\<open>We now prove that \\<open>next1\\<close> preserves the property.\n      Observe that \\<open>next1\\<close> may establish a majority of processes\n      with current timestamps, so we cannot just refer to the induction\n      hypothesis. However, if that happens, there is at least one process\n      with a fresh timestamp that copies the vote of the (only) committed\n      coordinator, thus establishing the property.\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "fix n"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "assume stp: \"step n = 1\"\n       and nxt: \"\\<forall>q. next1 n q (rho n q) \n                               (HOrcvdMsgs LV_M n q (HOs n q) (rho n)) \n                               (coords (Suc n) q)\n                               (rho (Suc n) q)\" \n               (is \"\\<forall>q. ?nxt q\")\n       and ih: \"?P p n\""], ["proof (state)\nthis:\n  step n = 1\n  \\<forall>q.\n     next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)\n  N div 2 < card (procsBeyondTS ts (rho n)) \\<and>\n  commt (rho n p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho n).\n      vote (rho n p) = Some (x (rho n q)))\n\ngoal (4 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "from nxt"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)", "have nxp: \"?nxt p\""], ["proof (prove)\nusing this:\n  \\<forall>q.\n     next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)\n\ngoal (1 subgoal):\n 1. next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n     (coords (Suc n) p) (rho (Suc n) p)", ".."], ["proof (state)\nthis:\n  next1 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (4 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 1;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 2;\n        \\<forall>p.\n           next1 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 4. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "show \"?P p (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS ts (rho (Suc n))) \\<and>\n    commt (rho (Suc n) p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n        vote (rho (Suc n) p) = Some (x (rho (Suc n) q)))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "assume mj': \"card (?bynd (Suc n)) > N div 2\"\n         and ct': \"commt (rho (Suc n) p)\""], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  commt (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp ct'"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n  commt (rho (Suc n) p)", "have ct: \"commt (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n  commt (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. commt (rho n p)", "by (simp add: notStep03EqualCommit)"], ["proof (state)\nthis:\n  commt (rho n p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 1", "have vote': \"vote (rho (Suc n) p) = vote (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 1\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = vote (rho n p)", "by (simp add: notStep0EqualVote)"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "show \"?Q (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "proof (cases \"\\<exists>q \\<in> ?bynd (Suc n). rho (Suc n) q \\<noteq> rho n q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "case True"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     rho (Suc n) q \\<noteq> rho n q\n\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "txt \\<open>in this case the property holds because \\<open>q\\<close> updates\n          its \\<open>x\\<close> field to the vote\\<close>"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     rho (Suc n) q \\<noteq> rho n q\n\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     rho (Suc n) q \\<noteq> rho n q", "obtain q where\n          q1: \"q \\<in> ?bynd (Suc n)\" and q2: \"rho (Suc n) q \\<noteq> rho n q\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     rho (Suc n) q \\<noteq> rho n q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> procsBeyondTS ts (rho (Suc n));\n         rho (Suc n) q \\<noteq> rho n q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS ts (rho (Suc n))\n  rho (Suc n) q \\<noteq> rho n q\n\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from nxt"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)", "have \"?nxt q\""], ["proof (prove)\nusing this:\n  \\<forall>q.\n     next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)\n\ngoal (1 subgoal):\n 1. next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n     (coords (Suc n) q) (rho (Suc n) q)", ".."], ["proof (state)\nthis:\n  next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n   (coords (Suc n) q) (rho (Suc n) q)\n\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "with q2 stp"], ["proof (chain)\npicking this:\n  rho (Suc n) q \\<noteq> rho n q\n  step n = 1\n  next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n   (coords (Suc n) q) (rho (Suc n) q)", "have  x': \"x (rho (Suc n) q) = the (vote (rho n (coord\\<Phi> (rho n q))))\"\n          and coord: \"commt (rho n (coord\\<Phi> (rho n q)))\""], ["proof (prove)\nusing this:\n  rho (Suc n) q \\<noteq> rho n q\n  step n = 1\n  next1 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n   (coords (Suc n) q) (rho (Suc n) q)\n\ngoal (1 subgoal):\n 1. x (rho (Suc n) q) = the (vote (rho n (coord\\<Phi> (rho n q)))) &&&\n    commt (rho n (coord\\<Phi> (rho n q)))", "by (auto simp: next1_def send1_def LV_CHOMachine_def HOrcvdMsgs_def\n                         LV_sendMsg_def isVote_def)"], ["proof (state)\nthis:\n  x (rho (Suc n) q) = the (vote (rho n (coord\\<Phi> (rho n q))))\n  commt (rho n (coord\\<Phi> (rho n q)))\n\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run ct"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho n p)", "have vote: \"vote (rho n p) \\<noteq> None\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho n p)\n\ngoal (1 subgoal):\n 1. vote (rho n p) \\<noteq> None", "by (rule commitE)"], ["proof (state)\nthis:\n  vote (rho n p) \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run coord ct"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho n (coord\\<Phi> (rho n q)))\n  commt (rho n p)", "have \"coord\\<Phi> (rho n q) = p\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho n (coord\\<Phi> (rho n q)))\n  commt (rho n p)\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho n q) = p", "by (rule committedProcsEqual)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho n q) = p\n\ngoal (2 subgoals):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       rho (Suc n) q \\<noteq> rho n q \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n 2. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "with q1 x' vote vote'"], ["proof (chain)\npicking this:\n  q \\<in> procsBeyondTS ts (rho (Suc n))\n  x (rho (Suc n) q) = the (vote (rho n (coord\\<Phi> (rho n q))))\n  vote (rho n p) \\<noteq> None\n  vote (rho (Suc n) p) = vote (rho n p)\n  coord\\<Phi> (rho n q) = p", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> procsBeyondTS ts (rho (Suc n))\n  x (rho (Suc n) q) = the (vote (rho n (coord\\<Phi> (rho n q))))\n  vote (rho n p) \\<noteq> None\n  vote (rho (Suc n) p) = vote (rho n p)\n  coord\\<Phi> (rho n q) = p\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "by auto"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n             rho (Suc n) q \\<noteq> rho n q)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "txt \\<open>if no relevant process moves then \\<open>procsBeyondTS\\<close> doesn't \n          change and we invoke the induction hypothesis\\<close>"], ["proof (state)\nthis:\n  \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n             rho (Suc n) q \\<noteq> rho n q)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "hence bynd: \"?bynd (Suc n) = ?bynd n\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n             rho (Suc n) q \\<noteq> rho n q)\n\ngoal (1 subgoal):\n 1. procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)", "proof (auto simp: procsBeyondTS_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>q.\n                   ts \\<le> timestamp (rho (Suc n) q) \\<longrightarrow>\n                   rho (Suc n) q = rho n q;\n        ts \\<le> timestamp (rho n x)\\<rbrakk>\n       \\<Longrightarrow> ts \\<le> timestamp (rho (Suc n) x)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>q.\n                   ts \\<le> timestamp (rho (Suc n) q) \\<longrightarrow>\n                   rho (Suc n) q = rho n q;\n        ts \\<le> timestamp (rho n x)\\<rbrakk>\n       \\<Longrightarrow> ts \\<le> timestamp (rho (Suc n) x)", "assume ts: \"ts \\<le> timestamp (rho n r)\""], ["proof (state)\nthis:\n  ts \\<le> timestamp (rho n r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>q.\n                   ts \\<le> timestamp (rho (Suc n) q) \\<longrightarrow>\n                   rho (Suc n) q = rho n q;\n        ts \\<le> timestamp (rho n x)\\<rbrakk>\n       \\<Longrightarrow> ts \\<le> timestamp (rho (Suc n) x)", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have \"timestamp (rho n r) \\<le> timestamp (rho (Suc n) r)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. timestamp (rho n r) \\<le> timestamp (rho (Suc n) r)", "by (simp add: LV_timestamp_monotonic)"], ["proof (state)\nthis:\n  timestamp (rho n r) \\<le> timestamp (rho (Suc n) r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>q.\n                   ts \\<le> timestamp (rho (Suc n) q) \\<longrightarrow>\n                   rho (Suc n) q = rho n q;\n        ts \\<le> timestamp (rho n x)\\<rbrakk>\n       \\<Longrightarrow> ts \\<le> timestamp (rho (Suc n) x)", "with ts"], ["proof (chain)\npicking this:\n  ts \\<le> timestamp (rho n r)\n  timestamp (rho n r) \\<le> timestamp (rho (Suc n) r)", "show \"ts \\<le> timestamp (rho (Suc n) r)\""], ["proof (prove)\nusing this:\n  ts \\<le> timestamp (rho n r)\n  timestamp (rho n r) \\<le> timestamp (rho (Suc n) r)\n\ngoal (1 subgoal):\n 1. ts \\<le> timestamp (rho (Suc n) r)", "by simp"], ["proof (state)\nthis:\n  ts \\<le> timestamp (rho (Suc n) r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "with mj'"], ["proof (chain)\npicking this:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)", "have mj: \"card (?bynd n) > N div 2\""], ["proof (prove)\nusing this:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)\n\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS ts (rho n))", "by simp"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "with ct ih"], ["proof (chain)\npicking this:\n  commt (rho n p)\n  N div 2 < card (procsBeyondTS ts (rho n)) \\<and>\n  commt (rho n p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho n).\n      vote (rho n p) = Some (x (rho n q)))\n  N div 2 < card (procsBeyondTS ts (rho n))", "obtain q where\n          \"q \\<in> ?bynd n\" and \"vote (rho n p) = Some (x (rho n q))\""], ["proof (prove)\nusing this:\n  commt (rho n p)\n  N div 2 < card (procsBeyondTS ts (rho n)) \\<and>\n  commt (rho n p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho n).\n      vote (rho n p) = Some (x (rho n q)))\n  N div 2 < card (procsBeyondTS ts (rho n))\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> procsBeyondTS ts (rho n);\n         vote (rho n p) = Some (x (rho n q))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS ts (rho n)\n  vote (rho n p) = Some (x (rho n q))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n               rho (Suc n) q \\<noteq> rho n q) \\<Longrightarrow>\n    \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "with vote' bynd False"], ["proof (chain)\npicking this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)\n  \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n             rho (Suc n) q \\<noteq> rho n q)\n  q \\<in> procsBeyondTS ts (rho n)\n  vote (rho n p) = Some (x (rho n q))", "show ?thesis"], ["proof (prove)\nusing this:\n  vote (rho (Suc n) p) = vote (rho n p)\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)\n  \\<not> (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n             rho (Suc n) q \\<noteq> rho n q)\n  q \\<in> procsBeyondTS ts (rho n)\n  vote (rho n p) = Some (x (rho n q))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "by auto"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n))) \\<and>\n  commt (rho (Suc n) p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n      vote (rho (Suc n) p) = Some (x (rho (Suc n) q)))\n\ngoal (3 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "txt \\<open>\\<open>step2\\<close> preserves the property, via the induction hypothesis.\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "assume stp: \"step n = 2\"\n       and nxt: \"\\<forall>q. next2 n q (rho n q) \n                               (HOrcvdMsgs LV_M n q (HOs n q) (rho n)) \n                               (coords (Suc n) q) \n                               (rho (Suc n) q)\"\n               (is \"\\<forall>q. ?nxt q\")\n       and ih: \"?P p n\""], ["proof (state)\nthis:\n  step n = 2\n  \\<forall>q.\n     next2 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)\n  N div 2 < card (procsBeyondTS ts (rho n)) \\<and>\n  commt (rho n p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho n).\n      vote (rho n p) = Some (x (rho n q)))\n\ngoal (3 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "from nxt"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     next2 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)", "have nxp: \"?nxt p\""], ["proof (prove)\nusing this:\n  \\<forall>q.\n     next2 n q (rho n q) (HOrcvdMsgs LV_M n q (HOs n q) (rho n))\n      (coords (Suc n) q) (rho (Suc n) q)\n\ngoal (1 subgoal):\n 1. next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n     (coords (Suc n) p) (rho (Suc n) p)", ".."], ["proof (state)\nthis:\n  next2 n p (rho n p) (HOrcvdMsgs LV_M n p (HOs n p) (rho n))\n   (coords (Suc n) p) (rho (Suc n) p)\n\ngoal (3 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 2;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = phase r; step (Suc r) = 3;\n        \\<forall>p.\n           next2 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))\n 3. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "show \"?P p (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS ts (rho (Suc n))) \\<and>\n    commt (rho (Suc n) p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n        vote (rho (Suc n) p) = Some (x (rho (Suc n) q)))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "assume mj': \"card (?bynd (Suc n)) > N div 2\"\n         and ct': \"commt (rho (Suc n) p)\""], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  commt (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp ct'"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n  commt (rho (Suc n) p)", "have ct: \"commt (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n  commt (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. commt (rho n p)", "by (simp add: notStep03EqualCommit)"], ["proof (state)\nthis:\n  commt (rho n p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2", "have vote': \"vote (rho (Suc n) p) = vote (rho n p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n\ngoal (1 subgoal):\n 1. vote (rho (Suc n) p) = vote (rho n p)", "by (simp add: notStep0EqualVote)"], ["proof (state)\nthis:\n  vote (rho (Suc n) p) = vote (rho n p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2", "have \"\\<forall>q. timestamp (rho (Suc n) q) = timestamp (rho n q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n\ngoal (1 subgoal):\n 1. \\<forall>q. timestamp (rho (Suc n) q) = timestamp (rho n q)", "by (simp add: notStep1EqualTimestamp)"], ["proof (state)\nthis:\n  \\<forall>q. timestamp (rho (Suc n) q) = timestamp (rho n q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "hence bynd': \"?bynd (Suc n) = ?bynd n\""], ["proof (prove)\nusing this:\n  \\<forall>q. timestamp (rho (Suc n) q) = timestamp (rho n q)\n\ngoal (1 subgoal):\n 1. procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)", "by (auto simp add: procsBeyondTS_def)"], ["proof (state)\nthis:\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "from run stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step n = 2", "have \"\\<forall>q. x (rho (Suc n) q) = x (rho n q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step n = 2\n\ngoal (1 subgoal):\n 1. \\<forall>q. x (rho (Suc n) q) = x (rho n q)", "by (simp add: notStep1EqualX)"], ["proof (state)\nthis:\n  \\<forall>q. x (rho (Suc n) q) = x (rho n q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>N div 2 < card (procsBeyondTS ts (rho (Suc n)));\n     commt (rho (Suc n) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n                         vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "with bynd' vote' ct mj' ih"], ["proof (chain)\npicking this:\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)\n  vote (rho (Suc n) p) = vote (rho n p)\n  commt (rho n p)\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  N div 2 < card (procsBeyondTS ts (rho n)) \\<and>\n  commt (rho n p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho n).\n      vote (rho n p) = Some (x (rho n q)))\n  \\<forall>q. x (rho (Suc n) q) = x (rho n q)", "show \"?Q (Suc n)\""], ["proof (prove)\nusing this:\n  procsBeyondTS ts (rho (Suc n)) = procsBeyondTS ts (rho n)\n  vote (rho (Suc n) p) = vote (rho n p)\n  commt (rho n p)\n  N div 2 < card (procsBeyondTS ts (rho (Suc n)))\n  N div 2 < card (procsBeyondTS ts (rho n)) \\<and>\n  commt (rho n p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho n).\n      vote (rho n p) = Some (x (rho n q)))\n  \\<forall>q. x (rho (Suc n) q) = x (rho n q)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n       vote (rho (Suc n) p) = Some (x (rho (Suc n) q))", "by auto"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n     vote (rho (Suc n) p) = Some (x (rho (Suc n) q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n))) \\<and>\n  commt (rho (Suc n) p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n      vote (rho (Suc n) p) = Some (x (rho (Suc n) q)))\n\ngoal (2 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "txt \\<open>the initial state and the \\<open>step3\\<close> transition are trivial \n    because the \\<open>commt\\<close> flag cannot be set.\\<close>"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho (Suc n))) \\<and>\n  commt (rho (Suc n) p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc n)).\n      vote (rho (Suc n) p) = Some (x (rho (Suc n) q)))\n\ngoal (2 subgoals):\n 1. \\<forall>p. CinitState LV_M p (rho 0 p) (coords 0 p) \\<Longrightarrow>\n    N div 2 < card (procsBeyondTS ts (rho 0)) \\<and>\n    commt (rho 0 p) \\<longrightarrow>\n    (\\<exists>q\\<in>procsBeyondTS ts (rho 0).\n        vote (rho 0 p) = Some (x (rho 0 q)))\n 2. \\<And>r.\n       \\<lbrakk>step r = 3;\n        N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n        commt (rho r p) \\<longrightarrow>\n        (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n            vote (rho r p) = Some (x (rho r q)));\n        phase (Suc r) = Suc (phase r); step (Suc r) = 0;\n        \\<forall>p.\n           next3 r p (rho r p) (HOrcvdMsgs LV_M r p (HOs r p) (rho r))\n            (coords (Suc r) p) (rho (Suc r) p)\\<rbrakk>\n       \\<Longrightarrow> N div 2\n                         < card (procsBeyondTS ts (rho (Suc r))) \\<and>\n                         commt (rho (Suc r) p) \\<longrightarrow>\n                         (\\<exists>q\\<in>procsBeyondTS ts (rho (Suc r)).\n                             vote (rho (Suc r) p) =\n                             Some (x (rho (Suc r) q)))", "qed (auto elim: commitE[OF run])"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n  commt (rho r p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n      vote (rho r p) = Some (x (rho r q)))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho r).\n       vote (rho r p) = Some (x (rho r q))", "with maj cmt"], ["proof (chain)\npicking this:\n  N div 2 < card (procsBeyondTS ts (rho r))\n  commt (rho r p)\n  N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n  commt (rho r p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n      vote (rho r p) = Some (x (rho r q)))", "show ?thesis"], ["proof (prove)\nusing this:\n  N div 2 < card (procsBeyondTS ts (rho r))\n  commt (rho r p)\n  N div 2 < card (procsBeyondTS ts (rho r)) \\<and>\n  commt (rho r p) \\<longrightarrow>\n  (\\<exists>q\\<in>procsBeyondTS ts (rho r).\n      vote (rho r p) = Some (x (rho r q)))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>procsBeyondTS ts (rho r).\n       vote (rho r p) = Some (x (rho r q))", "by simp"], ["proof (state)\nthis:\n  \\<exists>q\\<in>procsBeyondTS ts (rho r).\n     vote (rho r p) = Some (x (rho r q))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following lemma gives the crucial argument for agreement:\n  after some process \\<open>p\\<close> has decided, all processes whose\n  timestamp is beyond the timestamp at the point of decision contain\n  the decision value in their \\<open>x\\<close> field.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text LV_timestamp_bounded},\n  @{text currentTimestampE}, @{text committedProcsEqual},\n  @{text decisionThenMajorityBeyondTS}, @{text procsBeyondTS_monotonic}\n  @{text commitThenVoteRecent}, @{text  notStep1EqualX}\n  and @{text notStep1EqualTimestamp}.\n*)"], ["", "lemma XOfTimestampBeyondDecision:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and dec: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  shows \"\\<forall>q \\<in> procsBeyondTS (Suc (phase r)) (rho (r+k)).\n              x (rho (r+k) q) = the (decide (rho (Suc r) p))\"\n  (is \"\\<forall>q \\<in> ?bynd k. _ = ?v\" is \"?P p k\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n       x (rho (r + k) q) = the (decide (rho (Suc r) p))", "proof (induct k)\n  \\<comment> \\<open>base step\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + 0)).\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))\n 2. \\<And>k.\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n          x (rho (r + k) q) = the (decide (rho (Suc r) p)) \\<Longrightarrow>\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + Suc k)).\n          x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "show \"?P p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + 0)).\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "assume q: \"q \\<in> ?bynd 0\""], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "txt \\<open>use preceding lemmas about the decision value and the \n      \\<open>x\\<close> field of processes with fresh timestamps\\<close>"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "from run dec"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)", "have  stp: \"step r = 3\"\n      and v: \"decide (rho (Suc r) p) = Some (the (vote (rho r (coord\\<Phi> (rho r p)))))\"\n      and cmt: \"commt (rho r (coord\\<Phi> (rho r p)))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n\ngoal (1 subgoal):\n 1. step r = 3 &&&\n    decide (rho (Suc r) p) =\n    Some (the (vote (rho r (coord\\<Phi> (rho r p))))) &&&\n    commt (rho r (coord\\<Phi> (rho r p)))", "by (auto elim: decisionE)"], ["proof (state)\nthis:\n  step r = 3\n  decide (rho (Suc r) p) = Some (the (vote (rho r (coord\\<Phi> (rho r p)))))\n  commt (rho r (coord\\<Phi> (rho r p)))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "from stp LV_timestamp_bounded[OF run, where n=r]"], ["proof (chain)\npicking this:\n  step r = 3\n  timestamp (rho r ?p) \\<le> (if step r < 2 then phase r else Suc (phase r))", "have \"timestamp (rho r q) \\<le> Suc (phase r)\""], ["proof (prove)\nusing this:\n  step r = 3\n  timestamp (rho r ?p) \\<le> (if step r < 2 then phase r else Suc (phase r))\n\ngoal (1 subgoal):\n 1. timestamp (rho r q) \\<le> Suc (phase r)", "by simp"], ["proof (state)\nthis:\n  timestamp (rho r q) \\<le> Suc (phase r)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "with q"], ["proof (chain)\npicking this:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0))\n  timestamp (rho r q) \\<le> Suc (phase r)", "have \"timestamp (rho r q) = Suc (phase r)\""], ["proof (prove)\nusing this:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0))\n  timestamp (rho r q) \\<le> Suc (phase r)\n\ngoal (1 subgoal):\n 1. timestamp (rho r q) = Suc (phase r)", "by (simp add: procsBeyondTS_def)"], ["proof (state)\nthis:\n  timestamp (rho r q) = Suc (phase r)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  timestamp (rho r q) = Suc (phase r)", "have  x: \"x (rho r q) = the (vote (rho r (coord\\<Phi> (rho r q))))\"\n      and cmt': \"commt (rho r (coord\\<Phi> (rho r q)))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  timestamp (rho r q) = Suc (phase r)\n\ngoal (1 subgoal):\n 1. x (rho r q) = the (vote (rho r (coord\\<Phi> (rho r q)))) &&&\n    commt (rho r (coord\\<Phi> (rho r q)))", "by (auto elim: currentTimestampE)"], ["proof (state)\nthis:\n  x (rho r q) = the (vote (rho r (coord\\<Phi> (rho r q))))\n  commt (rho r (coord\\<Phi> (rho r q)))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "from run cmt cmt'"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho r (coord\\<Phi> (rho r p)))\n  commt (rho r (coord\\<Phi> (rho r q)))", "have \"coord\\<Phi> (rho r p) = coord\\<Phi> (rho r q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho r (coord\\<Phi> (rho r p)))\n  commt (rho r (coord\\<Phi> (rho r q)))\n\ngoal (1 subgoal):\n 1. coord\\<Phi> (rho r p) = coord\\<Phi> (rho r q)", "by (rule committedProcsEqual)"], ["proof (state)\nthis:\n  coord\\<Phi> (rho r p) = coord\\<Phi> (rho r q)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + 0)) \\<Longrightarrow>\n       x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "with x v"], ["proof (chain)\npicking this:\n  x (rho r q) = the (vote (rho r (coord\\<Phi> (rho r q))))\n  decide (rho (Suc r) p) = Some (the (vote (rho r (coord\\<Phi> (rho r p)))))\n  coord\\<Phi> (rho r p) = coord\\<Phi> (rho r q)", "show \"x (rho (r+0) q) = ?v\""], ["proof (prove)\nusing this:\n  x (rho r q) = the (vote (rho r (coord\\<Phi> (rho r q))))\n  decide (rho (Suc r) p) = Some (the (vote (rho r (coord\\<Phi> (rho r p)))))\n  coord\\<Phi> (rho r p) = coord\\<Phi> (rho r q)\n\ngoal (1 subgoal):\n 1. x (rho (r + 0) q) = the (decide (rho (Suc r) p))", "by simp"], ["proof (state)\nthis:\n  x (rho (r + 0) q) = the (decide (rho (Suc r) p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + 0)).\n     x (rho (r + 0) q) = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n          x (rho (r + k) q) = the (decide (rho (Suc r) p)) \\<Longrightarrow>\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + Suc k)).\n          x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "next\n  \\<comment> \\<open>induction step\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n          x (rho (r + k) q) = the (decide (rho (Suc r) p)) \\<Longrightarrow>\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + Suc k)).\n          x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n          x (rho (r + k) q) = the (decide (rho (Suc r) p)) \\<Longrightarrow>\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + Suc k)).\n          x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "assume ih: \"?P p k\""], ["proof (state)\nthis:\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n          x (rho (r + k) q) = the (decide (rho (Suc r) p)) \\<Longrightarrow>\n       \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + Suc k)).\n          x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "show \"?P p (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + Suc k)).\n       x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r))\n                (rho (r + Suc k)) \\<Longrightarrow>\n       x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r))\n                (rho (r + Suc k)) \\<Longrightarrow>\n       x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "assume q: \"q \\<in> ?bynd (Suc k)\"\n    \\<comment> \\<open>distinguish the kind of transition---only @{text step1} is interesting\\<close>"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r))\n                (rho (r + Suc k)) \\<Longrightarrow>\n       x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "have \"x (rho (Suc (r + k)) q) = ?v\" (is \"?X q (r+k)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "proof (rule LV_Suc'[OF run, where P=\"?X\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>step (r + k) = 0; step (Suc (r + k)) = 1;\n     phase (Suc (r + k)) = phase (r + k);\n     next0 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 1; step (Suc (r + k)) = 2;\n     phase (Suc (r + k)) = phase (r + k);\n     next1 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 3. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 4. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "assume stp: \"step (r + k) = 1\"\n      and nxt: \"next1 (r+k) q (rho (r+k) q)\n                      (HOrcvdMsgs LV_M (r+k) q (HOs (r+k) q) (rho (r+k)))\n                      (coords (Suc (r+k)) q)\n                      (rho (Suc (r+k)) q)\""], ["proof (state)\nthis:\n  step (r + k) = 1\n  next1 (r + k) q (rho (r + k) q)\n   (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n   (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>step (r + k) = 0; step (Suc (r + k)) = 1;\n     phase (Suc (r + k)) = phase (r + k);\n     next0 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 1; step (Suc (r + k)) = 2;\n     phase (Suc (r + k)) = phase (r + k);\n     next1 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 3. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 4. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "proof (cases \"rho (Suc (r+k)) q = rho (r+k) q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rho (Suc (r + k)) q = rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "case True"], ["proof (state)\nthis:\n  rho (Suc (r + k)) q = rho (r + k) q\n\ngoal (2 subgoals):\n 1. rho (Suc (r + k)) q = rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with q ih"], ["proof (chain)\npicking this:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  rho (Suc (r + k)) q = rho (r + k) q", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  rho (Suc (r + k)) q = rho (r + k) q\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "by (auto simp: procsBeyondTS_def)"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "case False"], ["proof (state)\nthis:\n  rho (Suc (r + k)) q \\<noteq> rho (r + k) q\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "from run dec"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)", "have \"card (?bynd 0) > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))", "by (simp add: decisionThenMajorityBeyondTS)"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "moreover"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "have \"?bynd 0 \\<subseteq> ?bynd k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. procsBeyondTS (Suc (phase r)) (rho (r + 0))\n    \\<subseteq> procsBeyondTS (Suc (phase r)) (rho (r + k))", "by (auto elim: procsBeyondTS_monotonic[OF run])"], ["proof (state)\nthis:\n  procsBeyondTS (Suc (phase r)) (rho (r + 0))\n  \\<subseteq> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "hence \"card (?bynd 0) \\<le> card (?bynd k)\""], ["proof (prove)\nusing this:\n  procsBeyondTS (Suc (phase r)) (rho (r + 0))\n  \\<subseteq> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n    \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "ultimately"], ["proof (chain)\npicking this:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))", "have maj: \"card (?bynd k) > N div 2\""], ["proof (prove)\nusing this:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))", "by simp"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "let ?crd = \"coord\\<Phi> (rho (r+k) q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "from False stp nxt"], ["proof (chain)\npicking this:\n  rho (Suc (r + k)) q \\<noteq> rho (r + k) q\n  step (r + k) = 1\n  next1 (r + k) q (rho (r + k) q)\n   (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n   (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)", "have \n          cmt: \"commt (rho (r+k) ?crd)\" and\n          x: \"x (rho (Suc (r+k)) q) = the (vote (rho (r+k) ?crd))\""], ["proof (prove)\nusing this:\n  rho (Suc (r + k)) q \\<noteq> rho (r + k) q\n  step (r + k) = 1\n  next1 (r + k) q (rho (r + k) q)\n   (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n   (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\n\ngoal (1 subgoal):\n 1. commt (rho (r + k) (coord\\<Phi> (rho (r + k) q))) &&&\n    x (rho (Suc (r + k)) q) =\n    the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))))", "by (auto simp: next1_def LV_CHOMachine_def HOrcvdMsgs_def\n                         LV_sendMsg_def send1_def isVote_def)"], ["proof (state)\nthis:\n  commt (rho (r + k) (coord\\<Phi> (rho (r + k) q)))\n  x (rho (Suc (r + k)) q) =\n  the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "from run maj cmt stp"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n  commt (rho (r + k) (coord\\<Phi> (rho (r + k) q)))\n  step (r + k) = 1", "obtain q'\n          where q1': \"q' \\<in> ?bynd k\"\n            and q2': \"vote (rho (r+k) ?crd) = Some (x (rho (r+k) q'))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n  commt (rho (r + k) (coord\\<Phi> (rho (r + k) q)))\n  step (r + k) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k));\n         vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n         Some (x (rho (r + k) q'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: commitThenVoteRecent)"], ["proof (state)\nthis:\n  q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n  vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n  Some (x (rho (r + k) q'))\n\ngoal (1 subgoal):\n 1. rho (Suc (r + k)) q \\<noteq> rho (r + k) q \\<Longrightarrow>\n    x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with x ih"], ["proof (chain)\npicking this:\n  x (rho (Suc (r + k)) q) =\n  the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))))\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n  vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n  Some (x (rho (r + k) q'))", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (Suc (r + k)) q) =\n  the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))))\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n  vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n  Some (x (rho (r + k) q'))\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step (r + k) = 0; step (Suc (r + k)) = 1;\n     phase (Suc (r + k)) = phase (r + k);\n     next0 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 3. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "next\n      \\<comment> \\<open>all other steps hold by induction hypothesis\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>step (r + k) = 0; step (Suc (r + k)) = 1;\n     phase (Suc (r + k)) = phase (r + k);\n     next0 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 3. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "assume \"step (r+k) = 0\""], ["proof (state)\nthis:\n  step (r + k) = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step (r + k) = 0; step (Suc (r + k)) = 1;\n     phase (Suc (r + k)) = phase (r + k);\n     next0 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 3. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step (r + k) = 0", "have x: \"x (rho (Suc (r+k)) q) = x (rho (r+k) q)\"\n        and ts: \"timestamp (rho (Suc (r+k)) q) = timestamp (rho (r+k) q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step (r + k) = 0\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = x (rho (r + k) q) &&&\n    timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)", "by (auto simp: notStep1EqualX notStep1EqualTimestamp)"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step (r + k) = 0; step (Suc (r + k)) = 1;\n     phase (Suc (r + k)) = phase (r + k);\n     next0 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 3. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "from ts q"], ["proof (chain)\npicking this:\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))", "have \"q \\<in> ?bynd k\""], ["proof (prove)\nusing this:\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))\n\ngoal (1 subgoal):\n 1. q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))", "by (auto simp: procsBeyondTS_def)"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>step (r + k) = 0; step (Suc (r + k)) = 1;\n     phase (Suc (r + k)) = phase (r + k);\n     next0 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 3. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with x ih"], ["proof (chain)\npicking this:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "assume \"step (r+k) = 2\""], ["proof (state)\nthis:\n  step (r + k) = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step (r + k) = 2", "have x: \"x (rho (Suc (r+k)) q) = x (rho (r+k) q)\"\n        and ts: \"timestamp (rho (Suc (r+k)) q) = timestamp (rho (r+k) q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step (r + k) = 2\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = x (rho (r + k) q) &&&\n    timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)", "by (auto simp: notStep1EqualX notStep1EqualTimestamp)"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "from ts q"], ["proof (chain)\npicking this:\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))", "have \"q \\<in> ?bynd k\""], ["proof (prove)\nusing this:\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))\n\ngoal (1 subgoal):\n 1. q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))", "by (auto simp: procsBeyondTS_def)"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>step (r + k) = 2; step (Suc (r + k)) = 3;\n     phase (Suc (r + k)) = phase (r + k);\n     next2 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n 2. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with x ih"], ["proof (chain)\npicking this:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "assume \"step (r+k) = 3\""], ["proof (state)\nthis:\n  step (r + k) = 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  step (r + k) = 3", "have x: \"x (rho (Suc (r+k)) q) = x (rho (r+k) q)\"\n        and ts: \"timestamp (rho (Suc (r+k)) q) = timestamp (rho (r+k) q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  step (r + k) = 3\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = x (rho (r + k) q) &&&\n    timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)", "by (auto simp: notStep1EqualX notStep1EqualTimestamp)"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "from ts q"], ["proof (chain)\npicking this:\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))", "have \"q \\<in> ?bynd k\""], ["proof (prove)\nusing this:\n  timestamp (rho (Suc (r + k)) q) = timestamp (rho (r + k) q)\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + Suc k))\n\ngoal (1 subgoal):\n 1. q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))", "by (auto simp: procsBeyondTS_def)"], ["proof (state)\nthis:\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step (r + k) = 3; step (Suc (r + k)) = 0;\n     phase (Suc (r + k)) = Suc (phase (r + k));\n     next3 (r + k) q (rho (r + k) q)\n      (HOrcvdMsgs LV_M (r + k) q (HOs (r + k) q) (rho (r + k)))\n      (coords (Suc (r + k)) q) (rho (Suc (r + k)) q)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "with x ih"], ["proof (chain)\npicking this:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (Suc (r + k)) q) = x (rho (r + k) q)\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + k)).\n     x (rho (r + k) q) = the (decide (rho (Suc r) p))\n  q \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> procsBeyondTS (Suc (phase r))\n                (rho (r + Suc k)) \\<Longrightarrow>\n       x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "thus \"x (rho (r + Suc k) q) = ?v\""], ["proof (prove)\nusing this:\n  x (rho (Suc (r + k)) q) = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))", "by simp"], ["proof (state)\nthis:\n  x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q\\<in>procsBeyondTS (Suc (phase r)) (rho (r + Suc k)).\n     x (rho (r + Suc k) q) = the (decide (rho (Suc r) p))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We are now in position to prove Agreement: if some process decides\n  at step \\<open>r\\<close> and another (or possibly the same) process decides\n  at step \\<open>r+k\\<close> then they decide the same value.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text decisionE},\n  @{text decisionThenMajorityBeyondTS}, @{text procsBeyondTS_monotonic}\n  @{text commitThenVoteRecent} and @{text XOfTimestampBeyondDecision}.\n*)"], ["", "lemma laterProcessDecidesSameValue:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n  and p: \"decide (rho (Suc r) p) \\<noteq> decide (rho r p)\"\n  and q: \"decide (rho (Suc (r+k)) q) \\<noteq> decide (rho (r+k) q)\"\n  shows \"decide (rho (Suc (r+k)) q) = decide (rho (Suc r) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "let \"?bynd k\" = \"procsBeyondTS (Suc (phase r)) (rho (r+k))\""], ["proof (state)\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "let ?qcrd = \"coord\\<Phi> (rho (r+k) q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "from run p"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)", "have notNone: \"decide (rho (Suc r) p) \\<noteq> None\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc r) p) \\<noteq> None", "by (auto elim: decisionE)\n  \\<comment> \\<open>process @{text q} decides on the vote of its coordinator\\<close>"], ["proof (state)\nthis:\n  decide (rho (Suc r) p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "from run q"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc (r + k)) q) \\<noteq> decide (rho (r + k) q)", "have dec: \"decide (rho (Suc (r+k)) q) = Some (the (vote (rho (r+k) ?qcrd)))\"\n   and cmt: \"commt (rho (r+k) ?qcrd)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc (r + k)) q) \\<noteq> decide (rho (r + k) q)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) =\n    Some (the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))))) &&&\n    commt (rho (r + k) (coord\\<Phi> (rho (r + k) q)))", "by (auto elim: decisionE)\n  \\<comment> \\<open>that vote is the @{text x} field of some process @{text \"q'\"} with a recent timestamp\\<close>"], ["proof (state)\nthis:\n  decide (rho (Suc (r + k)) q) =\n  Some (the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q)))))\n  commt (rho (r + k) (coord\\<Phi> (rho (r + k) q)))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "from run p"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)", "have \"card (?bynd 0) > N div 2\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))", "by (simp add: decisionThenMajorityBeyondTS)"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "moreover"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "have \"?bynd 0 \\<subseteq> ?bynd k\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. procsBeyondTS (Suc (phase r)) (rho (r + 0))\n    \\<subseteq> procsBeyondTS (Suc (phase r)) (rho (r + k))", "by (auto elim: procsBeyondTS_monotonic)"], ["proof (state)\nthis:\n  procsBeyondTS (Suc (phase r)) (rho (r + 0))\n  \\<subseteq> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "hence \"card (?bynd 0) \\<le> card (?bynd k)\""], ["proof (prove)\nusing this:\n  procsBeyondTS (Suc (phase r)) (rho (r + 0))\n  \\<subseteq> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n    \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "ultimately"], ["proof (chain)\npicking this:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))", "have maj: \"card (?bynd k) > N div 2\""], ["proof (prove)\nusing this:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  card (procsBeyondTS (Suc (phase r)) (rho (r + 0)))\n  \\<le> card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n\ngoal (1 subgoal):\n 1. N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))", "by simp"], ["proof (state)\nthis:\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "from run maj cmt"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n  commt (rho (r + k) (coord\\<Phi> (rho (r + k) q)))", "obtain q' \n    where q'1: \"q' \\<in> ?bynd k\"\n      and q'2: \"vote (rho (r+k) ?qcrd) = Some (x (rho (r+k) q'))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  N div 2 < card (procsBeyondTS (Suc (phase r)) (rho (r + k)))\n  commt (rho (r + k) (coord\\<Phi> (rho (r + k) q)))\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k));\n         vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n         Some (x (rho (r + k) q'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: commitThenVoteRecent)\n  \\<comment> \\<open>the @{text x} field of process @{text \"q'\"} is the value @{text p} decided on\\<close>"], ["proof (state)\nthis:\n  q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n  vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n  Some (x (rho (r + k) q'))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "from run p q'1"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))", "have \"x (rho (r+k) q') = the (decide (rho (Suc r) p))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc r) p) \\<noteq> decide (rho r p)\n  q' \\<in> procsBeyondTS (Suc (phase r)) (rho (r + k))\n\ngoal (1 subgoal):\n 1. x (rho (r + k) q') = the (decide (rho (Suc r) p))", "by (auto dest: XOfTimestampBeyondDecision)\n  \\<comment> \\<open>which proves the assertion\\<close>"], ["proof (state)\nthis:\n  x (rho (r + k) q') = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "with dec q'2 notNone"], ["proof (chain)\npicking this:\n  decide (rho (Suc (r + k)) q) =\n  Some (the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q)))))\n  vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n  Some (x (rho (r + k) q'))\n  decide (rho (Suc r) p) \\<noteq> None\n  x (rho (r + k) q') = the (decide (rho (Suc r) p))", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc (r + k)) q) =\n  Some (the (vote (rho (r + k) (coord\\<Phi> (rho (r + k) q)))))\n  vote (rho (r + k) (coord\\<Phi> (rho (r + k) q))) =\n  Some (x (rho (r + k) q'))\n  decide (rho (Suc r) p) \\<noteq> None\n  x (rho (r + k) q') = the (decide (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)", "by auto"], ["proof (state)\nthis:\n  decide (rho (Suc (r + k)) q) = decide (rho (Suc r) p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A process that holds some decision \\<open>v\\<close> has decided \\<open>v\\<close>\n  sometime in the past.\n\\<close>"], ["", "lemma decisionNonNullThenDecided:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and dec: \"decide (rho n p) = Some v\"\n  shows \"\\<exists>m<n. decide (rho (Suc m) p) \\<noteq> decide (rho m p) \n             \\<and> decide (rho (Suc m) p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "let \"?dec k\" = \"decide (rho k p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "have \"(\\<forall>m<n. ?dec (Suc m) \\<noteq> ?dec m \\<longrightarrow> ?dec (Suc m) \\<noteq> Some v)\n         \\<longrightarrow> ?dec n \\<noteq> Some v\"\n    (is \"?P n\" is \"?A n \\<longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m<n.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho n p) \\<noteq> Some v", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>m<0.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho 0 p) \\<noteq> Some v\n 2. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "from run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords", "show \"?P 0\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n\ngoal (1 subgoal):\n 1. (\\<forall>m<0.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho 0 p) \\<noteq> Some v", "by (auto simp: CHORun_eq LV_CHOMachine_def\n                     CHOinitConfig_def LV_initState_def)"], ["proof (state)\nthis:\n  (\\<forall>m<0.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho 0 p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "assume ih: \"?P n\""], ["proof (state)\nthis:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "show \"?P (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m<Suc n.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho (Suc n) p) \\<noteq> Some v", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<Suc n.\n                decide (rho (Suc m) p) \\<noteq>\n                decide (rho m p) \\<longrightarrow>\n                decide (rho (Suc m) p) \\<noteq> Some v;\n     decide (rho (Suc n) p) = Some v\\<rbrakk>\n    \\<Longrightarrow> False", "assume p: \"?A (Suc n)\" and v: \"?dec (Suc n) = Some v\""], ["proof (state)\nthis:\n  \\<forall>m<Suc n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v\n  decide (rho (Suc n) p) = Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<Suc n.\n                decide (rho (Suc m) p) \\<noteq>\n                decide (rho m p) \\<longrightarrow>\n                decide (rho (Suc m) p) \\<noteq> Some v;\n     decide (rho (Suc n) p) = Some v\\<rbrakk>\n    \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  \\<forall>m<Suc n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v", "have \"?A n\""], ["proof (prove)\nusing this:\n  \\<forall>m<Suc n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<forall>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n       decide (rho (Suc m) p) \\<noteq> Some v", "by simp"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<Suc n.\n                decide (rho (Suc m) p) \\<noteq>\n                decide (rho m p) \\<longrightarrow>\n                decide (rho (Suc m) p) \\<noteq> Some v;\n     decide (rho (Suc n) p) = Some v\\<rbrakk>\n    \\<Longrightarrow> False", "with ih"], ["proof (chain)\npicking this:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n  \\<forall>m<n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v", "have \"?dec n \\<noteq> Some v\""], ["proof (prove)\nusing this:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n  \\<forall>m<n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. decide (rho n p) \\<noteq> Some v", "by simp"], ["proof (state)\nthis:\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<Suc n.\n                decide (rho (Suc m) p) \\<noteq>\n                decide (rho m p) \\<longrightarrow>\n                decide (rho (Suc m) p) \\<noteq> Some v;\n     decide (rho (Suc n) p) = Some v\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<Suc n.\n                decide (rho (Suc m) p) \\<noteq>\n                decide (rho m p) \\<longrightarrow>\n                decide (rho (Suc m) p) \\<noteq> Some v;\n     decide (rho (Suc n) p) = Some v\\<rbrakk>\n    \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  \\<forall>m<Suc n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v", "have \"?dec (Suc n) \\<noteq> ?dec n \\<longrightarrow> ?dec (Suc n) \\<noteq> Some v\""], ["proof (prove)\nusing this:\n  \\<forall>m<Suc n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n     decide (rho (Suc m) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<longrightarrow>\n    decide (rho (Suc n) p) \\<noteq> Some v", "by simp"], ["proof (state)\nthis:\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<longrightarrow>\n  decide (rho (Suc n) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<Suc n.\n                decide (rho (Suc m) p) \\<noteq>\n                decide (rho m p) \\<longrightarrow>\n                decide (rho (Suc m) p) \\<noteq> Some v;\n     decide (rho (Suc n) p) = Some v\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  decide (rho n p) \\<noteq> Some v\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<longrightarrow>\n  decide (rho (Suc n) p) \\<noteq> Some v", "have \"?dec (Suc n) \\<noteq> Some v\""], ["proof (prove)\nusing this:\n  decide (rho n p) \\<noteq> Some v\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p) \\<longrightarrow>\n  decide (rho (Suc n) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. decide (rho (Suc n) p) \\<noteq> Some v", "by auto"], ["proof (state)\nthis:\n  decide (rho (Suc n) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m<Suc n.\n                decide (rho (Suc m) p) \\<noteq>\n                decide (rho m p) \\<longrightarrow>\n                decide (rho (Suc m) p) \\<noteq> Some v;\n     decide (rho (Suc n) p) = Some v\\<rbrakk>\n    \\<Longrightarrow> False", "with v"], ["proof (chain)\npicking this:\n  decide (rho (Suc n) p) = Some v\n  decide (rho (Suc n) p) \\<noteq> Some v", "show \"False\""], ["proof (prove)\nusing this:\n  decide (rho (Suc n) p) = Some v\n  decide (rho (Suc n) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>m<Suc n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho (Suc n) p) \\<noteq> Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "with dec"], ["proof (chain)\npicking this:\n  decide (rho n p) = Some v\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho n p) = Some v\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "by auto"], ["proof (state)\nthis:\n  \\<exists>m<n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n     decide (rho (Suc m) p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Irrevocability and Agreement are straightforward consequences\n  of the two preceding lemmas.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text decisionNonNullThenDecided}\n  and @{text laterProcessDecidesSameValue}. \n*)"], ["", "theorem lv_irrevocability:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and p: \"decide (rho m p) = Some v\"\n  shows \"decide (rho (m+k) p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decide (rho (m + k) p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decide (rho (m + k) p) = Some v", "from run p"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho m p) = Some v", "obtain n where\n    n1: \"n < m\" and\n    n2: \"decide (rho (Suc n) p) \\<noteq> decide (rho n p)\" and\n    n3: \"decide (rho (Suc n) p) = Some v\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho m p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < m; decide (rho (Suc n) p) \\<noteq> decide (rho n p);\n         decide (rho (Suc n) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  n < m\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p)\n  decide (rho (Suc n) p) = Some v\n\ngoal (1 subgoal):\n 1. decide (rho (m + k) p) = Some v", "have \"\\<forall>i. decide (rho (Suc (n+i)) p) = Some v\" (is \"\\<forall>i. ?dec i\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. decide (rho (Suc (n + i)) p) = Some v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. decide (rho (Suc (n + i)) p) = Some v", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. decide (rho (Suc (n + i)) p) = Some v", "show \"?dec i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + i)) p) = Some v", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. decide (rho (Suc (n + 0)) p) = Some v\n 2. \\<And>i.\n       decide (rho (Suc (n + i)) p) = Some v \\<Longrightarrow>\n       decide (rho (Suc (n + Suc i)) p) = Some v", "from n3"], ["proof (chain)\npicking this:\n  decide (rho (Suc n) p) = Some v", "show \"?dec 0\""], ["proof (prove)\nusing this:\n  decide (rho (Suc n) p) = Some v\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + 0)) p) = Some v", "by simp"], ["proof (state)\nthis:\n  decide (rho (Suc (n + 0)) p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       decide (rho (Suc (n + i)) p) = Some v \\<Longrightarrow>\n       decide (rho (Suc (n + Suc i)) p) = Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       decide (rho (Suc (n + i)) p) = Some v \\<Longrightarrow>\n       decide (rho (Suc (n + Suc i)) p) = Some v", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       decide (rho (Suc (n + i)) p) = Some v \\<Longrightarrow>\n       decide (rho (Suc (n + Suc i)) p) = Some v", "assume ih: \"?dec j\""], ["proof (state)\nthis:\n  decide (rho (Suc (n + j)) p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       decide (rho (Suc (n + i)) p) = Some v \\<Longrightarrow>\n       decide (rho (Suc (n + Suc i)) p) = Some v", "show \"?dec (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + Suc j)) p) = Some v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v \\<Longrightarrow> False", "assume ctr: \"\\<not> (?dec (Suc j))\""], ["proof (state)\nthis:\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v \\<Longrightarrow> False", "with ih"], ["proof (chain)\npicking this:\n  decide (rho (Suc (n + j)) p) = Some v\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v", "have \"decide (rho (Suc (n + Suc j)) p) \\<noteq> decide (rho (n + Suc j) p)\""], ["proof (prove)\nusing this:\n  decide (rho (Suc (n + j)) p) = Some v\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + Suc j)) p) \\<noteq> decide (rho (n + Suc j) p)", "by simp"], ["proof (state)\nthis:\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> decide (rho (n + Suc j) p)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v \\<Longrightarrow> False", "with run n2"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p)\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> decide (rho (n + Suc j) p)", "have \"decide (rho (Suc (n + Suc j)) p) = decide (rho (Suc n) p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc n) p) \\<noteq> decide (rho n p)\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> decide (rho (n + Suc j) p)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + Suc j)) p) = decide (rho (Suc n) p)", "by (rule laterProcessDecidesSameValue)"], ["proof (state)\nthis:\n  decide (rho (Suc (n + Suc j)) p) = decide (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v \\<Longrightarrow> False", "with ctr n3"], ["proof (chain)\npicking this:\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v\n  decide (rho (Suc n) p) = Some v\n  decide (rho (Suc (n + Suc j)) p) = decide (rho (Suc n) p)", "show \"False\""], ["proof (prove)\nusing this:\n  decide (rho (Suc (n + Suc j)) p) \\<noteq> Some v\n  decide (rho (Suc n) p) = Some v\n  decide (rho (Suc (n + Suc j)) p) = decide (rho (Suc n) p)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decide (rho (Suc (n + Suc j)) p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decide (rho (Suc (n + i)) p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. decide (rho (Suc (n + i)) p) = Some v\n\ngoal (1 subgoal):\n 1. decide (rho (m + k) p) = Some v", "moreover"], ["proof (state)\nthis:\n  \\<forall>i. decide (rho (Suc (n + i)) p) = Some v\n\ngoal (1 subgoal):\n 1. decide (rho (m + k) p) = Some v", "from n1"], ["proof (chain)\npicking this:\n  n < m", "obtain j where \"m+k = Suc(n+j)\""], ["proof (prove)\nusing this:\n  n < m\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        m + k = Suc (n + j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: less_imp_Suc_add)"], ["proof (state)\nthis:\n  m + k = Suc (n + j)\n\ngoal (1 subgoal):\n 1. decide (rho (m + k) p) = Some v", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i. decide (rho (Suc (n + i)) p) = Some v\n  m + k = Suc (n + j)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. decide (rho (Suc (n + i)) p) = Some v\n  m + k = Suc (n + j)\n\ngoal (1 subgoal):\n 1. decide (rho (m + k) p) = Some v", "by auto"], ["proof (state)\nthis:\n  decide (rho (m + k) p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem lv_agreement:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and p: \"decide (rho m p) = Some v\"\n      and q: \"decide (rho n q) = Some w\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "from run p"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho m p) = Some v", "obtain k \n    where k1: \"decide (rho (Suc k) p) \\<noteq> decide (rho k p)\"\n      and k2: \"decide (rho (Suc k) p) = Some v\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho m p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>decide (rho (Suc k) p) \\<noteq> decide (rho k p);\n         decide (rho (Suc k) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  decide (rho (Suc k) p) = Some v\n\ngoal (1 subgoal):\n 1. v = w", "from run q"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho n q) = Some w", "obtain l \n    where l1: \"decide (rho (Suc l) q) \\<noteq> decide (rho l q)\"\n      and l2: \"decide (rho (Suc l) q) = Some w\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho n q) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>decide (rho (Suc l) q) \\<noteq> decide (rho l q);\n         decide (rho (Suc l) q) = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  decide (rho (Suc l) q) = Some w\n\ngoal (1 subgoal):\n 1. v = w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof (cases \"k \\<le> l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "case True"], ["proof (state)\nthis:\n  k \\<le> l\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "then"], ["proof (chain)\npicking this:\n  k \\<le> l", "obtain m where m: \"l = k+m\""], ["proof (prove)\nusing this:\n  k \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<And>m. l = k + m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: le_iff_add)"], ["proof (state)\nthis:\n  l = k + m\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "from run k1 l1 m"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  l = k + m", "have \"decide (rho (Suc l) q) = decide (rho (Suc k) p)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  l = k + m\n\ngoal (1 subgoal):\n 1. decide (rho (Suc l) q) = decide (rho (Suc k) p)", "by (auto elim: laterProcessDecidesSameValue)"], ["proof (state)\nthis:\n  decide (rho (Suc l) q) = decide (rho (Suc k) p)\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "with k2 l2"], ["proof (chain)\npicking this:\n  decide (rho (Suc k) p) = Some v\n  decide (rho (Suc l) q) = Some w\n  decide (rho (Suc l) q) = decide (rho (Suc k) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc k) p) = Some v\n  decide (rho (Suc l) q) = Some w\n  decide (rho (Suc l) q) = decide (rho (Suc k) p)\n\ngoal (1 subgoal):\n 1. v = w", "by simp"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> l\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "hence \"l \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> l\n\ngoal (1 subgoal):\n 1. l \\<le> k", "by simp"], ["proof (state)\nthis:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "then"], ["proof (chain)\npicking this:\n  l \\<le> k", "obtain m where m: \"k = l+m\""], ["proof (prove)\nusing this:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>m. k = l + m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: le_iff_add)"], ["proof (state)\nthis:\n  k = l + m\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "from run l1 k1 m"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  k = l + m", "have \"decide (rho (Suc k) p) = decide (rho (Suc l) q)\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  k = l + m\n\ngoal (1 subgoal):\n 1. decide (rho (Suc k) p) = decide (rho (Suc l) q)", "by (auto elim: laterProcessDecidesSameValue)"], ["proof (state)\nthis:\n  decide (rho (Suc k) p) = decide (rho (Suc l) q)\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "with l2 k2"], ["proof (chain)\npicking this:\n  decide (rho (Suc l) q) = Some w\n  decide (rho (Suc k) p) = Some v\n  decide (rho (Suc k) p) = decide (rho (Suc l) q)", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho (Suc l) q) = Some w\n  decide (rho (Suc k) p) = Some v\n  decide (rho (Suc k) p) = decide (rho (Suc l) q)\n\ngoal (1 subgoal):\n 1. v = w", "by simp"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Termination\\<close>"], ["", "text\\<open>\n  The proof of termination relies on the communication predicate,\n  which stipulates the existence of some phase\n  during which there is a single coordinator that (a) receives a majority\n  of messages and (b) is heard by everybody. Therefore, all processes\n  successfully execute the protocol, deciding at step $3$ of that phase.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text notStep3EqualCoord},\n  @{text commitE} and @{text readyE}.\n*)"], ["", "theorem lv_termination:\n  assumes run: \"CHORun LV_M rho HOs coords\"\n      and commG:\"CHOcommGlobal LV_M HOs coords\" \n  shows \"\\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "txt \\<open>The communication predicate implies the existence of a ``successful'' phase\n    \\<open>ph\\<close>, coordinated by some process \\<open>c\\<close> for all processes.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "from commG"], ["proof (chain)\npicking this:\n  CHOcommGlobal LV_M HOs coords", "obtain ph c\n    where c: \"\\<forall>p. coords (4*ph) p = c\"\n    and maj0: \"card (HOs (4*ph) c) > N div 2\"\n    and maj2: \"card (HOs (4*ph+2) c) > N div 2\"\n    and rcv1: \"\\<forall>p. c \\<in> HOs (4*ph+1) p\"\n    and rcv3: \"\\<forall>p. c \\<in> HOs (4*ph+3) p\""], ["proof (prove)\nusing this:\n  CHOcommGlobal LV_M HOs coords\n\ngoal (1 subgoal):\n 1. (\\<And>ph c.\n        \\<lbrakk>\\<forall>p. coords (4 * ph) p = c;\n         N div 2 < card (HOs (4 * ph) c);\n         N div 2 < card (HOs (4 * ph + 2) c);\n         \\<forall>p. c \\<in> HOs (4 * ph + 1) p;\n         \\<forall>p. c \\<in> HOs (4 * ph + 3) p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: LV_CHOMachine_def LV_commGlobal_def)"], ["proof (state)\nthis:\n  \\<forall>p. coords (4 * ph) p = c\n  N div 2 < card (HOs (4 * ph) c)\n  N div 2 < card (HOs (4 * ph + 2) c)\n  \\<forall>p. c \\<in> HOs (4 * ph + 1) p\n  \\<forall>p. c \\<in> HOs (4 * ph + 3) p\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "let ?r0 = \"4*ph\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "let ?r1 = \"Suc ?r0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "let ?r2 = \"Suc ?r1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "let ?r3 = \"Suc ?r2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "let ?r4 = \"Suc ?r3\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "txt \\<open>Process \\<open>c\\<close> is the coordinator of all steps of phase \\<open>ph\\<close>.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "from run c"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coords (4 * ph) p = c", "have c':\"\\<forall>p. coord\\<Phi> (rho ?r p) = c\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coords (4 * ph) p = c\n\ngoal (1 subgoal):\n 1. \\<forall>p. coord\\<Phi> (rho (4 * ph) p) = c", "by (auto simp add: phase_def coordinators)"], ["proof (state)\nthis:\n  \\<forall>p. coord\\<Phi> (rho (4 * ph) p) = c\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coord\\<Phi> (rho (4 * ph) p) = c", "have c1: \"\\<forall>p. coord\\<Phi> (rho ?r1 p) = c\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coord\\<Phi> (rho (4 * ph) p) = c\n\ngoal (1 subgoal):\n 1. \\<forall>p. coord\\<Phi> (rho (Suc (4 * ph)) p) = c", "by (auto simp add: step_def mod_Suc notStep3EqualCoord)"], ["proof (state)\nthis:\n  \\<forall>p. coord\\<Phi> (rho (Suc (4 * ph)) p) = c\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coord\\<Phi> (rho (Suc (4 * ph)) p) = c", "have c2: \"\\<forall>p. coord\\<Phi> (rho ?r2 p) = c\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coord\\<Phi> (rho (Suc (4 * ph)) p) = c\n\ngoal (1 subgoal):\n 1. \\<forall>p. coord\\<Phi> (rho (Suc (Suc (4 * ph))) p) = c", "by (auto simp add: step_def mod_Suc notStep3EqualCoord)"], ["proof (state)\nthis:\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (4 * ph))) p) = c\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "with run"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (4 * ph))) p) = c", "have c3: \"\\<forall>p. coord\\<Phi> (rho ?r3 p) = c\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (4 * ph))) p) = c\n\ngoal (1 subgoal):\n 1. \\<forall>p. coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p) = c", "by (auto simp add: step_def mod_Suc notStep3EqualCoord)"], ["proof (state)\nthis:\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p) = c\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "txt \\<open>The coordinator receives \\<open>ValStamp\\<close> messages from a majority of\n    processes at step $0$ of phase \\<open>ph\\<close> and therefore commits during the\n    transition at the end of step $0$.\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p) = c\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "have 1: \"commt (rho ?r1 c)\" (is \"?P c (4*ph)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. commt (rho (Suc (4 * ph)) c)", "proof (rule LV_Suc'[OF run, where P=\"?P\"], auto simp: step_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (4 * ph)) = phase (4 * ph);\n     next0 (4 * ph) c (rho (4 * ph) c)\n      (HOrcvdMsgs LV_M (4 * ph) c (HOs (4 * ph) c) (rho (4 * ph)))\n      (coords (Suc (4 * ph)) c) (rho (Suc (4 * ph)) c)\\<rbrakk>\n    \\<Longrightarrow> commt (rho (Suc (4 * ph)) c)", "assume \"next0 ?r c (rho ?r c) (HOrcvdMsgs LV_M ?r c (HOs ?r c) (rho ?r))\n                  (coords (Suc ?r) c) (rho (Suc ?r) c)\""], ["proof (state)\nthis:\n  next0 (4 * ph) c (rho (4 * ph) c)\n   (HOrcvdMsgs LV_M (4 * ph) c (HOs (4 * ph) c) (rho (4 * ph)))\n   (coords (Suc (4 * ph)) c) (rho (Suc (4 * ph)) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (4 * ph)) = phase (4 * ph);\n     next0 (4 * ph) c (rho (4 * ph) c)\n      (HOrcvdMsgs LV_M (4 * ph) c (HOs (4 * ph) c) (rho (4 * ph)))\n      (coords (Suc (4 * ph)) c) (rho (Suc (4 * ph)) c)\\<rbrakk>\n    \\<Longrightarrow> commt (rho (Suc (4 * ph)) c)", "with c' maj0"], ["proof (chain)\npicking this:\n  \\<forall>p. coord\\<Phi> (rho (4 * ph) p) = c\n  N div 2 < card (HOs (4 * ph) c)\n  next0 (4 * ph) c (rho (4 * ph) c)\n   (HOrcvdMsgs LV_M (4 * ph) c (HOs (4 * ph) c) (rho (4 * ph)))\n   (coords (Suc (4 * ph)) c) (rho (Suc (4 * ph)) c)", "show \"commt (rho (Suc ?r) c)\""], ["proof (prove)\nusing this:\n  \\<forall>p. coord\\<Phi> (rho (4 * ph) p) = c\n  N div 2 < card (HOs (4 * ph) c)\n  next0 (4 * ph) c (rho (4 * ph) c)\n   (HOrcvdMsgs LV_M (4 * ph) c (HOs (4 * ph) c) (rho (4 * ph)))\n   (coords (Suc (4 * ph)) c) (rho (Suc (4 * ph)) c)\n\ngoal (1 subgoal):\n 1. commt (rho (Suc (4 * ph)) c)", "by (auto simp: step_def next0_def send0_def valStampsRcvd_def \n                     LV_CHOMachine_def HOrcvdMsgs_def LV_sendMsg_def)"], ["proof (state)\nthis:\n  commt (rho (Suc (4 * ph)) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  commt (rho (Suc (4 * ph)) c)\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "txt \\<open>All processes receive the vote of \\<open>c\\<close> at step 1 and therefore\n    update their time stamps during the transition at the end of step $1$.\\<close>"], ["proof (state)\nthis:\n  commt (rho (Suc (4 * ph)) c)\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "have 2: \"\\<forall>p. timestamp (rho ?r2 p) = Suc ph\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "let ?msgs = \"HOrcvdMsgs LV_M ?r1 p (HOs ?r1 p) (rho ?r1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "let ?crd = \"coord\\<Phi> (rho ?r1 p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "from run 1 c1 rcv1"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  commt (rho (Suc (4 * ph)) c)\n  \\<forall>p. coord\\<Phi> (rho (Suc (4 * ph)) p) = c\n  \\<forall>p. c \\<in> HOs (4 * ph + 1) p", "have cnd: \"?msgs ?crd \\<noteq> None \\<and> isVote (the (?msgs ?crd))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  commt (rho (Suc (4 * ph)) c)\n  \\<forall>p. coord\\<Phi> (rho (Suc (4 * ph)) p) = c\n  \\<forall>p. c \\<in> HOs (4 * ph + 1) p\n\ngoal (1 subgoal):\n 1. HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n     (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p)) \\<noteq>\n    None \\<and>\n    isVote\n     (the (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n            (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p))))", "by (auto elim: commitE\n               simp: step_def LV_CHOMachine_def HOrcvdMsgs_def\n                     LV_sendMsg_def send1_def isVote_def)"], ["proof (state)\nthis:\n  HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n   (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p)) \\<noteq>\n  None \\<and>\n  isVote\n   (the (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n          (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p))))\n\ngoal (1 subgoal):\n 1. \\<And>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "show \"timestamp (rho ?r2 p) = Suc ph\" (is \"?P p (Suc (4*ph))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "proof (rule LV_Suc'[OF run, where P=\"?P\"], auto simp: step_def mod_Suc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (Suc (4 * ph))) = phase (Suc (4 * ph));\n     next1 (Suc (4 * ph)) p (rho (Suc (4 * ph)) p)\n      (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n        (rho (Suc (4 * ph))))\n      (coords (Suc (Suc (4 * ph))) p) (rho (Suc (Suc (4 * ph))) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "assume \"next1 ?r1 p (rho ?r1 p) ?msgs (coords (Suc ?r1) p) (rho ?r2 p)\""], ["proof (state)\nthis:\n  next1 (Suc (4 * ph)) p (rho (Suc (4 * ph)) p)\n   (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n     (rho (Suc (4 * ph))))\n   (coords (Suc (Suc (4 * ph))) p) (rho (Suc (Suc (4 * ph))) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (Suc (4 * ph))) = phase (Suc (4 * ph));\n     next1 (Suc (4 * ph)) p (rho (Suc (4 * ph)) p)\n      (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n        (rho (Suc (4 * ph))))\n      (coords (Suc (Suc (4 * ph))) p) (rho (Suc (Suc (4 * ph))) p)\\<rbrakk>\n    \\<Longrightarrow> timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "with cnd"], ["proof (chain)\npicking this:\n  HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n   (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p)) \\<noteq>\n  None \\<and>\n  isVote\n   (the (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n          (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p))))\n  next1 (Suc (4 * ph)) p (rho (Suc (4 * ph)) p)\n   (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n     (rho (Suc (4 * ph))))\n   (coords (Suc (Suc (4 * ph))) p) (rho (Suc (Suc (4 * ph))) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n   (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p)) \\<noteq>\n  None \\<and>\n  isVote\n   (the (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n          (rho (Suc (4 * ph))) (coord\\<Phi> (rho (Suc (4 * ph)) p))))\n  next1 (Suc (4 * ph)) p (rho (Suc (4 * ph)) p)\n   (HOrcvdMsgs LV_M (Suc (4 * ph)) p (HOs (Suc (4 * ph)) p)\n     (rho (Suc (4 * ph))))\n   (coords (Suc (Suc (4 * ph))) p) (rho (Suc (Suc (4 * ph))) p)\n\ngoal (1 subgoal):\n 1. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph", "by (auto simp: next1_def phase_def)"], ["proof (state)\nthis:\n  timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "txt \\<open>The coordinator receives acknowledgements from a majority of processes\n    at step $2$ and sets its \\<open>ready\\<close> flag during the transition at the\n    end of step $2$.\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "have 3: \"ready (rho ?r3 c)\" (is \"?P c (Suc (Suc (4*ph)))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ready (rho (Suc (Suc (Suc (4 * ph)))) c)", "proof (rule LV_Suc'[OF run, where P=\"?P\"], auto simp: step_def mod_Suc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (Suc (Suc (4 * ph)))) = phase (Suc (Suc (4 * ph)));\n     next2 (Suc (Suc (4 * ph))) c (rho (Suc (Suc (4 * ph))) c)\n      (HOrcvdMsgs LV_M (Suc (Suc (4 * ph))) c (HOs (Suc (Suc (4 * ph))) c)\n        (rho (Suc (Suc (4 * ph)))))\n      (coords (Suc (Suc (Suc (4 * ph)))) c)\n      (rho (Suc (Suc (Suc (4 * ph)))) c)\\<rbrakk>\n    \\<Longrightarrow> ready (rho (Suc (Suc (Suc (4 * ph)))) c)", "assume \"next2 ?r2 c (rho ?r2 c) \n                      (HOrcvdMsgs LV_M ?r2 c (HOs ?r2 c) (rho ?r2))\n                      (coords (Suc ?r2) c) (rho ?r3 c)\""], ["proof (state)\nthis:\n  next2 (Suc (Suc (4 * ph))) c (rho (Suc (Suc (4 * ph))) c)\n   (HOrcvdMsgs LV_M (Suc (Suc (4 * ph))) c (HOs (Suc (Suc (4 * ph))) c)\n     (rho (Suc (Suc (4 * ph)))))\n   (coords (Suc (Suc (Suc (4 * ph)))) c) (rho (Suc (Suc (Suc (4 * ph)))) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (Suc (Suc (4 * ph)))) = phase (Suc (Suc (4 * ph)));\n     next2 (Suc (Suc (4 * ph))) c (rho (Suc (Suc (4 * ph))) c)\n      (HOrcvdMsgs LV_M (Suc (Suc (4 * ph))) c (HOs (Suc (Suc (4 * ph))) c)\n        (rho (Suc (Suc (4 * ph)))))\n      (coords (Suc (Suc (Suc (4 * ph)))) c)\n      (rho (Suc (Suc (Suc (4 * ph)))) c)\\<rbrakk>\n    \\<Longrightarrow> ready (rho (Suc (Suc (Suc (4 * ph)))) c)", "with 2 c2 maj2"], ["proof (chain)\npicking this:\n  \\<forall>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (4 * ph))) p) = c\n  N div 2 < card (HOs (4 * ph + 2) c)\n  next2 (Suc (Suc (4 * ph))) c (rho (Suc (Suc (4 * ph))) c)\n   (HOrcvdMsgs LV_M (Suc (Suc (4 * ph))) c (HOs (Suc (Suc (4 * ph))) c)\n     (rho (Suc (Suc (4 * ph)))))\n   (coords (Suc (Suc (Suc (4 * ph)))) c) (rho (Suc (Suc (Suc (4 * ph)))) c)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>p. timestamp (rho (Suc (Suc (4 * ph))) p) = Suc ph\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (4 * ph))) p) = c\n  N div 2 < card (HOs (4 * ph + 2) c)\n  next2 (Suc (Suc (4 * ph))) c (rho (Suc (Suc (4 * ph))) c)\n   (HOrcvdMsgs LV_M (Suc (Suc (4 * ph))) c (HOs (Suc (Suc (4 * ph))) c)\n     (rho (Suc (Suc (4 * ph)))))\n   (coords (Suc (Suc (Suc (4 * ph)))) c) (rho (Suc (Suc (Suc (4 * ph)))) c)\n\ngoal (1 subgoal):\n 1. ready (rho (Suc (Suc (Suc (4 * ph)))) c)", "by (auto simp: mod_Suc step_def LV_CHOMachine_def HOrcvdMsgs_def\n                     LV_sendMsg_def next2_def send2_def acksRcvd_def\n                     isAck_def phase_def)"], ["proof (state)\nthis:\n  ready (rho (Suc (Suc (Suc (4 * ph)))) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ready (rho (Suc (Suc (Suc (4 * ph)))) c)\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "txt \\<open>All processes receive the vote of the coordinator during step $3$\n    and decide during the transition at the end of that step.\\<close>"], ["proof (state)\nthis:\n  ready (rho (Suc (Suc (Suc (4 * ph)))) c)\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "have 4: \"\\<forall>p. decide (rho ?r4 p) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "let ?msgs = \"HOrcvdMsgs LV_M ?r3 p (HOs ?r3 p) (rho ?r3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "let ?crd = \"coord\\<Phi> (rho ?r3 p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "from run 3 c3 rcv3"], ["proof (chain)\npicking this:\n  CHORun LV_M rho HOs coords\n  ready (rho (Suc (Suc (Suc (4 * ph)))) c)\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p) = c\n  \\<forall>p. c \\<in> HOs (4 * ph + 3) p", "have cnd: \"?msgs ?crd \\<noteq> None \\<and> isVote (the (?msgs ?crd))\""], ["proof (prove)\nusing this:\n  CHORun LV_M rho HOs coords\n  ready (rho (Suc (Suc (Suc (4 * ph)))) c)\n  \\<forall>p. coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p) = c\n  \\<forall>p. c \\<in> HOs (4 * ph + 3) p\n\ngoal (1 subgoal):\n 1. HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n     (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph)))))\n     (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p)) \\<noteq>\n    None \\<and>\n    isVote\n     (the (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n            (HOs (Suc (Suc (Suc (4 * ph)))) p)\n            (rho (Suc (Suc (Suc (4 * ph)))))\n            (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p))))", "by (auto elim: readyE\n               simp: step_def mod_Suc LV_CHOMachine_def HOrcvdMsgs_def\n                     LV_sendMsg_def send3_def isVote_def numeral_3_eq_3)"], ["proof (state)\nthis:\n  HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n   (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph)))))\n   (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p)) \\<noteq>\n  None \\<and>\n  isVote\n   (the (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n          (HOs (Suc (Suc (Suc (4 * ph)))) p)\n          (rho (Suc (Suc (Suc (4 * ph)))))\n          (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p))))\n\ngoal (1 subgoal):\n 1. \\<And>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "show \"decide (rho ?r4 p) \\<noteq> None\" (is \"?P p (Suc (Suc (Suc (4*ph))))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "proof (rule LV_Suc'[OF run, where P=\"?P\"], auto simp: step_def mod_Suc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (Suc (Suc (Suc (4 * ph))))) =\n             Suc (phase (Suc (Suc (Suc (4 * ph)))));\n     next3 (Suc (Suc (Suc (4 * ph)))) p (rho (Suc (Suc (Suc (4 * ph)))) p)\n      (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n        (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph))))))\n      (coords (Suc (Suc (Suc (Suc (4 * ph))))) p)\n      (rho (Suc (Suc (Suc (Suc (4 * ph))))) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) =\n                         Some y", "assume \"next3 ?r3 p (rho ?r3 p) ?msgs (coords (Suc ?r3) p) (rho ?r4 p)\""], ["proof (state)\nthis:\n  next3 (Suc (Suc (Suc (4 * ph)))) p (rho (Suc (Suc (Suc (4 * ph)))) p)\n   (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n     (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph))))))\n   (coords (Suc (Suc (Suc (Suc (4 * ph))))) p)\n   (rho (Suc (Suc (Suc (Suc (4 * ph))))) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phase (Suc (Suc (Suc (Suc (4 * ph))))) =\n             Suc (phase (Suc (Suc (Suc (4 * ph)))));\n     next3 (Suc (Suc (Suc (4 * ph)))) p (rho (Suc (Suc (Suc (4 * ph)))) p)\n      (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n        (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph))))))\n      (coords (Suc (Suc (Suc (Suc (4 * ph))))) p)\n      (rho (Suc (Suc (Suc (Suc (4 * ph))))) p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) =\n                         Some y", "with cnd"], ["proof (chain)\npicking this:\n  HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n   (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph)))))\n   (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p)) \\<noteq>\n  None \\<and>\n  isVote\n   (the (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n          (HOs (Suc (Suc (Suc (4 * ph)))) p)\n          (rho (Suc (Suc (Suc (4 * ph)))))\n          (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p))))\n  next3 (Suc (Suc (Suc (4 * ph)))) p (rho (Suc (Suc (Suc (4 * ph)))) p)\n   (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n     (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph))))))\n   (coords (Suc (Suc (Suc (Suc (4 * ph))))) p)\n   (rho (Suc (Suc (Suc (Suc (4 * ph))))) p)", "show \"\\<exists>v. decide (rho ?r4 p) = Some v\""], ["proof (prove)\nusing this:\n  HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n   (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph)))))\n   (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p)) \\<noteq>\n  None \\<and>\n  isVote\n   (the (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n          (HOs (Suc (Suc (Suc (4 * ph)))) p)\n          (rho (Suc (Suc (Suc (4 * ph)))))\n          (coord\\<Phi> (rho (Suc (Suc (Suc (4 * ph)))) p))))\n  next3 (Suc (Suc (Suc (4 * ph)))) p (rho (Suc (Suc (Suc (4 * ph)))) p)\n   (HOrcvdMsgs LV_M (Suc (Suc (Suc (4 * ph)))) p\n     (HOs (Suc (Suc (Suc (4 * ph)))) p) (rho (Suc (Suc (Suc (4 * ph))))))\n   (coords (Suc (Suc (Suc (Suc (4 * ph))))) p)\n   (rho (Suc (Suc (Suc (Suc (4 * ph))))) p)\n\ngoal (1 subgoal):\n 1. \\<exists>v. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) = Some v", "by (auto simp: next3_def)"], ["proof (state)\nthis:\n  \\<exists>v. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "txt \\<open>This immediately proves the assertion.\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "from 4"], ["proof (chain)\npicking this:\n  \\<forall>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>p. decide (rho (Suc (Suc (Suc (Suc (4 * ph))))) p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", ".."], ["proof (state)\nthis:\n  \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\emph{LastVoting} Solves Consensus\\<close>"], ["", "text \\<open>\n  Summing up, all (coarse-grained) runs of \\emph{LastVoting} for\n  HO collections that satisfy the communication predicate satisfy\n  the Consensus property.\n\\<close>"], ["", "theorem lv_consensus:\n  assumes run: \"CHORun LV_M rho HOs coords\" \n      and commG: \"CHOcommGlobal LV_M HOs coords\"\n  shows \"consensus (x \\<circ> (rho 0)) decide rho\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consensus (x \\<circ> rho 0) decide rho", "proof -\n  \\<comment> \\<open>the above statement of termination is stronger than what we need\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. consensus (x \\<circ> rho 0) decide rho", "from lv_termination[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None", "obtain r where \"\\<forall>p. decide (rho r p) \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<exists>r. \\<forall>p. decide (rho r p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<forall>p. decide (rho r p) \\<noteq> None \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<forall>p. decide (rho r p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. consensus (x \\<circ> rho 0) decide rho", "hence \"\\<forall>p. \\<exists>r. decide (rho r p) \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<forall>p. decide (rho r p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<exists>r. decide (rho r p) \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  \\<forall>p. \\<exists>r. decide (rho r p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. consensus (x \\<circ> rho 0) decide rho", "with lv_integrity[OF run] lv_agreement[OF run]"], ["proof (chain)\npicking this:\n  decide (rho ?n ?p) = Some ?v \\<Longrightarrow>\n  \\<exists>q. ?v = x (rho 0 q)\n  \\<lbrakk>decide (rho ?m ?p) = Some ?v;\n   decide (rho ?n ?q) = Some ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  \\<forall>p. \\<exists>r. decide (rho r p) \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho ?n ?p) = Some ?v \\<Longrightarrow>\n  \\<exists>q. ?v = x (rho 0 q)\n  \\<lbrakk>decide (rho ?m ?p) = Some ?v;\n   decide (rho ?n ?q) = Some ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  \\<forall>p. \\<exists>r. decide (rho r p) \\<noteq> None\n\ngoal (1 subgoal):\n 1. consensus (x \\<circ> rho 0) decide rho", "by (auto simp: consensus_def image_def)"], ["proof (state)\nthis:\n  consensus (x \\<circ> rho 0) decide rho\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  By the reduction theorem, the correctness of the algorithm carries over\n  to the fine-grained model of runs.\n\\<close>"], ["", "theorem lv_consensus_fg:\n  assumes run: \"fg_run LV_M rho HOs HOs coords\"\n      and commG: \"CHOcommGlobal LV_M HOs coords\"\n  shows \"consensus (\\<lambda>p. x (state (rho 0) p)) decide (state \\<circ> rho)\"\n    (is \"consensus ?inits _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. consensus (\\<lambda>p. x (state (rho 0) p)) decide (state \\<circ> rho)", "proof (rule local_property_reduction[OF run consensus_is_local])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun LV_M crho HOs HOs coords;\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> consensus (\\<lambda>p. x (state (rho 0) p)) decide\n                          crho", "fix crun"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun LV_M crho HOs HOs coords;\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> consensus (\\<lambda>p. x (state (rho 0) p)) decide\n                          crho", "assume crun: \"CSHORun LV_M crun HOs HOs coords\"\n     and init: \"crun 0 = state (rho 0)\""], ["proof (state)\nthis:\n  CSHORun LV_M crun HOs HOs coords\n  crun 0 = state (rho 0)\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun LV_M crho HOs HOs coords;\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> consensus (\\<lambda>p. x (state (rho 0) p)) decide\n                          crho", "from crun"], ["proof (chain)\npicking this:\n  CSHORun LV_M crun HOs HOs coords", "have \"CHORun LV_M crun HOs coords\""], ["proof (prove)\nusing this:\n  CSHORun LV_M crun HOs HOs coords\n\ngoal (1 subgoal):\n 1. CHORun LV_M crun HOs coords", "by (unfold CHORun_def SHORun_def)"], ["proof (state)\nthis:\n  CHORun LV_M crun HOs coords\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun LV_M crho HOs HOs coords;\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> consensus (\\<lambda>p. x (state (rho 0) p)) decide\n                          crho", "from this commG"], ["proof (chain)\npicking this:\n  CHORun LV_M crun HOs coords\n  CHOcommGlobal LV_M HOs coords", "have \"consensus (x \\<circ> (crun 0)) decide crun\""], ["proof (prove)\nusing this:\n  CHORun LV_M crun HOs coords\n  CHOcommGlobal LV_M HOs coords\n\ngoal (1 subgoal):\n 1. consensus (x \\<circ> crun 0) decide crun", "by (rule lv_consensus)"], ["proof (state)\nthis:\n  consensus (x \\<circ> crun 0) decide crun\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun LV_M crho HOs HOs coords;\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> consensus (\\<lambda>p. x (state (rho 0) p)) decide\n                          crho", "with init"], ["proof (chain)\npicking this:\n  crun 0 = state (rho 0)\n  consensus (x \\<circ> crun 0) decide crun", "show \"consensus ?inits decide crun\""], ["proof (prove)\nusing this:\n  crun 0 = state (rho 0)\n  consensus (x \\<circ> crun 0) decide crun\n\ngoal (1 subgoal):\n 1. consensus (\\<lambda>p. x (state (rho 0) p)) decide crun", "by (simp add: o_def)"], ["proof (state)\nthis:\n  consensus (\\<lambda>p. x (state (rho 0) p)) decide crun\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}