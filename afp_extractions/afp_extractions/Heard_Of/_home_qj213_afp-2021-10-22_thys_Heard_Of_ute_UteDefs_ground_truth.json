{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/ute/UteDefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma phase_zero [simp]: \"phase 0 = 0\"", "lemma step_zero [simp]: \"step 0 = 0\"", "lemma phase_step: \"(phase r * nSteps) + step r = r\"", "lemma alpha_lt_N: \"\\<alpha> < N\"", "lemma alpha_lt_T: \"\\<alpha> < T\"", "lemma alpha_lt_E: \"\\<alpha> < E\""], "translations": [["", "lemma phase_zero [simp]: \"phase 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phase 0 = 0", "by (simp add: phase_def)"], ["", "lemma step_zero [simp]: \"step 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step 0 = 0", "by (simp add: step_def)"], ["", "lemma phase_step: \"(phase r * nSteps) + step r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phase r * nSteps + step r = r", "by (auto simp add: phase_def step_def)"], ["", "text \\<open>The following record models the local state of a process.\\<close>"], ["", "record 'val pstate =\n  x :: 'val                \\<comment> \\<open>current value held by process\\<close>\n  vote :: \"'val option\"    \\<comment> \\<open>value the process voted for, if any\\<close>\n  decide :: \"'val option\"  \\<comment> \\<open>value the process has decided on, if any\\<close>"], ["", "text \\<open>Possible messages sent during the execution of the algorithm.\\<close>"], ["", "datatype 'val msg =\n   Val \"'val\"\n | Vote \"'val option\""], ["", "text \\<open>\n  The \\<open>x\\<close> field of the initial state is unconstrained, all other\n  fields are initialized appropriately.\n\\<close>"], ["", "definition Ute_initState where\n  \"Ute_initState p st \\<equiv>\n   (vote st = None) \\<and> (decide st = None)\""], ["", "text \\<open>\n  The following locale introduces the parameters used for the \\ute{}\n  algorithm and their constraints~\\cite{biely:tolerating}.\n\\<close>"], ["", "locale ute_parameters =\n  fixes \\<alpha>::nat and T::nat and E::nat\n  assumes majE: \"2*E \\<ge> N + 2*\\<alpha>\"\n      and majT: \"2*T \\<ge> N + 2*\\<alpha>\"\n      and EltN: \"E < N\"\n      and TltN: \"T < N\"\nbegin"], ["", "text \\<open>Simple consequences of the above parameter constraints.\\<close>"], ["", "lemma alpha_lt_N: \"\\<alpha> < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < N", "using EltN majE"], ["proof (prove)\nusing this:\n  E < N\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n\ngoal (1 subgoal):\n 1. \\<alpha> < N", "by auto"], ["", "lemma alpha_lt_T: \"\\<alpha> < T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < T", "using majT alpha_lt_N"], ["proof (prove)\nusing this:\n  N + nSteps * \\<alpha> \\<le> nSteps * T\n  \\<alpha> < N\n\ngoal (1 subgoal):\n 1. \\<alpha> < T", "by auto"], ["", "lemma alpha_lt_E: \"\\<alpha> < E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < E", "using majE alpha_lt_N"], ["proof (prove)\nusing this:\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n  \\<alpha> < N\n\ngoal (1 subgoal):\n 1. \\<alpha> < E", "by auto"], ["", "text \\<open>\n  We separately define the transition predicates and the send functions\n  for each step and later combine them to define the overall next-state relation.\n\\<close>"], ["", "text \\<open>\n  In step 0, each process sends its current \\<open>x\\<close>.\n  If it receives the value $v$ more than $T$ times, it votes for $v$,\n  otherwise it doesn't vote.\n\\<close>"], ["", "definition\n  send0 :: \"nat \\<Rightarrow> Proc \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> 'val msg\"\nwhere\n  \"send0 r p q st \\<equiv> Val (x st)\""], ["", "definition\n  next0 :: \"nat \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> (Proc \\<Rightarrow> 'val msg option) \n                \\<Rightarrow> 'val pstate \\<Rightarrow> bool\" \nwhere\n  \"next0 r p st msgs st' \\<equiv>\n     (\\<exists>v. card {q. msgs q = Some (Val v)} > T \\<and> st' = st \\<lparr> vote := Some v \\<rparr>)\n   \\<or> \\<not>(\\<exists>v. card {q. msgs q = Some (Val v)} > T) \\<and> st' = st \\<lparr> vote := None \\<rparr>\""], ["", "text \\<open>\n  In step 1, each process sends its current \\<open>vote\\<close>.\n\n  If it receives more than \\<open>\\<alpha>\\<close> votes for a given value \\<open>v\\<close>,\n  it sets its \\<open>x\\<close> field to \\<open>v\\<close>, else it sets \\<open>x\\<close> to a\n  default value.\n\n  If the process receives more than \\<open>E\\<close> votes for \\<open>v\\<close>, it decides\n  \\<open>v\\<close>, otherwise it leaves its decision unchanged.\n\\<close>"], ["", "definition\n  send1 :: \"nat \\<Rightarrow> Proc \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> 'val msg\" \nwhere\n  \"send1 r p q st \\<equiv> Vote (vote st)\""], ["", "definition\n  next1 :: \"nat \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> (Proc \\<Rightarrow> 'val msg option) \n                \\<Rightarrow> 'val pstate \\<Rightarrow> bool\" \nwhere\n  \"next1 r p st msgs st' \\<equiv>\n    ( (\\<exists>v. card {q. msgs q = Some (Vote (Some v))} > \\<alpha> \\<and> x st' = v)\n     \\<or> \\<not>(\\<exists>v. card {q. msgs q = Some (Vote (Some v))} > \\<alpha>) \n         \\<and> x st' = undefined  )\n  \\<and> ( (\\<exists>v. card {q. msgs q = Some (Vote (Some v))} > E \\<and> decide st' = Some v)\n     \\<or> \\<not>(\\<exists>v. card {q. msgs q = Some (Vote (Some v))} > E) \n         \\<and> decide st' = decide st )\n  \\<and> vote st' = None\""], ["", "text \\<open>\n  The overall send function and next-state relation are simply obtained as\n  the composition of the individual relations defined above.\n\\<close>"], ["", "definition \n  Ute_sendMsg :: \"nat \\<Rightarrow> Proc \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> 'val msg\" \nwhere\n  \"Ute_sendMsg (r::nat) \\<equiv> if step r = 0 then send0 r else send1 r\""], ["", "definition \n  Ute_nextState :: \"nat \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> (Proc \\<Rightarrow> 'val msg option)\n                        \\<Rightarrow> 'val pstate \\<Rightarrow> bool\" \nwhere\n  \"Ute_nextState r \\<equiv> if step r = 0 then next0 r else next1 r\""], ["", "subsection \\<open>Communication Predicate for \\ute{}\\<close>"], ["", "text \\<open>\n  Following~\\cite{biely:tolerating}, we now define the communication predicate\n  for the \\ute{} algorithm to be correct.\n\n  The round-by-round predicate stipulates the following conditions:\n  \\begin{itemize}\n  \\item no process may receive more than \\<open>\\<alpha>\\<close> corrupted messages, and\n  \\item every process should receive more than \\<open>max(T, N + 2*\\<alpha> - E - 1)\\<close> \n    correct messages.\n  \\end{itemize}\n  \\cite{biely:tolerating} also requires that every process should receive more\n  than \\<open>\\<alpha>\\<close> correct messages, but this is implied, since \\<open>T > \\<alpha>\\<close>\n  (cf. lemma \\<open>alpha_lt_T\\<close>).\n\\<close>"], ["", "definition Ute_commPerRd where\n  \"Ute_commPerRd HOrs SHOrs \\<equiv>\n   \\<forall>p. card (HOrs p - SHOrs p) \\<le> \\<alpha>\n     \\<and> card (SHOrs p \\<inter> HOrs p) > N + 2*\\<alpha> - E - 1\n     \\<and> card (SHOrs p \\<inter> HOrs p) > T\""], ["", "text \\<open>\n  The global communication predicate requires there exists some phase\n  \\<open>\\<Phi>\\<close> such that:\n  \\begin{itemize}\n  \\item all HO and SHO sets of all processes are equal in the second step\n    of phase \\<open>\\<Phi>\\<close>, i.e.\\ all processes receive messages from the \n    same set of processes, and none of these messages is corrupted,\n  \\item every process receives more than \\<open>T\\<close> correct messages in\n    the first step of phase \\<open>\\<Phi>+1\\<close>, and\n  \\item every process receives more than \\<open>E\\<close> correct messages in the\n    second step of phase \\<open>\\<Phi>+1\\<close>.\n  \\end{itemize}\n  The predicate in the article~\\cite{biely:tolerating} requires infinitely\n  many such phases, but one is clearly enough.\n\\<close>"], ["", "definition Ute_commGlobal where\n  \"Ute_commGlobal HOs SHOs \\<equiv>\n    \\<exists>\\<Phi>. (let r = Suc (nSteps*\\<Phi>)\n         in  (\\<exists>\\<pi>. \\<forall>p. \\<pi> = HOs r p \\<and> \\<pi> = SHOs r p)\n           \\<and> (\\<forall>p. card (SHOs (Suc r) p \\<inter> HOs (Suc r) p) > T)\n           \\<and> (\\<forall>p. card (SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p) > E))\""], ["", "subsection \\<open>The \\ute{} Heard-Of Machine\\<close>"], ["", "text \\<open>\n  We now define the coordinated HO machine for the \\ute{} algorithm\n  by assembling the algorithm definition and its communication-predicate.\n\\<close>"], ["", "definition Ute_SHOMachine where\n  \"Ute_SHOMachine = \\<lparr>\n     CinitState =  (\\<lambda> p st crd. Ute_initState p st),\n     sendMsg =  Ute_sendMsg,\n     CnextState = (\\<lambda> r p st msgs crd st'. Ute_nextState r p st msgs st'),\n     SHOcommPerRd = Ute_commPerRd,\n     SHOcommGlobal = Ute_commGlobal \n   \\<rparr>\""], ["", "abbreviation\n  \"Ute_M \\<equiv> (Ute_SHOMachine::(Proc, 'val pstate, 'val msg) SHOMachine)\""], ["", "end   \\<comment> \\<open>locale @{text \"ute_parameters\"}\\<close>"], ["", "end"], ["", "(* theory UteDefs *)"]]}