{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/ute/UteProof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma vote_step:\n  assumes  nxt: \"nextState Ute_M r p (rho r p) \\<mu> (rho (Suc r) p)\"\n  and \"vote (rho (Suc r) p) \\<noteq> None\"\n  shows \"step r = 0\"", "lemma decide_step:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and d1: \"decide (rho r p) \\<noteq> Some v\"\n  and d2: \"decide (rho (Suc r) p) = Some v\"\n  shows \"step r \\<noteq> 0\"", "lemma unique_majority_E:\n  assumes majv: \"card {qq::Proc. F qq = Some m} > E\"\n  and majw: \"card {qq::Proc. F qq = Some m'} > E\"\n  shows \"m = m'\"", "lemma unique_majority_E_\\<alpha>:\n  assumes majv: \"card {qq::Proc. F qq = m} > E - \\<alpha>\"\n  and majw: \"card {qq::Proc. F qq = m'} > E - \\<alpha>\"\n  shows \"m = m'\"", "lemma unique_majority_T:\n  assumes majv: \"card {qq::Proc. F qq = Some m} > T\"\n  and majw: \"card {qq::Proc. F qq = Some m'} > T\"\n  shows \"m = m'\"", "lemma common_vote:\n  assumes usafe: \"SHOcommPerRd Ute_M HO SHO\"\n  and nxtp: \"nextState Ute_M r p (rho r p)  \\<mu>p (rho (Suc r) p)\"\n  and mup: \"\\<mu>p \\<in> SHOmsgVectors Ute_M r p (rho r) (HO p) (SHO p)\"\n  and nxtq: \"nextState Ute_M r q (rho r q)  \\<mu>q (rho (Suc r) q)\"\n  and muq: \"\\<mu>q \\<in> SHOmsgVectors Ute_M r q (rho r) (HO q) (SHO q)\"\n  and vp: \"vote (rho (Suc r) p) = Some vp\"\n  and vq: \"vote (rho (Suc r) q) = Some vq\"\n  shows \"vp = vq\"", "lemma decide_with_threshold_E:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and usafe: \"SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and d1: \"decide (rho r p) \\<noteq> Some v\"\n  and d2: \"decide (rho (Suc r) p) = Some v\"\n  shows \"card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}\n           > E - \\<alpha>\"", "lemma common_x_argument_1:\n  assumes usafe:\"SHOcommPerRd Ute_M (HOs (Suc r)) (SHOs (Suc r))\"\n  and threshold: \"card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) \n                            = Vote (Some v)} > E - \\<alpha>\"\n                 (is \"card (?msgs p v) > _\")\n  shows \"card (?msgs pp v \\<inter> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)) > \\<alpha>\"", "lemma common_x_argument_2:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and usafe: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and nxtpp: \"nextState Ute_M (Suc r) pp (rho (Suc r) pp) \n                        \\<mu>pp (rho (Suc (Suc r)) pp)\"\n  and mupp: \"\\<mu>pp \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) \n                                 (HOs (Suc r) pp) (SHOs (Suc r) pp)\"\n  and threshold: \"card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) \n                             = Vote (Some v)} > E - \\<alpha>\"\n                 (is \"card (?sent p v) > _\")\n  shows \"x (rho (Suc (Suc r)) pp) = v\"", "lemma safety_inductive_argument:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and ih: \"E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}\"\n  and stp1: \"step r' = Suc 0\"\n  shows \"E - \\<alpha> <\n         card {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q)\n                     = Vote (Some v)}\"", "lemma decisionNonNullThenDecided:\n  assumes run:\"SHORun Ute_M rho HOs SHOs\" and dec: \"decide (rho n p) = Some v\"\n  shows \"\\<exists>m<n. decide (rho (Suc m) p) \\<noteq> decide (rho m p) \n             \\<and> decide (rho (Suc m) p) = Some v\"", "lemma laterProcessDecidesSameValue:\n  assumes run:\"SHORun Ute_M rho HOs SHOs\"\n  and comm:\"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and dv1:\"decide (rho (Suc r) p1) = Some v1\"\n  and dn2:\"decide (rho (r + k) p2) \\<noteq> Some v2\"\n  and dv2:\"decide (rho (Suc (r + k)) p2) = Some v2\"\n  shows \"v2 = v1\"", "theorem ute_agreement:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and p: \"decide (rho m p) = Some v\"\n  and q: \"decide (rho n q) = Some w\"\n  shows \"v = w\"", "lemma validity_argument:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and init: \"\\<forall>p. x ((rho 0) p) = v\"\n  and dw: \"decide (rho r p) = Some w\"\n  and stp: \"step r' = Suc 0\"\n  shows \"card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)} > E - \\<alpha>\"", "theorem ute_validity:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and init: \"\\<forall>p. x (rho 0 p) = v\"\n  and dw: \"decide (rho r p) = Some w\"\n  shows \"v = w\"", "lemma set_x_from_vote:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and comm: \"SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and stp: \"step (Suc r) = Suc 0\"\n  and \\<pi>: \"\\<forall>p. HOs (Suc r) p = SHOs (Suc r) p\"\n  and nxt: \"nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu> (rho (Suc (Suc r)) p)\"\n  and mu: \"\\<mu> \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r))\n                                   (HOs (Suc r) p) (SHOs (Suc r) p)\"\n  and vp: \"\\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some v))}\"\n  shows \"x ((rho (Suc (Suc r))) p) = v\"", "lemma termination_argument_1:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and comm: \"SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and stp: \"step (Suc r) = Suc 0\"\n  and \\<pi>: \"\\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\"\n  obtains v where \n    \"\\<And>p \\<mu>p' q. \n       \\<lbrakk> q \\<in> SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p; \n         \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                             (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\n       \\<rbrakk> \\<Longrightarrow> \\<mu>p' q = (Some (Val v))\"", "lemma termination_argument_2:\n  assumes mup: \"\\<mu>p \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) \n                                     (HOs (Suc r) p) (SHOs (Suc r) p)\"\n  and nxtq: \"nextState Ute_M r q (rho r q)  \\<mu>q (rho (Suc r) q)\"\n  and vq: \"vote (rho (Suc r) q) = Some v\"\n  and qsho: \"q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p\"\n  shows \"\\<mu>p q = Some (Vote (Some v))\"", "theorem ute_termination:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and commR: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and commG: \"SHOcommGlobal Ute_M HOs SHOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\"", "theorem ute_weak_consensus:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ute_M HOs SHOs\"\n  shows \"weak_consensus (x \\<circ> (rho 0)) decide rho\"", "theorem ute_weak_consensus_fg:\n  assumes run: \"fg_run Ute_M rho HOs SHOs (\\<lambda>r q. undefined)\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ute_M HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide (state \\<circ> rho)\"\n    (is \"weak_consensus ?inits _ _\")"], "translations": [["", "lemma vote_step:\n  assumes  nxt: \"nextState Ute_M r p (rho r p) \\<mu> (rho (Suc r) p)\"\n  and \"vote (rho (Suc r) p) \\<noteq> None\"\n  shows \"step r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step r = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. step r \\<noteq> 0 \\<Longrightarrow> False", "assume \"step r \\<noteq> 0\""], ["proof (state)\nthis:\n  step r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. step r \\<noteq> 0 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  nextState Ute_M r p (rho r p) \\<mu> (rho (Suc r) p)\n  vote (rho (Suc r) p) \\<noteq> None\n  step r \\<noteq> 0", "have \"vote (rho (Suc r) p) = None\""], ["proof (prove)\nusing this:\n  nextState Ute_M r p (rho r p) \\<mu> (rho (Suc r) p)\n  vote (rho (Suc r) p) \\<noteq> None\n  step r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) p) = None", "by (auto simp:Ute_SHOMachine_def nextState_def Ute_nextState_def next1_def)"], ["proof (state)\nthis:\n  vote (rho (Suc r) p) = None\n\ngoal (1 subgoal):\n 1. step r \\<noteq> 0 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  nextState Ute_M r p (rho r p) \\<mu> (rho (Suc r) p)\n  vote (rho (Suc r) p) \\<noteq> None\n  vote (rho (Suc r) p) = None", "show False"], ["proof (prove)\nusing this:\n  nextState Ute_M r p (rho r p) \\<mu> (rho (Suc r) p)\n  vote (rho (Suc r) p) \\<noteq> None\n  vote (rho (Suc r) p) = None\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Processes can make a new decision only at second round of each phase.\\<close>"], ["", "lemma decide_step:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and d1: \"decide (rho r p) \\<noteq> Some v\"\n  and d2: \"decide (rho (Suc r) p) = Some v\"\n  shows \"step r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step r \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. step r = 0 \\<Longrightarrow> False", "assume sr:\"step r = 0\""], ["proof (state)\nthis:\n  step r = 0\n\ngoal (1 subgoal):\n 1. step r = 0 \\<Longrightarrow> False", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu> where \"Ute_nextState r p (rho r p) \\<mu> (rho (Suc r) p)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>.\n        Ute_nextState r p (rho r p) \\<mu> (rho (Suc r) p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Ute_SHOMachine_def nextState_def SHORun_eq SHOnextConfig_eq"], ["proof (prove)\nusing this:\n  HOinitConfig\n   \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n      sendMsg = Ute_sendMsg,\n      CnextState = \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n      SHOcommPerRd = Ute_commPerRd, SHOcommGlobal = Ute_commGlobal\\<rparr>\n   (rho 0) \\<and>\n  (\\<forall>r p.\n      \\<exists>\\<mu>\n               \\<in>SHOmsgVectors\n                     \\<lparr>CinitState =\n                               \\<lambda>p st crd. Ute_initState p st,\n                        sendMsg = Ute_sendMsg,\n                        CnextState =\n                          \\<lambda>r p st msgs crd.\n                             Ute_nextState r p st msgs,\n                        SHOcommPerRd = Ute_commPerRd,\n                        SHOcommGlobal = Ute_commGlobal\\<rparr>\n                     r p (rho r) (HOs r p) (SHOs r p).\n         CnextState\n          \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n             sendMsg = Ute_sendMsg,\n             CnextState =\n               \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n             SHOcommPerRd = Ute_commPerRd,\n             SHOcommGlobal = Ute_commGlobal\\<rparr>\n          r p (rho r p) \\<mu> undefined (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>.\n        Ute_nextState r p (rho r p) \\<mu> (rho (Suc r) p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  Ute_nextState r p (rho r p) \\<mu> (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. step r = 0 \\<Longrightarrow> False", "with sr"], ["proof (chain)\npicking this:\n  step r = 0\n  Ute_nextState r p (rho r p) \\<mu> (rho (Suc r) p)", "have \"next0 r p (rho r p) \\<mu> (rho (Suc r) p)\""], ["proof (prove)\nusing this:\n  step r = 0\n  Ute_nextState r p (rho r p) \\<mu> (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. next0 r p (rho r p) \\<mu> (rho (Suc r) p)", "unfolding Ute_nextState_def"], ["proof (prove)\nusing this:\n  step r = 0\n  (if step r = 0 then next0 r else next1 r) p (rho r p) \\<mu>\n   (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. next0 r p (rho r p) \\<mu> (rho (Suc r) p)", "by auto"], ["proof (state)\nthis:\n  next0 r p (rho r p) \\<mu> (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. step r = 0 \\<Longrightarrow> False", "hence \"decide (rho r p) = decide (rho (Suc r) p)\""], ["proof (prove)\nusing this:\n  next0 r p (rho r p) \\<mu> (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. decide (rho r p) = decide (rho (Suc r) p)", "by (auto simp:next0_def)"], ["proof (state)\nthis:\n  decide (rho r p) = decide (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. step r = 0 \\<Longrightarrow> False", "with d1 d2"], ["proof (chain)\npicking this:\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  decide (rho r p) = decide (rho (Suc r) p)", "show False"], ["proof (prove)\nusing this:\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  decide (rho r p) = decide (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_majority_E:\n  assumes majv: \"card {qq::Proc. F qq = Some m} > E\"\n  and majw: \"card {qq::Proc. F qq = Some m'} > E\"\n  shows \"m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m = m'", "from majv majw majE"], ["proof (chain)\npicking this:\n  E < card {qq. F qq = Some m}\n  E < card {qq. F qq = Some m'}\n  N + nSteps * \\<alpha> \\<le> nSteps * E", "have \"card {qq::Proc. F qq = Some m} > N div 2\"\n    and \"card {qq::Proc. F qq = Some m'} > N div 2\""], ["proof (prove)\nusing this:\n  E < card {qq. F qq = Some m}\n  E < card {qq. F qq = Some m'}\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n\ngoal (1 subgoal):\n 1. N div nSteps < card {qq. F qq = Some m} &&&\n    N div nSteps < card {qq. F qq = Some m'}", "by auto"], ["proof (state)\nthis:\n  N div nSteps < card {qq. F qq = Some m}\n  N div nSteps < card {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. m = m'", "then"], ["proof (chain)\npicking this:\n  N div nSteps < card {qq. F qq = Some m}\n  N div nSteps < card {qq. F qq = Some m'}", "obtain qq\n    where \"qq \\<in> {qq::Proc. F qq = Some m}\"\n      and \"qq \\<in> {qq::Proc. F qq = Some m'}\""], ["proof (prove)\nusing this:\n  N div nSteps < card {qq. F qq = Some m}\n  N div nSteps < card {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<lbrakk>qq \\<in> {qq. F qq = Some m};\n         qq \\<in> {qq. F qq = Some m'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule majoritiesE')"], ["proof (state)\nthis:\n  qq \\<in> {qq. F qq = Some m}\n  qq \\<in> {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. m = m'", "thus ?thesis"], ["proof (prove)\nusing this:\n  qq \\<in> {qq. F qq = Some m}\n  qq \\<in> {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. m = m'", "by auto"], ["proof (state)\nthis:\n  m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_majority_E_\\<alpha>:\n  assumes majv: \"card {qq::Proc. F qq = m} > E - \\<alpha>\"\n  and majw: \"card {qq::Proc. F qq = m'} > E - \\<alpha>\"\n  shows \"m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m = m'", "from majE alpha_lt_N majv majw"], ["proof (chain)\npicking this:\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n  \\<alpha> < N\n  E - \\<alpha> < card {qq. F qq = m}\n  E - \\<alpha> < card {qq. F qq = m'}", "have \"card {qq::Proc. F qq = m} > N div 2\"\n    and \"card {qq::Proc. F qq = m'} > N div 2\""], ["proof (prove)\nusing this:\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n  \\<alpha> < N\n  E - \\<alpha> < card {qq. F qq = m}\n  E - \\<alpha> < card {qq. F qq = m'}\n\ngoal (1 subgoal):\n 1. N div nSteps < card {qq. F qq = m} &&&\n    N div nSteps < card {qq. F qq = m'}", "by auto"], ["proof (state)\nthis:\n  N div nSteps < card {qq. F qq = m}\n  N div nSteps < card {qq. F qq = m'}\n\ngoal (1 subgoal):\n 1. m = m'", "then"], ["proof (chain)\npicking this:\n  N div nSteps < card {qq. F qq = m}\n  N div nSteps < card {qq. F qq = m'}", "obtain qq\n    where \"qq \\<in> {qq::Proc. F qq = m}\"\n      and \"qq \\<in> {qq::Proc. F qq = m'}\""], ["proof (prove)\nusing this:\n  N div nSteps < card {qq. F qq = m}\n  N div nSteps < card {qq. F qq = m'}\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<lbrakk>qq \\<in> {qq. F qq = m}; qq \\<in> {qq. F qq = m'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule majoritiesE')"], ["proof (state)\nthis:\n  qq \\<in> {qq. F qq = m}\n  qq \\<in> {qq. F qq = m'}\n\ngoal (1 subgoal):\n 1. m = m'", "thus ?thesis"], ["proof (prove)\nusing this:\n  qq \\<in> {qq. F qq = m}\n  qq \\<in> {qq. F qq = m'}\n\ngoal (1 subgoal):\n 1. m = m'", "by auto"], ["proof (state)\nthis:\n  m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_majority_T:\n  assumes majv: \"card {qq::Proc. F qq = Some m} > T\"\n  and majw: \"card {qq::Proc. F qq = Some m'} > T\"\n  shows \"m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m = m'", "from majT majv majw"], ["proof (chain)\npicking this:\n  N + nSteps * \\<alpha> \\<le> nSteps * T\n  T < card {qq. F qq = Some m}\n  T < card {qq. F qq = Some m'}", "have \"card {qq::Proc. F qq = Some m} > N div 2\"\n    and \"card {qq::Proc. F qq = Some m'} > N div 2\""], ["proof (prove)\nusing this:\n  N + nSteps * \\<alpha> \\<le> nSteps * T\n  T < card {qq. F qq = Some m}\n  T < card {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. N div nSteps < card {qq. F qq = Some m} &&&\n    N div nSteps < card {qq. F qq = Some m'}", "by auto"], ["proof (state)\nthis:\n  N div nSteps < card {qq. F qq = Some m}\n  N div nSteps < card {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. m = m'", "then"], ["proof (chain)\npicking this:\n  N div nSteps < card {qq. F qq = Some m}\n  N div nSteps < card {qq. F qq = Some m'}", "obtain qq\n    where \"qq \\<in> {qq::Proc. F qq = Some m}\"\n      and \"qq \\<in> {qq::Proc. F qq = Some m'}\""], ["proof (prove)\nusing this:\n  N div nSteps < card {qq. F qq = Some m}\n  N div nSteps < card {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<lbrakk>qq \\<in> {qq. F qq = Some m};\n         qq \\<in> {qq. F qq = Some m'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule majoritiesE')"], ["proof (state)\nthis:\n  qq \\<in> {qq. F qq = Some m}\n  qq \\<in> {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. m = m'", "thus ?thesis"], ["proof (prove)\nusing this:\n  qq \\<in> {qq. F qq = Some m}\n  qq \\<in> {qq. F qq = Some m'}\n\ngoal (1 subgoal):\n 1. m = m'", "by auto"], ["proof (state)\nthis:\n  m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>No two processes may vote for different values in the same round.\\<close>"], ["", "lemma common_vote:\n  assumes usafe: \"SHOcommPerRd Ute_M HO SHO\"\n  and nxtp: \"nextState Ute_M r p (rho r p)  \\<mu>p (rho (Suc r) p)\"\n  and mup: \"\\<mu>p \\<in> SHOmsgVectors Ute_M r p (rho r) (HO p) (SHO p)\"\n  and nxtq: \"nextState Ute_M r q (rho r q)  \\<mu>q (rho (Suc r) q)\"\n  and muq: \"\\<mu>q \\<in> SHOmsgVectors Ute_M r q (rho r) (HO q) (SHO q)\"\n  and vp: \"vote (rho (Suc r) p) = Some vp\"\n  and vq: \"vote (rho (Suc r) q) = Some vq\"\n  shows \"vp = vq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vp = vq", "using assms"], ["proof (prove)\nusing this:\n  SHOcommPerRd Ute_M HO SHO\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  \\<mu>p \\<in> SHOmsgVectors Ute_M r p (rho r) (HO p) (SHO p)\n  nextState Ute_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  \\<mu>q \\<in> SHOmsgVectors Ute_M r q (rho r) (HO q) (SHO q)\n  vote (rho (Suc r) p) = Some vp\n  vote (rho (Suc r) q) = Some vq\n\ngoal (1 subgoal):\n 1. vp = vq", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>SHOcommPerRd Ute_M HO SHO;\n     nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p);\n     \\<mu>p \\<in> SHOmsgVectors Ute_M r p (rho r) (HO p) (SHO p);\n     nextState Ute_M r q (rho r q) \\<mu>q (rho (Suc r) q);\n     \\<mu>q \\<in> SHOmsgVectors Ute_M r q (rho r) (HO q) (SHO q);\n     vote (rho (Suc r) p) = Some vp; vote (rho (Suc r) q) = Some vq\\<rbrakk>\n    \\<Longrightarrow> vp = vq", "have gtn: \"card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n           + card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} > N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n        card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n        card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "have \"card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} > T - \\<alpha>\n        \\<and> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} > T - \\<alpha>\"\n      (is \"card ?vsentp > _ \\<and> card ?vsentq > _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "from nxtp vp"], ["proof (chain)\npicking this:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  vote (rho (Suc r) p) = Some vp", "have stp:\"step r = 0\""], ["proof (prove)\nusing this:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  vote (rho (Suc r) p) = Some vp\n\ngoal (1 subgoal):\n 1. step r = 0", "by (auto simp: vote_step)"], ["proof (state)\nthis:\n  step r = 0\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "from mup"], ["proof (chain)\npicking this:\n  \\<mu>p \\<in> SHOmsgVectors Ute_M r p (rho r) (HO p) (SHO p)", "have \"{qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p) \n             \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\"\n             (is \"?vrcvdp - ?ahop \\<subseteq> ?vsentp\")"], ["proof (prove)\nusing this:\n  \\<mu>p \\<in> SHOmsgVectors Ute_M r p (rho r) (HO p) (SHO p)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p)\n    \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  {qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p)\n  \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "hence \"card (?vrcvdp - ?ahop) \\<le> card ?vsentp\"\n        and \"card (?vrcvdp - ?ahop) \\<ge> card ?vrcvdp - card ?ahop\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p)\n  \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p))\n    \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} &&&\n    card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n    \\<le> card ({qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p))", "by (auto simp: card_mono diff_card_le_card_Diff)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p))\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n  card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n  \\<le> card ({qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p))\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "hence \"card ?vsentp \\<ge> card ?vrcvdp - card ?ahop\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p))\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n  card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n  \\<le> card ({qq. \\<mu>p qq = Some (Val vp)} - (HO p - SHO p))\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n    \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}", "by auto"], ["proof (state)\nthis:\n  card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "moreover"], ["proof (state)\nthis:\n  card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "from nxtp stp"], ["proof (chain)\npicking this:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  step r = 0", "have \"next0 r p (rho r p) \\<mu>p (rho (Suc r) p)\""], ["proof (prove)\nusing this:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  step r = 0\n\ngoal (1 subgoal):\n 1. next0 r p (rho r p) \\<mu>p (rho (Suc r) p)", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def)"], ["proof (state)\nthis:\n  next0 r p (rho r p) \\<mu>p (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "with vp"], ["proof (chain)\npicking this:\n  vote (rho (Suc r) p) = Some vp\n  next0 r p (rho r p) \\<mu>p (rho (Suc r) p)", "have \"card ?vrcvdp > T\""], ["proof (prove)\nusing this:\n  vote (rho (Suc r) p) = Some vp\n  next0 r p (rho r p) \\<mu>p (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. T < card {qq. \\<mu>p qq = Some (Val vp)}", "unfolding next0_def"], ["proof (prove)\nusing this:\n  vote (rho (Suc r) p) = Some vp\n  (\\<exists>v.\n      T < card {q. \\<mu>p q = Some (Val v)} \\<and>\n      rho (Suc r) p = rho r p\\<lparr>vote := Some v\\<rparr>) \\<or>\n  (\\<nexists>v. T < card {q. \\<mu>p q = Some (Val v)}) \\<and>\n  rho (Suc r) p = vote_update Map.empty (rho r p)\n\ngoal (1 subgoal):\n 1. T < card {qq. \\<mu>p qq = Some (Val vp)}", "by auto"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>p qq = Some (Val vp)}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "moreover"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>p qq = Some (Val vp)}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "from muq"], ["proof (chain)\npicking this:\n  \\<mu>q \\<in> SHOmsgVectors Ute_M r q (rho r) (HO q) (SHO q)", "have \"{qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q)\n             \\<subseteq> {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\"\n             (is \"?vrcvdq - ?ahoq \\<subseteq> ?vsentq\")"], ["proof (prove)\nusing this:\n  \\<mu>q \\<in> SHOmsgVectors Ute_M r q (rho r) (HO q) (SHO q)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q)\n    \\<subseteq> {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q)\n  \\<subseteq> {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "hence \"card (?vrcvdq - ?ahoq) \\<le> card ?vsentq\"\n        and \"card (?vrcvdq - ?ahoq) \\<ge> card ?vrcvdq - card ?ahoq\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q)\n  \\<subseteq> {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q))\n    \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} &&&\n    card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n    \\<le> card ({qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q))", "by (auto simp: card_mono diff_card_le_card_Diff)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q))\n  \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n  \\<le> card ({qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q))\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "hence \"card ?vsentq \\<ge> card ?vrcvdq - card ?ahoq\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q))\n  \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n  \\<le> card ({qq. \\<mu>q qq = Some (Val vq)} - (HO q - SHO q))\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n    \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "by auto"], ["proof (state)\nthis:\n  card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n  \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "moreover"], ["proof (state)\nthis:\n  card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n  \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "from nxtq stp"], ["proof (chain)\npicking this:\n  nextState Ute_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  step r = 0", "have \"next0 r q (rho r q) \\<mu>q (rho (Suc r) q)\""], ["proof (prove)\nusing this:\n  nextState Ute_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  step r = 0\n\ngoal (1 subgoal):\n 1. next0 r q (rho r q) \\<mu>q (rho (Suc r) q)", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def)"], ["proof (state)\nthis:\n  next0 r q (rho r q) \\<mu>q (rho (Suc r) q)\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "with vq"], ["proof (chain)\npicking this:\n  vote (rho (Suc r) q) = Some vq\n  next0 r q (rho r q) \\<mu>q (rho (Suc r) q)", "have \"card {qq. \\<mu>q qq = Some (Val vq)} > T\""], ["proof (prove)\nusing this:\n  vote (rho (Suc r) q) = Some vq\n  next0 r q (rho r q) \\<mu>q (rho (Suc r) q)\n\ngoal (1 subgoal):\n 1. T < card {qq. \\<mu>q qq = Some (Val vq)}", "by (unfold next0_def, auto)"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>q qq = Some (Val vq)}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "moreover"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>q qq = Some (Val vq)}\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "from usafe"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ute_M HO SHO", "have \"card ?ahop \\<le> \\<alpha>\" and \"card ?ahoq \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ute_M HO SHO\n\ngoal (1 subgoal):\n 1. card (HO p - SHO p) \\<le> \\<alpha> &&&\n    card (HO q - SHO q) \\<le> \\<alpha>", "by (auto simp: Ute_SHOMachine_def Ute_commPerRd_def)"], ["proof (state)\nthis:\n  card (HO p - SHO p) \\<le> \\<alpha>\n  card (HO q - SHO q) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "ultimately"], ["proof (chain)\npicking this:\n  card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n  T < card {qq. \\<mu>p qq = Some (Val vp)}\n  card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n  \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  T < card {qq. \\<mu>q qq = Some (Val vq)}\n  card (HO p - SHO p) \\<le> \\<alpha>\n  card (HO q - SHO q) \\<le> \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n  T < card {qq. \\<mu>p qq = Some (Val vp)}\n  card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n  \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  T < card {qq. \\<mu>q qq = Some (Val vq)}\n  card (HO p - SHO p) \\<le> \\<alpha>\n  card (HO q - SHO q) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "using alpha_lt_T"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>p qq = Some (Val vp)} - card (HO p - SHO p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp}\n  T < card {qq. \\<mu>p qq = Some (Val vp)}\n  card {qq. \\<mu>q qq = Some (Val vq)} - card (HO q - SHO q)\n  \\<le> card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  T < card {qq. \\<mu>q qq = Some (Val vq)}\n  card (HO p - SHO p) \\<le> \\<alpha>\n  card (HO q - SHO q) \\<le> \\<alpha>\n  \\<alpha> < T\n\ngoal (1 subgoal):\n 1. T - \\<alpha>\n    < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n    T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "by auto"], ["proof (state)\nthis:\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n        card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "thus ?thesis"], ["proof (prove)\nusing this:\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n        card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "using majT"], ["proof (prove)\nusing this:\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<and>\n  T - \\<alpha> < card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  N + nSteps * \\<alpha> \\<le> nSteps * T\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n        card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}", "by auto"], ["proof (state)\nthis:\n  N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n      card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n      card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>SHOcommPerRd Ute_M HO SHO;\n     nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p);\n     \\<mu>p \\<in> SHOmsgVectors Ute_M r p (rho r) (HO p) (SHO p);\n     nextState Ute_M r q (rho r q) \\<mu>q (rho (Suc r) q);\n     \\<mu>q \\<in> SHOmsgVectors Ute_M r q (rho r) (HO q) (SHO q);\n     vote (rho (Suc r) p) = Some vp; vote (rho (Suc r) q) = Some vq\\<rbrakk>\n    \\<Longrightarrow> vp = vq", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vp = vq", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. vp \\<noteq> vq \\<Longrightarrow> False", "assume vpq:\"vp \\<noteq> vq\""], ["proof (state)\nthis:\n  vp \\<noteq> vq\n\ngoal (1 subgoal):\n 1. vp \\<noteq> vq \\<Longrightarrow> False", "have \"\\<forall>qq. sendMsg Ute_M r qq p (rho r qq)\n               = sendMsg Ute_M r qq q (rho r qq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qq.\n       sendMsg Ute_M r qq p (rho r qq) = sendMsg Ute_M r qq q (rho r qq)", "by (auto simp: Ute_SHOMachine_def Ute_sendMsg_def \n                     step_def send0_def send1_def)"], ["proof (state)\nthis:\n  \\<forall>qq.\n     sendMsg Ute_M r qq p (rho r qq) = sendMsg Ute_M r qq q (rho r qq)\n\ngoal (1 subgoal):\n 1. vp \\<noteq> vq \\<Longrightarrow> False", "with vpq"], ["proof (chain)\npicking this:\n  vp \\<noteq> vq\n  \\<forall>qq.\n     sendMsg Ute_M r qq p (rho r qq) = sendMsg Ute_M r qq q (rho r qq)", "have \"{qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \n           \\<inter> {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} = {}\""], ["proof (prove)\nusing this:\n  vp \\<noteq> vq\n  \\<forall>qq.\n     sendMsg Ute_M r qq p (rho r qq) = sendMsg Ute_M r qq q (rho r qq)\n\ngoal (1 subgoal):\n 1. {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<inter>\n    {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<inter>\n  {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} =\n  {}\n\ngoal (1 subgoal):\n 1. vp \\<noteq> vq \\<Longrightarrow> False", "with gtn"], ["proof (chain)\npicking this:\n  N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n      card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<inter>\n  {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} =\n  {}", "have \"card ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \n                  \\<union> {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}) > N\""], ["proof (prove)\nusing this:\n  N < card {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} +\n      card {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}\n  {qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<inter>\n  {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq} =\n  {}\n\ngoal (1 subgoal):\n 1. N < card\n         ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n          {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})", "by (auto simp: card_Un_Int)"], ["proof (state)\nthis:\n  N < card\n       ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n        {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n\ngoal (1 subgoal):\n 1. vp \\<noteq> vq \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  N < card\n       ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n        {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n\ngoal (1 subgoal):\n 1. vp \\<noteq> vq \\<Longrightarrow> False", "have \"card ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \n                  \\<union> {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq}) \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n      {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n    \\<le> N", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card\n   ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n    {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n  \\<le> N\n\ngoal (1 subgoal):\n 1. vp \\<noteq> vq \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  N < card\n       ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n        {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n  card\n   ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n    {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n  \\<le> N", "show \"False\""], ["proof (prove)\nusing this:\n  N < card\n       ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n        {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n  card\n   ({qq. sendMsg Ute_M r qq p (rho r qq) = Val vp} \\<union>\n    {qq. sendMsg Ute_M r qq q (rho r qq) = Val vq})\n  \\<le> N\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vp = vq\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  No decision may be taken by a process unless it received enough messages\n  holding the same value.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemma @{text decide_step}\n  and the @{text Ute_commPerRound} predicate. \n*)"], ["", "lemma decide_with_threshold_E:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and usafe: \"SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and d1: \"decide (rho r p) \\<noteq> Some v\"\n  and d2: \"decide (rho (Suc r) p) = Some v\"\n  shows \"card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}\n           > E - \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>p\n    where nxt:\"nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\"\n      and \"\\<forall>qq. qq \\<in> HOs r p \\<longleftrightarrow> \\<mu>p qq \\<noteq> None\"\n      and \"\\<forall>qq. qq \\<in> SHOs r p \\<inter> HOs r p \n                \\<longrightarrow> \\<mu>p qq = Some (sendMsg Ute_M r qq p (rho r qq))\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p);\n         \\<forall>qq. (qq \\<in> HOs r p) = (\\<mu>p qq \\<noteq> None);\n         \\<forall>qq.\n            qq \\<in> SHOs r p \\<inter> HOs r p \\<longrightarrow>\n            \\<mu>p qq = Some (sendMsg Ute_M r qq p (rho r qq))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  HOinitConfig\n   \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n      sendMsg = Ute_sendMsg,\n      CnextState = \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n      SHOcommPerRd = Ute_commPerRd, SHOcommGlobal = Ute_commGlobal\\<rparr>\n   (rho 0) \\<and>\n  (\\<forall>r p.\n      \\<exists>\\<mu>\n               \\<in>{\\<mu>.\n                     (\\<forall>q.\n                         (q \\<in> HOs r p) = (\\<mu> q \\<noteq> None)) \\<and>\n                     (\\<forall>q.\n                         q \\<in> SHOs r p \\<inter> HOs r p \\<longrightarrow>\n                         \\<mu> q =\n                         Some\n                          (sendMsg\n                            \\<lparr>CinitState =\n\\<lambda>p st crd. Ute_initState p st,\n                               sendMsg = Ute_sendMsg,\n                               CnextState =\n                                 \\<lambda>r p st msgs crd.\n                                    Ute_nextState r p st msgs,\n                               SHOcommPerRd = Ute_commPerRd,\n                               SHOcommGlobal = Ute_commGlobal\\<rparr>\n                            r q p (rho r q)))}.\n         nextState\n          \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n             sendMsg = Ute_sendMsg,\n             CnextState =\n               \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n             SHOcommPerRd = Ute_commPerRd,\n             SHOcommGlobal = Ute_commGlobal\\<rparr>\n          r p (rho r p) \\<mu> (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState\n                  \\<lparr>CinitState =\n                            \\<lambda>p st crd. Ute_initState p st,\n                     sendMsg = Ute_sendMsg,\n                     CnextState =\n                       \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                     SHOcommPerRd = Ute_commPerRd,\n                     SHOcommGlobal = Ute_commGlobal\\<rparr>\n                  r p (rho r p) \\<mu>p (rho (Suc r) p);\n         \\<forall>qq. (qq \\<in> HOs r p) = (\\<mu>p qq \\<noteq> None);\n         \\<forall>qq.\n            qq \\<in> SHOs r p \\<inter> HOs r p \\<longrightarrow>\n            \\<mu>p qq =\n            Some\n             (sendMsg\n               \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n                  sendMsg = Ute_sendMsg,\n                  CnextState =\n                    \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                  SHOcommPerRd = Ute_commPerRd,\n                  SHOcommGlobal = Ute_commGlobal\\<rparr>\n               r qq p (rho r qq))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  \\<forall>qq. (qq \\<in> HOs r p) = (\\<mu>p qq \\<noteq> None)\n  \\<forall>qq.\n     qq \\<in> SHOs r p \\<inter> HOs r p \\<longrightarrow>\n     \\<mu>p qq = Some (sendMsg Ute_M r qq p (rho r qq))\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "hence \"{qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p)\n          \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\"\n         (is \"?vrcvdp - ?ahop \\<subseteq> ?vsentp\")"], ["proof (prove)\nusing this:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  \\<forall>qq. (qq \\<in> HOs r p) = (\\<mu>p qq \\<noteq> None)\n  \\<forall>qq.\n     qq \\<in> SHOs r p \\<inter> HOs r p \\<longrightarrow>\n     \\<mu>p qq = Some (sendMsg Ute_M r qq p (rho r qq))\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p)\n    \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p)\n  \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "hence \"card (?vrcvdp - ?ahop) \\<le> card ?vsentp\"\n    and \"card (?vrcvdp - ?ahop) \\<ge> card ?vrcvdp - card ?ahop\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p)\n  \\<subseteq> {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p))\n    \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)} &&&\n    card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n    \\<le> card\n           ({qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p))", "by (auto simp: card_mono diff_card_le_card_Diff)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p))\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n  card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n  \\<le> card ({qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p))\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "hence \"card ?vsentp \\<ge> card ?vrcvdp - card ?ahop\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p))\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n  card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n  \\<le> card ({qq. \\<mu>p qq = Some (Vote (Some v))} - (HOs r p - SHOs r p))\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n    \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}", "by auto"], ["proof (state)\nthis:\n  card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "moreover"], ["proof (state)\nthis:\n  card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "from usafe"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ute_M (HOs r) (SHOs r)", "have \"card (HOs r p - SHOs r p) \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. card (HOs r p - SHOs r p) \\<le> \\<alpha>", "by (auto simp: Ute_SHOMachine_def Ute_commPerRd_def)"], ["proof (state)\nthis:\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "moreover"], ["proof (state)\nthis:\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "from run d1 d2"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v", "have \"step r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n\ngoal (1 subgoal):\n 1. step r \\<noteq> 0", "by (rule decide_step)"], ["proof (state)\nthis:\n  step r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "with nxt"], ["proof (chain)\npicking this:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  step r \\<noteq> 0", "have \"next1 r p (rho r p) \\<mu>p (rho (Suc r) p)\""], ["proof (prove)\nusing this:\n  nextState Ute_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  step r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. next1 r p (rho r p) \\<mu>p (rho (Suc r) p)", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def)"], ["proof (state)\nthis:\n  next1 r p (rho r p) \\<mu>p (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "with run d1 d2"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  next1 r p (rho r p) \\<mu>p (rho (Suc r) p)", "have \"card {qq. \\<mu>p qq = Some (Vote (Some v))} > E\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  next1 r p (rho r p) \\<mu>p (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. E < card {qq. \\<mu>p qq = Some (Vote (Some v))}", "unfolding next1_def"], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  ((\\<exists>v.\n       \\<alpha> < card {q. \\<mu>p q = Some (Vote (Some v))} \\<and>\n       x (rho (Suc r) p) = v) \\<or>\n   (\\<nexists>v.\n       \\<alpha> < card {q. \\<mu>p q = Some (Vote (Some v))}) \\<and>\n   x (rho (Suc r) p) = undefined) \\<and>\n  ((\\<exists>v.\n       E < card {q. \\<mu>p q = Some (Vote (Some v))} \\<and>\n       decide (rho (Suc r) p) = Some v) \\<or>\n   (\\<nexists>v. E < card {q. \\<mu>p q = Some (Vote (Some v))}) \\<and>\n   decide (rho (Suc r) p) = decide (rho r p)) \\<and>\n  vote (rho (Suc r) p) = None\n\ngoal (1 subgoal):\n 1. E < card {qq. \\<mu>p qq = Some (Vote (Some v))}", "by auto"], ["proof (state)\nthis:\n  E < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "ultimately"], ["proof (chain)\npicking this:\n  card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n  E < card {qq. \\<mu>p qq = Some (Vote (Some v))}", "show ?thesis"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n  E < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "using alpha_lt_E"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>p qq = Some (Vote (Some v))} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ute_M r qq p (rho r qq) = Vote (Some v)}\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n  E < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n  \\<alpha> < E\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}", "by auto"], ["proof (state)\nthis:\n  E - \\<alpha> < card {q. sendMsg Ute_M r q p (rho r q) = Vote (Some v)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Agreement and Validity\\<close>"], ["", "text \\<open>\n  If more than \\<open>E - \\<alpha>\\<close> messages holding \\<open>v\\<close> are sent to\n  some process \\<open>p\\<close> at round \\<open>r\\<close>, then every process \\<open>pp\\<close>\n  correctly receives more than \\<open>\\<alpha>\\<close> such messages.\n\\<close>"], ["", "(*\n  The proof mainly relies on the @{text Ute_commPerRound} predicate. \n*)"], ["", "lemma common_x_argument_1:\n  assumes usafe:\"SHOcommPerRd Ute_M (HOs (Suc r)) (SHOs (Suc r))\"\n  and threshold: \"card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) \n                            = Vote (Some v)} > E - \\<alpha>\"\n                 (is \"card (?msgs p v) > _\")\n  shows \"card (?msgs pp v \\<inter> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)) > \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "have \"card (?msgs pp v) + card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) > N + \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N + \\<alpha>\n    < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n      card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N + \\<alpha>\n    < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n      card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "have \"\\<forall>q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) \n                = sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       sendMsg Ute_M (Suc r) q p (rho (Suc r) q) =\n       sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)", "by (auto simp: Ute_SHOMachine_def Ute_sendMsg_def \n                     step_def send0_def send1_def)"], ["proof (state)\nthis:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) =\n     sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)\n\ngoal (1 subgoal):\n 1. N + \\<alpha>\n    < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n      card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "moreover"], ["proof (state)\nthis:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) =\n     sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)\n\ngoal (1 subgoal):\n 1. N + \\<alpha>\n    < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n      card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "from usafe"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ute_M (HOs (Suc r)) (SHOs (Suc r))", "have \"card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) > N + 2*\\<alpha> - E - 1\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ute_M (HOs (Suc r)) (SHOs (Suc r))\n\ngoal (1 subgoal):\n 1. N + nSteps * \\<alpha> - E - 1\n    < card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "by (auto simp: Ute_SHOMachine_def step_def Ute_commPerRd_def)"], ["proof (state)\nthis:\n  N + nSteps * \\<alpha> - E - 1\n  < card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. N + \\<alpha>\n    < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n      card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) =\n     sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)\n  N + nSteps * \\<alpha> - E - 1\n  < card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) =\n     sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)\n  N + nSteps * \\<alpha> - E - 1\n  < card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. N + \\<alpha>\n    < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n      card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "using threshold"], ["proof (prove)\nusing this:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) =\n     sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)\n  N + nSteps * \\<alpha> - E - 1\n  < card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  E - \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. N + \\<alpha>\n    < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n      card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)", "by auto"], ["proof (state)\nthis:\n  N + \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n    card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N + \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n    card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "moreover"], ["proof (state)\nthis:\n  N + \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n    card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "have \"card (?msgs pp v) + card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n        = card (?msgs pp v \\<union> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n          + card (?msgs pp v \\<inter> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n    card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) =\n    card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<union>\n      SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) +\n    card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<inter>\n      (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "by (auto intro: card_Un_Int)"], ["proof (state)\nthis:\n  card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n  card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) =\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<union>\n    SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) +\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "moreover"], ["proof (state)\nthis:\n  card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n  card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) =\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<union>\n    SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) +\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "have \"card (?msgs pp v \\<union> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)) \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<union>\n      SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n    \\<le> N", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<union>\n    SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  \\<le> N\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "ultimately"], ["proof (chain)\npicking this:\n  N + \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n    card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n  card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) =\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<union>\n    SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) +\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<union>\n    SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  \\<le> N", "show ?thesis"], ["proof (prove)\nusing this:\n  N + \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n    card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  card {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} +\n  card (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) =\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<union>\n    SHOs (Suc r) pp \\<inter> HOs (Suc r) pp) +\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<union>\n    SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  \\<le> N\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "by auto"], ["proof (state)\nthis:\n  \\<alpha>\n  < card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<inter>\n      (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If more than \\<open>E - \\<alpha>\\<close> messages holding \\<open>v\\<close> are sent to \\<open>p\\<close>\n  at some round \\<open>r\\<close>, then any process \\<open>pp\\<close> will set its \\<open>x\\<close> to\n  value \\<open>v\\<close> in \\<open>r\\<close>.\n\\<close>"], ["", "(*\n  The proof relies on previous lemmas @{text common_x_argument_1}\n  and @{text common_vote} and the @{text Ute_commPerRound} predicate. \n*)"], ["", "lemma common_x_argument_2:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and usafe: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and nxtpp: \"nextState Ute_M (Suc r) pp (rho (Suc r) pp) \n                        \\<mu>pp (rho (Suc (Suc r)) pp)\"\n  and mupp: \"\\<mu>pp \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) \n                                 (HOs (Suc r) pp) (SHOs (Suc r) pp)\"\n  and threshold: \"card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) \n                             = Vote (Some v)} > E - \\<alpha>\"\n                 (is \"card (?sent p v) > _\")\n  shows \"x (rho (Suc (Suc r)) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "have stp:\"step (Suc r) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (Suc r) \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. step (Suc r) = 0 \\<Longrightarrow> False", "assume sr: \"step (Suc r) = 0\""], ["proof (state)\nthis:\n  step (Suc r) = 0\n\ngoal (1 subgoal):\n 1. step (Suc r) = 0 \\<Longrightarrow> False", "hence \"\\<forall>q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) \n                 = Val (x (rho (Suc r) q))\""], ["proof (prove)\nusing this:\n  step (Suc r) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Val (x (rho (Suc r) q))", "by (auto simp: Ute_SHOMachine_def Ute_sendMsg_def send0_def)"], ["proof (state)\nthis:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Val (x (rho (Suc r) q))\n\ngoal (1 subgoal):\n 1. step (Suc r) = 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Val (x (rho (Suc r) q))\n\ngoal (1 subgoal):\n 1. step (Suc r) = 0 \\<Longrightarrow> False", "from threshold"], ["proof (chain)\npicking this:\n  E - \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Vote (Some v)}", "obtain qq where\n      \"sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq) = Vote (Some v)\""], ["proof (prove)\nusing this:\n  E - \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq) =\n        Vote (Some v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq) = Vote (Some v)\n\ngoal (1 subgoal):\n 1. step (Suc r) = 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Val (x (rho (Suc r) q))\n  sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq) = Vote (Some v)", "show False"], ["proof (prove)\nusing this:\n  \\<forall>q.\n     sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Val (x (rho (Suc r) q))\n  sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq) = Vote (Some v)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  step (Suc r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "have va: \"card {qq. \\<mu>pp qq = Some (Vote (Some v))} > \\<alpha>\"\n       (is \"card (?msgs v) > \\<alpha>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "from mupp"], ["proof (chain)\npicking this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)", "have \"SHOs (Suc r) pp \\<inter> HOs (Suc r) pp \n          \\<subseteq> {qq. \\<mu>pp qq = Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}\""], ["proof (prove)\nusing this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. SHOs (Suc r) pp \\<inter> HOs (Suc r) pp\n    \\<subseteq> {qq.\n                 \\<mu>pp qq =\n                 Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>pp\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) pp) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) pp \\<inter>\n                     HOs (Suc r) pp \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)))}\n\ngoal (1 subgoal):\n 1. SHOs (Suc r) pp \\<inter> HOs (Suc r) pp\n    \\<subseteq> {qq.\n                 \\<mu>pp qq =\n                 Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}", "by auto"], ["proof (state)\nthis:\n  SHOs (Suc r) pp \\<inter> HOs (Suc r) pp\n  \\<subseteq> {qq.\n               \\<mu>pp qq =\n               Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "moreover"], ["proof (state)\nthis:\n  SHOs (Suc r) pp \\<inter> HOs (Suc r) pp\n  \\<subseteq> {qq.\n               \\<mu>pp qq =\n               Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "hence \"(?msgs v) \\<supseteq> (?sent pp v) \\<inter> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\""], ["proof (prove)\nusing this:\n  SHOs (Suc r) pp \\<inter> HOs (Suc r) pp\n  \\<subseteq> {qq.\n               \\<mu>pp qq =\n               Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}\n\ngoal (1 subgoal):\n 1. {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n    \\<subseteq> {qq. \\<mu>pp qq = Some (Vote (Some v))}", "by auto"], ["proof (state)\nthis:\n  {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n  (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  \\<subseteq> {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "hence \"card (?msgs v) \n             \\<ge> card ((?sent pp v) \\<inter> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\""], ["proof (prove)\nusing this:\n  {q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n  (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)\n  \\<subseteq> {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<inter>\n      (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n    \\<le> card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n  \\<le> card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "moreover"], ["proof (state)\nthis:\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n  \\<le> card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "from usafe threshold"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Vote (Some v)}", "have alph:\"card ((?sent pp v) \\<inter> (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp)) > \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha>\n  < card {q. sendMsg Ute_M (Suc r) q p (rho (Suc r) q) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < card\n       ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n            Vote (Some v)} \\<inter>\n        (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "by (blast dest: common_x_argument_1)"], ["proof (state)\nthis:\n  \\<alpha>\n  < card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<inter>\n      (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "ultimately"], ["proof (chain)\npicking this:\n  SHOs (Suc r) pp \\<inter> HOs (Suc r) pp\n  \\<subseteq> {qq.\n               \\<mu>pp qq =\n               Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n  \\<le> card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<alpha>\n  < card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<inter>\n      (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))", "show ?thesis"], ["proof (prove)\nusing this:\n  SHOs (Suc r) pp \\<inter> HOs (Suc r) pp\n  \\<subseteq> {qq.\n               \\<mu>pp qq =\n               Some (sendMsg Ute_M (Suc r) qq pp (rho (Suc r) qq))}\n  card\n   ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) = Vote (Some v)} \\<inter>\n    (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n  \\<le> card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<alpha>\n  < card\n     ({q. sendMsg Ute_M (Suc r) q pp (rho (Suc r) q) =\n          Vote (Some v)} \\<inter>\n      (SHOs (Suc r) pp \\<inter> HOs (Suc r) pp))\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "by auto"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "moreover"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "from nxtpp stp"], ["proof (chain)\npicking this:\n  nextState Ute_M (Suc r) pp (rho (Suc r) pp) \\<mu>pp (rho (Suc (Suc r)) pp)\n  step (Suc r) \\<noteq> 0", "have \"next1 (Suc r) pp (rho (Suc r) pp)  \\<mu>pp (rho (Suc (Suc r)) pp)\""], ["proof (prove)\nusing this:\n  nextState Ute_M (Suc r) pp (rho (Suc r) pp) \\<mu>pp (rho (Suc (Suc r)) pp)\n  step (Suc r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. next1 (Suc r) pp (rho (Suc r) pp) \\<mu>pp (rho (Suc (Suc r)) pp)", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def)"], ["proof (state)\nthis:\n  next1 (Suc r) pp (rho (Suc r) pp) \\<mu>pp (rho (Suc (Suc r)) pp)\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  next1 (Suc r) pp (rho (Suc r) pp) \\<mu>pp (rho (Suc (Suc r)) pp)", "obtain w where wa:\"card (?msgs w) > \\<alpha>\" and xw:\"x (rho (Suc (Suc r)) pp) = w\""], ["proof (prove)\nusing this:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  next1 (Suc r) pp (rho (Suc r) pp) \\<mu>pp (rho (Suc (Suc r)) pp)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>\\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some w))};\n         x (rho (Suc (Suc r)) pp) = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding next1_def"], ["proof (prove)\nusing this:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  ((\\<exists>v.\n       \\<alpha> < card {q. \\<mu>pp q = Some (Vote (Some v))} \\<and>\n       x (rho (Suc (Suc r)) pp) = v) \\<or>\n   (\\<nexists>v.\n       \\<alpha> < card {q. \\<mu>pp q = Some (Vote (Some v))}) \\<and>\n   x (rho (Suc (Suc r)) pp) = undefined) \\<and>\n  ((\\<exists>v.\n       E < card {q. \\<mu>pp q = Some (Vote (Some v))} \\<and>\n       decide (rho (Suc (Suc r)) pp) = Some v) \\<or>\n   (\\<nexists>v. E < card {q. \\<mu>pp q = Some (Vote (Some v))}) \\<and>\n   decide (rho (Suc (Suc r)) pp) = decide (rho (Suc r) pp)) \\<and>\n  vote (rho (Suc (Suc r)) pp) = None\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>\\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some w))};\n         x (rho (Suc (Suc r)) pp) = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n  x (rho (Suc (Suc r)) pp) = w\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "have \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "note usafe"], ["proof (state)\nthis:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. v = w", "moreover"], ["proof (state)\nthis:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. v = w", "obtain qv where \"qv \\<in> SHOs (Suc r) pp\" and \"\\<mu>pp qv = Some (Vote (Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qv.\n        \\<lbrakk>qv \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qv = Some (Vote (Some v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qv.\n        \\<lbrakk>qv \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qv = Some (Vote (Some v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<not> (?msgs v \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {qq. \\<mu>pp qq = Some (Vote (Some v))}\n           \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "assume \"?msgs v \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\""], ["proof (state)\nthis:\n  {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "hence \"card (?msgs v) \\<le> card ((HOs (Suc r) pp) - (SHOs (Suc r) pp))\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "from usafe"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)", "have \"card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>", "by (auto simp: Ute_SHOMachine_def Ute_commPerRd_def)"], ["proof (state)\nthis:\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "note va"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some v))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}", "show False"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> {qq. \\<mu>pp qq = Some (Vote (Some v))}\n         \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. (\\<And>qv.\n        \\<lbrakk>qv \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qv = Some (Vote (Some v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<not> {qq. \\<mu>pp qq = Some (Vote (Some v))}\n         \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp", "obtain qv\n        where \"qv \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\"\n          and qsv:\"\\<mu>pp qv = Some (Vote (Some v))\""], ["proof (prove)\nusing this:\n  \\<not> {qq. \\<mu>pp qq = Some (Vote (Some v))}\n         \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. (\\<And>qv.\n        \\<lbrakk>qv \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp;\n         \\<mu>pp qv = Some (Vote (Some v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qv \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qv = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. (\\<And>qv.\n        \\<lbrakk>qv \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qv = Some (Vote (Some v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with mupp"], ["proof (chain)\npicking this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qv \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qv = Some (Vote (Some v))", "have \"qv \\<in> SHOs (Suc r) pp\""], ["proof (prove)\nusing this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qv \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qv = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. qv \\<in> SHOs (Suc r) pp", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>pp\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) pp) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) pp \\<inter>\n                     HOs (Suc r) pp \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)))}\n  qv \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qv = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. qv \\<in> SHOs (Suc r) pp", "by auto"], ["proof (state)\nthis:\n  qv \\<in> SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. (\\<And>qv.\n        \\<lbrakk>qv \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qv = Some (Vote (Some v))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with qsv that"], ["proof (chain)\npicking this:\n  \\<mu>pp qv = Some (Vote (Some v))\n  \\<lbrakk>?qv7 \\<in> SHOs (Suc r) pp;\n   \\<mu>pp ?qv7 = Some (Vote (Some v))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  qv \\<in> SHOs (Suc r) pp", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu>pp qv = Some (Vote (Some v))\n  \\<lbrakk>?qv7 \\<in> SHOs (Suc r) pp;\n   \\<mu>pp ?qv7 = Some (Vote (Some v))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  qv \\<in> SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qv \\<in> SHOs (Suc r) pp\n  \\<mu>pp qv = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. v = w", "with stp mupp"], ["proof (chain)\npicking this:\n  step (Suc r) \\<noteq> 0\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qv \\<in> SHOs (Suc r) pp\n  \\<mu>pp qv = Some (Vote (Some v))", "have \"vote (rho (Suc r) qv) = Some v\""], ["proof (prove)\nusing this:\n  step (Suc r) \\<noteq> 0\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qv \\<in> SHOs (Suc r) pp\n  \\<mu>pp qv = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) qv) = Some v", "by (auto simp: Ute_SHOMachine_def SHOmsgVectors_def \n                     Ute_sendMsg_def send1_def)"], ["proof (state)\nthis:\n  vote (rho (Suc r) qv) = Some v\n\ngoal (1 subgoal):\n 1. v = w", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc r) qv) = Some v\n\ngoal (1 subgoal):\n 1. v = w", "obtain qw where\n      \"qw \\<in> SHOs (Suc r) pp\" and \"\\<mu>pp qw = Some (Vote (Some w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qw.\n        \\<lbrakk>qw \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qw = Some (Vote (Some w))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qw.\n        \\<lbrakk>qw \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qw = Some (Vote (Some w))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<not> (?msgs w \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {qq. \\<mu>pp qq = Some (Vote (Some w))}\n           \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "assume \"?msgs w \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\""], ["proof (state)\nthis:\n  {qq. \\<mu>pp qq = Some (Vote (Some w))}\n  \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "hence \"card (?msgs w) \\<le> card ((HOs (Suc r) pp) - (SHOs (Suc r) pp))\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>pp qq = Some (Vote (Some w))}\n  \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "from usafe"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)", "have \"card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>", "by (auto simp: Ute_SHOMachine_def Ute_commPerRd_def)"], ["proof (state)\nthis:\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "note wa"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>pp qq = Some (Vote (Some w))}\n    \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some w))}", "show False"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n  \\<le> card (HOs (Suc r) pp - SHOs (Suc r) pp)\n  card (HOs (Suc r) pp - SHOs (Suc r) pp) \\<le> \\<alpha>\n  \\<alpha> < card {qq. \\<mu>pp qq = Some (Vote (Some w))}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> {qq. \\<mu>pp qq = Some (Vote (Some w))}\n         \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. (\\<And>qw.\n        \\<lbrakk>qw \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qw = Some (Vote (Some w))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<not> {qq. \\<mu>pp qq = Some (Vote (Some w))}\n         \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp", "obtain qw\n        where \"qw \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\"\n          and qsw: \"\\<mu>pp qw = Some (Vote (Some w))\""], ["proof (prove)\nusing this:\n  \\<not> {qq. \\<mu>pp qq = Some (Vote (Some w))}\n         \\<subseteq> HOs (Suc r) pp - SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. (\\<And>qw.\n        \\<lbrakk>qw \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp;\n         \\<mu>pp qw = Some (Vote (Some w))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qw \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qw = Some (Vote (Some w))\n\ngoal (1 subgoal):\n 1. (\\<And>qw.\n        \\<lbrakk>qw \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qw = Some (Vote (Some w))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with mupp"], ["proof (chain)\npicking this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qw \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qw = Some (Vote (Some w))", "have \"qw \\<in> SHOs (Suc r) pp\""], ["proof (prove)\nusing this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qw \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qw = Some (Vote (Some w))\n\ngoal (1 subgoal):\n 1. qw \\<in> SHOs (Suc r) pp", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>pp\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) pp) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) pp \\<inter>\n                     HOs (Suc r) pp \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q pp (rho (Suc r) q)))}\n  qw \\<notin> HOs (Suc r) pp - SHOs (Suc r) pp\n  \\<mu>pp qw = Some (Vote (Some w))\n\ngoal (1 subgoal):\n 1. qw \\<in> SHOs (Suc r) pp", "by auto"], ["proof (state)\nthis:\n  qw \\<in> SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. (\\<And>qw.\n        \\<lbrakk>qw \\<in> SHOs (Suc r) pp;\n         \\<mu>pp qw = Some (Vote (Some w))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with qsw that"], ["proof (chain)\npicking this:\n  \\<mu>pp qw = Some (Vote (Some w))\n  \\<lbrakk>?qw7 \\<in> SHOs (Suc r) pp;\n   \\<mu>pp ?qw7 = Some (Vote (Some w))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  qw \\<in> SHOs (Suc r) pp", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu>pp qw = Some (Vote (Some w))\n  \\<lbrakk>?qw7 \\<in> SHOs (Suc r) pp;\n   \\<mu>pp ?qw7 = Some (Vote (Some w))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  qw \\<in> SHOs (Suc r) pp\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qw \\<in> SHOs (Suc r) pp\n  \\<mu>pp qw = Some (Vote (Some w))\n\ngoal (1 subgoal):\n 1. v = w", "with stp mupp"], ["proof (chain)\npicking this:\n  step (Suc r) \\<noteq> 0\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qw \\<in> SHOs (Suc r) pp\n  \\<mu>pp qw = Some (Vote (Some w))", "have \"vote (rho (Suc r) qw) = Some w\""], ["proof (prove)\nusing this:\n  step (Suc r) \\<noteq> 0\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r) pp (rho (Suc r)) (HOs (Suc r) pp)\n         (SHOs (Suc r) pp)\n  qw \\<in> SHOs (Suc r) pp\n  \\<mu>pp qw = Some (Vote (Some w))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) qw) = Some w", "by (auto simp: Ute_SHOMachine_def SHOmsgVectors_def\n                     Ute_sendMsg_def send1_def)"], ["proof (state)\nthis:\n  vote (rho (Suc r) qw) = Some w\n\ngoal (1 subgoal):\n 1. v = w", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc r) qw) = Some w\n\ngoal (1 subgoal):\n 1. v = w", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>qv \\<mu>qw\n      where \"nextState Ute_M r qv ((rho r) qv)  \\<mu>qv (rho (Suc r) qv)\"\n        and \"\\<mu>qv \\<in> SHOmsgVectors Ute_M r qv (rho r) (HOs r qv) (SHOs r qv)\"\n        and \"nextState Ute_M r qw ((rho r) qw)  \\<mu>qw (rho (Suc r) qw)\"\n        and \"\\<mu>qw \\<in> SHOmsgVectors Ute_M r qw (rho r) (HOs r qw) (SHOs r qw)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>qv \\<mu>qw.\n        \\<lbrakk>nextState Ute_M r qv (rho r qv) \\<mu>qv (rho (Suc r) qv);\n         \\<mu>qv\n         \\<in> SHOmsgVectors Ute_M r qv (rho r) (HOs r qv) (SHOs r qv);\n         nextState Ute_M r qw (rho r qw) \\<mu>qw (rho (Suc r) qw);\n         \\<mu>qw\n         \\<in> SHOmsgVectors Ute_M r qw (rho r) (HOs r qw)\n                (SHOs r qw)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq) blast"], ["proof (state)\nthis:\n  nextState Ute_M r qv (rho r qv) \\<mu>qv (rho (Suc r) qv)\n  \\<mu>qv \\<in> SHOmsgVectors Ute_M r qv (rho r) (HOs r qv) (SHOs r qv)\n  nextState Ute_M r qw (rho r qw) \\<mu>qw (rho (Suc r) qw)\n  \\<mu>qw \\<in> SHOmsgVectors Ute_M r qw (rho r) (HOs r qw) (SHOs r qw)\n\ngoal (1 subgoal):\n 1. v = w", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  vote (rho (Suc r) qv) = Some v\n  vote (rho (Suc r) qw) = Some w\n  nextState Ute_M r qv (rho r qv) \\<mu>qv (rho (Suc r) qv)\n  \\<mu>qv \\<in> SHOmsgVectors Ute_M r qv (rho r) (HOs r qv) (SHOs r qv)\n  nextState Ute_M r qw (rho r qw) \\<mu>qw (rho (Suc r) qw)\n  \\<mu>qw \\<in> SHOmsgVectors Ute_M r qw (rho r) (HOs r qw) (SHOs r qw)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  vote (rho (Suc r) qv) = Some v\n  vote (rho (Suc r) qw) = Some w\n  nextState Ute_M r qv (rho r qv) \\<mu>qv (rho (Suc r) qv)\n  \\<mu>qv \\<in> SHOmsgVectors Ute_M r qv (rho r) (HOs r qv) (SHOs r qv)\n  nextState Ute_M r qw (rho r qw) \\<mu>qw (rho (Suc r) qw)\n  \\<mu>qw \\<in> SHOmsgVectors Ute_M r qw (rho r) (HOs r qw) (SHOs r qw)\n\ngoal (1 subgoal):\n 1. v = w", "using usafe"], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  vote (rho (Suc r) qv) = Some v\n  vote (rho (Suc r) qw) = Some w\n  nextState Ute_M r qv (rho r qv) \\<mu>qv (rho (Suc r) qv)\n  \\<mu>qv \\<in> SHOmsgVectors Ute_M r qv (rho r) (HOs r qv) (SHOs r qv)\n  nextState Ute_M r qw (rho r qw) \\<mu>qw (rho (Suc r) qw)\n  \\<mu>qw \\<in> SHOmsgVectors Ute_M r qw (rho r) (HOs r qw) (SHOs r qw)\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. v = w", "by (auto dest: common_vote)"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "with xw"], ["proof (chain)\npicking this:\n  x (rho (Suc (Suc r)) pp) = w\n  v = w", "show \"x (rho (Suc (Suc r)) pp) = v\""], ["proof (prove)\nusing this:\n  x (rho (Suc (Suc r)) pp) = w\n  v = w\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Inductive argument for the agreement and validity theorems.\n\\<close>"], ["", "(*\n  The proof relies on previous lemmas @{text common_x_argument_2}\n  and @{text unique_majority_T} and the @{text Ute_commPerRound} predicate.\n*)"], ["", "lemma safety_inductive_argument:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and ih: \"E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}\"\n  and stp1: \"step r' = Suc 0\"\n  shows \"E - \\<alpha> <\n         card {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q)\n                     = Vote (Some v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "from stp1"], ["proof (chain)\npicking this:\n  step r' = Suc 0", "have \"r' > 0\""], ["proof (prove)\nusing this:\n  step r' = Suc 0\n\ngoal (1 subgoal):\n 1. 0 < r'", "by (auto simp: step_def)"], ["proof (state)\nthis:\n  0 < r'\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "with stp1"], ["proof (chain)\npicking this:\n  step r' = Suc 0\n  0 < r'", "obtain r where rr':\"r' = Suc r\" and stpr:\"step (Suc r) = Suc 0\""], ["proof (prove)\nusing this:\n  step r' = Suc 0\n  0 < r'\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r' = Suc r; step (Suc r) = Suc 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: gr0_implies_Suc)"], ["proof (state)\nthis:\n  r' = Suc r\n  step (Suc r) = Suc 0\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "have \"\\<forall>pp. x (rho (Suc (Suc r)) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pp. x (rho (Suc (Suc r)) pp) = v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. x (rho (Suc (Suc r)) pp) = v", "fix pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. x (rho (Suc (Suc r)) pp) = v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>pp\n      where \"\\<mu>pp \\<in> SHOmsgVectors Ute_M r' pp (rho r') (HOs r' pp) (SHOs r' pp)\"\n        and \"nextState Ute_M r' pp (rho r' pp)  \\<mu>pp (rho (Suc r') pp)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp.\n        \\<lbrakk>\\<mu>pp\n                 \\<in> SHOmsgVectors Ute_M r' pp (rho r') (HOs r' pp)\n                        (SHOs r' pp);\n         nextState Ute_M r' pp (rho r' pp) \\<mu>pp\n          (rho (Suc r') pp)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M r' pp (rho r') (HOs r' pp) (SHOs r' pp)\n  nextState Ute_M r' pp (rho r' pp) \\<mu>pp (rho (Suc r') pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. x (rho (Suc (Suc r)) pp) = v", "with run comm ih rr'"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}\n  r' = Suc r\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M r' pp (rho r') (HOs r' pp) (SHOs r' pp)\n  nextState Ute_M r' pp (rho r' pp) \\<mu>pp (rho (Suc r') pp)", "show \"x (rho (Suc (Suc r)) pp) = v\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}\n  r' = Suc r\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M r' pp (rho r') (HOs r' pp) (SHOs r' pp)\n  nextState Ute_M r' pp (rho r' pp) \\<mu>pp (rho (Suc r') pp)\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) pp) = v", "by (auto dest: common_x_argument_2)"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp. x (rho (Suc (Suc r)) pp) = v\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "with run stpr"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  step (Suc r) = Suc 0\n  \\<forall>pp. x (rho (Suc (Suc r)) pp) = v", "have \"\\<forall>pp p. sendMsg Ute_M (Suc (Suc r)) pp p (rho (Suc (Suc r)) pp) = Val v\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  step (Suc r) = Suc 0\n  \\<forall>pp. x (rho (Suc (Suc r)) pp) = v\n\ngoal (1 subgoal):\n 1. \\<forall>pp p.\n       sendMsg Ute_M (Suc (Suc r)) pp p (rho (Suc (Suc r)) pp) = Val v", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq\n                   Ute_sendMsg_def send0_def mod_Suc step_def)"], ["proof (state)\nthis:\n  \\<forall>pp p.\n     sendMsg Ute_M (Suc (Suc r)) pp p (rho (Suc (Suc r)) pp) = Val v\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "with rr'"], ["proof (chain)\npicking this:\n  r' = Suc r\n  \\<forall>pp p.\n     sendMsg Ute_M (Suc (Suc r)) pp p (rho (Suc (Suc r)) pp) = Val v", "have \"\\<And>p \\<mu>p'. \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc r') p (rho (Suc r')) \n                                     (HOs (Suc r') p) (SHOs (Suc r') p)\n             \\<Longrightarrow> SHOs (Suc r') p \\<inter> HOs (Suc r') p\n                   \\<subseteq> {q. \\<mu>p' q = Some (Val v)}\""], ["proof (prove)\nusing this:\n  r' = Suc r\n  \\<forall>pp p.\n     sendMsg Ute_M (Suc (Suc r)) pp p (rho (Suc (Suc r)) pp) = Val v\n\ngoal (1 subgoal):\n 1. \\<And>p \\<mu>p'.\n       \\<mu>p'\n       \\<in> SHOmsgVectors Ute_M (Suc r') p (rho (Suc r')) (HOs (Suc r') p)\n              (SHOs (Suc r') p) \\<Longrightarrow>\n       SHOs (Suc r') p \\<inter> HOs (Suc r') p\n       \\<subseteq> {q. \\<mu>p' q = Some (Val v)}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7\n  \\<subseteq> {q. ?\\<mu>p'7 q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "hence \"\\<And>p \\<mu>p'. \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc r') p (rho (Suc r')) \n                                       (HOs (Suc r') p) (SHOs (Suc r') p)\n             \\<Longrightarrow> card (SHOs (Suc r') p \\<inter> HOs (Suc r') p)\n                   \\<le> card {q. \\<mu>p' q = Some (Val v)}\""], ["proof (prove)\nusing this:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7\n  \\<subseteq> {q. ?\\<mu>p'7 q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<And>p \\<mu>p'.\n       \\<mu>p'\n       \\<in> SHOmsgVectors Ute_M (Suc r') p (rho (Suc r')) (HOs (Suc r') p)\n              (SHOs (Suc r') p) \\<Longrightarrow>\n       card (SHOs (Suc r') p \\<inter> HOs (Suc r') p)\n       \\<le> card {q. \\<mu>p' q = Some (Val v)}", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  card (SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7)\n  \\<le> card {q. ?\\<mu>p'7 q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "moreover"], ["proof (state)\nthis:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  card (SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7)\n  \\<le> card {q. ?\\<mu>p'7 q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "from comm"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)", "have \"\\<And>p. T < card (SHOs (Suc r') p \\<inter> HOs (Suc r') p)\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. \\<And>p. T < card (SHOs (Suc r') p \\<inter> HOs (Suc r') p)", "by (auto simp: Ute_SHOMachine_def Ute_commPerRd_def)"], ["proof (state)\nthis:\n  T < card (SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7)\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "ultimately"], ["proof (chain)\npicking this:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  card (SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7)\n  \\<le> card {q. ?\\<mu>p'7 q = Some (Val v)}\n  T < card (SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7)", "have vT:\"\\<And>p \\<mu>p'. \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc r') p (rho (Suc r')) \n                                         (HOs (Suc r') p) (SHOs (Suc r') p)\n                \\<Longrightarrow> T < card {q. \\<mu>p' q = Some (Val v)}\""], ["proof (prove)\nusing this:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  card (SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7)\n  \\<le> card {q. ?\\<mu>p'7 q = Some (Val v)}\n  T < card (SHOs (Suc r') ?p7 \\<inter> HOs (Suc r') ?p7)\n\ngoal (1 subgoal):\n 1. \\<And>p \\<mu>p'.\n       \\<mu>p'\n       \\<in> SHOmsgVectors Ute_M (Suc r') p (rho (Suc r')) (HOs (Suc r') p)\n              (SHOs (Suc r') p) \\<Longrightarrow>\n       T < card {q. \\<mu>p' q = Some (Val v)}", "by (auto dest: less_le_trans)"], ["proof (state)\nthis:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  T < card {q. ?\\<mu>p'7 q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "have \"\\<forall>pp. vote ((rho (Suc (Suc r'))) pp) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pp. vote (rho (Suc (Suc r')) pp) = Some v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "fix pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>pp\n        where nxtpp: \"nextState Ute_M (Suc r') pp (rho (Suc r') pp) \\<mu>pp \n                                      (rho (Suc (Suc r')) pp)\"\n          and mupp: \"\\<mu>pp \\<in> SHOmsgVectors Ute_M (Suc r') pp (rho (Suc r'))\n                                     (HOs (Suc r') pp) (SHOs (Suc r') pp)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp.\n        \\<lbrakk>nextState Ute_M (Suc r') pp (rho (Suc r') pp) \\<mu>pp\n                  (rho (Suc (Suc r')) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors Ute_M (Suc r') pp (rho (Suc r'))\n                (HOs (Suc r') pp) (SHOs (Suc r') pp)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ute_M (Suc r') pp (rho (Suc r') pp) \\<mu>pp\n   (rho (Suc (Suc r')) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r') pp (rho (Suc r')) (HOs (Suc r') pp)\n         (SHOs (Suc r') pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "with vT"], ["proof (chain)\npicking this:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  T < card {q. ?\\<mu>p'7 q = Some (Val v)}\n  nextState Ute_M (Suc r') pp (rho (Suc r') pp) \\<mu>pp\n   (rho (Suc (Suc r')) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r') pp (rho (Suc r')) (HOs (Suc r') pp)\n         (SHOs (Suc r') pp)", "have vT':\"card {q. \\<mu>pp q = Some (Val v)} > T\""], ["proof (prove)\nusing this:\n  ?\\<mu>p'7\n  \\<in> SHOmsgVectors Ute_M (Suc r') ?p7 (rho (Suc r')) (HOs (Suc r') ?p7)\n         (SHOs (Suc r') ?p7) \\<Longrightarrow>\n  T < card {q. ?\\<mu>p'7 q = Some (Val v)}\n  nextState Ute_M (Suc r') pp (rho (Suc r') pp) \\<mu>pp\n   (rho (Suc (Suc r')) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r') pp (rho (Suc r')) (HOs (Suc r') pp)\n         (SHOs (Suc r') pp)\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "by auto"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "moreover"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "from stpr rr'"], ["proof (chain)\npicking this:\n  step (Suc r) = Suc 0\n  r' = Suc r", "have \"step (Suc r') = 0\""], ["proof (prove)\nusing this:\n  step (Suc r) = Suc 0\n  r' = Suc r\n\ngoal (1 subgoal):\n 1. step (Suc r') = 0", "by (auto simp: mod_Suc step_def)"], ["proof (state)\nthis:\n  step (Suc r') = 0\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "with nxtpp"], ["proof (chain)\npicking this:\n  nextState Ute_M (Suc r') pp (rho (Suc r') pp) \\<mu>pp\n   (rho (Suc (Suc r')) pp)\n  step (Suc r') = 0", "have \"next0 (Suc r') pp (rho (Suc r') pp) \\<mu>pp (rho (Suc (Suc r')) pp)\""], ["proof (prove)\nusing this:\n  nextState Ute_M (Suc r') pp (rho (Suc r') pp) \\<mu>pp\n   (rho (Suc (Suc r')) pp)\n  step (Suc r') = 0\n\ngoal (1 subgoal):\n 1. next0 (Suc r') pp (rho (Suc r') pp) \\<mu>pp (rho (Suc (Suc r')) pp)", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def)"], ["proof (state)\nthis:\n  next0 (Suc r') pp (rho (Suc r') pp) \\<mu>pp (rho (Suc (Suc r')) pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "ultimately"], ["proof (chain)\npicking this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  next0 (Suc r') pp (rho (Suc r') pp) \\<mu>pp (rho (Suc (Suc r')) pp)", "obtain w\n        where wT:\"card {q. \\<mu>pp q = Some (Val w)} > T\"\n          and votew:\"vote (rho (Suc (Suc r')) pp) = Some w\""], ["proof (prove)\nusing this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  next0 (Suc r') pp (rho (Suc r') pp) \\<mu>pp (rho (Suc (Suc r')) pp)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>T < card {q. \\<mu>pp q = Some (Val w)};\n         vote (rho (Suc (Suc r')) pp) = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: next0_def)"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q = Some (Val w)}\n  vote (rho (Suc (Suc r')) pp) = Some w\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "from vT' wT"], ["proof (chain)\npicking this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  T < card {q. \\<mu>pp q = Some (Val w)}", "have \"v = w\""], ["proof (prove)\nusing this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  T < card {q. \\<mu>pp q = Some (Val w)}\n\ngoal (1 subgoal):\n 1. v = w", "by (auto dest: unique_majority_T)"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r')) pp) = Some v", "with votew"], ["proof (chain)\npicking this:\n  vote (rho (Suc (Suc r')) pp) = Some w\n  v = w", "show \"vote (rho (Suc (Suc r')) pp) = Some v\""], ["proof (prove)\nusing this:\n  vote (rho (Suc (Suc r')) pp) = Some w\n  v = w\n\ngoal (1 subgoal):\n 1. vote (rho (Suc (Suc r')) pp) = Some v", "by simp"], ["proof (state)\nthis:\n  vote (rho (Suc (Suc r')) pp) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp. vote (rho (Suc (Suc r')) pp) = Some v\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "with run stpr rr'"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  step (Suc r) = Suc 0\n  r' = Suc r\n  \\<forall>pp. vote (rho (Suc (Suc r')) pp) = Some v", "have \"\\<forall>p. N = card {q. sendMsg Ute_M (Suc (Suc (Suc r))) q p \n                                  ((rho (Suc (Suc (Suc r)))) q) = Vote (Some v)}\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  step (Suc r) = Suc 0\n  r' = Suc r\n  \\<forall>pp. vote (rho (Suc (Suc r')) pp) = Some v\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       N =\n       card\n        {q. sendMsg Ute_M (Suc (Suc (Suc r))) q p\n             (rho (Suc (Suc (Suc r))) q) =\n            Vote (Some v)}", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq \n                     Ute_sendMsg_def send1_def step_def mod_Suc)"], ["proof (state)\nthis:\n  \\<forall>p.\n     N =\n     card\n      {q. sendMsg Ute_M (Suc (Suc (Suc r))) q p\n           (rho (Suc (Suc (Suc r))) q) =\n          Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "with rr' majE EltN"], ["proof (chain)\npicking this:\n  r' = Suc r\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n  E < N\n  \\<forall>p.\n     N =\n     card\n      {q. sendMsg Ute_M (Suc (Suc (Suc r))) q p\n           (rho (Suc (Suc (Suc r))) q) =\n          Vote (Some v)}", "show ?thesis"], ["proof (prove)\nusing this:\n  r' = Suc r\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n  E < N\n  \\<forall>p.\n     N =\n     card\n      {q. sendMsg Ute_M (Suc (Suc (Suc r))) q p\n           (rho (Suc (Suc (Suc r))) q) =\n          Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n           Vote (Some v)}", "by auto"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n         Vote (Some v)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc (Suc r')) q p (rho (Suc (Suc r')) q) =\n         Vote (Some v)}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A process that holds some decision \\<open>v\\<close> has decided \\<open>v\\<close>\n  sometime in the past.\n\\<close>"], ["", "lemma decisionNonNullThenDecided:\n  assumes run:\"SHORun Ute_M rho HOs SHOs\" and dec: \"decide (rho n p) = Some v\"\n  shows \"\\<exists>m<n. decide (rho (Suc m) p) \\<noteq> decide (rho m p) \n             \\<and> decide (rho (Suc m) p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "let \"?dec k\" = \"decide ((rho k) p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "have \"(\\<forall>m<n. ?dec (Suc m) \\<noteq> ?dec m \\<longrightarrow> ?dec (Suc m) \\<noteq> Some v)\n        \\<longrightarrow> ?dec n \\<noteq> Some v\"\n    (is \"?P n\" is \"?A n \\<longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m<n.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho n p) \\<noteq> Some v", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>m<0.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho 0 p) \\<noteq> Some v\n 2. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "show \"?P 0\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<forall>m<0.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho 0 p) \\<noteq> Some v", "by (auto simp: Ute_SHOMachine_def SHORun_eq HOinitConfig_eq\n                     initState_def Ute_initState_def)"], ["proof (state)\nthis:\n  (\\<forall>m<0.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho 0 p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "assume ih: \"?P n\""], ["proof (state)\nthis:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "thus \"?P (Suc n)\""], ["proof (prove)\nusing this:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. (\\<forall>m<Suc n.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho (Suc n) p) \\<noteq> Some v", "by force"], ["proof (state)\nthis:\n  (\\<forall>m<Suc n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho (Suc n) p) \\<noteq> Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "with dec"], ["proof (chain)\npicking this:\n  decide (rho n p) = Some v\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho n p) = Some v\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n       decide (rho (Suc m) p) = Some v", "by auto"], ["proof (state)\nthis:\n  \\<exists>m<n.\n     decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<and>\n     decide (rho (Suc m) p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If process \\<open>p1\\<close> has decided value \\<open>v1\\<close> and process\n  \\<open>p2\\<close> later decides, then \\<open>p2\\<close> must decide \\<open>v1\\<close>.\n\\<close>"], ["", "(*\n  The proof relies on previous lemmas @{text decide_step},\n  @{text decide_with_threshold_E}, @{text unique_majority_E_\\<alpha>},\n  @{text decisionNonNullThenDecided} and @{text safety_inductive_argument}.\n*)"], ["", "lemma laterProcessDecidesSameValue:\n  assumes run:\"SHORun Ute_M rho HOs SHOs\"\n  and comm:\"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and dv1:\"decide (rho (Suc r) p1) = Some v1\"\n  and dn2:\"decide (rho (r + k) p2) \\<noteq> Some v2\"\n  and dv2:\"decide (rho (Suc (r + k)) p2) = Some v2\"\n  shows \"v2 = v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 = v1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v2 = v1", "from run dv1"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho (Suc r) p1) = Some v1", "obtain r1\n    where r1r:\"r1 < Suc r\"\n      and dn1:\"decide (rho r1 p1) \\<noteq> Some v1\"\n      and dv1':\"decide (rho (Suc r1) p1) = Some v1\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho (Suc r) p1) = Some v1\n\ngoal (1 subgoal):\n 1. (\\<And>r1.\n        \\<lbrakk>r1 < Suc r; decide (rho r1 p1) \\<noteq> Some v1;\n         decide (rho (Suc r1) p1) = Some v1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  r1 < Suc r\n  decide (rho r1 p1) \\<noteq> Some v1\n  decide (rho (Suc r1) p1) = Some v1\n\ngoal (1 subgoal):\n 1. v2 = v1", "from r1r"], ["proof (chain)\npicking this:\n  r1 < Suc r", "obtain s where rr1:\"Suc r = Suc (r1 + s)\""], ["proof (prove)\nusing this:\n  r1 < Suc r\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        Suc r = Suc (r1 + s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: less_imp_Suc_add)"], ["proof (state)\nthis:\n  Suc r = Suc (r1 + s)\n\ngoal (1 subgoal):\n 1. v2 = v1", "then"], ["proof (chain)\npicking this:\n  Suc r = Suc (r1 + s)", "obtain k' where kk':\"r + k = r1 + k'\""], ["proof (prove)\nusing this:\n  Suc r = Suc (r1 + s)\n\ngoal (1 subgoal):\n 1. (\\<And>k'. r + k = r1 + k' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r + k = r1 + k'\n\ngoal (1 subgoal):\n 1. v2 = v1", "with dn2 dv2"], ["proof (chain)\npicking this:\n  decide (rho (r + k) p2) \\<noteq> Some v2\n  decide (rho (Suc (r + k)) p2) = Some v2\n  r + k = r1 + k'", "have dn2': \"decide (rho (r1 + k') p2) \\<noteq> Some v2\"\n    and dv2': \"decide (rho (Suc (r1 + k')) p2) = Some v2\""], ["proof (prove)\nusing this:\n  decide (rho (r + k) p2) \\<noteq> Some v2\n  decide (rho (Suc (r + k)) p2) = Some v2\n  r + k = r1 + k'\n\ngoal (1 subgoal):\n 1. decide (rho (r1 + k') p2) \\<noteq> Some v2 &&&\n    decide (rho (Suc (r1 + k')) p2) = Some v2", "by auto"], ["proof (state)\nthis:\n  decide (rho (r1 + k') p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k')) p2) = Some v2\n\ngoal (1 subgoal):\n 1. v2 = v1", "from run dn1 dv1' dn2' dv2'"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r1 p1) \\<noteq> Some v1\n  decide (rho (Suc r1) p1) = Some v1\n  decide (rho (r1 + k') p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k')) p2) = Some v2", "have rs0:\"step r1 = Suc 0\" and  rks0:\"step (r1 + k') = Suc 0\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r1 p1) \\<noteq> Some v1\n  decide (rho (Suc r1) p1) = Some v1\n  decide (rho (r1 + k') p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k')) p2) = Some v2\n\ngoal (1 subgoal):\n 1. step r1 = Suc 0 &&& step (r1 + k') = Suc 0", "by (auto simp: mod_Suc step_def dest: decide_step)"], ["proof (state)\nthis:\n  step r1 = Suc 0\n  step (r1 + k') = Suc 0\n\ngoal (1 subgoal):\n 1. v2 = v1", "have \"step (r1 + k') = step (step r1 + k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (r1 + k') = step (step r1 + k')", "unfolding step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r1 + k') mod nSteps = (r1 mod nSteps + k') mod nSteps", "by (simp add: mod_add_left_eq)"], ["proof (state)\nthis:\n  step (r1 + k') = step (step r1 + k')\n\ngoal (1 subgoal):\n 1. v2 = v1", "with rs0 rks0"], ["proof (chain)\npicking this:\n  step r1 = Suc 0\n  step (r1 + k') = Suc 0\n  step (r1 + k') = step (step r1 + k')", "have \"step k' = 0\""], ["proof (prove)\nusing this:\n  step r1 = Suc 0\n  step (r1 + k') = Suc 0\n  step (r1 + k') = step (step r1 + k')\n\ngoal (1 subgoal):\n 1. step k' = 0", "by (auto simp: step_def mod_Suc)"], ["proof (state)\nthis:\n  step k' = 0\n\ngoal (1 subgoal):\n 1. v2 = v1", "then"], ["proof (chain)\npicking this:\n  step k' = 0", "obtain k'' where \"k' = k''*nSteps\""], ["proof (prove)\nusing this:\n  step k' = 0\n\ngoal (1 subgoal):\n 1. (\\<And>k''.\n        k' = k'' * nSteps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: step_def)"], ["proof (state)\nthis:\n  k' = k'' * nSteps\n\ngoal (1 subgoal):\n 1. v2 = v1", "with dn2' dv2'"], ["proof (chain)\npicking this:\n  decide (rho (r1 + k') p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k')) p2) = Some v2\n  k' = k'' * nSteps", "have dn2'':\"decide (rho (r1 + k''*nSteps) p2) \\<noteq> Some v2\"\n    and dv2'':\"decide (rho (Suc (r1 + k''*nSteps)) p2) = Some v2\""], ["proof (prove)\nusing this:\n  decide (rho (r1 + k') p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k')) p2) = Some v2\n  k' = k'' * nSteps\n\ngoal (1 subgoal):\n 1. decide (rho (r1 + k'' * nSteps) p2) \\<noteq> Some v2 &&&\n    decide (rho (Suc (r1 + k'' * nSteps)) p2) = Some v2", "by auto"], ["proof (state)\nthis:\n  decide (rho (r1 + k'' * nSteps) p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k'' * nSteps)) p2) = Some v2\n\ngoal (1 subgoal):\n 1. v2 = v1", "from rs0"], ["proof (chain)\npicking this:\n  step r1 = Suc 0", "have stp:\"step (r1 + k''*nSteps) = Suc 0\""], ["proof (prove)\nusing this:\n  step r1 = Suc 0\n\ngoal (1 subgoal):\n 1. step (r1 + k'' * nSteps) = Suc 0", "unfolding step_def"], ["proof (prove)\nusing this:\n  r1 mod nSteps = Suc 0\n\ngoal (1 subgoal):\n 1. (r1 + k'' * nSteps) mod nSteps = Suc 0", "by auto"], ["proof (state)\nthis:\n  step (r1 + k'' * nSteps) = Suc 0\n\ngoal (1 subgoal):\n 1. v2 = v1", "have inv:\"card {q. sendMsg Ute_M (r1 + k''*nSteps) q p1 (rho (r1 + k''*nSteps) q)\n                         = Vote (Some v1)} > E - \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n            (rho (r1 + k'' * nSteps) q) =\n           Vote (Some v1)}", "proof (induct k'')"], ["proof (state)\ngoal (2 subgoals):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (r1 + 0 * nSteps) q p1 (rho (r1 + 0 * nSteps) q) =\n           Vote (Some v1)}\n 2. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "from stp"], ["proof (chain)\npicking this:\n  step (r1 + k'' * nSteps) = Suc 0", "have \"step (r1 + 0*nSteps) = Suc 0\""], ["proof (prove)\nusing this:\n  step (r1 + k'' * nSteps) = Suc 0\n\ngoal (1 subgoal):\n 1. step (r1 + 0 * nSteps) = Suc 0", "by (auto simp: step_def)"], ["proof (state)\nthis:\n  step (r1 + 0 * nSteps) = Suc 0\n\ngoal (2 subgoals):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (r1 + 0 * nSteps) q p1 (rho (r1 + 0 * nSteps) q) =\n           Vote (Some v1)}\n 2. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "from run comm dn1 dv1'"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho r1 p1) \\<noteq> Some v1\n  decide (rho (Suc r1) p1) = Some v1", "show \"card {q. sendMsg Ute_M (r1 + 0*nSteps) q p1 (rho (r1 + 0*nSteps) q)\n                      = Vote (Some v1)} > E - \\<alpha>\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho r1 p1) \\<noteq> Some v1\n  decide (rho (Suc r1) p1) = Some v1\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (r1 + 0 * nSteps) q p1 (rho (r1 + 0 * nSteps) q) =\n           Vote (Some v1)}", "by (intro decide_with_threshold_E) auto"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + 0 * nSteps) q p1 (rho (r1 + 0 * nSteps) q) =\n         Vote (Some v1)}\n\ngoal (1 subgoal):\n 1. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "fix k''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "assume ih: \"E - \\<alpha> <\n          card {q. sendMsg Ute_M (r1 + k''*nSteps) q p1 (rho (r1 + k''*nSteps) q)\n                       = Vote (Some v1)}\""], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v1)}\n\ngoal (1 subgoal):\n 1. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "from rs0"], ["proof (chain)\npicking this:\n  step r1 = Suc 0", "have stps: \"step (r1 + k''*nSteps) = Suc 0\""], ["proof (prove)\nusing this:\n  step r1 = Suc 0\n\ngoal (1 subgoal):\n 1. step (r1 + k'' * nSteps) = Suc 0", "by (auto simp: step_def)"], ["proof (state)\nthis:\n  step (r1 + k'' * nSteps) = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "with run comm ih"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v1)}\n  step (r1 + k'' * nSteps) = Suc 0", "have \"E - \\<alpha>  <\n       card {q. sendMsg Ute_M (Suc (Suc (r1 + k''*nSteps))) q p1 \n                              (rho (Suc (Suc (r1 + k''*nSteps))) q) \n                   = Vote (Some v1)}\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v1)}\n  step (r1 + k'' * nSteps) = Suc 0\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc (r1 + k'' * nSteps))) q p1\n            (rho (Suc (Suc (r1 + k'' * nSteps))) q) =\n           Vote (Some v1)}", "by (rule safety_inductive_argument)"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc (Suc (r1 + k'' * nSteps))) q p1\n          (rho (Suc (Suc (r1 + k'' * nSteps))) q) =\n         Vote (Some v1)}\n\ngoal (1 subgoal):\n 1. \\<And>k''.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n               (rho (r1 + k'' * nSteps) q) =\n              Vote (Some v1)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n               (rho (r1 + Suc k'' * nSteps) q) =\n              Vote (Some v1)}", "thus \"E - \\<alpha> <\n       card {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n                              (rho (r1 + Suc k'' * nSteps) q)\n                     = Vote (Some v1)}\""], ["proof (prove)\nusing this:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc (Suc (r1 + k'' * nSteps))) q p1\n          (rho (Suc (Suc (r1 + k'' * nSteps))) q) =\n         Vote (Some v1)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n            (rho (r1 + Suc k'' * nSteps) q) =\n           Vote (Some v1)}", "by auto"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + Suc k'' * nSteps) q p1\n          (rho (r1 + Suc k'' * nSteps) q) =\n         Vote (Some v1)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v1)}\n\ngoal (1 subgoal):\n 1. v2 = v1", "moreover"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v1)}\n\ngoal (1 subgoal):\n 1. v2 = v1", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "have \"\\<forall>q. sendMsg Ute_M (r1 + k''*nSteps) q p1 (rho (r1 + k''*nSteps) q)\n          = sendMsg Ute_M (r1 + k''*nSteps) q p2 (rho (r1 + k''*nSteps) q)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       sendMsg Ute_M (r1 + k'' * nSteps) q p1 (rho (r1 + k'' * nSteps) q) =\n       sendMsg Ute_M (r1 + k'' * nSteps) q p2 (rho (r1 + k'' * nSteps) q)", "by (auto simp: Ute_SHOMachine_def Ute_sendMsg_def \n                   step_def send0_def send1_def)"], ["proof (state)\nthis:\n  \\<forall>q.\n     sendMsg Ute_M (r1 + k'' * nSteps) q p1 (rho (r1 + k'' * nSteps) q) =\n     sendMsg Ute_M (r1 + k'' * nSteps) q p2 (rho (r1 + k'' * nSteps) q)\n\ngoal (1 subgoal):\n 1. v2 = v1", "moreover"], ["proof (state)\nthis:\n  \\<forall>q.\n     sendMsg Ute_M (r1 + k'' * nSteps) q p1 (rho (r1 + k'' * nSteps) q) =\n     sendMsg Ute_M (r1 + k'' * nSteps) q p2 (rho (r1 + k'' * nSteps) q)\n\ngoal (1 subgoal):\n 1. v2 = v1", "from run comm dn2'' dv2''"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho (r1 + k'' * nSteps) p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k'' * nSteps)) p2) = Some v2", "have \"E - \\<alpha> <\n      card {q. sendMsg Ute_M (r1 + k''*nSteps) q p2 (rho (r1 + k''*nSteps) q)\n                  = Vote (Some v2)}\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho (r1 + k'' * nSteps) p2) \\<noteq> Some v2\n  decide (rho (Suc (r1 + k'' * nSteps)) p2) = Some v2\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (r1 + k'' * nSteps) q p2\n            (rho (r1 + k'' * nSteps) q) =\n           Vote (Some v2)}", "by (auto dest: decide_with_threshold_E)"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p2\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v2)}\n\ngoal (1 subgoal):\n 1. v2 = v1", "ultimately"], ["proof (chain)\npicking this:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v1)}\n  \\<forall>q.\n     sendMsg Ute_M (r1 + k'' * nSteps) q p1 (rho (r1 + k'' * nSteps) q) =\n     sendMsg Ute_M (r1 + k'' * nSteps) q p2 (rho (r1 + k'' * nSteps) q)\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p2\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v2)}", "show \"v2 = v1\""], ["proof (prove)\nusing this:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p1\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v1)}\n  \\<forall>q.\n     sendMsg Ute_M (r1 + k'' * nSteps) q p1 (rho (r1 + k'' * nSteps) q) =\n     sendMsg Ute_M (r1 + k'' * nSteps) q p2 (rho (r1 + k'' * nSteps) q)\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (r1 + k'' * nSteps) q p2\n          (rho (r1 + k'' * nSteps) q) =\n         Vote (Some v2)}\n\ngoal (1 subgoal):\n 1. v2 = v1", "by (auto dest: unique_majority_E_\\<alpha>)"], ["proof (state)\nthis:\n  v2 = v1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The Agreement property is an immediate consequence of the two\n  preceding lemmas.\n\\<close>"], ["", "theorem ute_agreement:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and p: \"decide (rho m p) = Some v\"\n  and q: \"decide (rho n q) = Some w\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "from run p"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho m p) = Some v", "obtain k \n    where k1: \"decide (rho (Suc k) p) \\<noteq> decide (rho k p)\"\n      and k2: \"decide (rho (Suc k) p) = Some v\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho m p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>decide (rho (Suc k) p) \\<noteq> decide (rho k p);\n         decide (rho (Suc k) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  decide (rho (Suc k) p) = Some v\n\ngoal (1 subgoal):\n 1. v = w", "from run q"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho n q) = Some w", "obtain l \n    where l1: \"decide (rho (Suc l) q) \\<noteq> decide (rho l q)\"\n      and l2: \"decide (rho (Suc l) q) = Some w\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho n q) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>decide (rho (Suc l) q) \\<noteq> decide (rho l q);\n         decide (rho (Suc l) q) = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  decide (rho (Suc l) q) = Some w\n\ngoal (1 subgoal):\n 1. v = w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof (cases \"k \\<le> l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "case True"], ["proof (state)\nthis:\n  k \\<le> l\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "then"], ["proof (chain)\npicking this:\n  k \\<le> l", "obtain m where m: \"l = k+m\""], ["proof (prove)\nusing this:\n  k \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<And>m. l = k + m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: le_iff_add)"], ["proof (state)\nthis:\n  l = k + m\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "from run comm k2 l1 l2 m"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho (Suc k) p) = Some v\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  decide (rho (Suc l) q) = Some w\n  l = k + m", "have \"w = v\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho (Suc k) p) = Some v\n  decide (rho (Suc l) q) \\<noteq> decide (rho l q)\n  decide (rho (Suc l) q) = Some w\n  l = k + m\n\ngoal (1 subgoal):\n 1. w = v", "by (auto elim!: laterProcessDecidesSameValue)"], ["proof (state)\nthis:\n  w = v\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> v = w\n 2. \\<not> k \\<le> l \\<Longrightarrow> v = w", "thus ?thesis"], ["proof (prove)\nusing this:\n  w = v\n\ngoal (1 subgoal):\n 1. v = w", "by simp"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> l\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "hence \"l \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> l\n\ngoal (1 subgoal):\n 1. l \\<le> k", "by simp"], ["proof (state)\nthis:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "then"], ["proof (chain)\npicking this:\n  l \\<le> k", "obtain m where m: \"k = l+m\""], ["proof (prove)\nusing this:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>m. k = l + m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: le_iff_add)"], ["proof (state)\nthis:\n  k = l + m\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> v = w", "from run comm l2 k1 k2 m"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho (Suc l) q) = Some w\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  decide (rho (Suc k) p) = Some v\n  k = l + m", "show ?thesis"], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho (Suc l) q) = Some w\n  decide (rho (Suc k) p) \\<noteq> decide (rho k p)\n  decide (rho (Suc k) p) = Some v\n  k = l + m\n\ngoal (1 subgoal):\n 1. v = w", "by (auto elim!: laterProcessDecidesSameValue)"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Main lemma for the proof of the Validity property.\n\\<close>"], ["", "(*\n  The proof relies on previous lemmas @{text safety_inductive_argument},\n  @{text unique_majority_T} and the @{text Ute_commPerRound} predicate.\n*)"], ["", "lemma validity_argument:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and init: \"\\<forall>p. x ((rho 0) p) = v\"\n  and dw: \"decide (rho r p) = Some w\"\n  and stp: \"step r' = Suc 0\"\n  shows \"card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)} > E - \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}", "define k where \"k = r' div nSteps\""], ["proof (state)\nthis:\n  k = r' div nSteps\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}", "with stp"], ["proof (chain)\npicking this:\n  step r' = Suc 0\n  k = r' div nSteps", "have stp: \"r' = Suc 0 + k * nSteps\""], ["proof (prove)\nusing this:\n  step r' = Suc 0\n  k = r' div nSteps\n\ngoal (1 subgoal):\n 1. r' = Suc 0 + k * nSteps", "using div_mult_mod_eq [of r' nSteps]"], ["proof (prove)\nusing this:\n  step r' = Suc 0\n  k = r' div nSteps\n  r' div nSteps * nSteps + r' mod nSteps = r'\n\ngoal (1 subgoal):\n 1. r' = Suc 0 + k * nSteps", "by (simp add: step_def)"], ["proof (state)\nthis:\n  r' = Suc 0 + k * nSteps\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}", "moreover"], ["proof (state)\nthis:\n  r' = Suc 0 + k * nSteps\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}", "have \"E - \\<alpha> <\n        card {q. sendMsg Ute_M (Suc 0 + k*nSteps) q p ((rho (Suc 0 + k*nSteps)) q)\n                   = Vote (Some v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n            (rho (Suc 0 + k * nSteps) q) =\n           Vote (Some v)}", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc 0 + 0 * nSteps) q p\n            (rho (Suc 0 + 0 * nSteps) q) =\n           Vote (Some v)}\n 2. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "have \"\\<forall>pp. vote ((rho (Suc 0)) pp) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pp. vote (rho (Suc 0) pp) = Some v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "fix pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>pp\n        where nxtpp:\"nextState Ute_M 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)\"\n          and mupp:\"\\<mu>pp \\<in> SHOmsgVectors Ute_M 0 pp (rho 0) (HOs 0 pp) (SHOs 0 pp)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp.\n        \\<lbrakk>nextState Ute_M 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors Ute_M 0 pp (rho 0) (HOs 0 pp)\n                (SHOs 0 pp)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ute_M 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M 0 pp (rho 0) (HOs 0 pp) (SHOs 0 pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "have majv:\"card {q. \\<mu>pp q = Some (Val v)} > T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "from run init"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>p. x (rho 0 p) = v", "have \"\\<forall>q. sendMsg Ute_M 0 q pp (rho 0 q) = Val v\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>p. x (rho 0 p) = v\n\ngoal (1 subgoal):\n 1. \\<forall>q. sendMsg Ute_M 0 q pp (rho 0 q) = Val v", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq \n                         Ute_sendMsg_def send0_def step_def)"], ["proof (state)\nthis:\n  \\<forall>q. sendMsg Ute_M 0 q pp (rho 0 q) = Val v\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "moreover"], ["proof (state)\nthis:\n  \\<forall>q. sendMsg Ute_M 0 q pp (rho 0 q) = Val v\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "from comm"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)", "have shoT:\"card (SHOs 0 pp \\<inter> HOs 0 pp) > T\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. T < card (SHOs 0 pp \\<inter> HOs 0 pp)", "by (auto simp: Ute_SHOMachine_def Ute_commPerRd_def)"], ["proof (state)\nthis:\n  T < card (SHOs 0 pp \\<inter> HOs 0 pp)\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "moreover"], ["proof (state)\nthis:\n  T < card (SHOs 0 pp \\<inter> HOs 0 pp)\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "from mupp"], ["proof (chain)\npicking this:\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M 0 pp (rho 0) (HOs 0 pp) (SHOs 0 pp)", "have \"SHOs 0 pp \\<inter> HOs 0 pp \n               \\<subseteq> {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}\""], ["proof (prove)\nusing this:\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M 0 pp (rho 0) (HOs 0 pp) (SHOs 0 pp)\n\ngoal (1 subgoal):\n 1. SHOs 0 pp \\<inter> HOs 0 pp\n    \\<subseteq> {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  SHOs 0 pp \\<inter> HOs 0 pp\n  \\<subseteq> {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "hence \"card (SHOs 0 pp \\<inter> HOs 0 pp)\n                 \\<le> card {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}\""], ["proof (prove)\nusing this:\n  SHOs 0 pp \\<inter> HOs 0 pp\n  \\<subseteq> {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}\n\ngoal (1 subgoal):\n 1. card (SHOs 0 pp \\<inter> HOs 0 pp)\n    \\<le> card {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card (SHOs 0 pp \\<inter> HOs 0 pp)\n  \\<le> card {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>q. sendMsg Ute_M 0 q pp (rho 0 q) = Val v\n  T < card (SHOs 0 pp \\<inter> HOs 0 pp)\n  card (SHOs 0 pp \\<inter> HOs 0 pp)\n  \\<le> card {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q. sendMsg Ute_M 0 q pp (rho 0 q) = Val v\n  T < card (SHOs 0 pp \\<inter> HOs 0 pp)\n  card (SHOs 0 pp \\<inter> HOs 0 pp)\n  \\<le> card {q. \\<mu>pp q = Some (sendMsg Ute_M 0 q pp (rho 0 q))}\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q = Some (Val v)}", "by (auto simp: less_le_trans)"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "moreover"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "from nxtpp"], ["proof (chain)\npicking this:\n  nextState Ute_M 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)", "have \"next0 0 pp ((rho 0) pp) \\<mu>pp (rho (Suc 0) pp)\""], ["proof (prove)\nusing this:\n  nextState Ute_M 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)\n\ngoal (1 subgoal):\n 1. next0 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def step_def)"], ["proof (state)\nthis:\n  next0 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "ultimately"], ["proof (chain)\npicking this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  next0 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)", "obtain w where majw:\"card {q. \\<mu>pp q = Some (Val w)} > T\"\n                 and votew:\"vote (rho (Suc 0) pp) = Some w\""], ["proof (prove)\nusing this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  next0 0 pp (rho 0 pp) \\<mu>pp (rho (Suc 0) pp)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>T < card {q. \\<mu>pp q = Some (Val w)};\n         vote (rho (Suc 0) pp) = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: next0_def)"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q = Some (Val w)}\n  vote (rho (Suc 0) pp) = Some w\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "from majv majw"], ["proof (chain)\npicking this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  T < card {q. \\<mu>pp q = Some (Val w)}", "have \"v = w\""], ["proof (prove)\nusing this:\n  T < card {q. \\<mu>pp q = Some (Val v)}\n  T < card {q. \\<mu>pp q = Some (Val w)}\n\ngoal (1 subgoal):\n 1. v = w", "by (auto dest: unique_majority_T)"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc 0) pp) = Some v", "with votew"], ["proof (chain)\npicking this:\n  vote (rho (Suc 0) pp) = Some w\n  v = w", "show \"vote ((rho (Suc 0)) pp) = Some v\""], ["proof (prove)\nusing this:\n  vote (rho (Suc 0) pp) = Some w\n  v = w\n\ngoal (1 subgoal):\n 1. vote (rho (Suc 0) pp) = Some v", "by simp"], ["proof (state)\nthis:\n  vote (rho (Suc 0) pp) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp. vote (rho (Suc 0) pp) = Some v\n\ngoal (2 subgoals):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc 0 + 0 * nSteps) q p\n            (rho (Suc 0 + 0 * nSteps) q) =\n           Vote (Some v)}\n 2. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "with run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>pp. vote (rho (Suc 0) pp) = Some v", "have \"card {q. sendMsg Ute_M (Suc 0) q p (rho (Suc 0) q) = Vote (Some v)} = N\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>pp. vote (rho (Suc 0) pp) = Some v\n\ngoal (1 subgoal):\n 1. card {q. sendMsg Ute_M (Suc 0) q p (rho (Suc 0) q) = Vote (Some v)} = N", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq\n                     Ute_nextState_def step_def Ute_sendMsg_def send1_def)"], ["proof (state)\nthis:\n  card {q. sendMsg Ute_M (Suc 0) q p (rho (Suc 0) q) = Vote (Some v)} = N\n\ngoal (2 subgoals):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc 0 + 0 * nSteps) q p\n            (rho (Suc 0 + 0 * nSteps) q) =\n           Vote (Some v)}\n 2. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "thus \"E - \\<alpha> <\n      card {q. sendMsg Ute_M (Suc 0 + 0 * nSteps) q p (rho (Suc 0 + 0 * nSteps) q)\n                   = Vote (Some v)}\""], ["proof (prove)\nusing this:\n  card {q. sendMsg Ute_M (Suc 0) q p (rho (Suc 0) q) = Vote (Some v)} = N\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc 0 + 0 * nSteps) q p\n            (rho (Suc 0 + 0 * nSteps) q) =\n           Vote (Some v)}", "using majE EltN"], ["proof (prove)\nusing this:\n  card {q. sendMsg Ute_M (Suc 0) q p (rho (Suc 0) q) = Vote (Some v)} = N\n  N + nSteps * \\<alpha> \\<le> nSteps * E\n  E < N\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc 0 + 0 * nSteps) q p\n            (rho (Suc 0 + 0 * nSteps) q) =\n           Vote (Some v)}", "by auto"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + 0 * nSteps) q p\n          (rho (Suc 0 + 0 * nSteps) q) =\n         Vote (Some v)}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "assume ih:\"E - \\<alpha> <\n        card {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p (rho (Suc 0 + k * nSteps) q)\n                     = Vote (Some v)}\""], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n          (rho (Suc 0 + k * nSteps) q) =\n         Vote (Some v)}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "have \"step (Suc 0 + k * nSteps) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (Suc 0 + k * nSteps) = Suc 0", "by (auto simp: mod_Suc step_def)"], ["proof (state)\nthis:\n  step (Suc 0 + k * nSteps) = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "from run comm ih this"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n          (rho (Suc 0 + k * nSteps) q) =\n         Vote (Some v)}\n  step (Suc 0 + k * nSteps) = Suc 0", "have \"E - \\<alpha> <\n      card {q. sendMsg Ute_M (Suc (Suc (Suc 0 + k * nSteps))) q p\n                             (rho (Suc (Suc (Suc 0 + k * nSteps))) q)\n                  = Vote (Some v)}\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n          (rho (Suc 0 + k * nSteps) q) =\n         Vote (Some v)}\n  step (Suc 0 + k * nSteps) = Suc 0\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc (Suc (Suc 0 + k * nSteps))) q p\n            (rho (Suc (Suc (Suc 0 + k * nSteps))) q) =\n           Vote (Some v)}", "by (rule safety_inductive_argument)"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc (Suc (Suc 0 + k * nSteps))) q p\n          (rho (Suc (Suc (Suc 0 + k * nSteps))) q) =\n         Vote (Some v)}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n               (rho (Suc 0 + k * nSteps) q) =\n              Vote (Some v)} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n               (rho (Suc 0 + Suc k * nSteps) q) =\n              Vote (Some v)}", "thus \"E - \\<alpha> <\n       card {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p \n                              (rho (Suc 0 + Suc k * nSteps) q)\n                 = Vote (Some v)}\""], ["proof (prove)\nusing this:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc (Suc (Suc 0 + k * nSteps))) q p\n          (rho (Suc (Suc (Suc 0 + k * nSteps))) q) =\n         Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n            (rho (Suc 0 + Suc k * nSteps) q) =\n           Vote (Some v)}", "by simp"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + Suc k * nSteps) q p\n          (rho (Suc 0 + Suc k * nSteps) q) =\n         Vote (Some v)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n          (rho (Suc 0 + k * nSteps) q) =\n         Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}", "ultimately"], ["proof (chain)\npicking this:\n  r' = Suc 0 + k * nSteps\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n          (rho (Suc 0 + k * nSteps) q) =\n         Vote (Some v)}", "show ?thesis"], ["proof (prove)\nusing this:\n  r' = Suc 0 + k * nSteps\n  E - \\<alpha>\n  < card\n     {q. sendMsg Ute_M (Suc 0 + k * nSteps) q p\n          (rho (Suc 0 + k * nSteps) q) =\n         Vote (Some v)}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}", "by simp"], ["proof (state)\nthis:\n  E - \\<alpha> < card {q. sendMsg Ute_M r' q p (rho r' q) = Vote (Some v)}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following theorem shows the Validity property of algorithm \\ute{}.\n\\<close>"], ["", "(*\n The proof relies on previous lemmas @{text decisionNonNullThenDecided},\n @{text decide_step}, @{text decide_with_threshold_E},  @{text unique_majority_E_\\<alpha>},\n and the @{text Validity_argument}. \n*)"], ["", "theorem ute_validity:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and init: \"\\<forall>p. x (rho 0 p) = v\"\n  and dw: \"decide (rho r p) = Some w\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "from run dw"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r p) = Some w", "obtain r1\n    where dnr1:\"decide ((rho r1) p) \\<noteq> Some w\"\n      and dwr1:\"decide ((rho (Suc r1)) p) = Some w\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r p) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>r1.\n        \\<lbrakk>decide (rho r1 p) \\<noteq> Some w;\n         decide (rho (Suc r1) p) = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force dest: decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  decide (rho r1 p) \\<noteq> Some w\n  decide (rho (Suc r1) p) = Some w\n\ngoal (1 subgoal):\n 1. v = w", "with run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r1 p) \\<noteq> Some w\n  decide (rho (Suc r1) p) = Some w", "have \"step r1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  decide (rho r1 p) \\<noteq> Some w\n  decide (rho (Suc r1) p) = Some w\n\ngoal (1 subgoal):\n 1. step r1 \\<noteq> 0", "by (rule decide_step)"], ["proof (state)\nthis:\n  step r1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v = w", "hence \"step r1 = Suc 0\""], ["proof (prove)\nusing this:\n  step r1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. step r1 = Suc 0", "by (simp add: step_def mod_Suc)"], ["proof (state)\nthis:\n  step r1 = Suc 0\n\ngoal (1 subgoal):\n 1. v = w", "with assms"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  \\<forall>p. x (rho 0 p) = v\n  decide (rho r p) = Some w\n  step r1 = Suc 0", "have \"E - \\<alpha> <\n        card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some v)}\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  \\<forall>p. x (rho 0 p) = v\n  decide (rho r p) = Some w\n  step r1 = Suc 0\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some v)}", "by (rule validity_argument)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. v = w", "moreover"], ["proof (state)\nthis:\n  E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some v)}\n\ngoal (1 subgoal):\n 1. v = w", "from run comm dnr1 dwr1"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho r1 p) \\<noteq> Some w\n  decide (rho (Suc r1) p) = Some w", "have \"card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some w)} > E - \\<alpha>\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  decide (rho r1 p) \\<noteq> Some w\n  decide (rho (Suc r1) p) = Some w\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some w)}", "by (auto dest: decide_with_threshold_E)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some w)}\n\ngoal (1 subgoal):\n 1. v = w", "ultimately"], ["proof (chain)\npicking this:\n  E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some v)}\n  E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some w)}", "show \"v = w\""], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some v)}\n  E - \\<alpha> < card {q. sendMsg Ute_M r1 q p (rho r1 q) = Vote (Some w)}\n\ngoal (1 subgoal):\n 1. v = w", "by (auto dest: unique_majority_E_\\<alpha>)"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Termination\\<close>"], ["", "text \\<open>\n  At the second round of a phase that satisfies the conditions expressed in\n  the global communication predicate, processes update their \\<open>x\\<close> variable \n  with the value \\<open>v\\<close> they receive in more than \\<open>\\<alpha>\\<close> messages.\n\\<close>"], ["", "(* The proof relies on @{text common_vote}. *)"], ["", "lemma set_x_from_vote:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and comm: \"SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and stp: \"step (Suc r) = Suc 0\"\n  and \\<pi>: \"\\<forall>p. HOs (Suc r) p = SHOs (Suc r) p\"\n  and nxt: \"nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu> (rho (Suc (Suc r)) p)\"\n  and mu: \"\\<mu> \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r))\n                                   (HOs (Suc r) p) (SHOs (Suc r) p)\"\n  and vp: \"\\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some v))}\"\n  shows \"x ((rho (Suc (Suc r))) p) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = v", "from nxt stp vp"], ["proof (chain)\npicking this:\n  nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu> (rho (Suc (Suc r)) p)\n  step (Suc r) = Suc 0\n  \\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some v))}", "obtain wp\n    where xwp:\"\\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some wp))}\"\n      and xp:\"x (rho (Suc (Suc r)) p) = wp\""], ["proof (prove)\nusing this:\n  nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu> (rho (Suc (Suc r)) p)\n  step (Suc r) = Suc 0\n  \\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. (\\<And>wp.\n        \\<lbrakk>\\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some wp))};\n         x (rho (Suc (Suc r)) p) = wp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def next1_def)"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some wp))}\n  x (rho (Suc (Suc r)) p) = wp\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = v", "have \"wp = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wp = v", "from xwp"], ["proof (chain)\npicking this:\n  \\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some wp))}", "obtain pp where smw:\"\\<mu> pp = Some (Vote (Some wp))\""], ["proof (prove)\nusing this:\n  \\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some wp))}\n\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<mu> pp = Some (Vote (Some wp)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  \\<mu> pp = Some (Vote (Some wp))\n\ngoal (1 subgoal):\n 1. wp = v", "have \"vote (rho (Suc r) pp) = Some wp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vote (rho (Suc r) pp) = Some wp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vote (rho (Suc r) pp) = Some wp", "from smw mu \\<pi>"], ["proof (chain)\npicking this:\n  \\<mu> pp = Some (Vote (Some wp))\n  \\<mu>\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. HOs (Suc r) p = SHOs (Suc r) p", "have \"\\<mu> pp = Some (sendMsg Ute_M (Suc r) pp p (rho (Suc r) pp))\""], ["proof (prove)\nusing this:\n  \\<mu> pp = Some (Vote (Some wp))\n  \\<mu>\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. HOs (Suc r) p = SHOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu> pp = Some (sendMsg Ute_M (Suc r) pp p (rho (Suc r) pp))", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu> pp = Some (Vote (Some wp))\n  \\<mu>\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) p) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q p (rho (Suc r) q)))}\n  \\<forall>p. HOs (Suc r) p = SHOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu> pp = Some (sendMsg Ute_M (Suc r) pp p (rho (Suc r) pp))", "by force"], ["proof (state)\nthis:\n  \\<mu> pp = Some (sendMsg Ute_M (Suc r) pp p (rho (Suc r) pp))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) pp) = Some wp", "with stp"], ["proof (chain)\npicking this:\n  step (Suc r) = Suc 0\n  \\<mu> pp = Some (sendMsg Ute_M (Suc r) pp p (rho (Suc r) pp))", "have \"\\<mu> pp = Some (Vote (vote (rho (Suc r) pp)))\""], ["proof (prove)\nusing this:\n  step (Suc r) = Suc 0\n  \\<mu> pp = Some (sendMsg Ute_M (Suc r) pp p (rho (Suc r) pp))\n\ngoal (1 subgoal):\n 1. \\<mu> pp = Some (Vote (vote (rho (Suc r) pp)))", "by (auto simp: Ute_SHOMachine_def Ute_sendMsg_def send1_def)"], ["proof (state)\nthis:\n  \\<mu> pp = Some (Vote (vote (rho (Suc r) pp)))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) pp) = Some wp", "with smw"], ["proof (chain)\npicking this:\n  \\<mu> pp = Some (Vote (Some wp))\n  \\<mu> pp = Some (Vote (vote (rho (Suc r) pp)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> pp = Some (Vote (Some wp))\n  \\<mu> pp = Some (Vote (vote (rho (Suc r) pp)))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) pp) = Some wp", "by auto"], ["proof (state)\nthis:\n  vote (rho (Suc r) pp) = Some wp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vote (rho (Suc r) pp) = Some wp\n\ngoal (1 subgoal):\n 1. wp = v", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc r) pp) = Some wp\n\ngoal (1 subgoal):\n 1. wp = v", "from vp"], ["proof (chain)\npicking this:\n  \\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some v))}", "obtain qq where smv:\"\\<mu> qq = Some (Vote (Some v))\""], ["proof (prove)\nusing this:\n  \\<alpha> < card {qq. \\<mu> qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<mu> qq = Some (Vote (Some v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  \\<mu> qq = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. wp = v", "have \"vote (rho (Suc r) qq) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vote (rho (Suc r) qq) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vote (rho (Suc r) qq) = Some v", "from smv mu \\<pi>"], ["proof (chain)\npicking this:\n  \\<mu> qq = Some (Vote (Some v))\n  \\<mu>\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. HOs (Suc r) p = SHOs (Suc r) p", "have \"\\<mu> qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\""], ["proof (prove)\nusing this:\n  \\<mu> qq = Some (Vote (Some v))\n  \\<mu>\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. HOs (Suc r) p = SHOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu> qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu> qq = Some (Vote (Some v))\n  \\<mu>\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) p) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q p (rho (Suc r) q)))}\n  \\<forall>p. HOs (Suc r) p = SHOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu> qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))", "by force"], ["proof (state)\nthis:\n  \\<mu> qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) qq) = Some v", "with stp"], ["proof (chain)\npicking this:\n  step (Suc r) = Suc 0\n  \\<mu> qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))", "have \"\\<mu> qq = Some (Vote (vote (rho (Suc r) qq)))\""], ["proof (prove)\nusing this:\n  step (Suc r) = Suc 0\n  \\<mu> qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\n\ngoal (1 subgoal):\n 1. \\<mu> qq = Some (Vote (vote (rho (Suc r) qq)))", "by (auto simp: Ute_SHOMachine_def Ute_sendMsg_def send1_def)"], ["proof (state)\nthis:\n  \\<mu> qq = Some (Vote (vote (rho (Suc r) qq)))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) qq) = Some v", "with smv"], ["proof (chain)\npicking this:\n  \\<mu> qq = Some (Vote (Some v))\n  \\<mu> qq = Some (Vote (vote (rho (Suc r) qq)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> qq = Some (Vote (Some v))\n  \\<mu> qq = Some (Vote (vote (rho (Suc r) qq)))\n\ngoal (1 subgoal):\n 1. vote (rho (Suc r) qq) = Some v", "by auto"], ["proof (state)\nthis:\n  vote (rho (Suc r) qq) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vote (rho (Suc r) qq) = Some v\n\ngoal (1 subgoal):\n 1. wp = v", "moreover"], ["proof (state)\nthis:\n  vote (rho (Suc r) qq) = Some v\n\ngoal (1 subgoal):\n 1. wp = v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>pp \\<mu>qq\n      where \"nextState Ute_M r pp (rho r pp) \\<mu>pp (rho (Suc r) pp)\"\n        and \"\\<mu>pp \\<in> SHOmsgVectors Ute_M r pp (rho r) (HOs r pp) (SHOs r pp)\"\n        and \"nextState Ute_M r qq ((rho r) qq)  \\<mu>qq (rho (Suc r) qq)\"\n        and \"\\<mu>qq \\<in> SHOmsgVectors Ute_M r qq (rho r) (HOs r qq) (SHOs r qq)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp \\<mu>qq.\n        \\<lbrakk>nextState Ute_M r pp (rho r pp) \\<mu>pp (rho (Suc r) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors Ute_M r pp (rho r) (HOs r pp) (SHOs r pp);\n         nextState Ute_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq);\n         \\<mu>qq\n         \\<in> SHOmsgVectors Ute_M r qq (rho r) (HOs r qq)\n                (SHOs r qq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq"], ["proof (prove)\nusing this:\n  HOinitConfig\n   \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n      sendMsg = Ute_sendMsg,\n      CnextState = \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n      SHOcommPerRd = Ute_commPerRd, SHOcommGlobal = Ute_commGlobal\\<rparr>\n   (rho 0) \\<and>\n  (\\<forall>r p.\n      \\<exists>\\<mu>\n               \\<in>SHOmsgVectors\n                     \\<lparr>CinitState =\n                               \\<lambda>p st crd. Ute_initState p st,\n                        sendMsg = Ute_sendMsg,\n                        CnextState =\n                          \\<lambda>r p st msgs crd.\n                             Ute_nextState r p st msgs,\n                        SHOcommPerRd = Ute_commPerRd,\n                        SHOcommGlobal = Ute_commGlobal\\<rparr>\n                     r p (rho r) (HOs r p) (SHOs r p).\n         nextState\n          \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n             sendMsg = Ute_sendMsg,\n             CnextState =\n               \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n             SHOcommPerRd = Ute_commPerRd,\n             SHOcommGlobal = Ute_commGlobal\\<rparr>\n          r p (rho r p) \\<mu> (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp \\<mu>qq.\n        \\<lbrakk>nextState\n                  \\<lparr>CinitState =\n                            \\<lambda>p st crd. Ute_initState p st,\n                     sendMsg = Ute_sendMsg,\n                     CnextState =\n                       \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                     SHOcommPerRd = Ute_commPerRd,\n                     SHOcommGlobal = Ute_commGlobal\\<rparr>\n                  r pp (rho r pp) \\<mu>pp (rho (Suc r) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors\n                \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n                   sendMsg = Ute_sendMsg,\n                   CnextState =\n                     \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                   SHOcommPerRd = Ute_commPerRd,\n                   SHOcommGlobal = Ute_commGlobal\\<rparr>\n                r pp (rho r) (HOs r pp) (SHOs r pp);\n         nextState\n          \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n             sendMsg = Ute_sendMsg,\n             CnextState =\n               \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n             SHOcommPerRd = Ute_commPerRd,\n             SHOcommGlobal = Ute_commGlobal\\<rparr>\n          r qq (rho r qq) \\<mu>qq (rho (Suc r) qq);\n         \\<mu>qq\n         \\<in> SHOmsgVectors\n                \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n                   sendMsg = Ute_sendMsg,\n                   CnextState =\n                     \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                   SHOcommPerRd = Ute_commPerRd,\n                   SHOcommGlobal = Ute_commGlobal\\<rparr>\n                r qq (rho r) (HOs r qq) (SHOs r qq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nextState Ute_M r pp (rho r pp) \\<mu>pp (rho (Suc r) pp)\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M r pp (rho r) (HOs r pp) (SHOs r pp)\n  nextState Ute_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)\n  \\<mu>qq \\<in> SHOmsgVectors Ute_M r qq (rho r) (HOs r qq) (SHOs r qq)\n\ngoal (1 subgoal):\n 1. wp = v", "ultimately"], ["proof (chain)\npicking this:\n  vote (rho (Suc r) pp) = Some wp\n  vote (rho (Suc r) qq) = Some v\n  nextState Ute_M r pp (rho r pp) \\<mu>pp (rho (Suc r) pp)\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M r pp (rho r) (HOs r pp) (SHOs r pp)\n  nextState Ute_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)\n  \\<mu>qq \\<in> SHOmsgVectors Ute_M r qq (rho r) (HOs r qq) (SHOs r qq)", "show ?thesis"], ["proof (prove)\nusing this:\n  vote (rho (Suc r) pp) = Some wp\n  vote (rho (Suc r) qq) = Some v\n  nextState Ute_M r pp (rho r pp) \\<mu>pp (rho (Suc r) pp)\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M r pp (rho r) (HOs r pp) (SHOs r pp)\n  nextState Ute_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)\n  \\<mu>qq \\<in> SHOmsgVectors Ute_M r qq (rho r) (HOs r qq) (SHOs r qq)\n\ngoal (1 subgoal):\n 1. wp = v", "using comm"], ["proof (prove)\nusing this:\n  vote (rho (Suc r) pp) = Some wp\n  vote (rho (Suc r) qq) = Some v\n  nextState Ute_M r pp (rho r pp) \\<mu>pp (rho (Suc r) pp)\n  \\<mu>pp \\<in> SHOmsgVectors Ute_M r pp (rho r) (HOs r pp) (SHOs r pp)\n  nextState Ute_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)\n  \\<mu>qq \\<in> SHOmsgVectors Ute_M r qq (rho r) (HOs r qq) (SHOs r qq)\n  SHOcommPerRd Ute_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. wp = v", "by (auto dest: common_vote)"], ["proof (state)\nthis:\n  wp = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wp = v\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = v", "with xp"], ["proof (chain)\npicking this:\n  x (rho (Suc (Suc r)) p) = wp\n  wp = v", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (Suc (Suc r)) p) = wp\n  wp = v\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = v", "by simp"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Assume that HO and SHO sets are uniform at the second step of some\n  phase. Then at the subsequent round there exists some value \\<open>v\\<close>\n  such that any received message which is not corrupted holds \\<open>v\\<close>.\n\\<close>"], ["", "(* The proof relies on lemma @{text set_x_from_vote}. *)"], ["", "lemma termination_argument_1:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\" \n  and comm: \"SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and stp: \"step (Suc r) = Suc 0\"\n  and \\<pi>: \"\\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\"\n  obtains v where \n    \"\\<And>p \\<mu>p' q. \n       \\<lbrakk> q \\<in> SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p; \n         \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                             (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\n       \\<rbrakk> \\<Longrightarrow> \\<mu>p' q = (Some (Val v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from \\<pi>"], ["proof (chain)\npicking this:\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p", "have hosho:\"\\<forall>p. SHOs (Suc r) p = SHOs (Suc r) p \\<inter> HOs (Suc r) p\""], ["proof (prove)\nusing this:\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<forall>p. SHOs (Suc r) p = SHOs (Suc r) p \\<inter> HOs (Suc r) p", "by simp"], ["proof (state)\nthis:\n  \\<forall>p. SHOs (Suc r) p = SHOs (Suc r) p \\<inter> HOs (Suc r) p\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>p\n      where nxt: \"nextState Ute_M (Suc r) p (rho (Suc r) p)  \n                                  \\<mu>p (rho (Suc (Suc r)) p)\"\n        and mu: \"\\<mu>p \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) \n                                          (HOs (Suc r) p) (SHOs (Suc r) p)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu>p\n                  (rho (Suc (Suc r)) p);\n         \\<mu>p\n         \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n                (SHOs (Suc r) p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu>p (rho (Suc (Suc r)) p)\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>q\n      where nxtq: \"nextState Ute_M (Suc r) q (rho (Suc r) q)\n                                   \\<mu>q (rho (Suc (Suc r)) q)\"\n       and muq: \"\\<mu>q \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r))\n                                          (HOs (Suc r) q) (SHOs (Suc r) q)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>q.\n        \\<lbrakk>nextState Ute_M (Suc r) q (rho (Suc r) q) \\<mu>q\n                  (rho (Suc (Suc r)) q);\n         \\<mu>q\n         \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n                (SHOs (Suc r) q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ute_M (Suc r) q (rho (Suc r) q) \\<mu>q (rho (Suc (Suc r)) q)\n  \\<mu>q\n  \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n         (SHOs (Suc r) q)\n\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "have \"\\<forall>qq. \\<mu>p qq = \\<mu>q qq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qq. \\<mu>p qq = \\<mu>q qq", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qq. \\<mu>p qq = \\<mu>q qq", "fix qq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qq. \\<mu>p qq = \\<mu>q qq", "show \"\\<mu>p qq = \\<mu>q qq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>p qq = \\<mu>q qq", "proof (cases \"\\<mu>p qq = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq\n 2. \\<mu>p qq \\<noteq> None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "case False"], ["proof (state)\nthis:\n  \\<mu>p qq \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq\n 2. \\<mu>p qq \\<noteq> None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "with mu \\<pi>"], ["proof (chain)\npicking this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  \\<mu>p qq \\<noteq> None", "have 1:\"qq \\<in> SHOs (Suc r) p\" and 2:\"qq \\<in> SHOs (Suc r) q\""], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  \\<mu>p qq \\<noteq> None\n\ngoal (1 subgoal):\n 1. qq \\<in> SHOs (Suc r) p &&& qq \\<in> SHOs (Suc r) q", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) p) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q p (rho (Suc r) q)))}\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  \\<mu>p qq \\<noteq> None\n\ngoal (1 subgoal):\n 1. qq \\<in> SHOs (Suc r) p &&& qq \\<in> SHOs (Suc r) q", "by auto"], ["proof (state)\nthis:\n  qq \\<in> SHOs (Suc r) p\n  qq \\<in> SHOs (Suc r) q\n\ngoal (2 subgoals):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq\n 2. \\<mu>p qq \\<noteq> None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "from mu \\<pi> 1"], ["proof (chain)\npicking this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  qq \\<in> SHOs (Suc r) p", "have \"\\<mu>p qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\""], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  qq \\<in> SHOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) p) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q p (rho (Suc r) q)))}\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  qq \\<in> SHOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))", "by auto"], ["proof (state)\nthis:\n  \\<mu>p qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\n\ngoal (2 subgoals):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq\n 2. \\<mu>p qq \\<noteq> None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "moreover"], ["proof (state)\nthis:\n  \\<mu>p qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\n\ngoal (2 subgoals):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq\n 2. \\<mu>p qq \\<noteq> None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "from muq \\<pi> 2"], ["proof (chain)\npicking this:\n  \\<mu>q\n  \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n         (SHOs (Suc r) q)\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  qq \\<in> SHOs (Suc r) q", "have \"\\<mu>q qq = Some (sendMsg Ute_M (Suc r) qq q (rho (Suc r) qq))\""], ["proof (prove)\nusing this:\n  \\<mu>q\n  \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n         (SHOs (Suc r) q)\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  qq \\<in> SHOs (Suc r) q\n\ngoal (1 subgoal):\n 1. \\<mu>q qq = Some (sendMsg Ute_M (Suc r) qq q (rho (Suc r) qq))", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa.\n             (qa \\<in> HOs (Suc r) q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> SHOs (Suc r) q \\<inter>\n                      HOs (Suc r) q \\<longrightarrow>\n             \\<mu> qa = Some (sendMsg Ute_M (Suc r) qa q (rho (Suc r) qa)))}\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  qq \\<in> SHOs (Suc r) q\n\ngoal (1 subgoal):\n 1. \\<mu>q qq = Some (sendMsg Ute_M (Suc r) qq q (rho (Suc r) qq))", "by auto"], ["proof (state)\nthis:\n  \\<mu>q qq = Some (sendMsg Ute_M (Suc r) qq q (rho (Suc r) qq))\n\ngoal (2 subgoals):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq\n 2. \\<mu>p qq \\<noteq> None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "ultimately"], ["proof (chain)\npicking this:\n  \\<mu>p qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\n  \\<mu>q qq = Some (sendMsg Ute_M (Suc r) qq q (rho (Suc r) qq))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu>p qq = Some (sendMsg Ute_M (Suc r) qq p (rho (Suc r) qq))\n  \\<mu>q qq = Some (sendMsg Ute_M (Suc r) qq q (rho (Suc r) qq))\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = \\<mu>q qq", "by (auto simp: Ute_SHOMachine_def Ute_sendMsg_def step_def \n                         send0_def send1_def)"], ["proof (state)\nthis:\n  \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "case True"], ["proof (state)\nthis:\n  \\<mu>p qq = None\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "with mu"], ["proof (chain)\npicking this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<mu>p qq = None", "have \"qq \\<notin> HOs (Suc r) p\""], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<mu>p qq = None\n\ngoal (1 subgoal):\n 1. qq \\<notin> HOs (Suc r) p", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> {\\<mu>.\n         (\\<forall>q.\n             (q \\<in> HOs (Suc r) p) = (\\<mu> q \\<noteq> None)) \\<and>\n         (\\<forall>q.\n             q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p \\<longrightarrow>\n             \\<mu> q = Some (sendMsg Ute_M (Suc r) q p (rho (Suc r) q)))}\n  \\<mu>p qq = None\n\ngoal (1 subgoal):\n 1. qq \\<notin> HOs (Suc r) p", "by auto"], ["proof (state)\nthis:\n  qq \\<notin> HOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "with \\<pi> muq"], ["proof (chain)\npicking this:\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  \\<mu>q\n  \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n         (SHOs (Suc r) q)\n  qq \\<notin> HOs (Suc r) p", "have \"\\<mu>q qq = None\""], ["proof (prove)\nusing this:\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  \\<mu>q\n  \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n         (SHOs (Suc r) q)\n  qq \\<notin> HOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu>q qq = None", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa.\n             (qa \\<in> HOs (Suc r) q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> SHOs (Suc r) q \\<inter>\n                      HOs (Suc r) q \\<longrightarrow>\n             \\<mu> qa = Some (sendMsg Ute_M (Suc r) qa q (rho (Suc r) qa)))}\n  qq \\<notin> HOs (Suc r) p\n\ngoal (1 subgoal):\n 1. \\<mu>q qq = None", "by auto"], ["proof (state)\nthis:\n  \\<mu>q qq = None\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = None \\<Longrightarrow> \\<mu>p qq = \\<mu>q qq", "with True"], ["proof (chain)\npicking this:\n  \\<mu>p qq = None\n  \\<mu>q qq = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu>p qq = None\n  \\<mu>q qq = None\n\ngoal (1 subgoal):\n 1. \\<mu>p qq = \\<mu>q qq", "by simp"], ["proof (state)\nthis:\n  \\<mu>p qq = \\<mu>q qq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu>p qq = \\<mu>q qq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qq. \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "hence vsets:\"\\<And>v. {qq. \\<mu>p qq = Some (Vote (Some v))} \n                    = {qq. \\<mu>q qq = Some (Vote (Some v))}\""], ["proof (prove)\nusing this:\n  \\<forall>qq. \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       {qq. \\<mu>p qq = Some (Vote (Some v))} =\n       {qq. \\<mu>q qq = Some (Vote (Some v))}", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>p qq = Some (Vote (Some ?v7))} =\n  {qq. \\<mu>q qq = Some (Vote (Some ?v7))}\n\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "(* NB: due to the Global predicate (HO = SHO), we do not need \\<alpha> + 1 msgs\n       holding a true vote, only 1. We might also prefer to invoke only the\n       @{text Ute_commPerRound} predicate to obtain qq :\n       since \"card (HOs (Suc r) p - SHOs (Suc r) p) < \\<alpha>\", there should be one\n       \"correct\" message holding a vote and this vote should be common according\n       to previous (Suc r)esults. *)"], ["proof (state)\nthis:\n  {qq. \\<mu>p qq = Some (Vote (Some ?v7))} =\n  {qq. \\<mu>q qq = Some (Vote (Some ?v7))}\n\ngoal (1 subgoal):\n 1. \\<And>p q. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "show \"x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "proof (cases \"\\<exists>v. \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\", clarify)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n       x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n 2. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n       x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n 2. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "assume vp: \"\\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\""], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n       x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n 2. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "with run comm stp \\<pi> nxt mu"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  step (Suc r) = Suc 0\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu>p (rho (Suc (Suc r)) p)\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}", "have \"x (rho (Suc (Suc r)) p) = v\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  step (Suc r) = Suc 0\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu>p (rho (Suc (Suc r)) p)\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = v", "by (auto dest: set_x_from_vote)"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = v\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n       x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n 2. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "moreover"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = v\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n       x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n 2. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "from vsets vp"], ["proof (chain)\npicking this:\n  {qq. \\<mu>p qq = Some (Vote (Some ?v7))} =\n  {qq. \\<mu>q qq = Some (Vote (Some ?v7))}\n  \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}", "have \"\\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>p qq = Some (Vote (Some ?v7))} =\n  {qq. \\<mu>q qq = Some (Vote (Some ?v7))}\n  \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}", "by auto"], ["proof (state)\nthis:\n  \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n       x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n 2. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "with run comm stp \\<pi> nxtq muq"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  step (Suc r) = Suc 0\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  nextState Ute_M (Suc r) q (rho (Suc r) q) \\<mu>q (rho (Suc (Suc r)) q)\n  \\<mu>q\n  \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n         (SHOs (Suc r) q)\n  \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}", "have \"x (rho (Suc (Suc r)) q) = v\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  step (Suc r) = Suc 0\n  \\<forall>p. \\<pi>0 = HOs (Suc r) p \\<and> \\<pi>0 = SHOs (Suc r) p\n  nextState Ute_M (Suc r) q (rho (Suc r) q) \\<mu>q (rho (Suc (Suc r)) q)\n  \\<mu>q\n  \\<in> SHOmsgVectors Ute_M (Suc r) q (rho (Suc r)) (HOs (Suc r) q)\n         (SHOs (Suc r) q)\n  \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) q) = v", "by (auto dest: set_x_from_vote)"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) q) = v\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n       x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n 2. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "ultimately"], ["proof (chain)\npicking this:\n  x (rho (Suc (Suc r)) p) = v\n  x (rho (Suc (Suc r)) q) = v", "show \"x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\""], ["proof (prove)\nusing this:\n  x (rho (Suc (Suc r)) p) = v\n  x (rho (Suc (Suc r)) q) = v\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "assume nov: \"\\<not> (\\<exists>v. \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))})\""], ["proof (state)\nthis:\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "with nxt stp"], ["proof (chain)\npicking this:\n  nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu>p (rho (Suc (Suc r)) p)\n  step (Suc r) = Suc 0\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}", "have \"x (rho (Suc (Suc r)) p) = undefined\""], ["proof (prove)\nusing this:\n  nextState Ute_M (Suc r) p (rho (Suc r) p) \\<mu>p (rho (Suc (Suc r)) p)\n  step (Suc r) = Suc 0\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = undefined", "by (auto simp: Ute_SHOMachine_def nextState_def \n                       Ute_nextState_def next1_def)"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = undefined\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "moreover"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = undefined\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "from vsets nov"], ["proof (chain)\npicking this:\n  {qq. \\<mu>p qq = Some (Vote (Some ?v7))} =\n  {qq. \\<mu>q qq = Some (Vote (Some ?v7))}\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}", "have \"\\<not> (\\<exists>v. \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))})\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>p qq = Some (Vote (Some ?v7))} =\n  {qq. \\<mu>q qq = Some (Vote (Some ?v7))}\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>p qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. \\<nexists>v. \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}", "by auto"], ["proof (state)\nthis:\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "with nxtq stp"], ["proof (chain)\npicking this:\n  nextState Ute_M (Suc r) q (rho (Suc r) q) \\<mu>q (rho (Suc (Suc r)) q)\n  step (Suc r) = Suc 0\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}", "have \"x (rho (Suc (Suc r)) q) = undefined\""], ["proof (prove)\nusing this:\n  nextState Ute_M (Suc r) q (rho (Suc r) q) \\<mu>q (rho (Suc (Suc r)) q)\n  step (Suc r) = Suc 0\n  \\<nexists>v. \\<alpha> < card {qq. \\<mu>q qq = Some (Vote (Some v))}\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) q) = undefined", "by (auto simp: Ute_SHOMachine_def nextState_def \n                       Ute_nextState_def next1_def)"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) q) = undefined\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<alpha>\n       < card {qq. \\<mu>p qq = Some (Vote (Some v))} \\<Longrightarrow>\n    x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "ultimately"], ["proof (chain)\npicking this:\n  x (rho (Suc (Suc r)) p) = undefined\n  x (rho (Suc (Suc r)) q) = undefined", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (Suc (Suc r)) p) = undefined\n  x (rho (Suc (Suc r)) q) = undefined\n\ngoal (1 subgoal):\n 1. x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)", "by simp"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) p) = x (rho (Suc (Suc r)) q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) ?p7) = x (rho (Suc (Suc r)) ?q7)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  x (rho (Suc (Suc r)) ?p7) = x (rho (Suc (Suc r)) ?q7)", "obtain v where \"\\<And>q. x (rho (Suc (Suc r)) q) = v\""], ["proof (prove)\nusing this:\n  x (rho (Suc (Suc r)) ?p7) = x (rho (Suc (Suc r)) ?q7)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>q. x (rho (Suc (Suc r)) q) = v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) ?q7) = v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  x (rho (Suc (Suc r)) ?q7) = v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from stp"], ["proof (chain)\npicking this:\n  step (Suc r) = Suc 0", "have \"step (Suc (Suc r)) = 0\""], ["proof (prove)\nusing this:\n  step (Suc r) = Suc 0\n\ngoal (1 subgoal):\n 1. step (Suc (Suc r)) = 0", "by (auto simp: step_def mod_Suc)"], ["proof (state)\nthis:\n  step (Suc (Suc r)) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<And>p \\<mu>p' q. \n    \\<lbrakk> q \\<in> SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p;\n      \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                          (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\n    \\<rbrakk> \\<Longrightarrow> \\<mu>p' q = Some (Val (x (rho (Suc (Suc r)) q)))\""], ["proof (prove)\nusing this:\n  step (Suc (Suc r)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>p \\<mu>p' q.\n       \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p;\n        \\<mu>p'\n        \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n               (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n       \\<Longrightarrow> \\<mu>p' q = Some (Val (x (rho (Suc (Suc r)) q)))", "by (auto simp: Ute_SHOMachine_def SHOmsgVectors_def Ute_sendMsg_def send0_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?q7 \\<in> SHOs (Suc (Suc r)) ?p7 \\<inter> HOs (Suc (Suc r)) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) ?p7 (rho (Suc (Suc r)))\n          (HOs (Suc (Suc r)) ?p7) (SHOs (Suc (Suc r)) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val (x (rho (Suc (Suc r)) ?q7)))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  x (rho (Suc (Suc r)) ?q7) = v\n  \\<lbrakk>?q7 \\<in> SHOs (Suc (Suc r)) ?p7 \\<inter> HOs (Suc (Suc r)) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) ?p7 (rho (Suc (Suc r)))\n          (HOs (Suc (Suc r)) ?p7) (SHOs (Suc (Suc r)) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val (x (rho (Suc (Suc r)) ?q7)))", "have \"\\<And>p \\<mu>p' q. \n    \\<lbrakk> q \\<in> SHOs (Suc (Suc r)) p  \\<inter> HOs (Suc (Suc r)) p; \n      \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                                (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\n    \\<rbrakk> \\<Longrightarrow> \\<mu>p' q = (Some (Val v))\""], ["proof (prove)\nusing this:\n  x (rho (Suc (Suc r)) ?q7) = v\n  \\<lbrakk>?q7 \\<in> SHOs (Suc (Suc r)) ?p7 \\<inter> HOs (Suc (Suc r)) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) ?p7 (rho (Suc (Suc r)))\n          (HOs (Suc (Suc r)) ?p7) (SHOs (Suc (Suc r)) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val (x (rho (Suc (Suc r)) ?q7)))\n\ngoal (1 subgoal):\n 1. \\<And>p \\<mu>p' q.\n       \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p;\n        \\<mu>p'\n        \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n               (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n       \\<Longrightarrow> \\<mu>p' q = Some (Val v)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?q7 \\<in> SHOs (Suc (Suc r)) ?p7 \\<inter> HOs (Suc (Suc r)) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) ?p7 (rho (Suc (Suc r)))\n          (HOs (Suc (Suc r)) ?p7) (SHOs (Suc (Suc r)) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter>\n                             HOs (Suc (Suc r)) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n                    (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  (\\<And>p \\<mu>p' q.\n      \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p;\n       \\<mu>p'\n       \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n              (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n      \\<Longrightarrow> \\<mu>p' q = Some (Val ?v7)) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>?q7 \\<in> SHOs (Suc (Suc r)) ?p7 \\<inter> HOs (Suc (Suc r)) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) ?p7 (rho (Suc (Suc r)))\n          (HOs (Suc (Suc r)) ?p7) (SHOs (Suc (Suc r)) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val v)", "show thesis"], ["proof (prove)\nusing this:\n  (\\<And>p \\<mu>p' q.\n      \\<lbrakk>q \\<in> SHOs (Suc (Suc r)) p \\<inter> HOs (Suc (Suc r)) p;\n       \\<mu>p'\n       \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) p (rho (Suc (Suc r)))\n              (HOs (Suc (Suc r)) p) (SHOs (Suc (Suc r)) p)\\<rbrakk>\n      \\<Longrightarrow> \\<mu>p' q = Some (Val ?v7)) \\<Longrightarrow>\n  thesis\n  \\<lbrakk>?q7 \\<in> SHOs (Suc (Suc r)) ?p7 \\<inter> HOs (Suc (Suc r)) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc (Suc r)) ?p7 (rho (Suc (Suc r)))\n          (HOs (Suc (Suc r)) ?p7) (SHOs (Suc (Suc r)) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val v)\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If a process \\<open>p\\<close> votes \\<open>v\\<close> at some round \\<open>r\\<close>,\n  then all messages received by \\<open>p\\<close> in \\<open>r\\<close> that are not\n  corrupted hold \\<open>v\\<close>.\n\\<close>"], ["", "(* immediate from lemma @{text vote_step} and the algorithm definition. *)"], ["", "lemma termination_argument_2:\n  assumes mup: \"\\<mu>p \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) \n                                     (HOs (Suc r) p) (SHOs (Suc r) p)\"\n  and nxtq: \"nextState Ute_M r q (rho r q)  \\<mu>q (rho (Suc r) q)\"\n  and vq: \"vote (rho (Suc r) q) = Some v\"\n  and qsho: \"q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p\"\n  shows \"\\<mu>p q = Some (Vote (Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu>p q = Some (Vote (Some v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu>p q = Some (Vote (Some v))", "from nxtq vq"], ["proof (chain)\npicking this:\n  nextState Ute_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  vote (rho (Suc r) q) = Some v", "have \"step r = 0\""], ["proof (prove)\nusing this:\n  nextState Ute_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  vote (rho (Suc r) q) = Some v\n\ngoal (1 subgoal):\n 1. step r = 0", "by (auto simp: vote_step)"], ["proof (state)\nthis:\n  step r = 0\n\ngoal (1 subgoal):\n 1. \\<mu>p q = Some (Vote (Some v))", "with mup qsho"], ["proof (chain)\npicking this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p\n  step r = 0", "have \"\\<mu>p q = Some (Vote (vote (rho (Suc r) q)))\""], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r) p (rho (Suc r)) (HOs (Suc r) p)\n         (SHOs (Suc r) p)\n  q \\<in> SHOs (Suc r) p \\<inter> HOs (Suc r) p\n  step r = 0\n\ngoal (1 subgoal):\n 1. \\<mu>p q = Some (Vote (vote (rho (Suc r) q)))", "by (auto simp: Ute_SHOMachine_def SHOmsgVectors_def Ute_sendMsg_def\n                   step_def send1_def mod_Suc)"], ["proof (state)\nthis:\n  \\<mu>p q = Some (Vote (vote (rho (Suc r) q)))\n\ngoal (1 subgoal):\n 1. \\<mu>p q = Some (Vote (Some v))", "with vq"], ["proof (chain)\npicking this:\n  vote (rho (Suc r) q) = Some v\n  \\<mu>p q = Some (Vote (vote (rho (Suc r) q)))", "show \"\\<mu>p q = Some (Vote (Some v))\""], ["proof (prove)\nusing this:\n  vote (rho (Suc r) q) = Some v\n  \\<mu>p q = Some (Vote (vote (rho (Suc r) q)))\n\ngoal (1 subgoal):\n 1. \\<mu>p q = Some (Vote (Some v))", "by auto"], ["proof (state)\nthis:\n  \\<mu>p q = Some (Vote (Some v))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  We now prove the Termination property.\n\\<close>"], ["", "(*\n  The proof relies on previous lemmas @{text termination_argument_1},\n  @{text termination_argument_2}, @{text common_vote}, @{text unique_majority_E},\n  and the @{text Ute_commGlobal} predicate.\n*)"], ["", "theorem ute_termination:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n  and commR: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n  and commG: \"SHOcommGlobal Ute_M HOs SHOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from commG"], ["proof (chain)\npicking this:\n  SHOcommGlobal Ute_M HOs SHOs", "obtain \\<Phi> \\<pi> r0\n    where rr: \"r0 = Suc (nSteps * \\<Phi>)\"\n      and \\<pi>: \"\\<forall>p. \\<pi> = HOs r0 p \\<and> \\<pi> = SHOs r0 p\"\n      and t: \"\\<forall>p. card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p) > T\"\n      and e: \"\\<forall>p. card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p) > E\""], ["proof (prove)\nusing this:\n  SHOcommGlobal Ute_M HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>r0 \\<Phi> \\<pi>.\n        \\<lbrakk>r0 = Suc (nSteps * \\<Phi>);\n         \\<forall>p. \\<pi> = HOs r0 p \\<and> \\<pi> = SHOs r0 p;\n         \\<forall>p. T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p);\n         \\<forall>p.\n            E < card\n                 (SHOs (Suc (Suc r0)) p \\<inter>\n                  HOs (Suc (Suc r0)) p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def Ute_commGlobal_def Let_def)"], ["proof (state)\nthis:\n  r0 = Suc (nSteps * \\<Phi>)\n  \\<forall>p. \\<pi> = HOs r0 p \\<and> \\<pi> = SHOs r0 p\n  \\<forall>p. T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n  \\<forall>p. E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from rr"], ["proof (chain)\npicking this:\n  r0 = Suc (nSteps * \\<Phi>)", "have stp:\"step r0 = Suc 0\""], ["proof (prove)\nusing this:\n  r0 = Suc (nSteps * \\<Phi>)\n\ngoal (1 subgoal):\n 1. step r0 = Suc 0", "by (auto simp: step_def)"], ["proof (state)\nthis:\n  step r0 = Suc 0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "obtain w where votew:\"\\<forall>p. (vote (rho (Suc (Suc r0)) p)) = Some w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have abc:\"\\<forall>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "from run stp"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  step r0 = Suc 0", "obtain \\<mu>p\n        where nxt:\"nextState Ute_M (Suc r0) p (rho (Suc r0) p) \\<mu>p \n                                   (rho (Suc (Suc r0)) p)\"\n          and mup:\"\\<mu>p \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0)) \n                                      (HOs (Suc r0) p) (SHOs (Suc r0) p)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  step r0 = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState Ute_M (Suc r0) p (rho (Suc r0) p) \\<mu>p\n                  (rho (Suc (Suc r0)) p);\n         \\<mu>p\n         \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0))\n                (HOs (Suc r0) p) (SHOs (Suc r0) p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ute_M (Suc r0) p (rho (Suc r0) p) \\<mu>p (rho (Suc (Suc r0)) p)\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0)) (HOs (Suc r0) p)\n         (SHOs (Suc r0) p)\n\ngoal (1 subgoal):\n 1. \\<And>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "have \"\\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "from t"], ["proof (chain)\npicking this:\n  \\<forall>p. T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)", "have \"card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p) > T\""], ["proof (prove)\nusing this:\n  \\<forall>p. T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n\ngoal (1 subgoal):\n 1. T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)", ".."], ["proof (state)\nthis:\n  T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "moreover"], ["proof (state)\nthis:\n  T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "from run commR stp \\<pi> rr"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  step r0 = Suc 0\n  \\<forall>p. \\<pi> = HOs r0 p \\<and> \\<pi> = SHOs r0 p\n  r0 = Suc (nSteps * \\<Phi>)", "obtain v where\n          \"\\<And>p \\<mu>p' q. \n              \\<lbrakk> q \\<in> SHOs (Suc r0) p \\<inter> HOs (Suc r0) p;\n                \\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0)) \n                                          (HOs (Suc r0) p) (SHOs (Suc r0) p)\n              \\<rbrakk> \\<Longrightarrow> \\<mu>p' q = Some (Val v)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  step r0 = Suc 0\n  \\<forall>p. \\<pi> = HOs r0 p \\<and> \\<pi> = SHOs r0 p\n  r0 = Suc (nSteps * \\<Phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc r0) p \\<inter> HOs (Suc r0) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0))\n                    (HOs (Suc r0) p) (SHOs (Suc r0) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using termination_argument_1"], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  step r0 = Suc 0\n  \\<forall>p. \\<pi> = HOs r0 p \\<and> \\<pi> = SHOs r0 p\n  r0 = Suc (nSteps * \\<Phi>)\n  \\<lbrakk>SHORun Ute_M ?rho ?HOs ?SHOs;\n   SHOcommPerRd Ute_M (?HOs ?r) (?SHOs ?r); step (Suc ?r) = Suc 0;\n   \\<forall>p.\n      ?\\<pi>0.0 = ?HOs (Suc ?r) p \\<and> ?\\<pi>0.0 = ?SHOs (Suc ?r) p;\n   \\<And>v.\n      (\\<And>p \\<mu>p' q.\n          \\<lbrakk>q \\<in> ?SHOs (Suc (Suc ?r)) p \\<inter>\n                           ?HOs (Suc (Suc ?r)) p;\n           \\<mu>p'\n           \\<in> SHOmsgVectors Ute_M (Suc (Suc ?r)) p (?rho (Suc (Suc ?r)))\n                  (?HOs (Suc (Suc ?r)) p) (?SHOs (Suc (Suc ?r)) p)\\<rbrakk>\n          \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>p \\<mu>p' q.\n            \\<lbrakk>q \\<in> SHOs (Suc r0) p \\<inter> HOs (Suc r0) p;\n             \\<mu>p'\n             \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0))\n                    (HOs (Suc r0) p) (SHOs (Suc r0) p)\\<rbrakk>\n            \\<Longrightarrow> \\<mu>p' q = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?q7 \\<in> SHOs (Suc r0) ?p7 \\<inter> HOs (Suc r0) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc r0) ?p7 (rho (Suc r0)) (HOs (Suc r0) ?p7)\n          (SHOs (Suc r0) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val v)\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "with mup"], ["proof (chain)\npicking this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0)) (HOs (Suc r0) p)\n         (SHOs (Suc r0) p)\n  \\<lbrakk>?q7 \\<in> SHOs (Suc r0) ?p7 \\<inter> HOs (Suc r0) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc r0) ?p7 (rho (Suc r0)) (HOs (Suc r0) ?p7)\n          (SHOs (Suc r0) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val v)", "obtain v where\n          \"\\<And>qq. qq \\<in> SHOs (Suc r0) p \\<inter> HOs (Suc r0) p \\<Longrightarrow> \\<mu>p qq = Some (Val v)\""], ["proof (prove)\nusing this:\n  \\<mu>p\n  \\<in> SHOmsgVectors Ute_M (Suc r0) p (rho (Suc r0)) (HOs (Suc r0) p)\n         (SHOs (Suc r0) p)\n  \\<lbrakk>?q7 \\<in> SHOs (Suc r0) ?p7 \\<inter> HOs (Suc r0) ?p7;\n   ?\\<mu>p'7\n   \\<in> SHOmsgVectors Ute_M (Suc r0) ?p7 (rho (Suc r0)) (HOs (Suc r0) ?p7)\n          (SHOs (Suc r0) ?p7)\\<rbrakk>\n  \\<Longrightarrow> ?\\<mu>p'7 ?q7 = Some (Val v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>qq.\n            qq \\<in> SHOs (Suc r0) p \\<inter>\n                     HOs (Suc r0) p \\<Longrightarrow>\n            \\<mu>p qq = Some (Val v)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?qq7 \\<in> SHOs (Suc r0) p \\<inter> HOs (Suc r0) p \\<Longrightarrow>\n  \\<mu>p ?qq7 = Some (Val v)\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "hence \"SHOs (Suc r0) p \\<inter> HOs (Suc r0) p \\<subseteq> {qq. \\<mu>p qq = Some (Val v)}\""], ["proof (prove)\nusing this:\n  ?qq7 \\<in> SHOs (Suc r0) p \\<inter> HOs (Suc r0) p \\<Longrightarrow>\n  \\<mu>p ?qq7 = Some (Val v)\n\ngoal (1 subgoal):\n 1. SHOs (Suc r0) p \\<inter> HOs (Suc r0) p\n    \\<subseteq> {qq. \\<mu>p qq = Some (Val v)}", "by auto"], ["proof (state)\nthis:\n  SHOs (Suc r0) p \\<inter> HOs (Suc r0) p\n  \\<subseteq> {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "hence \"card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n                 \\<le> card {qq. \\<mu>p qq = Some (Val v)}\""], ["proof (prove)\nusing this:\n  SHOs (Suc r0) p \\<inter> HOs (Suc r0) p\n  \\<subseteq> {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n    \\<le> card {qq. \\<mu>p qq = Some (Val v)}", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n  \\<le> card {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "ultimately"], ["proof (chain)\npicking this:\n  T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n  card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n  \\<le> card {qq. \\<mu>p qq = Some (Val v)}", "have \"T < card {qq. \\<mu>p qq = Some (Val v)}\""], ["proof (prove)\nusing this:\n  T < card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n  card (SHOs (Suc r0) p \\<inter> HOs (Suc r0) p)\n  \\<le> card {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. T < card {qq. \\<mu>p qq = Some (Val v)}", "by auto"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  T < card {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "by auto"], ["proof (state)\nthis:\n  \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<And>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "with stp nxt"], ["proof (chain)\npicking this:\n  step r0 = Suc 0\n  nextState Ute_M (Suc r0) p (rho (Suc r0) p) \\<mu>p (rho (Suc (Suc r0)) p)\n  \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}", "show \"\\<exists>w. vote ((rho (Suc (Suc r0))) p) = Some w\""], ["proof (prove)\nusing this:\n  step r0 = Suc 0\n  nextState Ute_M (Suc r0) p (rho (Suc r0) p) \\<mu>p (rho (Suc (Suc r0)) p)\n  \\<exists>v. T < card {qq. \\<mu>p qq = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def \n                       step_def mod_Suc next0_def)"], ["proof (state)\nthis:\n  \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "obtain qq w where qqw:\"vote (rho (Suc (Suc r0)) qq) = Some w\""], ["proof (prove)\nusing this:\n  \\<forall>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>qq w.\n        vote (rho (Suc (Suc r0)) qq) = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vote (rho (Suc (Suc r0)) qq) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>pp. vote (rho (Suc (Suc r0)) pp) = Some w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pp. vote (rho (Suc (Suc r0)) pp) = Some w", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r0)) pp) = Some w", "fix pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r0)) pp) = Some w", "from abc"], ["proof (chain)\npicking this:\n  \\<forall>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w", "obtain wp where pwp:\"vote ((rho (Suc (Suc r0))) pp) = Some wp\""], ["proof (prove)\nusing this:\n  \\<forall>p. \\<exists>w. vote (rho (Suc (Suc r0)) p) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>wp.\n        vote (rho (Suc (Suc r0)) pp) = Some wp \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  vote (rho (Suc (Suc r0)) pp) = Some wp\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r0)) pp) = Some w", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>pp \\<mu>qq\n        where nxtp: \"nextState Ute_M (Suc r0) pp (rho (Suc r0) pp)\n                                     \\<mu>pp (rho (Suc (Suc r0)) pp)\"\n          and mup: \"\\<mu>pp \\<in> SHOmsgVectors Ute_M (Suc r0) pp (rho (Suc r0))\n                                          (HOs (Suc r0) pp) (SHOs (Suc r0) pp)\"\n          and nxtq: \"nextState Ute_M (Suc r0) qq (rho (Suc r0) qq)\n                                     \\<mu>qq (rho (Suc (Suc r0)) qq)\"\n          and muq: \"\\<mu>qq \\<in> SHOmsgVectors Ute_M (Suc r0) qq (rho (Suc r0))\n                                          (HOs (Suc r0) qq) (SHOs (Suc r0) qq)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp \\<mu>qq.\n        \\<lbrakk>nextState Ute_M (Suc r0) pp (rho (Suc r0) pp) \\<mu>pp\n                  (rho (Suc (Suc r0)) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors Ute_M (Suc r0) pp (rho (Suc r0))\n                (HOs (Suc r0) pp) (SHOs (Suc r0) pp);\n         nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n          (rho (Suc (Suc r0)) qq);\n         \\<mu>qq\n         \\<in> SHOmsgVectors Ute_M (Suc r0) qq (rho (Suc r0))\n                (HOs (Suc r0) qq) (SHOs (Suc r0) qq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq"], ["proof (prove)\nusing this:\n  HOinitConfig\n   \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n      sendMsg = Ute_sendMsg,\n      CnextState = \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n      SHOcommPerRd = Ute_commPerRd, SHOcommGlobal = Ute_commGlobal\\<rparr>\n   (rho 0) \\<and>\n  (\\<forall>r p.\n      \\<exists>\\<mu>\n               \\<in>SHOmsgVectors\n                     \\<lparr>CinitState =\n                               \\<lambda>p st crd. Ute_initState p st,\n                        sendMsg = Ute_sendMsg,\n                        CnextState =\n                          \\<lambda>r p st msgs crd.\n                             Ute_nextState r p st msgs,\n                        SHOcommPerRd = Ute_commPerRd,\n                        SHOcommGlobal = Ute_commGlobal\\<rparr>\n                     r p (rho r) (HOs r p) (SHOs r p).\n         nextState\n          \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n             sendMsg = Ute_sendMsg,\n             CnextState =\n               \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n             SHOcommPerRd = Ute_commPerRd,\n             SHOcommGlobal = Ute_commGlobal\\<rparr>\n          r p (rho r p) \\<mu> (rho (Suc r) p))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp \\<mu>qq.\n        \\<lbrakk>nextState\n                  \\<lparr>CinitState =\n                            \\<lambda>p st crd. Ute_initState p st,\n                     sendMsg = Ute_sendMsg,\n                     CnextState =\n                       \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                     SHOcommPerRd = Ute_commPerRd,\n                     SHOcommGlobal = Ute_commGlobal\\<rparr>\n                  (Suc r0) pp (rho (Suc r0) pp) \\<mu>pp\n                  (rho (Suc (Suc r0)) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors\n                \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n                   sendMsg = Ute_sendMsg,\n                   CnextState =\n                     \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                   SHOcommPerRd = Ute_commPerRd,\n                   SHOcommGlobal = Ute_commGlobal\\<rparr>\n                (Suc r0) pp (rho (Suc r0)) (HOs (Suc r0) pp)\n                (SHOs (Suc r0) pp);\n         nextState\n          \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n             sendMsg = Ute_sendMsg,\n             CnextState =\n               \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n             SHOcommPerRd = Ute_commPerRd,\n             SHOcommGlobal = Ute_commGlobal\\<rparr>\n          (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq (rho (Suc (Suc r0)) qq);\n         \\<mu>qq\n         \\<in> SHOmsgVectors\n                \\<lparr>CinitState = \\<lambda>p st crd. Ute_initState p st,\n                   sendMsg = Ute_sendMsg,\n                   CnextState =\n                     \\<lambda>r p st msgs crd. Ute_nextState r p st msgs,\n                   SHOcommPerRd = Ute_commPerRd,\n                   SHOcommGlobal = Ute_commGlobal\\<rparr>\n                (Suc r0) qq (rho (Suc r0)) (HOs (Suc r0) qq)\n                (SHOs (Suc r0) qq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nextState Ute_M (Suc r0) pp (rho (Suc r0) pp) \\<mu>pp\n   (rho (Suc (Suc r0)) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r0) pp (rho (Suc r0)) (HOs (Suc r0) pp)\n         (SHOs (Suc r0) pp)\n  nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n   (rho (Suc (Suc r0)) qq)\n  \\<mu>qq\n  \\<in> SHOmsgVectors Ute_M (Suc r0) qq (rho (Suc r0)) (HOs (Suc r0) qq)\n         (SHOs (Suc r0) qq)\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r0)) pp) = Some w", "from commR this pwp qqw"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  nextState Ute_M (Suc r0) pp (rho (Suc r0) pp) \\<mu>pp\n   (rho (Suc (Suc r0)) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r0) pp (rho (Suc r0)) (HOs (Suc r0) pp)\n         (SHOs (Suc r0) pp)\n  nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n   (rho (Suc (Suc r0)) qq)\n  \\<mu>qq\n  \\<in> SHOmsgVectors Ute_M (Suc r0) qq (rho (Suc r0)) (HOs (Suc r0) qq)\n         (SHOs (Suc r0) qq)\n  vote (rho (Suc (Suc r0)) pp) = Some wp\n  vote (rho (Suc (Suc r0)) qq) = Some w", "have \"wp = w\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  nextState Ute_M (Suc r0) pp (rho (Suc r0) pp) \\<mu>pp\n   (rho (Suc (Suc r0)) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ute_M (Suc r0) pp (rho (Suc r0)) (HOs (Suc r0) pp)\n         (SHOs (Suc r0) pp)\n  nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n   (rho (Suc (Suc r0)) qq)\n  \\<mu>qq\n  \\<in> SHOmsgVectors Ute_M (Suc r0) qq (rho (Suc r0)) (HOs (Suc r0) qq)\n         (SHOs (Suc r0) qq)\n  vote (rho (Suc (Suc r0)) pp) = Some wp\n  vote (rho (Suc (Suc r0)) qq) = Some w\n\ngoal (1 subgoal):\n 1. wp = w", "by (auto dest: common_vote)"], ["proof (state)\nthis:\n  wp = w\n\ngoal (1 subgoal):\n 1. \\<And>pp. vote (rho (Suc (Suc r0)) pp) = Some w", "with pwp"], ["proof (chain)\npicking this:\n  vote (rho (Suc (Suc r0)) pp) = Some wp\n  wp = w", "show \"vote ((rho (Suc (Suc r0))) pp) = Some w\""], ["proof (prove)\nusing this:\n  vote (rho (Suc (Suc r0)) pp) = Some wp\n  wp = w\n\ngoal (1 subgoal):\n 1. vote (rho (Suc (Suc r0)) pp) = Some w", "by auto"], ["proof (state)\nthis:\n  vote (rho (Suc (Suc r0)) pp) = Some w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp. vote (rho (Suc (Suc r0)) pp) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some ?w7 \\<Longrightarrow>\n  thesis\n  \\<forall>pp. vote (rho (Suc (Suc r0)) pp) = Some w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some ?w7 \\<Longrightarrow>\n  thesis\n  \\<forall>pp. vote (rho (Suc (Suc r0)) pp) = Some w\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>p'\n    where nxtp: \"nextState Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)) p)\n                                 \\<mu>p' (rho (Suc (Suc (Suc r0))) p)\"\n      and mup': \"\\<mu>p' \\<in> SHOmsgVectors Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)))\n                                     (HOs (Suc (Suc r0)) p) (SHOs (Suc (Suc r0)) p)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p'.\n        \\<lbrakk>nextState Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)) p)\n                  \\<mu>p' (rho (Suc (Suc (Suc r0))) p);\n         \\<mu>p'\n         \\<in> SHOmsgVectors Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)))\n                (HOs (Suc (Suc r0)) p) (SHOs (Suc (Suc r0)) p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n   (rho (Suc (Suc (Suc r0))) p)\n  \\<mu>p'\n  \\<in> SHOmsgVectors Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)))\n         (HOs (Suc (Suc r0)) p) (SHOs (Suc (Suc r0)) p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have \"\\<And>qq. qq \\<in> SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p \n              \\<Longrightarrow> \\<mu>p' qq = Some (Vote (Some w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>qq.\n       qq \\<in> SHOs (Suc (Suc r0)) p \\<inter>\n                HOs (Suc (Suc r0)) p \\<Longrightarrow>\n       \\<mu>p' qq = Some (Vote (Some w))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qq.\n       qq \\<in> SHOs (Suc (Suc r0)) p \\<inter>\n                HOs (Suc (Suc r0)) p \\<Longrightarrow>\n       \\<mu>p' qq = Some (Vote (Some w))", "fix qq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qq.\n       qq \\<in> SHOs (Suc (Suc r0)) p \\<inter>\n                HOs (Suc (Suc r0)) p \\<Longrightarrow>\n       \\<mu>p' qq = Some (Vote (Some w))", "assume qqsho:\"qq \\<in> SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p\""], ["proof (state)\nthis:\n  qq \\<in> SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p\n\ngoal (1 subgoal):\n 1. \\<And>qq.\n       qq \\<in> SHOs (Suc (Suc r0)) p \\<inter>\n                HOs (Suc (Suc r0)) p \\<Longrightarrow>\n       \\<mu>p' qq = Some (Vote (Some w))", "from run"], ["proof (chain)\npicking this:\n  SHORun Ute_M rho HOs SHOs", "obtain \\<mu>qq where\n      nxtqq:\"nextState Ute_M (Suc r0) qq (rho (Suc r0) qq)\n                             \\<mu>qq (rho (Suc (Suc r0)) qq)\""], ["proof (prove)\nusing this:\n  SHORun Ute_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>qq.\n        nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n         (rho (Suc (Suc r0)) qq) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ute_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n   (rho (Suc (Suc r0)) qq)\n\ngoal (1 subgoal):\n 1. \\<And>qq.\n       qq \\<in> SHOs (Suc (Suc r0)) p \\<inter>\n                HOs (Suc (Suc r0)) p \\<Longrightarrow>\n       \\<mu>p' qq = Some (Vote (Some w))", "from commR mup' nxtqq votew qqsho"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  \\<mu>p'\n  \\<in> SHOmsgVectors Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)))\n         (HOs (Suc (Suc r0)) p) (SHOs (Suc (Suc r0)) p)\n  nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n   (rho (Suc (Suc r0)) qq)\n  \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w\n  qq \\<in> SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p", "show \"\\<mu>p' qq = Some (Vote (Some w))\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  \\<mu>p'\n  \\<in> SHOmsgVectors Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)))\n         (HOs (Suc (Suc r0)) p) (SHOs (Suc (Suc r0)) p)\n  nextState Ute_M (Suc r0) qq (rho (Suc r0) qq) \\<mu>qq\n   (rho (Suc (Suc r0)) qq)\n  \\<forall>p. vote (rho (Suc (Suc r0)) p) = Some w\n  qq \\<in> SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p\n\ngoal (1 subgoal):\n 1. \\<mu>p' qq = Some (Vote (Some w))", "by (auto dest: termination_argument_2)"], ["proof (state)\nthis:\n  \\<mu>p' qq = Some (Vote (Some w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?qq7\n  \\<in> SHOs (Suc (Suc r0)) p \\<inter>\n        HOs (Suc (Suc r0)) p \\<Longrightarrow>\n  \\<mu>p' ?qq7 = Some (Vote (Some w))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "hence \"SHOs (Suc (Suc r0)) p  \\<inter> HOs (Suc (Suc r0)) p\n           \\<subseteq> {qq. \\<mu>p' qq = Some (Vote (Some w))}\""], ["proof (prove)\nusing this:\n  ?qq7\n  \\<in> SHOs (Suc (Suc r0)) p \\<inter>\n        HOs (Suc (Suc r0)) p \\<Longrightarrow>\n  \\<mu>p' ?qq7 = Some (Vote (Some w))\n\ngoal (1 subgoal):\n 1. SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p\n    \\<subseteq> {qq. \\<mu>p' qq = Some (Vote (Some w))}", "by auto"], ["proof (state)\nthis:\n  SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p\n  \\<subseteq> {qq. \\<mu>p' qq = Some (Vote (Some w))}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "hence wsho: \"card (SHOs (Suc (Suc r0)) p  \\<inter> HOs (Suc (Suc r0)) p)\n                 \\<le> card {qq. \\<mu>p' qq = Some (Vote (Some w))}\""], ["proof (prove)\nusing this:\n  SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p\n  \\<subseteq> {qq. \\<mu>p' qq = Some (Vote (Some w))}\n\ngoal (1 subgoal):\n 1. card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n    \\<le> card {qq. \\<mu>p' qq = Some (Vote (Some w))}", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n  \\<le> card {qq. \\<mu>p' qq = Some (Vote (Some w))}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from stp"], ["proof (chain)\npicking this:\n  step r0 = Suc 0", "have \"step (Suc (Suc r0)) = Suc 0\""], ["proof (prove)\nusing this:\n  step r0 = Suc 0\n\ngoal (1 subgoal):\n 1. step (Suc (Suc r0)) = Suc 0", "unfolding step_def"], ["proof (prove)\nusing this:\n  r0 mod nSteps = Suc 0\n\ngoal (1 subgoal):\n 1. Suc (Suc r0) mod nSteps = Suc 0", "by auto"], ["proof (state)\nthis:\n  step (Suc (Suc r0)) = Suc 0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "with nxtp"], ["proof (chain)\npicking this:\n  nextState Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n   (rho (Suc (Suc (Suc r0))) p)\n  step (Suc (Suc r0)) = Suc 0", "have \"next1 (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n                        (rho (Suc (Suc (Suc r0))) p)\""], ["proof (prove)\nusing this:\n  nextState Ute_M (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n   (rho (Suc (Suc (Suc r0))) p)\n  step (Suc (Suc r0)) = Suc 0\n\ngoal (1 subgoal):\n 1. next1 (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n     (rho (Suc (Suc (Suc r0))) p)", "by (auto simp: Ute_SHOMachine_def nextState_def Ute_nextState_def)"], ["proof (state)\nthis:\n  next1 (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n   (rho (Suc (Suc (Suc r0))) p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "moreover"], ["proof (state)\nthis:\n  next1 (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n   (rho (Suc (Suc (Suc r0))) p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from e"], ["proof (chain)\npicking this:\n  \\<forall>p. E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)", "have \"E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\""], ["proof (prove)\nusing this:\n  \\<forall>p. E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n\ngoal (1 subgoal):\n 1. E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)", "by auto"], ["proof (state)\nthis:\n  E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "with wsho"], ["proof (chain)\npicking this:\n  card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n  \\<le> card {qq. \\<mu>p' qq = Some (Vote (Some w))}\n  E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)", "have majv:\"card {qq. \\<mu>p' qq = Some (Vote (Some w))} > E\""], ["proof (prove)\nusing this:\n  card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n  \\<le> card {qq. \\<mu>p' qq = Some (Vote (Some w))}\n  E < card (SHOs (Suc (Suc r0)) p \\<inter> HOs (Suc (Suc r0)) p)\n\ngoal (1 subgoal):\n 1. E < card {qq. \\<mu>p' qq = Some (Vote (Some w))}", "by auto"], ["proof (state)\nthis:\n  E < card {qq. \\<mu>p' qq = Some (Vote (Some w))}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "ultimately"], ["proof (chain)\npicking this:\n  next1 (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n   (rho (Suc (Suc (Suc r0))) p)\n  E < card {qq. \\<mu>p' qq = Some (Vote (Some w))}", "show ?thesis"], ["proof (prove)\nusing this:\n  next1 (Suc (Suc r0)) p (rho (Suc (Suc r0)) p) \\<mu>p'\n   (rho (Suc (Suc (Suc r0))) p)\n  E < card {qq. \\<mu>p' qq = Some (Vote (Some w))}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "by (auto simp: next1_def)"], ["proof (state)\nthis:\n  \\<exists>r v. decide (rho r p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\ute{} Solves Weak Consensus\\<close>"], ["", "text \\<open>\n  Summing up, all (coarse-grained) runs of \\ute{} for\n  HO and SHO collections that satisfy the communication predicate \n  satisfy the Weak Consensus property.\n\\<close>"], ["", "theorem ute_weak_consensus:\n  assumes run: \"SHORun Ute_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ute_M HOs SHOs\"\n  shows \"weak_consensus (x \\<circ> (rho 0)) decide rho\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_consensus (x \\<circ> rho 0) decide rho", "unfolding weak_consensus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        (\\<forall>p. (x \\<circ> rho 0) p = v) \\<longrightarrow>\n        (\\<forall>n p w.\n            decide (rho n p) = Some w \\<longrightarrow> w = v)) \\<and>\n    (\\<forall>m n p q v w.\n        decide (rho m p) = Some v \\<and>\n        decide (rho n q) = Some w \\<longrightarrow>\n        v = w) \\<and>\n    (\\<forall>p. \\<exists>n. decide (rho n p) \\<noteq> None)", "using ute_validity[OF run commR]\n        ute_agreement[OF run commR]\n        ute_termination[OF run commR commG]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p. x (rho 0 p) = ?v;\n   decide (rho ?r ?p) = Some ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  \\<lbrakk>decide (rho ?m ?p) = Some ?v;\n   decide (rho ?n ?q) = Some ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  \\<exists>r v. decide (rho r ?p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        (\\<forall>p. (x \\<circ> rho 0) p = v) \\<longrightarrow>\n        (\\<forall>n p w.\n            decide (rho n p) = Some w \\<longrightarrow> w = v)) \\<and>\n    (\\<forall>m n p q v w.\n        decide (rho m p) = Some v \\<and>\n        decide (rho n q) = Some w \\<longrightarrow>\n        v = w) \\<and>\n    (\\<forall>p. \\<exists>n. decide (rho n p) \\<noteq> None)", "by auto"], ["", "text \\<open>\n  By the reduction theorem, the correctness of the algorithm carries over\n  to the fine-grained model of runs.\n\\<close>"], ["", "theorem ute_weak_consensus_fg:\n  assumes run: \"fg_run Ute_M rho HOs SHOs (\\<lambda>r q. undefined)\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ute_M HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide (state \\<circ> rho)\"\n    (is \"weak_consensus ?inits _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide\n     (state \\<circ> rho)", "proof (rule local_property_reduction[OF run weak_consensus_is_local])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ute_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "fix crun"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ute_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "assume crun: \"CSHORun Ute_M crun HOs SHOs (\\<lambda>r q. undefined)\"\n     and init: \"crun 0 = state (rho 0)\""], ["proof (state)\nthis:\n  CSHORun Ute_M crun HOs SHOs (\\<lambda>r q. undefined)\n  crun 0 = state (rho 0)\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ute_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "from crun"], ["proof (chain)\npicking this:\n  CSHORun Ute_M crun HOs SHOs (\\<lambda>r q. undefined)", "have \"SHORun Ute_M crun HOs SHOs\""], ["proof (prove)\nusing this:\n  CSHORun Ute_M crun HOs SHOs (\\<lambda>r q. undefined)\n\ngoal (1 subgoal):\n 1. SHORun Ute_M crun HOs SHOs", "by (unfold SHORun_def)"], ["proof (state)\nthis:\n  SHORun Ute_M crun HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ute_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "from this commR commG"], ["proof (chain)\npicking this:\n  SHORun Ute_M crun HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  SHOcommGlobal Ute_M HOs SHOs", "have \"weak_consensus (x \\<circ> (crun 0)) decide crun\""], ["proof (prove)\nusing this:\n  SHORun Ute_M crun HOs SHOs\n  \\<forall>r. SHOcommPerRd Ute_M (HOs r) (SHOs r)\n  SHOcommGlobal Ute_M HOs SHOs\n\ngoal (1 subgoal):\n 1. weak_consensus (x \\<circ> crun 0) decide crun", "by (rule ute_weak_consensus)"], ["proof (state)\nthis:\n  weak_consensus (x \\<circ> crun 0) decide crun\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ute_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "with init"], ["proof (chain)\npicking this:\n  crun 0 = state (rho 0)\n  weak_consensus (x \\<circ> crun 0) decide crun", "show \"weak_consensus ?inits decide crun\""], ["proof (prove)\nusing this:\n  crun 0 = state (rho 0)\n  weak_consensus (x \\<circ> crun 0) decide crun\n\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide crun", "by (simp add: o_def)"], ["proof (state)\nthis:\n  weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide crun\n\ngoal:\nNo subgoals!", "qed"], ["", "end    \\<comment> \\<open>context @{text \"ute_parameters\"}\\<close>"], ["", "end"], ["", "(* theory UteProof *)"]]}