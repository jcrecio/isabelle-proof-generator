{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/eigbyz/EigbyzDefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma finite_Label: \"finite Label\"", "lemma finite_UNIV_Label: \"finite (UNIV::Label set)\"", "lemma finite_Label_set [iff]: \"finite (S :: Label set)\"", "lemma length_lbl [intro]: \"length_lbl l \\<le> Suc f\""], "translations": [["", "lemma finite_Label: \"finite Label\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Label", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite Label", "have \"Label \\<subseteq> {xs. set xs \\<subseteq> (UNIV::Proc set) \\<and> length xs \\<le> Suc f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Label\n    \\<subseteq> {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}", "by (auto simp: Label_def)"], ["proof (state)\nthis:\n  Label\n  \\<subseteq> {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}\n\ngoal (1 subgoal):\n 1. finite Label", "moreover"], ["proof (state)\nthis:\n  Label\n  \\<subseteq> {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}\n\ngoal (1 subgoal):\n 1. finite Label", "have \"finite {xs. set xs \\<subseteq> (UNIV::Proc set) \\<and> length xs \\<le> Suc f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}", "by (rule finite_lists_length_le) auto"], ["proof (state)\nthis:\n  finite {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}\n\ngoal (1 subgoal):\n 1. finite Label", "ultimately"], ["proof (chain)\npicking this:\n  Label\n  \\<subseteq> {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}\n  finite {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}", "show ?thesis"], ["proof (prove)\nusing this:\n  Label\n  \\<subseteq> {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}\n  finite {xs. set xs \\<subseteq> UNIV \\<and> length xs \\<le> Suc f}\n\ngoal (1 subgoal):\n 1. finite Label", "by (auto elim: finite_subset)"], ["proof (state)\nthis:\n  finite Label\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_UNIV_Label: \"finite (UNIV::Label set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "from finite_Label"], ["proof (chain)\npicking this:\n  finite Label", "have \"finite (Abs_Label ` Label)\""], ["proof (prove)\nusing this:\n  finite Label\n\ngoal (1 subgoal):\n 1. finite (Abs_Label ` Label)", "by simp"], ["proof (state)\nthis:\n  finite (Abs_Label ` Label)\n\ngoal (1 subgoal):\n 1. finite UNIV", "moreover"], ["proof (state)\nthis:\n  finite (Abs_Label ` Label)\n\ngoal (1 subgoal):\n 1. finite UNIV", "{"], ["proof (state)\nthis:\n  finite (Abs_Label ` Label)\n\ngoal (1 subgoal):\n 1. finite UNIV", "fix l::Label"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "have \"l \\<in> Abs_Label ` Label\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> Abs_Label ` Label", "by (rule Abs_Label_cases) auto"], ["proof (state)\nthis:\n  l \\<in> Abs_Label ` Label\n\ngoal (1 subgoal):\n 1. finite UNIV", "}"], ["proof (state)\nthis:\n  ?l2 \\<in> Abs_Label ` Label\n\ngoal (1 subgoal):\n 1. finite UNIV", "hence \"(UNIV::Label set) = (Abs_Label ` Label)\""], ["proof (prove)\nusing this:\n  ?l2 \\<in> Abs_Label ` Label\n\ngoal (1 subgoal):\n 1. UNIV = Abs_Label ` Label", "by auto"], ["proof (state)\nthis:\n  UNIV = Abs_Label ` Label\n\ngoal (1 subgoal):\n 1. finite UNIV", "ultimately"], ["proof (chain)\npicking this:\n  finite (Abs_Label ` Label)\n  UNIV = Abs_Label ` Label", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (Abs_Label ` Label)\n  UNIV = Abs_Label ` Label\n\ngoal (1 subgoal):\n 1. finite UNIV", "by simp"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_Label_set [iff]: \"finite (S :: Label set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "using finite_UNIV_Label"], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite S", "by (auto intro: finite_subset)"], ["", "text \\<open>Utility functions on labels.\\<close>"], ["", "definition root_node where\n  \"root_node \\<equiv> Abs_Label []\""], ["", "definition length_lbl where\n  \"length_lbl l \\<equiv> length (Rep_Label l)\""], ["", "(* Don't declare the following [simp] because it would then be simplified away from\n   hypotheses, whereas it can be useful for arithmetic reasoning. *)"], ["", "lemma length_lbl [intro]: \"length_lbl l \\<le> Suc f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_lbl l \\<le> Suc f", "unfolding length_lbl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Rep_Label l) \\<le> Suc f", "using Label_def Rep_Label"], ["proof (prove)\nusing this:\n  Label = {xs. length xs \\<le> Suc f \\<and> distinct xs}\n  Rep_Label ?x \\<in> Label\n\ngoal (1 subgoal):\n 1. length (Rep_Label l) \\<le> Suc f", "by auto"], ["", "definition is_leaf where\n \"is_leaf l \\<equiv> length_lbl l = Suc f\""], ["", "definition last_lbl where\n  \"last_lbl l \\<equiv> last (Rep_Label l)\""], ["", "definition butlast_lbl where\n  \"butlast_lbl l \\<equiv> Abs_Label (butlast (Rep_Label l))\""], ["", "definition set_lbl where\n  \"set_lbl l = set (Rep_Label l)\""], ["", "text \\<open>\n  The children of a non-leaf label are all possible extensions of that label.\n\\<close>"], ["", "(**\ndefinition children where\n  \"children t \\<equiv> { s . s \\<noteq> root_node \\<and> t = butlast_lbl s }\"\n**)"], ["", "definition children where\n  \"children l \\<equiv> \n   if is_leaf l\n   then {} \n   else { Abs_Label (Rep_Label l @ [p]) | p . p \\<notin> set_lbl l }\""], ["", "subsection \\<open>Model of the Algorithm\\<close>"], ["", "text \\<open>\n  The following record models the local state of a process.\n\\<close>"], ["", "record 'val pstate =\n  vals :: \"Label \\<Rightarrow> 'val option\"\n  newvals :: \"Label \\<Rightarrow> 'val\"\n  decide :: \"'val option\""], ["", "text \\<open>\n  Initially, no values are assigned to non-root labels, and an arbitrary value\n  is assigned to the root: that value is interpreted as the initial proposal of\n  the process. No decision has yet been taken, and the \\<open>newvals\\<close> field\n  is unconstrained.\n\\<close>"], ["", "definition EIG_initState (*::\"Proc \\<Rightarrow> 'val pstate \\<Rightarrow> bool\"*) where\n  \"EIG_initState p st \\<equiv>\n     (\\<forall>l. (vals st l = None) = (l \\<noteq> root_node))\n   \\<and> decide st = None\""], ["", "type_synonym 'val Msg = \"Label \\<Rightarrow> 'val option\""], ["", "text \\<open>\n  At every round, every process sends its current \\<open>vals\\<close> tree to all processes.\n  In fact, only the level of the tree corresponding to the round number\n  is used (cf. definition of \\<open>extend_vals\\<close> below).\n\\<close>"], ["", "definition EIG_sendMsg (*:: \"nat \\<Rightarrow> Proc \\<Rightarrow> Proc \\<Rightarrow> 'val pstate \\<Rightarrow> 'val Msg\"*) where\n  \"EIG_sendMsg r p q st \\<equiv> vals st\""], ["", "text \\<open>\n  During the first \\<open>f-1\\<close> rounds, every process extends its\n  tree \\<open>vals\\<close> according to the values received in the round.\n  No decision is taken.\n\\<close>"], ["", "definition extend_vals where\n  \"extend_vals r p st msgs st' \\<equiv>\n   vals st' = (\\<lambda> l.\n      if length_lbl l = Suc r \\<and> msgs (last_lbl l) \\<noteq> None\n      then (the (msgs (last_lbl l))) (butlast_lbl l)\n      else if length_lbl l = Suc r \\<and> msgs (last_lbl l) = None then None\n      else vals st l)\""], ["", "definition next_main where\n  \"next_main r p st msgs st' \\<equiv> extend_vals r p st msgs st' \\<and> decide st' = None\""], ["", "text \\<open>\n  In the final round, in addition to extending the tree as described previously,\n  processes construct the tree \\<open>newvals\\<close>, starting\n  at the leaves. The values at the leaves are copied from \\<open>vals\\<close>,\n  except that missing values \\<open>None\\<close> are replaced by the default value\n  \\<open>undefined\\<close>. Moving up, if there exists a majority value among the \n  children, it is assigned to the parent node, otherwise the parent node\n  receives the default value \\<open>undefined\\<close>. The decision is set to the\n  value computed for the root of the tree.\n\\<close>"], ["", "fun fixupval :: \"'val option \\<Rightarrow> 'val\" where\n  \"fixupval None = undefined\"\n| \"fixupval (Some v) = v\""], ["", "definition has_majority :: \"'val \\<Rightarrow> ('a \\<Rightarrow> 'val) \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"has_majority v g S \\<equiv> card {e \\<in> S. g e = v} > (card S) div 2\""], ["", "definition check_newvals :: \"'val pstate \\<Rightarrow> bool\" where\n  \"check_newvals st \\<equiv>\n   \\<forall>l. is_leaf l \\<and> newvals st l = fixupval (vals st l)\n     \\<or> \\<not>(is_leaf l) \\<and>\n       ( (\\<exists>w. has_majority w (newvals st) (children l) \\<and> newvals st l = w)\n       \\<or> (\\<not>(\\<exists>w. has_majority w (newvals st) (children l))\n             \\<and> newvals st l = undefined))\""], ["", "definition next_end where\n  \"next_end r p st msgs st' \\<equiv> \n     extend_vals r p st msgs st'\n   \\<and> check_newvals st'\n   \\<and> decide st' = Some (newvals st' root_node)\""], ["", "text \\<open>\n  The overall next-state relation is defined such that every process applies\n  \\<open>nextMain\\<close> during rounds \\<open>0\\<close>, \\ldots, \\<open>f-1\\<close>, and applies\n  \\<open>nextEnd\\<close> during round \\<open>f\\<close>. After that, the algorithm terminates\n  and nothing changes anymore.\n\\<close>"], ["", "definition EIG_nextState where\n  \"EIG_nextState r \\<equiv> \n   if r < f then next_main r\n   else if r = f then next_end r\n   else (\\<lambda>p st msgs st'. st' = st)\""], ["", "subsection \\<open>Communication Predicate for \\eigbyz\\<close>"], ["", "text \\<open>\n  The secure kernel \\<open>SKr\\<close> w.r.t. given HO and SHO collections consists\n  of the process from which every process receives the correct message.\n\\<close>"], ["", "definition SKr :: \"Proc HO \\<Rightarrow> Proc HO \\<Rightarrow> Proc set\" where\n  \"SKr HO SHO \\<equiv> { q . \\<forall>p. q \\<in> HO p \\<inter> SHO p}\""], ["", "text \\<open>\n  The secure kernel \\<open>SK\\<close> of an entire execution (i.e., for sequences of\n  HO and SHO collections) is the intersection of the secure kernels for\n  all rounds. Obviously, only the first \\<open>f\\<close> rounds really matter,\n  since the algorithm terminates after that.\n\\<close>"], ["", "definition SK :: \"(nat \\<Rightarrow> Proc HO) \\<Rightarrow> (nat \\<Rightarrow> Proc HO) \\<Rightarrow> Proc set\" where\n  \"SK HOs SHOs \\<equiv> {q. \\<forall>r. q \\<in> SKr (HOs r) (SHOs r)}\""], ["", "text \\<open>\n  The round-by-round predicate requires that the secure kernel at every round\n  contains more than \\<open>(N+f) div 2\\<close> processes.\n\\<close>"], ["", "definition EIG_commPerRd where\n  \"EIG_commPerRd HO SHO \\<equiv> card (SKr HO SHO) > (N + f) div 2\""], ["", "text \\<open>\n  The global predicate requires that the secure kernel for the entire\n  execution contains at least \\<open>N-f\\<close> processes. Messages from these\n  processes are always correctly received by all processes.\n\\<close>"], ["", "definition EIG_commGlobal where\n  \"EIG_commGlobal HOs SHOs \\<equiv> card (SK HOs SHOs) \\<ge> N - f\""], ["", "text \\<open>\n  The above communication predicates differ from Lynch's presentation of\n  \\eigbyz{}. In fact, the algorithm was originally designed for synchronous\n  systems with reliable links and at most \\<open>f\\<close> faulty processes.\n  In such a system, every process receives the correct message from at least\n  the non-faulty processes at every round, and therefore the global predicate\n  \\<open>EIG_commGlobal\\<close> is satisfied. The standard correctness\n  proof assumes that $N>3f$, and therefore $N - f > (N + f) \\div 2$.\n  Since moreover, for any $r$, we obviously have\n  \\[\n   \\bigg(\\bigcap_{p \\in \\Pi, r' \\in \\nat}\\!\\!\\!\\! SHO(p,r')\\bigg)\n   \\ \\subseteq\\ \\bigg(\\bigcap_{p \\in \\Pi} SHO(p,r)\\bigg),\n  \\]\n  it follows that any execution of \\eigbyz{} where $N>3f$ also satisfies\n  \\<open>EIG_commPerRd\\<close> at any round. The standard correctness hypotheses thus imply\n  our communication predicates.\n\n  However, our proof shows that \\eigbyz{} can indeed tolerate more\n  transient faults than the standard bound can express. For example, consider the\n  case where $N=5$ and $f=2$. Our predicates are satisfied in\n  executions where two processes exhibit transient faults, but never fail\n  simultaneously. Indeed, in such an execution, every process receives four\n  correct messages at every round, hence \\<open>EIG_commPerRd\\<close> always holds.\n  Also, \\<open>EIG_commGlobal\\<close> is satisfied because there are\n  three processes from which every process receives the correct messages at all\n  rounds. By our correctness proof, it follows that $EIGByz_f$ then\n  achieves Consensus, unlike what one could expect from the standard correctness\n  predicate. This observation underlines the interest of expressing assumptions\n  about transient faults, as in the HO model.\n\\<close>"], ["", "subsection \\<open>The \\eigbyz{} Heard-Of Machine\\<close>"], ["", "text \\<open>\n  We now define the non-coordinated SHO machine for \\eigbyz{} by assembling\n  the algorithm definition and its communication-predicate.\n\\<close>"], ["", "definition EIG_SHOMachine where\n  \"EIG_SHOMachine = \\<lparr>\n    CinitState =  (\\<lambda> p st crd. EIG_initState p st),\n    sendMsg =  EIG_sendMsg,\n    CnextState = (\\<lambda> r p st msgs crd st'. EIG_nextState r p st msgs st'),\n    SHOcommPerRd = EIG_commPerRd,\n    SHOcommGlobal = EIG_commGlobal \n   \\<rparr>\""], ["", "abbreviation \"EIG_M \\<equiv> (EIG_SHOMachine::(Proc, 'val pstate, 'val Msg) SHOMachine)\""], ["", "end"], ["", "(* theory EIGbyzDefs *)"]]}