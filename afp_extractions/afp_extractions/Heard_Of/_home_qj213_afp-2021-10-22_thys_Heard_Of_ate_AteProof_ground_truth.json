{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/ate/AteProof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma decide_sent_msgs_threshold:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nvp: \"decide (rho r p) \\<noteq> Some v\"\n  and vp: \"decide (rho (Suc r) p) = Some v\"\n  shows \"card {qq. sendMsg Ate_M r qq p (rho r qq) = v} > E - \\<alpha>\"", "lemma other_values_received:\n  assumes comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nxt: \"nextState Ate_M r q (rho r q) \\<mu>q ((rho (Suc r)) q)\"\n  and muq: \"\\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\"\n  and vsent: \"card {qq. sendMsg Ate_M r qq q (rho r qq) = v} > E - \\<alpha>\"\n             (is \"card ?vsent > _\")\n  shows \"card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) \\<le> N + 2*\\<alpha> - E\"", "lemma mostOftenRcvd_v:\n  assumes comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nxt: \"nextState Ate_M r q (rho r q) \\<mu>q ((rho (Suc r)) q)\"\n  and muq: \"\\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\"\n  and threshold_T: \"card {qq. \\<mu>q qq \\<noteq> None} > T\"\n  and threshold_E: \"card {qq. sendMsg Ate_M r qq q (rho r qq) = v} > E - \\<alpha>\"\n  shows \"mostOftenRcvd \\<mu>q = {v}\"", "lemma common_x_induct:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\" \n  and comm: \"SHOcommPerRd Ate_M (HOs (r+k)) (SHOs (r+k))\"\n  and ih: \"card {qq. x (rho (r + k) qq) = v} > E - \\<alpha>\"\n  shows \"card {qq. x (rho (r + Suc k) qq) = v} > E - \\<alpha>\"", "lemma common_x:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd (Ate_M::(Proc, 'val::linorder pstate, 'val) SHOMachine)\n                              (HOs r) (SHOs r)\"\n  and d1: \"decide (rho r p) \\<noteq> Some v\"\n  and d2: \"decide (rho (Suc r) p) = Some v\"\n  and qupdatex: \"x (rho (r + Suc k) q) \\<noteq> x (rho (r + k) q)\"\n  shows \"x (rho (r + Suc k) q) = v\"", "lemma decisionNonNullThenDecided:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n      and dec: \"decide (rho n p) = Some v\"\n  obtains m where \"m < n\"\n              and \"decide (rho m p) \\<noteq> Some v\"\n              and \"decide (rho (Suc m) p) = Some v\"", "theorem ate_validity:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and initv: \"\\<forall>q. x (rho 0 q) = v\"\n  and dp: \"decide (rho r p) = Some w\"\n  shows \"w = v\"", "lemma common_decision:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nvp: \"decide (rho r p) \\<noteq> Some v\"\n  and vp: \"decide (rho (Suc r) p) = Some v\"\n  and nwq: \"decide (rho r q) \\<noteq> Some w\"\n  and wq: \"decide (rho (Suc r) q) = Some w\"\n  shows \"w = v\"", "lemma laterProcessDecidesSameValue :\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nd1: \"decide (rho r p) \\<noteq> Some v\"\n  and d1: \"decide (rho (Suc r) p) = Some v\"\n  and nd2: \"decide (rho (r+k) q) \\<noteq> Some w\"\n  and d2: \"decide (rho (Suc (r+k)) q) = Some w\"\n  shows \"w = v\"", "theorem ate_agreement:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and p: \"decide (rho m p) = Some v\"\n  and q: \"decide (rho n q) = Some w\"\n  shows \"w = v\"", "theorem ate_termination:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and commR: \"\\<forall>r. (SHOcommPerRd::((Proc, 'val::linorder pstate, 'val) SHOMachine)\n                                     \\<Rightarrow> (Proc HO) \\<Rightarrow> (Proc HO) \\<Rightarrow> bool) \n                  Ate_M (HOs r) (SHOs r)\"\n  and commG: \"SHOcommGlobal Ate_M HOs SHOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\"", "theorem ate_weak_consensus:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ate_M HOs SHOs\"\n  shows \"weak_consensus (x \\<circ> (rho 0)) decide rho\"", "theorem ate_weak_consensus_fg:\n  assumes run: \"fg_run Ate_M rho HOs SHOs (\\<lambda>r q. undefined)\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ate_M HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide (state \\<circ> rho)\"\n    (is \"weak_consensus ?inits _ _\")"], "translations": [["", "lemma decide_sent_msgs_threshold:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nvp: \"decide (rho r p) \\<noteq> Some v\"\n  and vp: \"decide (rho (Suc r) p) = Some v\"\n  shows \"card {qq. sendMsg Ate_M r qq p (rho r qq) = v} > E - \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>p\n    where mu: \"\\<mu>p \\<in> SHOmsgVectors Ate_M r p (rho r) (HOs r p) (SHOs r p)\"\n      and nxt: \"nextState Ate_M r p (rho r p) \\<mu>p (rho (Suc r) p)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>\\<mu>p\n                 \\<in> SHOmsgVectors Ate_M r p (rho r) (HOs r p) (SHOs r p);\n         nextState Ate_M r p (rho r p) \\<mu>p (rho (Suc r) p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r p (rho r) (HOs r p) (SHOs r p)\n  nextState Ate_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "from mu"], ["proof (chain)\npicking this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r p (rho r) (HOs r p) (SHOs r p)", "have \"{qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p)\n          \\<subseteq> {qq. sendMsg Ate_M r qq p (rho r qq) = v}\"\n       (is \"?vrcvdp - ?ahop \\<subseteq> ?vsentp\")"], ["proof (prove)\nusing this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r p (rho r) (HOs r p) (SHOs r p)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p)\n    \\<subseteq> {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  {qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p)\n  \\<subseteq> {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "hence \"card (?vrcvdp - ?ahop) \\<le> card ?vsentp\"\n    and \"card (?vrcvdp - ?ahop) \\<ge> card ?vrcvdp - card ?ahop\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p)\n  \\<subseteq> {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p))\n    \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v} &&&\n    card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n    \\<le> card ({qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p))", "by (auto simp: card_mono diff_card_le_card_Diff)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p))\n  \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n  \\<le> card ({qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p))\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "hence \"card ?vsentp \\<ge> card ?vrcvdp - card ?ahop\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p))\n  \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n  \\<le> card ({qq. \\<mu>p qq = Some v} - (HOs r p - SHOs r p))\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n    \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "by auto"], ["proof (state)\nthis:\n  card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "moreover"], ["proof (state)\nthis:\n  card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "from nxt nvp vp"], ["proof (chain)\npicking this:\n  nextState Ate_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v", "have \"card ?vrcvdp > E\""], ["proof (prove)\nusing this:\n  nextState Ate_M r p (rho r p) \\<mu>p (rho (Suc r) p)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n\ngoal (1 subgoal):\n 1. E < card {qq. \\<mu>p qq = Some v}", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  E < card {qq. \\<mu>p qq = Some v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "moreover"], ["proof (state)\nthis:\n  E < card {qq. \\<mu>p qq = Some v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "from comm"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have \"card (HOs r p - SHOs r p) \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. card (HOs r p - SHOs r p) \\<le> \\<alpha>", "by (auto simp: Ate_SHOMachine_def Ate_commPerRd_def)"], ["proof (state)\nthis:\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "ultimately"], ["proof (chain)\npicking this:\n  card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  E < card {qq. \\<mu>p qq = Some v}\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  E < card {qq. \\<mu>p qq = Some v}\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "using Egta"], ["proof (prove)\nusing this:\n  card {qq. \\<mu>p qq = Some v} - card (HOs r p - SHOs r p)\n  \\<le> card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  E < card {qq. \\<mu>p qq = Some v}\n  card (HOs r p - SHOs r p) \\<le> \\<alpha>\n  \\<alpha> < E\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "by auto"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If more than \\<open>E - \\<alpha>\\<close> processes send a value \\<open>v\\<close> to some\n  process \\<open>q\\<close> at some round, then \\<open>q\\<close> will receive at least\n  \\<open>N + 2*\\<alpha> - E\\<close> messages holding \\<open>v\\<close> at this round. \n\\<close>"], ["", "lemma other_values_received:\n  assumes comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nxt: \"nextState Ate_M r q (rho r q) \\<mu>q ((rho (Suc r)) q)\"\n  and muq: \"\\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\"\n  and vsent: \"card {qq. sendMsg Ate_M r qq q (rho r qq) = v} > E - \\<alpha>\"\n             (is \"card ?vsent > _\")\n  shows \"card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) \\<le> N + 2*\\<alpha> - E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "from nxt muq"], ["proof (chain)\npicking this:\n  nextState Ate_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)", "have \"({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) - (HOs r q - SHOs r q)\n        \\<subseteq>  {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\"\n    (is \"?notvrcvd - ?aho \\<subseteq> ?notvsent\")"], ["proof (prove)\nusing this:\n  nextState Ate_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q)\n    \\<subseteq> {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  nextState Ate_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa. (qa \\<in> HOs r q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> SHOs r q \\<inter> HOs r q \\<longrightarrow>\n             \\<mu> qa = Some (sendMsg Ate_M r qa q (rho r qa)))}\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q)\n    \\<subseteq> {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q)\n  \\<subseteq> {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "hence \"card ?notvsent \\<ge> card (?notvrcvd - ?aho)\"\n    and \"card (?notvrcvd - ?aho) \\<ge> card ?notvrcvd - card ?aho\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q)\n  \\<subseteq> {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card\n     ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n      (HOs r q - SHOs r q))\n    \\<le> card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} &&&\n    card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n    card (HOs r q - SHOs r q)\n    \\<le> card\n           ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n            (HOs r q - SHOs r q))", "by (auto simp: card_mono diff_card_le_card_Diff)"], ["proof (state)\nthis:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - SHOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - SHOs r q))\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "moreover"], ["proof (state)\nthis:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - SHOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - SHOs r q))\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "from comm"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have \"card ?aho \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. card (HOs r q - SHOs r q) \\<le> \\<alpha>", "by (auto simp: Ate_SHOMachine_def Ate_commPerRd_def)"], ["proof (state)\nthis:\n  card (HOs r q - SHOs r q) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "moreover"], ["proof (state)\nthis:\n  card (HOs r q - SHOs r q) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "have 1: \"card ?notvsent + card ?vsent = card (?notvsent \\<union> ?vsent)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} +\n    card {qq. sendMsg Ate_M r qq q (rho r qq) = v} =\n    card\n     ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n      {qq. sendMsg Ate_M r qq q (rho r qq) = v})", "by (subst card_Un_Int) auto"], ["proof (state)\nthis:\n  card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} +\n  card {qq. sendMsg Ate_M r qq q (rho r qq) = v} =\n  card\n   ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = v})\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "have \"?notvsent \\<union> ?vsent = (UNIV::Proc set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = v} =\n    UNIV", "by auto"], ["proof (state)\nthis:\n  {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n  {qq. sendMsg Ate_M r qq q (rho r qq) = v} =\n  UNIV\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "hence \"card (?notvsent \\<union> ?vsent) = N\""], ["proof (prove)\nusing this:\n  {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n  {qq. sendMsg Ate_M r qq q (rho r qq) = v} =\n  UNIV\n\ngoal (1 subgoal):\n 1. card\n     ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n      {qq. sendMsg Ate_M r qq q (rho r qq) = v}) =\n    N", "by simp"], ["proof (state)\nthis:\n  card\n   ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = v}) =\n  N\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "with 1 vsent"], ["proof (chain)\npicking this:\n  card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} +\n  card {qq. sendMsg Ate_M r qq q (rho r qq) = v} =\n  card\n   ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = v})\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = v}\n  card\n   ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = v}) =\n  N", "have \"card ?notvsent \\<le>  N - (E + 1 - \\<alpha>)\""], ["proof (prove)\nusing this:\n  card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} +\n  card {qq. sendMsg Ate_M r qq q (rho r qq) = v} =\n  card\n   ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = v})\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = v}\n  card\n   ({qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = v}) =\n  N\n\ngoal (1 subgoal):\n 1. card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n    \\<le> N - (E + 1 - \\<alpha>)", "by auto"], ["proof (state)\nthis:\n  card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "ultimately"], ["proof (chain)\npicking this:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - SHOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - SHOs r q))\n  card (HOs r q - SHOs r q) \\<le> \\<alpha>\n  card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - SHOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - SHOs r q))\n  card (HOs r q - SHOs r q) \\<le> \\<alpha>\n  card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "using EltN Egta"], ["proof (prove)\nusing this:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - SHOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - SHOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - SHOs r q))\n  card (HOs r q - SHOs r q) \\<le> \\<alpha>\n  card {qq. sendMsg Ate_M r qq q (rho r qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)\n  E < N\n  \\<alpha> < E\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "by auto"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If more than \\<open>E - \\<alpha>\\<close> processes send a value \\<open>v\\<close> to some\n  process \\<open>q\\<close> at some round \\<open>r\\<close>, and if \\<open>q\\<close> receives more than\n  \\<open>T\\<close> messages in \\<open>r\\<close>, then \\<open>v\\<close> is the most frequently\n  received value by \\<open>q\\<close> in \\<open>r\\<close>.\n\\<close>"], ["", "lemma mostOftenRcvd_v:\n  assumes comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nxt: \"nextState Ate_M r q (rho r q) \\<mu>q ((rho (Suc r)) q)\"\n  and muq: \"\\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\"\n  and threshold_T: \"card {qq. \\<mu>q qq \\<noteq> None} > T\"\n  and threshold_E: \"card {qq. sendMsg Ate_M r qq q (rho r qq) = v} > E - \\<alpha>\"\n  shows \"mostOftenRcvd \\<mu>q = {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "from muq"], ["proof (chain)\npicking this:\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)", "have hodef:\"HOs r q = {qq. \\<mu>q qq \\<noteq> None}\""], ["proof (prove)\nusing this:\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\n\ngoal (1 subgoal):\n 1. HOs r q = {qq. \\<mu>q qq \\<noteq> None}", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa. (qa \\<in> HOs r q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> SHOs r q \\<inter> HOs r q \\<longrightarrow>\n             \\<mu> qa = Some (sendMsg Ate_M r qa q (rho r qa)))}\n\ngoal (1 subgoal):\n 1. HOs r q = {qq. \\<mu>q qq \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "from comm nxt muq threshold_E"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  nextState Ate_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = v}", "have \"card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) \\<le> N + 2*\\<alpha> - E\"\n    (is \"card ?heardnotv \\<le> _\")"], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  nextState Ate_M r q (rho r q) \\<mu>q (rho (Suc r) q)\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "by (rule other_values_received)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "moreover"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "have \"card ?heardnotv \\<ge> T + 1 - card {qq. \\<mu>q qq = Some v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "from muq"], ["proof (chain)\npicking this:\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)", "have \"?heardnotv = (HOs r q) - {qq. \\<mu>q qq = Some v}\"\n      and \"{qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q\""], ["proof (prove)\nusing this:\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r q (rho r) (HOs r q) (SHOs r q)\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n    HOs r q - {qq. \\<mu>q qq = Some v} &&&\n    {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q", "unfolding SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa. (qa \\<in> HOs r q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> SHOs r q \\<inter> HOs r q \\<longrightarrow>\n             \\<mu> qa = Some (sendMsg Ate_M r qa q (rho r qa)))}\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n    HOs r q - {qq. \\<mu>q qq = Some v} &&&\n    {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n  HOs r q - {qq. \\<mu>q qq = Some v}\n  {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q\n\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "hence \"card ?heardnotv = card (HOs r q) - card {qq. \\<mu>q qq = Some v}\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n  HOs r q - {qq. \\<mu>q qq = Some v}\n  {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n    card (HOs r q) - card {qq. \\<mu>q qq = Some v}", "by (auto simp: card_Diff_subset)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n  card (HOs r q) - card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "with hodef threshold_T"], ["proof (chain)\npicking this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n  card (HOs r q) - card {qq. \\<mu>q qq = Some v}", "show ?thesis"], ["proof (prove)\nusing this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n  card (HOs r q) - card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "by auto"], ["proof (state)\nthis:\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "ultimately"], ["proof (chain)\npicking this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "have \"card {qq. \\<mu>q qq = Some v} > card ?heardnotv\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    < card {qq. \\<mu>q qq = Some v}", "using TNaE"], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  2 * (N + 2 * \\<alpha> - E) \\<le> T\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    < card {qq. \\<mu>q qq = Some v}", "by auto"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "moreover"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "{"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "assume w: \"w \\<noteq> v\""], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "with hodef"], ["proof (chain)\npicking this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  w \\<noteq> v", "have \"{qq. \\<mu>q qq = Some w} \\<subseteq> ?heardnotv\""], ["proof (prove)\nusing this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq = Some w}\n    \\<subseteq> {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq = Some w}\n  \\<subseteq> {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "hence \"card {qq. \\<mu>q qq = Some w} \\<le> card ?heardnotv\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>q qq = Some w}\n  \\<subseteq> {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>q qq = Some w}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card {qq. \\<mu>q qq = Some w}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "}"], ["proof (state)\nthis:\n  ?w7 \\<noteq> v \\<Longrightarrow>\n  card {qq. \\<mu>q qq = Some ?w7}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "ultimately"], ["proof (chain)\npicking this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n  ?w7 \\<noteq> v \\<Longrightarrow>\n  card {qq. \\<mu>q qq = Some ?w7}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "have \"{w. card {qq. \\<mu>q qq = Some w} \\<ge> card {qq. \\<mu>q qq = Some v}} = {v}\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n  ?w7 \\<noteq> v \\<Longrightarrow>\n  card {qq. \\<mu>q qq = Some ?w7}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n    {v}", "by force"], ["proof (state)\nthis:\n  {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n  {v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n  {v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "unfolding mostOftenRcvd_def"], ["proof (prove)\nusing this:\n  {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n  {v}\n\ngoal (1 subgoal):\n 1. {v. \\<forall>w.\n           card {qq. \\<mu>q qq = Some w}\n           \\<le> card {qq. \\<mu>q qq = Some v}} =\n    {v}", "by auto"], ["proof (state)\nthis:\n  mostOftenRcvd \\<mu>q = {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If at some round more than \\<open>E - \\<alpha>\\<close> processes have their \\<open>x\\<close>\n  variable set to \\<open>v\\<close>, then this is also true at next round.\n\\<close>"], ["", "lemma common_x_induct:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\" \n  and comm: \"SHOcommPerRd Ate_M (HOs (r+k)) (SHOs (r+k))\"\n  and ih: \"card {qq. x (rho (r + k) qq) = v} > E - \\<alpha>\"\n  shows \"card {qq. x (rho (r + Suc k) qq) = v} > E - \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "from ih"], ["proof (chain)\npicking this:\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}", "have thrE:\"\\<forall>pp. card {qq. sendMsg Ate_M (r + k) qq pp (rho (r + k) qq) = v}\n                      > E - \\<alpha>\""], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<forall>pp.\n       E - \\<alpha>\n       < card {qq. sendMsg Ate_M (r + k) qq pp (rho (r + k) qq) = v}", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (r + k) qq pp (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "{"], ["proof (state)\nthis:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (r + k) qq pp (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "fix qq"], ["proof (state)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "assume kv:\"x (rho (r + k) qq) = v\""], ["proof (state)\nthis:\n  x (rho (r + k) qq) = v\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>qq\n      where nxt: \"nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq ((rho (Suc (r + k))) qq)\"\n        and muq: \"\\<mu>qq \\<in> SHOmsgVectors Ate_M (r + k) qq (rho (r + k)) \n                                         (HOs (r + k) qq) (SHOs (r + k) qq)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>qq.\n        \\<lbrakk>nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq\n                  (rho (Suc (r + k)) qq);\n         \\<mu>qq\n         \\<in> SHOmsgVectors Ate_M (r + k) qq (rho (r + k)) (HOs (r + k) qq)\n                (SHOs (r + k) qq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq (rho (Suc (r + k)) qq)\n  \\<mu>qq\n  \\<in> SHOmsgVectors Ate_M (r + k) qq (rho (r + k)) (HOs (r + k) qq)\n         (SHOs (r + k) qq)\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "have \"x (rho (r + Suc k) qq) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) qq) = v", "proof (cases \"card {pp. \\<mu>qq pp \\<noteq> None} > T\")"], ["proof (state)\ngoal (2 subgoals):\n 1. T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v\n 2. \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v", "case True"], ["proof (state)\nthis:\n  T < card {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (2 subgoals):\n 1. T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v\n 2. \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v", "with comm nxt muq thrE"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs (r + k)) (SHOs (r + k))\n  nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq (rho (Suc (r + k)) qq)\n  \\<mu>qq\n  \\<in> SHOmsgVectors Ate_M (r + k) qq (rho (r + k)) (HOs (r + k) qq)\n         (SHOs (r + k) qq)\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (r + k) qq pp (rho (r + k) qq) = v}\n  T < card {pp. \\<mu>qq pp \\<noteq> None}", "have \"mostOftenRcvd \\<mu>qq = {v}\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs (r + k)) (SHOs (r + k))\n  nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq (rho (Suc (r + k)) qq)\n  \\<mu>qq\n  \\<in> SHOmsgVectors Ate_M (r + k) qq (rho (r + k)) (HOs (r + k) qq)\n         (SHOs (r + k) qq)\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (r + k) qq pp (rho (r + k) qq) = v}\n  T < card {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>qq = {v}", "by (auto dest: mostOftenRcvd_v)"], ["proof (state)\nthis:\n  mostOftenRcvd \\<mu>qq = {v}\n\ngoal (2 subgoals):\n 1. T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v\n 2. \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v", "with nxt True"], ["proof (chain)\npicking this:\n  nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq (rho (Suc (r + k)) qq)\n  T < card {pp. \\<mu>qq pp \\<noteq> None}\n  mostOftenRcvd \\<mu>qq = {v}", "show \"x (rho (r + Suc k) qq) = v\""], ["proof (prove)\nusing this:\n  nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq (rho (Suc (r + k)) qq)\n  T < card {pp. \\<mu>qq pp \\<noteq> None}\n  mostOftenRcvd \\<mu>qq = {v}\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) qq) = v", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  x (rho (r + Suc k) qq) = v\n\ngoal (1 subgoal):\n 1. \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v", "case False"], ["proof (state)\nthis:\n  \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v", "with nxt"], ["proof (chain)\npicking this:\n  nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq (rho (Suc (r + k)) qq)\n  \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None}", "have \"x (rho (r + Suc k) qq) = x (rho (r + k) qq)\""], ["proof (prove)\nusing this:\n  nextState Ate_M (r + k) qq (rho (r + k) qq) \\<mu>qq (rho (Suc (r + k)) qq)\n  \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) qq) = x (rho (r + k) qq)", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  x (rho (r + Suc k) qq) = x (rho (r + k) qq)\n\ngoal (1 subgoal):\n 1. \\<not> T < card {pp. \\<mu>qq pp \\<noteq> None} \\<Longrightarrow>\n    x (rho (r + Suc k) qq) = v", "with kv"], ["proof (chain)\npicking this:\n  x (rho (r + k) qq) = v\n  x (rho (r + Suc k) qq) = x (rho (r + k) qq)", "show \"x (rho (r + Suc k) qq) = v\""], ["proof (prove)\nusing this:\n  x (rho (r + k) qq) = v\n  x (rho (r + Suc k) qq) = x (rho (r + k) qq)\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) qq) = v", "by simp"], ["proof (state)\nthis:\n  x (rho (r + Suc k) qq) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (r + Suc k) qq) = v\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "}"], ["proof (state)\nthis:\n  x (rho (r + k) ?qq7) = v \\<Longrightarrow> x (rho (r + Suc k) ?qq7) = v\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "hence \"{qq. x (rho (r + k) qq) = v} \\<subseteq> {qq. x (rho (r + Suc k) qq) = v}\""], ["proof (prove)\nusing this:\n  x (rho (r + k) ?qq7) = v \\<Longrightarrow> x (rho (r + Suc k) ?qq7) = v\n\ngoal (1 subgoal):\n 1. {qq. x (rho (r + k) qq) = v}\n    \\<subseteq> {qq. x (rho (r + Suc k) qq) = v}", "by auto"], ["proof (state)\nthis:\n  {qq. x (rho (r + k) qq) = v} \\<subseteq> {qq. x (rho (r + Suc k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "hence \"card {qq. x (rho (r + k) qq) = v} \\<le> card {qq. x (rho (r + Suc k) qq) = v}\""], ["proof (prove)\nusing this:\n  {qq. x (rho (r + k) qq) = v} \\<subseteq> {qq. x (rho (r + Suc k) qq) = v}\n\ngoal (1 subgoal):\n 1. card {qq. x (rho (r + k) qq) = v}\n    \\<le> card {qq. x (rho (r + Suc k) qq) = v}", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card {qq. x (rho (r + k) qq) = v}\n  \\<le> card {qq. x (rho (r + Suc k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "with ih"], ["proof (chain)\npicking this:\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\n  card {qq. x (rho (r + k) qq) = v}\n  \\<le> card {qq. x (rho (r + Suc k) qq) = v}", "show ?thesis"], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\n  card {qq. x (rho (r + k) qq) = v}\n  \\<le> card {qq. x (rho (r + Suc k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "by auto"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Whenever some process newly decides value \\<open>v\\<close>, then any\n  process that updates its \\<open>x\\<close> variable will set it to \\<open>v\\<close>.\n\\<close>"], ["", "(* The proof mainly relies on lemmas @{text decide_sent_msgs_threshold},\n   @{text mostOftenRcvd_v} and @{text common_x_induct}. *)"], ["", "lemma common_x:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd (Ate_M::(Proc, 'val::linorder pstate, 'val) SHOMachine)\n                              (HOs r) (SHOs r)\"\n  and d1: \"decide (rho r p) \\<noteq> Some v\"\n  and d2: \"decide (rho (Suc r) p) = Some v\"\n  and qupdatex: \"x (rho (r + Suc k) q) \\<noteq> x (rho (r + k) q)\"\n  shows \"x (rho (r + Suc k) q) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "from comm"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have \"SHOcommPerRd (Ate_M::(Proc, 'val::linorder pstate, 'val) SHOMachine) \n                     (HOs (r+k)) (SHOs (r+k))\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. SHOcommPerRd Ate_M (HOs (r + k)) (SHOs (r + k))", ".."], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (r + k)) (SHOs (r + k))\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "moreover"], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (r + k)) (SHOs (r + k))\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>q\n    where nxt: \"nextState Ate_M (r+k) q (rho (r+k) q) \\<mu>q (rho (r + Suc k) q)\"\n      and muq: \"\\<mu>q \\<in> SHOmsgVectors Ate_M (r+k) q (rho (r+k))\n                                   (HOs (r+k) q) (SHOs (r+k) q)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>q.\n        \\<lbrakk>nextState Ate_M (r + k) q (rho (r + k) q) \\<mu>q\n                  (rho (r + Suc k) q);\n         \\<mu>q\n         \\<in> SHOmsgVectors Ate_M (r + k) q (rho (r + k)) (HOs (r + k) q)\n                (SHOs (r + k) q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M (r + k) q (rho (r + k) q) \\<mu>q (rho (r + Suc k) q)\n  \\<mu>q\n  \\<in> SHOmsgVectors Ate_M (r + k) q (rho (r + k)) (HOs (r + k) q)\n         (SHOs (r + k) q)\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "moreover"], ["proof (state)\nthis:\n  nextState Ate_M (r + k) q (rho (r + k) q) \\<mu>q (rho (r + Suc k) q)\n  \\<mu>q\n  \\<in> SHOmsgVectors Ate_M (r + k) q (rho (r + k)) (HOs (r + k) q)\n         (SHOs (r + k) q)\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "from nxt qupdatex"], ["proof (chain)\npicking this:\n  nextState Ate_M (r + k) q (rho (r + k) q) \\<mu>q (rho (r + Suc k) q)\n  x (rho (r + Suc k) q) \\<noteq> x (rho (r + k) q)", "have threshold_T: \"card {qq. \\<mu>q qq \\<noteq> None} > T\"\n    and xsmall: \"x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)\""], ["proof (prove)\nusing this:\n  nextState Ate_M (r + k) q (rho (r + k) q) \\<mu>q (rho (r + Suc k) q)\n  x (rho (r + Suc k) q) \\<noteq> x (rho (r + k) q)\n\ngoal (1 subgoal):\n 1. T < card {qq. \\<mu>q qq \\<noteq> None} &&&\n    x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "moreover"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "have \"E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. E - \\<alpha> < card {qq. x (rho (r + 0) qq) = v}\n 2. \\<And>k.\n       E - \\<alpha> < card {qq. x (rho (r + k) qq) = v} \\<Longrightarrow>\n       E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "from run comm d1 d2"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v", "have \"E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "by (auto dest: decide_sent_msgs_threshold)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (2 subgoals):\n 1. E - \\<alpha> < card {qq. x (rho (r + 0) qq) = v}\n 2. \\<And>k.\n       E - \\<alpha> < card {qq. x (rho (r + k) qq) = v} \\<Longrightarrow>\n       E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "thus \"E - \\<alpha> < card {qq. x (rho (r + 0) qq) = v}\""], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + 0) qq) = v}", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. x (rho (r + 0) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha> < card {qq. x (rho (r + k) qq) = v} \\<Longrightarrow>\n       E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha> < card {qq. x (rho (r + k) qq) = v} \\<Longrightarrow>\n       E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha> < card {qq. x (rho (r + k) qq) = v} \\<Longrightarrow>\n       E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "assume \"E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\""], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha> < card {qq. x (rho (r + k) qq) = v} \\<Longrightarrow>\n       E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "with run comm"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}", "show \"E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}", "by (auto dest: common_x_induct)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. x (rho (r + Suc k) qq) = v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "with run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}", "have \"E - \\<alpha> < card {qq. sendMsg Ate_M (r+k) qq q (rho (r+k) qq) = v}\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  E - \\<alpha> < card {qq. x (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = v}", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "ultimately"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs (r + k)) (SHOs (r + k))\n  nextState Ate_M (r + k) q (rho (r + k) q) \\<mu>q (rho (r + Suc k) q)\n  \\<mu>q\n  \\<in> SHOmsgVectors Ate_M (r + k) q (rho (r + k)) (HOs (r + k) q)\n         (SHOs (r + k) q)\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)\n  E - \\<alpha> < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = v}", "have \"mostOftenRcvd \\<mu>q = {v}\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs (r + k)) (SHOs (r + k))\n  nextState Ate_M (r + k) q (rho (r + k) q) \\<mu>q (rho (r + Suc k) q)\n  \\<mu>q\n  \\<in> SHOmsgVectors Ate_M (r + k) q (rho (r + k)) (HOs (r + k) q)\n         (SHOs (r + k) q)\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)\n  E - \\<alpha> < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "by (auto dest:mostOftenRcvd_v)"], ["proof (state)\nthis:\n  mostOftenRcvd \\<mu>q = {v}\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "with xsmall"], ["proof (chain)\npicking this:\n  x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)\n  mostOftenRcvd \\<mu>q = {v}", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (r + Suc k) q) = Min (mostOftenRcvd \\<mu>q)\n  mostOftenRcvd \\<mu>q = {v}\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k) q) = v", "by auto"], ["proof (state)\nthis:\n  x (rho (r + Suc k) q) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A process that holds some decision \\<open>v\\<close> has decided \\<open>v\\<close>\n  sometime in the past.\n\\<close>"], ["", "lemma decisionNonNullThenDecided:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n      and dec: \"decide (rho n p) = Some v\"\n  obtains m where \"m < n\"\n              and \"decide (rho m p) \\<noteq> Some v\"\n              and \"decide (rho (Suc m) p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m < n; decide (rho m p) \\<noteq> Some v;\n         decide (rho (Suc m) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m < n; decide (rho m p) \\<noteq> Some v;\n         decide (rho (Suc m) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let \"?dec k\" = \"decide (rho k p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m < n; decide (rho m p) \\<noteq> Some v;\n         decide (rho (Suc m) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<forall>m<n. ?dec (Suc m) \\<noteq> ?dec m \\<longrightarrow> ?dec (Suc m) \\<noteq> Some v) \\<longrightarrow> ?dec n \\<noteq> Some v\"\n    (is \"?P n\" is \"?A n \\<longrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m<n.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho n p) \\<noteq> Some v", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>m<0.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho 0 p) \\<noteq> Some v\n 2. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "show \"?P 0\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<forall>m<0.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho 0 p) \\<noteq> Some v", "by (auto simp: Ate_SHOMachine_def SHORun_eq HOinitConfig_eq\n                     initState_def Ate_initState_def)"], ["proof (state)\nthis:\n  (\\<forall>m<0.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho 0 p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "assume ih: \"?P n\""], ["proof (state)\nthis:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<forall>m<n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho n p) \\<noteq> Some v \\<Longrightarrow>\n       (\\<forall>m<Suc n.\n           decide (rho (Suc m) p) \\<noteq>\n           decide (rho m p) \\<longrightarrow>\n           decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n       decide (rho (Suc n) p) \\<noteq> Some v", "thus \"?P (Suc n)\""], ["proof (prove)\nusing this:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. (\\<forall>m<Suc n.\n        decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n        decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n    decide (rho (Suc n) p) \\<noteq> Some v", "by force"], ["proof (state)\nthis:\n  (\\<forall>m<Suc n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho (Suc n) p) \\<noteq> Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m < n; decide (rho m p) \\<noteq> Some v;\n         decide (rho (Suc m) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with dec that"], ["proof (chain)\npicking this:\n  decide (rho n p) = Some v\n  \\<lbrakk>?m5 < n; decide (rho ?m5 p) \\<noteq> Some v;\n   decide (rho (Suc ?m5) p) = Some v\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho n p) = Some v\n  \\<lbrakk>?m5 < n; decide (rho ?m5 p) \\<noteq> Some v;\n   decide (rho (Suc ?m5) p) = Some v\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (\\<forall>m<n.\n      decide (rho (Suc m) p) \\<noteq> decide (rho m p) \\<longrightarrow>\n      decide (rho (Suc m) p) \\<noteq> Some v) \\<longrightarrow>\n  decide (rho n p) \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Validity\\<close>"], ["", "text \\<open>\n  Validity asserts that if all processes were initialized with the same value,\n  then no other value may ever be decided.\n\\<close>"], ["", "theorem ate_validity:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and initv: \"\\<forall>q. x (rho 0 q) = v\"\n  and dp: \"decide (rho r p) = Some w\"\n  shows \"w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w = v", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. w = v", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. w = v", "have \"\\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v", "proof (induct r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>qq. sendMsg Ate_M 0 qq p (rho 0 qq) = v\n 2. \\<And>r.\n       \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v \\<Longrightarrow>\n       \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v", "from run initv"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>q. x (rho 0 q) = v", "show \"\\<forall>qq. sendMsg Ate_M 0 qq p (rho 0 qq) = v\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>q. x (rho 0 q) = v\n\ngoal (1 subgoal):\n 1. \\<forall>qq. sendMsg Ate_M 0 qq p (rho 0 qq) = v", "by (auto simp: SHORun_eq SHOnextConfig_eq Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  \\<forall>qq. sendMsg Ate_M 0 qq p (rho 0 qq) = v\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v \\<Longrightarrow>\n       \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v \\<Longrightarrow>\n       \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v \\<Longrightarrow>\n       \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v", "assume ih:\"\\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v\""], ["proof (state)\nthis:\n  \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v \\<Longrightarrow>\n       \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v", "have \"\\<forall>qq. x (rho (Suc r) qq) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qq. x (rho (Suc r) qq) = v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qq. x (rho (Suc r) qq) = v", "fix qq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qq. x (rho (Suc r) qq) = v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>qq\n          where nxt: \"nextState Ate_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)\"\n            and mu: \"\\<mu>qq \\<in> SHOmsgVectors Ate_M r qq (rho r) (HOs r qq) (SHOs r qq)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>qq.\n        \\<lbrakk>nextState Ate_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq);\n         \\<mu>qq\n         \\<in> SHOmsgVectors Ate_M r qq (rho r) (HOs r qq)\n                (SHOs r qq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)\n  \\<mu>qq \\<in> SHOmsgVectors Ate_M r qq (rho r) (HOs r qq) (SHOs r qq)\n\ngoal (1 subgoal):\n 1. \\<And>qq. x (rho (Suc r) qq) = v", "from nxt"], ["proof (chain)\npicking this:\n  nextState Ate_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)", "have \"(card {pp. \\<mu>qq pp \\<noteq> None} > T \\<and> x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq))\n            \\<or> (card {pp. \\<mu>qq pp \\<noteq> None} \\<le> T \\<and> x (rho (Suc r) qq) = x (rho r qq))\""], ["proof (prove)\nusing this:\n  nextState Ate_M r qq (rho r qq) \\<mu>qq (rho (Suc r) qq)\n\ngoal (1 subgoal):\n 1. T < card {pp. \\<mu>qq pp \\<noteq> None} \\<and>\n    x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq) \\<or>\n    card {pp. \\<mu>qq pp \\<noteq> None} \\<le> T \\<and>\n    x (rho (Suc r) qq) = x (rho r qq)", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  T < card {pp. \\<mu>qq pp \\<noteq> None} \\<and>\n  x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq) \\<or>\n  card {pp. \\<mu>qq pp \\<noteq> None} \\<le> T \\<and>\n  x (rho (Suc r) qq) = x (rho r qq)\n\ngoal (1 subgoal):\n 1. \\<And>qq. x (rho (Suc r) qq) = v", "thus \"x (rho (Suc r) qq) = v\""], ["proof (prove)\nusing this:\n  T < card {pp. \\<mu>qq pp \\<noteq> None} \\<and>\n  x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq) \\<or>\n  card {pp. \\<mu>qq pp \\<noteq> None} \\<le> T \\<and>\n  x (rho (Suc r) qq) = x (rho r qq)\n\ngoal (1 subgoal):\n 1. x (rho (Suc r) qq) = v", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v\n 2. \\<lbrakk>card {pp. \\<mu>qq pp \\<noteq> None} \\<le> T;\n     x (rho (Suc r) qq) = x (rho r qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "assume \"x (rho (Suc r) qq) = x (rho r qq)\""], ["proof (state)\nthis:\n  x (rho (Suc r) qq) = x (rho r qq)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v\n 2. \\<lbrakk>card {pp. \\<mu>qq pp \\<noteq> None} \\<le> T;\n     x (rho (Suc r) qq) = x (rho r qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "with ih"], ["proof (chain)\npicking this:\n  \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v\n  x (rho (Suc r) qq) = x (rho r qq)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v\n  x (rho (Suc r) qq) = x (rho r qq)\n\ngoal (1 subgoal):\n 1. x (rho (Suc r) qq) = v", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  x (rho (Suc r) qq) = v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "assume threshold_T:\"T < card {pp. \\<mu>qq pp \\<noteq> None}\"\n             and xsmall:\"x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\""], ["proof (state)\nthis:\n  T < card {pp. \\<mu>qq pp \\<noteq> None}\n  x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "have \"card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w} \\<le> T div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "from comm"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have 1:\"card (HOs r qq - SHOs r qq) \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. card (HOs r qq - SHOs r qq) \\<le> \\<alpha>", "by (auto simp: Ate_SHOMachine_def Ate_commPerRd_def)"], ["proof (state)\nthis:\n  card (HOs r qq - SHOs r qq) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "moreover"], ["proof (state)\nthis:\n  card (HOs r qq - SHOs r qq) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "from mu ih"], ["proof (chain)\npicking this:\n  \\<mu>qq \\<in> SHOmsgVectors Ate_M r qq (rho r) (HOs r qq) (SHOs r qq)\n  \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v", "have \"SHOs r qq \\<inter> HOs r qq \\<subseteq> {pp. \\<mu>qq pp = Some v}\"\n              and \"HOs r qq = {pp. \\<mu>qq pp \\<noteq> None}\""], ["proof (prove)\nusing this:\n  \\<mu>qq \\<in> SHOmsgVectors Ate_M r qq (rho r) (HOs r qq) (SHOs r qq)\n  \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v\n\ngoal (1 subgoal):\n 1. SHOs r qq \\<inter> HOs r qq \\<subseteq> {pp. \\<mu>qq pp = Some v} &&&\n    HOs r qq = {pp. \\<mu>qq pp \\<noteq> None}", "by (auto simp: SHOmsgVectors_def Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  SHOs r qq \\<inter> HOs r qq \\<subseteq> {pp. \\<mu>qq pp = Some v}\n  HOs r qq = {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "hence \"{pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v} \n                   \\<subseteq> HOs r qq - SHOs r qq\""], ["proof (prove)\nusing this:\n  SHOs r qq \\<inter> HOs r qq \\<subseteq> {pp. \\<mu>qq pp = Some v}\n  HOs r qq = {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. {pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v}\n    \\<subseteq> HOs r qq - SHOs r qq", "by auto"], ["proof (state)\nthis:\n  {pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v}\n  \\<subseteq> HOs r qq - SHOs r qq\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "hence \"card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n                      \\<le> card (HOs r qq - SHOs r qq)\""], ["proof (prove)\nusing this:\n  {pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v}\n  \\<subseteq> HOs r qq - SHOs r qq\n\ngoal (1 subgoal):\n 1. card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n    \\<le> card (HOs r qq - SHOs r qq)", "by (auto simp:card_mono)"], ["proof (state)\nthis:\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> card (HOs r qq - SHOs r qq)\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "ultimately"], ["proof (chain)\npicking this:\n  card (HOs r qq - SHOs r qq) \\<le> \\<alpha>\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> card (HOs r qq - SHOs r qq)", "have \"card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v}) \\<le> T div 2\""], ["proof (prove)\nusing this:\n  card (HOs r qq - SHOs r qq) \\<le> \\<alpha>\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> card (HOs r qq - SHOs r qq)\n\ngoal (1 subgoal):\n 1. card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n    \\<le> T div 2", "using Tge2a"], ["proof (prove)\nusing this:\n  card (HOs r qq - SHOs r qq) \\<le> \\<alpha>\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> card (HOs r qq - SHOs r qq)\n  2 * \\<alpha> \\<le> T\n\ngoal (1 subgoal):\n 1. card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n    \\<le> T div 2", "by auto"], ["proof (state)\nthis:\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> T div 2\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "moreover"], ["proof (state)\nthis:\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> T div 2\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "have \"{pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v}\n                  = {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v} =\n    {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}", "by auto"], ["proof (state)\nthis:\n  {pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v} =\n  {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "ultimately"], ["proof (chain)\npicking this:\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> T div 2\n  {pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v} =\n  {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}", "show ?thesis"], ["proof (prove)\nusing this:\n  card ({pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v})\n  \\<le> T div 2\n  {pp. \\<mu>qq pp \\<noteq> None} - {pp. \\<mu>qq pp = Some v} =\n  {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    \\<le> T div 2", "by simp"], ["proof (state)\nthis:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  \\<le> T div 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  \\<le> T div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "moreover"], ["proof (state)\nthis:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  \\<le> T div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "have \"{pp. \\<mu>qq pp \\<noteq> None}\n                = {pp. \\<mu>qq pp = Some v} \\<union> {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\"\n            and \"{pp. \\<mu>qq pp = Some v} \\<inter> {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pp. \\<mu>qq pp \\<noteq> None} =\n    {pp. \\<mu>qq pp = Some v} \\<union>\n    {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w} &&&\n    {pp. \\<mu>qq pp = Some v} \\<inter>\n    {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {pp. \\<mu>qq pp \\<noteq> None} =\n  {pp. \\<mu>qq pp = Some v} \\<union>\n  {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  {pp. \\<mu>qq pp = Some v} \\<inter>\n  {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "hence \"card {pp. \\<mu>qq pp \\<noteq> None}\n                 = card {pp. \\<mu>qq pp = Some v} + card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\""], ["proof (prove)\nusing this:\n  {pp. \\<mu>qq pp \\<noteq> None} =\n  {pp. \\<mu>qq pp = Some v} \\<union>\n  {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  {pp. \\<mu>qq pp = Some v} \\<inter>\n  {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w} =\n  {}\n\ngoal (1 subgoal):\n 1. card {pp. \\<mu>qq pp \\<noteq> None} =\n    card {pp. \\<mu>qq pp = Some v} +\n    card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}", "by (auto simp: card_Un_Int)"], ["proof (state)\nthis:\n  card {pp. \\<mu>qq pp \\<noteq> None} =\n  card {pp. \\<mu>qq pp = Some v} +\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "moreover"], ["proof (state)\nthis:\n  card {pp. \\<mu>qq pp \\<noteq> None} =\n  card {pp. \\<mu>qq pp = Some v} +\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "note threshold_T"], ["proof (state)\nthis:\n  T < card {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "ultimately"], ["proof (chain)\npicking this:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  \\<le> T div 2\n  card {pp. \\<mu>qq pp \\<noteq> None} =\n  card {pp. \\<mu>qq pp = Some v} +\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  T < card {pp. \\<mu>qq pp \\<noteq> None}", "have \"card {pp. \\<mu>qq pp = Some v} > card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\""], ["proof (prove)\nusing this:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  \\<le> T div 2\n  card {pp. \\<mu>qq pp \\<noteq> None} =\n  card {pp. \\<mu>qq pp = Some v} +\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  T < card {pp. \\<mu>qq pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n    < card {pp. \\<mu>qq pp = Some v}", "by auto"], ["proof (state)\nthis:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  < card {pp. \\<mu>qq pp = Some v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "moreover"], ["proof (state)\nthis:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  < card {pp. \\<mu>qq pp = Some v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "{"], ["proof (state)\nthis:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  < card {pp. \\<mu>qq pp = Some v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "assume \"w \\<noteq> v\""], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "hence \"{pp. \\<mu>qq pp = Some w} \\<subseteq> {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\""], ["proof (prove)\nusing this:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. {pp. \\<mu>qq pp = Some w}\n    \\<subseteq> {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}", "by auto"], ["proof (state)\nthis:\n  {pp. \\<mu>qq pp = Some w}\n  \\<subseteq> {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "hence \"card {pp. \\<mu>qq pp = Some w} \\<le> card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\""], ["proof (prove)\nusing this:\n  {pp. \\<mu>qq pp = Some w}\n  \\<subseteq> {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. card {pp. \\<mu>qq pp = Some w}\n    \\<le> card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card {pp. \\<mu>qq pp = Some w}\n  \\<le> card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "}"], ["proof (state)\nthis:\n  ?wa7 \\<noteq> v \\<Longrightarrow>\n  card {pp. \\<mu>qq pp = Some ?wa7}\n  \\<le> card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "ultimately"], ["proof (chain)\npicking this:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  < card {pp. \\<mu>qq pp = Some v}\n  ?wa7 \\<noteq> v \\<Longrightarrow>\n  card {pp. \\<mu>qq pp = Some ?wa7}\n  \\<le> card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}", "have zz:\"\\<And>w. w \\<noteq> v \\<Longrightarrow> \n                       card {pp. \\<mu>qq pp = Some w} < card {pp. \\<mu>qq pp = Some v}\""], ["proof (prove)\nusing this:\n  card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n  < card {pp. \\<mu>qq pp = Some v}\n  ?wa7 \\<noteq> v \\<Longrightarrow>\n  card {pp. \\<mu>qq pp = Some ?wa7}\n  \\<le> card {pp. \\<exists>w. w \\<noteq> v \\<and> \\<mu>qq pp = Some w}\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<noteq> v \\<Longrightarrow>\n       card {pp. \\<mu>qq pp = Some w} < card {pp. \\<mu>qq pp = Some v}", "by force"], ["proof (state)\nthis:\n  ?w5 \\<noteq> v \\<Longrightarrow>\n  card {pp. \\<mu>qq pp = Some ?w5} < card {pp. \\<mu>qq pp = Some v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "hence \"\\<And>w. card {pp. \\<mu>qq pp = Some v} \\<le> card {pp. \\<mu>qq pp = Some w}\n                      \\<Longrightarrow> w = v\""], ["proof (prove)\nusing this:\n  ?w5 \\<noteq> v \\<Longrightarrow>\n  card {pp. \\<mu>qq pp = Some ?w5} < card {pp. \\<mu>qq pp = Some v}\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       card {pp. \\<mu>qq pp = Some v}\n       \\<le> card {pp. \\<mu>qq pp = Some w} \\<Longrightarrow>\n       w = v", "by force"], ["proof (state)\nthis:\n  card {pp. \\<mu>qq pp = Some v}\n  \\<le> card {pp. \\<mu>qq pp = Some ?w5} \\<Longrightarrow>\n  ?w5 = v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "with zz"], ["proof (chain)\npicking this:\n  ?w5 \\<noteq> v \\<Longrightarrow>\n  card {pp. \\<mu>qq pp = Some ?w5} < card {pp. \\<mu>qq pp = Some v}\n  card {pp. \\<mu>qq pp = Some v}\n  \\<le> card {pp. \\<mu>qq pp = Some ?w5} \\<Longrightarrow>\n  ?w5 = v", "have \"mostOftenRcvd \\<mu>qq = {v}\""], ["proof (prove)\nusing this:\n  ?w5 \\<noteq> v \\<Longrightarrow>\n  card {pp. \\<mu>qq pp = Some ?w5} < card {pp. \\<mu>qq pp = Some v}\n  card {pp. \\<mu>qq pp = Some v}\n  \\<le> card {pp. \\<mu>qq pp = Some ?w5} \\<Longrightarrow>\n  ?w5 = v\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>qq = {v}", "by (force simp: mostOftenRcvd_def)"], ["proof (state)\nthis:\n  mostOftenRcvd \\<mu>qq = {v}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < card {pp. \\<mu>qq pp \\<noteq> None};\n     x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\\<rbrakk>\n    \\<Longrightarrow> x (rho (Suc r) qq) = v", "with xsmall"], ["proof (chain)\npicking this:\n  x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\n  mostOftenRcvd \\<mu>qq = {v}", "show \"x (rho (Suc r) qq) = v\""], ["proof (prove)\nusing this:\n  x (rho (Suc r) qq) = Min (mostOftenRcvd \\<mu>qq)\n  mostOftenRcvd \\<mu>qq = {v}\n\ngoal (1 subgoal):\n 1. x (rho (Suc r) qq) = v", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc r) qq) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc r) qq) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qq. x (rho (Suc r) qq) = v\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v \\<Longrightarrow>\n       \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v", "thus \"\\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v\""], ["proof (prove)\nusing this:\n  \\<forall>qq. x (rho (Suc r) qq) = v\n\ngoal (1 subgoal):\n 1. \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  \\<forall>qq. sendMsg Ate_M (Suc r) qq p (rho (Suc r) qq) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = v\n\ngoal (1 subgoal):\n 1. w = v", "}"], ["proof (state)\nthis:\n  \\<forall>qq. sendMsg Ate_M ?ra7 qq p (rho ?ra7 qq) = v\n\ngoal (1 subgoal):\n 1. w = v", "note P = this"], ["proof (state)\nthis:\n  \\<forall>qq. sendMsg Ate_M ?ra7 qq p (rho ?ra7 qq) = v\n\ngoal (1 subgoal):\n 1. w = v", "from run dp"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  decide (rho r p) = Some w", "obtain rp\n    where rp: \"rp < r\" \"decide (rho rp p) \\<noteq> Some w\" \n              \"decide (rho (Suc rp) p) = Some w\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  decide (rho r p) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>rp.\n        \\<lbrakk>rp < r; decide (rho rp p) \\<noteq> Some w;\n         decide (rho (Suc rp) p) = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  rp < r\n  decide (rho rp p) \\<noteq> Some w\n  decide (rho (Suc rp) p) = Some w\n\ngoal (1 subgoal):\n 1. w = v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>p\n    where nxt: \"nextState Ate_M rp p (rho rp p) \\<mu>p (rho (Suc rp) p)\"\n      and mu: \"\\<mu>p \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p) (SHOs rp p)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState Ate_M rp p (rho rp p) \\<mu>p (rho (Suc rp) p);\n         \\<mu>p\n         \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p)\n                (SHOs rp p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M rp p (rho rp p) \\<mu>p (rho (Suc rp) p)\n  \\<mu>p \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p) (SHOs rp p)\n\ngoal (1 subgoal):\n 1. w = v", "{"], ["proof (state)\nthis:\n  nextState Ate_M rp p (rho rp p) \\<mu>p (rho (Suc rp) p)\n  \\<mu>p \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p) (SHOs rp p)\n\ngoal (1 subgoal):\n 1. w = v", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. w = v", "assume w: \"w \\<noteq> v\""], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w = v", "from comm"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have \"card (HOs rp p - SHOs rp p) \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. card (HOs rp p - SHOs rp p) \\<le> \\<alpha>", "by (auto simp: Ate_SHOMachine_def Ate_commPerRd_def)"], ["proof (state)\nthis:\n  card (HOs rp p - SHOs rp p) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. w = v", "moreover"], ["proof (state)\nthis:\n  card (HOs rp p - SHOs rp p) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. w = v", "from mu P"], ["proof (chain)\npicking this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p) (SHOs rp p)\n  \\<forall>qq. sendMsg Ate_M ?ra7 qq p (rho ?ra7 qq) = v", "have \"SHOs rp p \\<inter> HOs rp p \\<subseteq> {pp. \\<mu>p pp = Some v}\"\n      and \"HOs rp p = {pp. \\<mu>p pp \\<noteq> None}\""], ["proof (prove)\nusing this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p) (SHOs rp p)\n  \\<forall>qq. sendMsg Ate_M ?ra7 qq p (rho ?ra7 qq) = v\n\ngoal (1 subgoal):\n 1. SHOs rp p \\<inter> HOs rp p \\<subseteq> {pp. \\<mu>p pp = Some v} &&&\n    HOs rp p = {pp. \\<mu>p pp \\<noteq> None}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  SHOs rp p \\<inter> HOs rp p \\<subseteq> {pp. \\<mu>p pp = Some v}\n  HOs rp p = {pp. \\<mu>p pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. w = v", "hence \"{pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}\n           \\<subseteq> HOs rp p - SHOs rp p\""], ["proof (prove)\nusing this:\n  SHOs rp p \\<inter> HOs rp p \\<subseteq> {pp. \\<mu>p pp = Some v}\n  HOs rp p = {pp. \\<mu>p pp \\<noteq> None}\n\ngoal (1 subgoal):\n 1. {pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}\n    \\<subseteq> HOs rp p - SHOs rp p", "by auto"], ["proof (state)\nthis:\n  {pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}\n  \\<subseteq> HOs rp p - SHOs rp p\n\ngoal (1 subgoal):\n 1. w = v", "hence \"card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n            \\<le> card (HOs rp p - SHOs rp p)\""], ["proof (prove)\nusing this:\n  {pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}\n  \\<subseteq> HOs rp p - SHOs rp p\n\ngoal (1 subgoal):\n 1. card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n    \\<le> card (HOs rp p - SHOs rp p)", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n  \\<le> card (HOs rp p - SHOs rp p)\n\ngoal (1 subgoal):\n 1. w = v", "ultimately"], ["proof (chain)\npicking this:\n  card (HOs rp p - SHOs rp p) \\<le> \\<alpha>\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n  \\<le> card (HOs rp p - SHOs rp p)", "have \"card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}) < E\""], ["proof (prove)\nusing this:\n  card (HOs rp p - SHOs rp p) \\<le> \\<alpha>\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n  \\<le> card (HOs rp p - SHOs rp p)\n\ngoal (1 subgoal):\n 1. card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}) < E", "using Egta"], ["proof (prove)\nusing this:\n  card (HOs rp p - SHOs rp p) \\<le> \\<alpha>\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n  \\<le> card (HOs rp p - SHOs rp p)\n  \\<alpha> < E\n\ngoal (1 subgoal):\n 1. card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}) < E", "by auto"], ["proof (state)\nthis:\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}) < E\n\ngoal (1 subgoal):\n 1. w = v", "moreover"], ["proof (state)\nthis:\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}) < E\n\ngoal (1 subgoal):\n 1. w = v", "from w"], ["proof (chain)\npicking this:\n  w \\<noteq> v", "have \"{pp. \\<mu>p pp = Some w} \n                 \\<subseteq> {pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}\""], ["proof (prove)\nusing this:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. {pp. \\<mu>p pp = Some w}\n    \\<subseteq> {pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}", "by auto"], ["proof (state)\nthis:\n  {pp. \\<mu>p pp = Some w}\n  \\<subseteq> {pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}\n\ngoal (1 subgoal):\n 1. w = v", "hence \"card {pp. \\<mu>p pp = Some w} \n             \\<le> card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\""], ["proof (prove)\nusing this:\n  {pp. \\<mu>p pp = Some w}\n  \\<subseteq> {pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}\n\ngoal (1 subgoal):\n 1. card {pp. \\<mu>p pp = Some w}\n    \\<le> card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card {pp. \\<mu>p pp = Some w}\n  \\<le> card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n\ngoal (1 subgoal):\n 1. w = v", "ultimately"], ["proof (chain)\npicking this:\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}) < E\n  card {pp. \\<mu>p pp = Some w}\n  \\<le> card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})", "have \"card {pp. \\<mu>p pp = Some w} < E\""], ["proof (prove)\nusing this:\n  card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v}) < E\n  card {pp. \\<mu>p pp = Some w}\n  \\<le> card ({pp. \\<mu>p pp \\<noteq> None} - {pp. \\<mu>p pp = Some v})\n\ngoal (1 subgoal):\n 1. card {pp. \\<mu>p pp = Some w} < E", "by simp"], ["proof (state)\nthis:\n  card {pp. \\<mu>p pp = Some w} < E\n\ngoal (1 subgoal):\n 1. w = v", "}"], ["proof (state)\nthis:\n  ?wa7 \\<noteq> v \\<Longrightarrow> card {pp. \\<mu>p pp = Some ?wa7} < E\n\ngoal (1 subgoal):\n 1. w = v", "hence PP: \"\\<And>w. card {pp. \\<mu>p pp = Some w} \\<ge> E \\<Longrightarrow> w = v\""], ["proof (prove)\nusing this:\n  ?wa7 \\<noteq> v \\<Longrightarrow> card {pp. \\<mu>p pp = Some ?wa7} < E\n\ngoal (1 subgoal):\n 1. \\<And>w. E \\<le> card {pp. \\<mu>p pp = Some w} \\<Longrightarrow> w = v", "by force"], ["proof (state)\nthis:\n  E \\<le> card {pp. \\<mu>p pp = Some ?w5} \\<Longrightarrow> ?w5 = v\n\ngoal (1 subgoal):\n 1. w = v", "from rp nxt mu"], ["proof (chain)\npicking this:\n  rp < r\n  decide (rho rp p) \\<noteq> Some w\n  decide (rho (Suc rp) p) = Some w\n  nextState Ate_M rp p (rho rp p) \\<mu>p (rho (Suc rp) p)\n  \\<mu>p \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p) (SHOs rp p)", "have \"card {q. \\<mu>p q = Some w} > E\""], ["proof (prove)\nusing this:\n  rp < r\n  decide (rho rp p) \\<noteq> Some w\n  decide (rho (Suc rp) p) = Some w\n  nextState Ate_M rp p (rho rp p) \\<mu>p (rho (Suc rp) p)\n  \\<mu>p \\<in> SHOmsgVectors Ate_M rp p (rho rp) (HOs rp p) (SHOs rp p)\n\ngoal (1 subgoal):\n 1. E < card {q. \\<mu>p q = Some w}", "by (auto simp: SHOmsgVectors_def Ate_SHOMachine_def \n                   nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  E < card {q. \\<mu>p q = Some w}\n\ngoal (1 subgoal):\n 1. w = v", "with PP"], ["proof (chain)\npicking this:\n  E \\<le> card {pp. \\<mu>p pp = Some ?w5} \\<Longrightarrow> ?w5 = v\n  E < card {q. \\<mu>p q = Some w}", "show ?thesis"], ["proof (prove)\nusing this:\n  E \\<le> card {pp. \\<mu>p pp = Some ?w5} \\<Longrightarrow> ?w5 = v\n  E < card {q. \\<mu>p q = Some w}\n\ngoal (1 subgoal):\n 1. w = v", "by auto"], ["proof (state)\nthis:\n  w = v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Agreement\\<close>"], ["", "text \\<open>\n  If two processes decide at the some round, they decide the same value.\n\\<close>"], ["", "(* The proof mainly relies on lemma @{text decide_sent_msgs_threshold}. *)"], ["", "lemma common_decision:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nvp: \"decide (rho r p) \\<noteq> Some v\"\n  and vp: \"decide (rho (Suc r) p) = Some v\"\n  and nwq: \"decide (rho r q) \\<noteq> Some w\"\n  and wq: \"decide (rho (Suc r) q) = Some w\"\n  shows \"w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w = v", "have gtn: \"card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n             + card {qq. sendMsg Ate_M r qq q (rho r qq) = w} > N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "from run comm nvp vp"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v", "have \"card {qq. sendMsg Ate_M r qq p (rho r qq) = v} > E - \\<alpha>\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "by (rule decide_sent_msgs_threshold)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "moreover"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "from run comm nwq wq"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r q) \\<noteq> Some w\n  decide (rho (Suc r) q) = Some w", "have \"card {qq. sendMsg Ate_M r qq q (rho r qq) = w} > E - \\<alpha>\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r q) \\<noteq> Some w\n  decide (rho (Suc r) q) = Some w\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "by (rule decide_sent_msgs_threshold)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = w}\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "ultimately"], ["proof (chain)\npicking this:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "show ?thesis"], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = w}\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "using majE"], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (rho r qq) = w}\n  N \\<le> 2 * (E - \\<alpha>)\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M r qq q (rho r qq) = w}", "by auto"], ["proof (state)\nthis:\n  N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n      card {qq. sendMsg Ate_M r qq q (rho r qq) = w}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n      card {qq. sendMsg Ate_M r qq q (rho r qq) = w}\n\ngoal (1 subgoal):\n 1. w = v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "assume vw:\"w \\<noteq> v\""], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "have \"\\<forall>qq. sendMsg Ate_M r qq p (rho r qq) = sendMsg Ate_M r qq q (rho r qq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qq.\n       sendMsg Ate_M r qq p (rho r qq) = sendMsg Ate_M r qq q (rho r qq)", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  \\<forall>qq.\n     sendMsg Ate_M r qq p (rho r qq) = sendMsg Ate_M r qq q (rho r qq)\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "with vw"], ["proof (chain)\npicking this:\n  w \\<noteq> v\n  \\<forall>qq.\n     sendMsg Ate_M r qq p (rho r qq) = sendMsg Ate_M r qq q (rho r qq)", "have \"{qq. sendMsg Ate_M r qq p (rho r qq) = v}\n          \\<inter> {qq. sendMsg Ate_M r qq q (rho r qq) = w} = {}\""], ["proof (prove)\nusing this:\n  w \\<noteq> v\n  \\<forall>qq.\n     sendMsg Ate_M r qq p (rho r qq) = sendMsg Ate_M r qq q (rho r qq)\n\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = w} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M r qq q (rho r qq) = w} =\n  {}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "with gtn"], ["proof (chain)\npicking this:\n  N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n      card {qq. sendMsg Ate_M r qq q (rho r qq) = w}\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M r qq q (rho r qq) = w} =\n  {}", "have \"card ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \n                 \\<union> {qq. sendMsg Ate_M r qq q (rho r qq) = w}) > N\""], ["proof (prove)\nusing this:\n  N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n      card {qq. sendMsg Ate_M r qq q (rho r qq) = w}\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M r qq q (rho r qq) = w} =\n  {}\n\ngoal (1 subgoal):\n 1. N < card\n         ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n          {qq. sendMsg Ate_M r qq q (rho r qq) = w})", "by (auto simp: card_Un_Int)"], ["proof (state)\nthis:\n  N < card\n       ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n        {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  N < card\n       ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n        {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "have \"card ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \n                 \\<union> {qq. sendMsg Ate_M r qq q (rho r qq) = w}) \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n      {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n    \\<le> N", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card\n   ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n  \\<le> N\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  N < card\n       ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n        {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n  card\n   ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n  \\<le> N", "show \"False\""], ["proof (prove)\nusing this:\n  N < card\n       ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n        {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n  card\n   ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n    {qq. sendMsg Ate_M r qq q (rho r qq) = w})\n  \\<le> N\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w = v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If process \\<open>p\\<close> decides at step \\<open>r\\<close> and process \\<open>q\\<close> decides\n  at some later step \\<open>r+k\\<close> then \\<open>p\\<close> and \\<open>q\\<close> decide the\n  same value.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text common_decision}, @{text common_x},\n  @{text decide_with_threshold_E}, @{text unique_majority_E_\\<alpha>} \n  and @{text  decide_sent_msgs_threshold}.\n*)"], ["", "lemma laterProcessDecidesSameValue :\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and nd1: \"decide (rho r p) \\<noteq> Some v\"\n  and d1: \"decide (rho (Suc r) p) = Some v\"\n  and nd2: \"decide (rho (r+k) q) \\<noteq> Some w\"\n  and d2: \"decide (rho (Suc (r+k)) q) = Some w\"\n  shows \"w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "assume vdifw:\"w \\<noteq> v\""], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "have kgt0: \"k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < k \\<Longrightarrow> False", "assume \"\\<not> k > 0\""], ["proof (state)\nthis:\n  \\<not> 0 < k\n\ngoal (1 subgoal):\n 1. \\<not> 0 < k \\<Longrightarrow> False", "hence \"k = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < k\n\ngoal (1 subgoal):\n 1. k = 0", "by auto"], ["proof (state)\nthis:\n  k = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < k \\<Longrightarrow> False", "with run comm nd1 d1 nd2 d2"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  decide (rho (r + k) q) \\<noteq> Some w\n  decide (rho (Suc (r + k)) q) = Some w\n  k = 0", "have \"w = v\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  decide (rho (r + k) q) \\<noteq> Some w\n  decide (rho (Suc (r + k)) q) = Some w\n  k = 0\n\ngoal (1 subgoal):\n 1. w = v", "by (auto dest: common_decision)"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<not> 0 < k \\<Longrightarrow> False", "with vdifw"], ["proof (chain)\npicking this:\n  w \\<noteq> v\n  w = v", "show False"], ["proof (prove)\nusing this:\n  w \\<noteq> v\n  w = v\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "have 1: \"{qq. sendMsg Ate_M r qq p (rho r qq) = v}\n           \\<inter> {qq. sendMsg Ate_M (r+k) qq q (rho (r+k) qq) = w} = {}\"\n    (is \"?sentv \\<inter> ?sentw = {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} =\n    {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n  {}", "obtain qq\n      where xrv: \"x (rho r qq) = v\" and rkw: \"x (rho (r+k) qq) = w\""], ["proof (prove)\nusing this:\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<lbrakk>x (rho r qq) = v; x (rho (r + k) qq) = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  x (rho r qq) = v\n  x (rho (r + k) qq) = w\n\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n    {} \\<Longrightarrow>\n    False", "have \"\\<exists>k' < k. x (rho (r + k') qq) \\<noteq> w \\<and> x (rho (r + Suc k') qq) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k'<k.\n       x (rho (r + k') qq) \\<noteq> w \\<and> x (rho (r + Suc k') qq) = w", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "assume f: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>k'<k.\n             x (rho (r + k') qq) \\<noteq> w \\<and>\n             x (rho (r + Suc k') qq) = w)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<not> (\\<exists>k'<k.\n             x (rho (r + k') qq) \\<noteq> w \\<and>\n             x (rho (r + Suc k') qq) = w)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "assume kk':\"k' < k\""], ["proof (state)\nthis:\n  k' < k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "hence \"x (rho (r + k') qq) \\<noteq> w\""], ["proof (prove)\nusing this:\n  k' < k\n\ngoal (1 subgoal):\n 1. x (rho (r + k') qq) \\<noteq> w", "proof (induct k')"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < k \\<Longrightarrow> x (rho (r + 0) qq) \\<noteq> w\n 2. \\<And>k'.\n       \\<lbrakk>k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w;\n        Suc k' < k\\<rbrakk>\n       \\<Longrightarrow> x (rho (r + Suc k') qq) \\<noteq> w", "from xrv vdifw"], ["proof (chain)\npicking this:\n  x (rho r qq) = v\n  w \\<noteq> v", "show \"x (rho (r + 0) qq) \\<noteq> w\""], ["proof (prove)\nusing this:\n  x (rho r qq) = v\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. x (rho (r + 0) qq) \\<noteq> w", "by simp"], ["proof (state)\nthis:\n  x (rho (r + 0) qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w;\n        Suc k' < k\\<rbrakk>\n       \\<Longrightarrow> x (rho (r + Suc k') qq) \\<noteq> w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w;\n        Suc k' < k\\<rbrakk>\n       \\<Longrightarrow> x (rho (r + Suc k') qq) \\<noteq> w", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w;\n        Suc k' < k\\<rbrakk>\n       \\<Longrightarrow> x (rho (r + Suc k') qq) \\<noteq> w", "assume ih:\"k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w\"\n             and ksk':\"Suc k' < k\""], ["proof (state)\nthis:\n  k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w\n  Suc k' < k\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w;\n        Suc k' < k\\<rbrakk>\n       \\<Longrightarrow> x (rho (r + Suc k') qq) \\<noteq> w", "from ksk'"], ["proof (chain)\npicking this:\n  Suc k' < k", "have \"k' < k\""], ["proof (prove)\nusing this:\n  Suc k' < k\n\ngoal (1 subgoal):\n 1. k' < k", "by simp"], ["proof (state)\nthis:\n  k' < k\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       \\<lbrakk>k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w;\n        Suc k' < k\\<rbrakk>\n       \\<Longrightarrow> x (rho (r + Suc k') qq) \\<noteq> w", "with ih f"], ["proof (chain)\npicking this:\n  k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w\n  \\<not> (\\<exists>k'<k.\n             x (rho (r + k') qq) \\<noteq> w \\<and>\n             x (rho (r + Suc k') qq) = w)\n  k' < k", "show \"x (rho (r + Suc k') qq) \\<noteq> w\""], ["proof (prove)\nusing this:\n  k' < k \\<Longrightarrow> x (rho (r + k') qq) \\<noteq> w\n  \\<not> (\\<exists>k'<k.\n             x (rho (r + k') qq) \\<noteq> w \\<and>\n             x (rho (r + Suc k') qq) = w)\n  k' < k\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k') qq) \\<noteq> w", "by auto"], ["proof (state)\nthis:\n  x (rho (r + Suc k') qq) \\<noteq> w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (r + k') qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  ?k'7 < k \\<Longrightarrow> x (rho (r + ?k'7) qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "with f"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>k'<k.\n             x (rho (r + k') qq) \\<noteq> w \\<and>\n             x (rho (r + Suc k') qq) = w)\n  ?k'7 < k \\<Longrightarrow> x (rho (r + ?k'7) qq) \\<noteq> w", "have \"\\<forall>k' < k. x (rho (r + Suc k') qq) \\<noteq> w\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>k'<k.\n             x (rho (r + k') qq) \\<noteq> w \\<and>\n             x (rho (r + Suc k') qq) = w)\n  ?k'7 < k \\<Longrightarrow> x (rho (r + ?k'7) qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<forall>k'<k. x (rho (r + Suc k') qq) \\<noteq> w", "by auto"], ["proof (state)\nthis:\n  \\<forall>k'<k. x (rho (r + Suc k') qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<forall>k'<k. x (rho (r + Suc k') qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "from kgt0"], ["proof (chain)\npicking this:\n  0 < k", "have \"k - 1 < k\" and kk:\"Suc (k - 1) = k\""], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. k - 1 < k &&& Suc (k - 1) = k", "by auto"], ["proof (state)\nthis:\n  k - 1 < k\n  Suc (k - 1) = k\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k'<k. x (rho (r + Suc k') qq) \\<noteq> w\n  k - 1 < k\n  Suc (k - 1) = k", "have \"x (rho (r + Suc (k - 1)) qq) \\<noteq> w\""], ["proof (prove)\nusing this:\n  \\<forall>k'<k. x (rho (r + Suc k') qq) \\<noteq> w\n  k - 1 < k\n  Suc (k - 1) = k\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc (k - 1)) qq) \\<noteq> w", "by blast"], ["proof (state)\nthis:\n  x (rho (r + Suc (k - 1)) qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k'<k.\n               x (rho (r + k') qq) \\<noteq> w \\<and>\n               x (rho (r + Suc k') qq) = w) \\<Longrightarrow>\n    False", "with rkw kk"], ["proof (chain)\npicking this:\n  x (rho (r + k) qq) = w\n  Suc (k - 1) = k\n  x (rho (r + Suc (k - 1)) qq) \\<noteq> w", "show \"False\""], ["proof (prove)\nusing this:\n  x (rho (r + k) qq) = w\n  Suc (k - 1) = k\n  x (rho (r + Suc (k - 1)) qq) \\<noteq> w\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k'<k.\n     x (rho (r + k') qq) \\<noteq> w \\<and> x (rho (r + Suc k') qq) = w\n\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>k'<k.\n     x (rho (r + k') qq) \\<noteq> w \\<and> x (rho (r + Suc k') qq) = w", "obtain k'\n      where \"k' < k\" \n        and w: \"x (rho (r + Suc k') qq) = w\"\n        and qqupdatex: \"x (rho (r + Suc k') qq) \\<noteq> x (rho (r + k') qq)\""], ["proof (prove)\nusing this:\n  \\<exists>k'<k.\n     x (rho (r + k') qq) \\<noteq> w \\<and> x (rho (r + Suc k') qq) = w\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>k' < k; x (rho (r + Suc k') qq) = w;\n         x (rho (r + Suc k') qq) \\<noteq> x (rho (r + k') qq)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k' < k\n  x (rho (r + Suc k') qq) = w\n  x (rho (r + Suc k') qq) \\<noteq> x (rho (r + k') qq)\n\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from run comm nd1 d1 qqupdatex"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  x (rho (r + Suc k') qq) \\<noteq> x (rho (r + k') qq)", "have \"x (rho (r + Suc k') qq) = v\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n  x (rho (r + Suc k') qq) \\<noteq> x (rho (r + k') qq)\n\ngoal (1 subgoal):\n 1. x (rho (r + Suc k') qq) = v", "by (rule common_x)"], ["proof (state)\nthis:\n  x (rho (r + Suc k') qq) = v\n\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with w vdifw"], ["proof (chain)\npicking this:\n  x (rho (r + Suc k') qq) = w\n  w \\<noteq> v\n  x (rho (r + Suc k') qq) = v", "show False"], ["proof (prove)\nusing this:\n  x (rho (r + Suc k') qq) = w\n  w \\<noteq> v\n  x (rho (r + Suc k') qq) = v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} =\n  {}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "from run comm nd1 d1"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v", "have sentv: \"card ?sentv > E - \\<alpha>\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho r p) \\<noteq> Some v\n  decide (rho (Suc r) p) = Some v\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}", "by (auto dest: decide_sent_msgs_threshold)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "from run comm nd2 d2"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho (r + k) q) \\<noteq> Some w\n  decide (rho (Suc (r + k)) q) = Some w", "have \"card ?sentw > E - \\<alpha>\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  decide (rho (r + k) q) \\<noteq> Some w\n  decide (rho (Suc (r + k)) q) = Some w\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}", "by (auto dest: decide_sent_msgs_threshold)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "with sentv majE"], ["proof (chain)\npicking this:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  N \\<le> 2 * (E - \\<alpha>)\n  E - \\<alpha> < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}", "have \"(card ?sentv) + (card ?sentw) > N\""], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (rho r qq) = v}\n  N \\<le> 2 * (E - \\<alpha>)\n  E - \\<alpha> < card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}\n\ngoal (1 subgoal):\n 1. N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n        card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}", "by simp"], ["proof (state)\nthis:\n  N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n      card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "with 1 vdifw"], ["proof (chain)\npicking this:\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} =\n  {}\n  w \\<noteq> v\n  N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n      card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}", "have 2: \"card (?sentv \\<union> ?sentw) > N\""], ["proof (prove)\nusing this:\n  {qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<inter>\n  {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w} =\n  {}\n  w \\<noteq> v\n  N < card {qq. sendMsg Ate_M r qq p (rho r qq) = v} +\n      card {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w}\n\ngoal (1 subgoal):\n 1. N < card\n         ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n          {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})", "by (auto simp: card_Un_Int)"], ["proof (state)\nthis:\n  N < card\n       ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n        {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "have \"card (?sentv \\<union> ?sentw) \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n      {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})\n    \\<le> N", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card\n   ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})\n  \\<le> N\n\ngoal (1 subgoal):\n 1. w \\<noteq> v \\<Longrightarrow> False", "with 2"], ["proof (chain)\npicking this:\n  N < card\n       ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n        {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})\n  card\n   ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})\n  \\<le> N", "show \"False\""], ["proof (prove)\nusing this:\n  N < card\n       ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n        {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})\n  card\n   ({qq. sendMsg Ate_M r qq p (rho r qq) = v} \\<union>\n    {qq. sendMsg Ate_M (r + k) qq q (rho (r + k) qq) = w})\n  \\<le> N\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The Agreement property is now an immediate consequence.\n\\<close>"], ["", "(*\n  The proof mainly relies on lemmas @{text decisionNonNullThenDecided}\n  and @{text laterProcessDecidesSameValue}.\n*)"], ["", "theorem ate_agreement:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and comm: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n  and p: \"decide (rho m p) = Some v\"\n  and q: \"decide (rho n q) = Some w\"\n  shows \"w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w = v", "from run p"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  decide (rho m p) = Some v", "obtain k where\n    k: \"k < m\" \"decide (rho k p) \\<noteq> Some v\" \"decide (rho (Suc k) p) = Some v\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  decide (rho m p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < m; decide (rho k p) \\<noteq> Some v;\n         decide (rho (Suc k) p) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  k < m\n  decide (rho k p) \\<noteq> Some v\n  decide (rho (Suc k) p) = Some v\n\ngoal (1 subgoal):\n 1. w = v", "from run q"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  decide (rho n q) = Some w", "obtain l where\n    l: \"l < n\" \"decide (rho l q) \\<noteq> Some w\" \"decide (rho (Suc l) q) = Some w\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  decide (rho n q) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l < n; decide (rho l q) \\<noteq> Some w;\n         decide (rho (Suc l) q) = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule decisionNonNullThenDecided)"], ["proof (state)\nthis:\n  l < n\n  decide (rho l q) \\<noteq> Some w\n  decide (rho (Suc l) q) = Some w\n\ngoal (1 subgoal):\n 1. w = v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v", "proof (cases \"k \\<le> l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> w = v\n 2. \\<not> k \\<le> l \\<Longrightarrow> w = v", "case True"], ["proof (state)\nthis:\n  k \\<le> l\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> w = v\n 2. \\<not> k \\<le> l \\<Longrightarrow> w = v", "then"], ["proof (chain)\npicking this:\n  k \\<le> l", "obtain i where \"l = k+i\""], ["proof (prove)\nusing this:\n  k \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<And>i. l = k + i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: le_iff_add)"], ["proof (state)\nthis:\n  l = k + i\n\ngoal (2 subgoals):\n 1. k \\<le> l \\<Longrightarrow> w = v\n 2. \\<not> k \\<le> l \\<Longrightarrow> w = v", "with run comm k l"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  k < m\n  decide (rho k p) \\<noteq> Some v\n  decide (rho (Suc k) p) = Some v\n  l < n\n  decide (rho l q) \\<noteq> Some w\n  decide (rho (Suc l) q) = Some w\n  l = k + i", "show ?thesis"], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  k < m\n  decide (rho k p) \\<noteq> Some v\n  decide (rho (Suc k) p) = Some v\n  l < n\n  decide (rho l q) \\<noteq> Some w\n  decide (rho (Suc l) q) = Some w\n  l = k + i\n\ngoal (1 subgoal):\n 1. w = v", "by (auto dest: laterProcessDecidesSameValue)"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> w = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> w = v", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> l\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> w = v", "hence \"l \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> l\n\ngoal (1 subgoal):\n 1. l \\<le> k", "by simp"], ["proof (state)\nthis:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> w = v", "then"], ["proof (chain)\npicking this:\n  l \\<le> k", "obtain i where m: \"k = l+i\""], ["proof (prove)\nusing this:\n  l \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<And>i. k = l + i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: le_iff_add)"], ["proof (state)\nthis:\n  k = l + i\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> l \\<Longrightarrow> w = v", "with run comm k l"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  k < m\n  decide (rho k p) \\<noteq> Some v\n  decide (rho (Suc k) p) = Some v\n  l < n\n  decide (rho l q) \\<noteq> Some w\n  decide (rho (Suc l) q) = Some w\n  k = l + i", "show ?thesis"], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  k < m\n  decide (rho k p) \\<noteq> Some v\n  decide (rho (Suc k) p) = Some v\n  l < n\n  decide (rho l q) \\<noteq> Some w\n  decide (rho (Suc l) q) = Some w\n  k = l + i\n\ngoal (1 subgoal):\n 1. w = v", "by (auto dest: laterProcessDecidesSameValue)"], ["proof (state)\nthis:\n  w = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w = v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Termination\\<close>"], ["", "text \\<open>\n  We now prove that every process must eventually decide, given the\n  global and round-by-round communication predicates.\n\\<close>"], ["", "(* The proof relies on previous lemmas @{text common_x_induct} and @{text mostOftenRcvd_v}. *)"], ["", "theorem ate_termination:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n  and commR: \"\\<forall>r. (SHOcommPerRd::((Proc, 'val::linorder pstate, 'val) SHOMachine)\n                                     \\<Rightarrow> (Proc HO) \\<Rightarrow> (Proc HO) \\<Rightarrow> bool) \n                  Ate_M (HOs r) (SHOs r)\"\n  and commG: \"SHOcommGlobal Ate_M HOs SHOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from commG"], ["proof (chain)\npicking this:\n  SHOcommGlobal Ate_M HOs SHOs", "obtain r' \\<pi>1 \\<pi>2\n    where \\<pi>ea: \"card \\<pi>1 > E - \\<alpha>\"\n      and \\<pi>t: \"card \\<pi>2 > T\"\n      and  hosho: \"\\<forall>p \\<in> \\<pi>1. (HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2)\""], ["proof (prove)\nusing this:\n  SHOcommGlobal Ate_M HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>1 \\<pi>2 r'.\n        \\<lbrakk>E - \\<alpha> < card \\<pi>1; T < card \\<pi>2;\n         \\<forall>p\\<in>\\<pi>1.\n            HOs r' p = \\<pi>2 \\<and>\n            SHOs r' p \\<inter> HOs r' p = \\<pi>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ate_SHOMachine_def Ate_commGlobal_def)"], ["proof (state)\nthis:\n  E - \\<alpha> < card \\<pi>1\n  T < card \\<pi>2\n  \\<forall>p\\<in>\\<pi>1.\n     HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "obtain v where\n    P1: \"\\<forall>pp. card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v} > E - \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>p \\<in> \\<pi>1. \\<forall>q \\<in> \\<pi>1. x (rho (Suc r') p) = x (rho (Suc r') q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>\\<pi>1.\n       \\<forall>q\\<in>\\<pi>1. x (rho (Suc r') p) = x (rho (Suc r') q)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "assume p: \"p \\<in> \\<pi>1\" and q: \"q \\<in> \\<pi>1\""], ["proof (state)\nthis:\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>p\n        where nxtp: \"nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\"\n          and mup: \"\\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p);\n         \\<mu>p\n         \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p)\n                (SHOs r' p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>q\n        where nxtq: \"nextState Ate_M r' q (rho r' q) \\<mu>q (rho (Suc r') q)\"\n          and muq: \"\\<mu>q \\<in> SHOmsgVectors Ate_M r' q (rho r') (HOs r' q) (SHOs r' q)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>q.\n        \\<lbrakk>nextState Ate_M r' q (rho r' q) \\<mu>q (rho (Suc r') q);\n         \\<mu>q\n         \\<in> SHOmsgVectors Ate_M r' q (rho r') (HOs r' q)\n                (SHOs r' q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M r' q (rho r' q) \\<mu>q (rho (Suc r') q)\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r' q (rho r') (HOs r' q) (SHOs r' q)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "from mup muq p q"], ["proof (chain)\npicking this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r' q (rho r') (HOs r' q) (SHOs r' q)\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1", "have \"{qq. \\<mu>q qq \\<noteq> None}  = HOs r' q\"\n        and 2:\"{qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n               \\<supseteq> SHOs r' q \\<inter> HOs r' q\"\n        and \"{qq. \\<mu>p qq \\<noteq> None}  = HOs r' p\"\n        and 4:\"{qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n               \\<supseteq> SHOs r' p \\<inter> HOs r' p\""], ["proof (prove)\nusing this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)\n  \\<mu>q \\<in> SHOmsgVectors Ate_M r' q (rho r') (HOs r' q) (SHOs r' q)\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n\ngoal (1 subgoal):\n 1. ({qq. \\<mu>q qq \\<noteq> None} = HOs r' q &&&\n     SHOs r' q \\<inter> HOs r' q\n     \\<subseteq> {qq.\n                  \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}) &&&\n    {qq. \\<mu>p qq \\<noteq> None} = HOs r' p &&&\n    SHOs r' p \\<inter> HOs r' p\n    \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq \\<noteq> None} = HOs r' q\n  SHOs r' q \\<inter> HOs r' q\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n  {qq. \\<mu>p qq \\<noteq> None} = HOs r' p\n  SHOs r' p \\<inter> HOs r' p\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "with p q hosho"], ["proof (chain)\npicking this:\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n  \\<forall>p\\<in>\\<pi>1.\n     HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2\n  {qq. \\<mu>q qq \\<noteq> None} = HOs r' q\n  SHOs r' q \\<inter> HOs r' q\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n  {qq. \\<mu>p qq \\<noteq> None} = HOs r' p\n  SHOs r' p \\<inter> HOs r' p\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}", "have aa:\"\\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\"\n        and cc:\"\\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\""], ["proof (prove)\nusing this:\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n  \\<forall>p\\<in>\\<pi>1.\n     HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2\n  {qq. \\<mu>q qq \\<noteq> None} = HOs r' q\n  SHOs r' q \\<inter> HOs r' q\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n  {qq. \\<mu>p qq \\<noteq> None} = HOs r' p\n  SHOs r' p \\<inter> HOs r' p\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n\ngoal (1 subgoal):\n 1. \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None} &&&\n    \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\n  \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "from p q hosho 2"], ["proof (chain)\npicking this:\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n  \\<forall>p\\<in>\\<pi>1.\n     HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2\n  SHOs r' q \\<inter> HOs r' q\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}", "have bb:\"{qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))} \\<supseteq> \\<pi>2\""], ["proof (prove)\nusing this:\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n  \\<forall>p\\<in>\\<pi>1.\n     HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2\n  SHOs r' q \\<inter> HOs r' q\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n\ngoal (1 subgoal):\n 1. \\<pi>2\n    \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}", "by auto"], ["proof (state)\nthis:\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "from p q hosho 4"], ["proof (chain)\npicking this:\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n  \\<forall>p\\<in>\\<pi>1.\n     HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2\n  SHOs r' p \\<inter> HOs r' p\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}", "have dd:\"{qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))} \\<supseteq> \\<pi>2\""], ["proof (prove)\nusing this:\n  p \\<in> \\<pi>1\n  q \\<in> \\<pi>1\n  \\<forall>p\\<in>\\<pi>1.\n     HOs r' p = \\<pi>2 \\<and> SHOs r' p \\<inter> HOs r' p = \\<pi>2\n  SHOs r' p \\<inter> HOs r' p\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n\ngoal (1 subgoal):\n 1. \\<pi>2\n    \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}", "by auto"], ["proof (state)\nthis:\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "have \"Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "have \"\\<forall>qq. sendMsg Ate_M r' qq p (rho r' qq)\n                   = sendMsg Ate_M r' qq q (rho r' qq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>qq.\n       sendMsg Ate_M r' qq p (rho r' qq) = sendMsg Ate_M r' qq q (rho r' qq)", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  \\<forall>qq.\n     sendMsg Ate_M r' qq p (rho r' qq) = sendMsg Ate_M r' qq q (rho r' qq)\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "with aa bb cc dd"], ["proof (chain)\npicking this:\n  \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n  \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n  \\<forall>qq.\n     sendMsg Ate_M r' qq p (rho r' qq) = sendMsg Ate_M r' qq q (rho r' qq)", "have \"\\<forall>qq. \\<mu>p qq \\<noteq> None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\""], ["proof (prove)\nusing this:\n  \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n  \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n  \\<forall>qq.\n     sendMsg Ate_M r' qq p (rho r' qq) = sendMsg Ate_M r' qq q (rho r' qq)\n\ngoal (1 subgoal):\n 1. \\<forall>qq.\n       \\<mu>p qq \\<noteq> None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq", "by force"], ["proof (state)\nthis:\n  \\<forall>qq.\n     \\<mu>p qq \\<noteq> None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "moreover"], ["proof (state)\nthis:\n  \\<forall>qq.\n     \\<mu>p qq \\<noteq> None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "from aa bb cc dd"], ["proof (chain)\npicking this:\n  \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n  \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}", "have \"{qq. \\<mu>p qq \\<noteq> None} = {qq. \\<mu>q qq \\<noteq> None}\""], ["proof (prove)\nusing this:\n  \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>q qq = Some (sendMsg Ate_M r' qq q (rho r' qq))}\n  \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\n  \\<pi>2\n  \\<subseteq> {qq. \\<mu>p qq = Some (sendMsg Ate_M r' qq p (rho r' qq))}\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>p qq \\<noteq> None} = {qq. \\<mu>q qq \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>p qq \\<noteq> None} = {qq. \\<mu>q qq \\<noteq> None}\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "hence \"\\<forall>qq. \\<mu>p qq = None \\<longleftrightarrow> \\<mu>q qq = None\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>p qq \\<noteq> None} = {qq. \\<mu>q qq \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<forall>qq. (\\<mu>p qq = None) = (\\<mu>q qq = None)", "by blast"], ["proof (state)\nthis:\n  \\<forall>qq. (\\<mu>p qq = None) = (\\<mu>q qq = None)\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "hence \"\\<forall>qq. \\<mu>p qq = None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\""], ["proof (prove)\nusing this:\n  \\<forall>qq. (\\<mu>p qq = None) = (\\<mu>q qq = None)\n\ngoal (1 subgoal):\n 1. \\<forall>qq. \\<mu>p qq = None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq", "by auto"], ["proof (state)\nthis:\n  \\<forall>qq. \\<mu>p qq = None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>qq.\n     \\<mu>p qq \\<noteq> None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\n  \\<forall>qq. \\<mu>p qq = None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq", "have \"\\<forall>qq. \\<mu>p qq = \\<mu>q qq\""], ["proof (prove)\nusing this:\n  \\<forall>qq.\n     \\<mu>p qq \\<noteq> None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\n  \\<forall>qq. \\<mu>p qq = None \\<longrightarrow> \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. \\<forall>qq. \\<mu>p qq = \\<mu>q qq", "by blast"], ["proof (state)\nthis:\n  \\<forall>qq. \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>qq. \\<mu>p qq = \\<mu>q qq\n\ngoal (1 subgoal):\n 1. Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "by (auto simp: mostOftenRcvd_def)"], ["proof (state)\nthis:\n  Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> \\<pi>1; q \\<in> \\<pi>1\\<rbrakk>\n       \\<Longrightarrow> x (rho (Suc r') p) = x (rho (Suc r') q)", "with \\<pi>t aa nxtq \\<pi>t cc nxtp"], ["proof (chain)\npicking this:\n  T < card \\<pi>2\n  \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\n  nextState Ate_M r' q (rho r' q) \\<mu>q (rho (Suc r') q)\n  T < card \\<pi>2\n  \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\n  nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\n  Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)", "show \"x (rho (Suc r') p) = x (rho (Suc r') q)\""], ["proof (prove)\nusing this:\n  T < card \\<pi>2\n  \\<pi>2 = {qq. \\<mu>q qq \\<noteq> None}\n  nextState Ate_M r' q (rho r' q) \\<mu>q (rho (Suc r') q)\n  T < card \\<pi>2\n  \\<pi>2 = {qq. \\<mu>p qq \\<noteq> None}\n  nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\n  Min (mostOftenRcvd \\<mu>p) = Min (mostOftenRcvd \\<mu>q)\n\ngoal (1 subgoal):\n 1. x (rho (Suc r') p) = x (rho (Suc r') q)", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  x (rho (Suc r') p) = x (rho (Suc r') q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>\\<pi>1.\n     \\<forall>q\\<in>\\<pi>1. x (rho (Suc r') p) = x (rho (Suc r') q)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>\\<pi>1.\n     \\<forall>q\\<in>\\<pi>1. x (rho (Suc r') p) = x (rho (Suc r') q)", "obtain v where Pv:\"\\<forall>p \\<in> \\<pi>1. x (rho (Suc r') p) = v\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>\\<pi>1.\n     \\<forall>q\\<in>\\<pi>1. x (rho (Suc r') p) = x (rho (Suc r') q)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>\\<pi>1. x (rho (Suc r') p) = v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>p\\<in>\\<pi>1. x (rho (Suc r') p) = v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  \\<forall>p\\<in>\\<pi>1. x (rho (Suc r') p) = v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "fix pp"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from Pv"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>\\<pi>1. x (rho (Suc r') p) = v", "have \"\\<forall>p \\<in> \\<pi>1. sendMsg Ate_M (Suc r') p pp (rho (Suc r') p) = v\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>\\<pi>1. x (rho (Suc r') p) = v\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>\\<pi>1. sendMsg Ate_M (Suc r') p pp (rho (Suc r') p) = v", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>\\<pi>1. sendMsg Ate_M (Suc r') p pp (rho (Suc r') p) = v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence \"card \\<pi>1 \\<le> card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>\\<pi>1. sendMsg Ate_M (Suc r') p pp (rho (Suc r') p) = v\n\ngoal (1 subgoal):\n 1. card \\<pi>1\n    \\<le> card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card \\<pi>1\n  \\<le> card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with \\<pi>ea"], ["proof (chain)\npicking this:\n  E - \\<alpha> < card \\<pi>1\n  card \\<pi>1\n  \\<le> card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}", "have \"E - \\<alpha> < card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\""], ["proof (prove)\nusing this:\n  E - \\<alpha> < card \\<pi>1\n  card \\<pi>1\n  \\<le> card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}", "by simp"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r') qq ?pp7 (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>pp.\n           E - \\<alpha>\n           < card\n              {qq.\n               sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n               v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card\n        {qq.\n         sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n         ?v5} \\<Longrightarrow>\n  thesis\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r') qq ?pp7 (rho (Suc r') qq) = v}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card\n        {qq.\n         sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) =\n         ?v5} \\<Longrightarrow>\n  thesis\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r') qq ?pp7 (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "{"], ["proof (state)\nthis:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "fix k pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have \"E - \\<alpha> < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\"\n      (is \"?P k\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (Suc r' + 0) qq pp (rho (Suc r' + 0) qq) = v}\n 2. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "from P1"], ["proof (chain)\npicking this:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}", "show \"?P 0\""], ["proof (prove)\nusing this:\n  \\<forall>pp.\n     E - \\<alpha>\n     < card {qq. sendMsg Ate_M (Suc r') qq pp (rho (Suc r') qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (Suc r' + 0) qq pp (rho (Suc r' + 0) qq) = v}", "by simp"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + 0) qq pp (rho (Suc r' + 0) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "assume ih: \"?P k\""], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "from commR"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have \"(SHOcommPerRd::((Proc, 'val::linorder pstate, 'val) SHOMachine) \n                               \\<Rightarrow> (Proc HO) \\<Rightarrow> (Proc HO) \\<Rightarrow> bool) \n                Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))", ".."], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "moreover"], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "from ih"], ["proof (chain)\npicking this:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}", "have \"E - \\<alpha> < card {qq. x (rho (Suc r' + k) qq) = v}\""], ["proof (prove)\nusing this:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (Suc r' + k) qq) = v}", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. x (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "ultimately"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n  E - \\<alpha> < card {qq. x (rho (Suc r' + k) qq) = v}", "have \"E - \\<alpha> < card {qq. x (rho (Suc r' + Suc k) qq) = v}\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n  E - \\<alpha> < card {qq. x (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. x (rho (Suc r' + Suc k) qq) = v}", "by (rule common_x_induct[OF run])"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. x (rho (Suc r' + Suc k) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) =\n           v} \\<Longrightarrow>\n       E - \\<alpha>\n       < card\n          {qq.\n           sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) =\n           v}", "thus \"?P (Suc k)\""], ["proof (prove)\nusing this:\n  E - \\<alpha> < card {qq. x (rho (Suc r' + Suc k) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card\n       {qq.\n        sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) = v}", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {qq.\n      sendMsg Ate_M (Suc r' + Suc k) qq pp (rho (Suc r' + Suc k) qq) = v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "}"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {qq. sendMsg Ate_M (Suc r' + ?k7) qq ?pp7 (rho (Suc r' + ?k7) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "note P2 = this"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {qq. sendMsg Ate_M (Suc r' + ?k7) qq ?pp7 (rho (Suc r' + ?k7) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "{"], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card\n     {qq. sendMsg Ate_M (Suc r' + ?k7) qq ?pp7 (rho (Suc r' + ?k7) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "fix k pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "assume ppupdatex: \"x (rho (Suc r' + Suc k) pp) \\<noteq> x (rho (Suc r' + k) pp)\""], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc k) pp) \\<noteq> x (rho (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from commR"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have \"(SHOcommPerRd::((Proc, 'val::linorder pstate, 'val) SHOMachine)\n                            \\<Rightarrow> (Proc HO) \\<Rightarrow> (Proc HO) \\<Rightarrow> bool)\n              Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))", ".."], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "moreover"], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>pp\n      where nxt:\"nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp \n                           (rho (Suc r' + Suc k) pp)\"\n        and mu: \"\\<mu>pp \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n                           (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp.\n        \\<lbrakk>nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp)\n                  \\<mu>pp (rho (Suc r' + Suc k) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n                (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "moreover"], ["proof (state)\nthis:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from nxt ppupdatex"], ["proof (chain)\npicking this:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  x (rho (Suc r' + Suc k) pp) \\<noteq> x (rho (Suc r' + k) pp)", "have threshold_T: \"card {qq. \\<mu>pp qq \\<noteq> None} > T\"\n      and xsmall: \"x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\""], ["proof (prove)\nusing this:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  x (rho (Suc r' + Suc k) pp) \\<noteq> x (rho (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. T < card {qq. \\<mu>pp qq \\<noteq> None} &&&\n    x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>pp qq \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "moreover"], ["proof (state)\nthis:\n  T < card {qq. \\<mu>pp qq \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from P2"], ["proof (chain)\npicking this:\n  E - \\<alpha>\n  < card\n     {qq. sendMsg Ate_M (Suc r' + ?k7) qq ?pp7 (rho (Suc r' + ?k7) qq) = v}", "have \"E - \\<alpha> < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\""], ["proof (prove)\nusing this:\n  E - \\<alpha>\n  < card\n     {qq. sendMsg Ate_M (Suc r' + ?k7) qq ?pp7 (rho (Suc r' + ?k7) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}", "."], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "ultimately"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n  T < card {qq. \\<mu>pp qq \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}", "have \"mostOftenRcvd \\<mu>pp = {v}\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n  T < card {qq. \\<mu>pp qq \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>pp = {v}", "by (auto dest!: mostOftenRcvd_v)"], ["proof (state)\nthis:\n  mostOftenRcvd \\<mu>pp = {v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "with xsmall"], ["proof (chain)\npicking this:\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  mostOftenRcvd \\<mu>pp = {v}", "have \"x (rho (Suc r' + Suc k) pp) = v\""], ["proof (prove)\nusing this:\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  mostOftenRcvd \\<mu>pp = {v}\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "by simp"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "}"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc ?k7) ?pp7) \\<noteq>\n  x (rho (Suc r' + ?k7) ?pp7) \\<Longrightarrow>\n  x (rho (Suc r' + Suc ?k7) ?pp7) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "note P3 = this"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc ?k7) ?pp7) \\<noteq>\n  x (rho (Suc r' + ?k7) ?pp7) \\<Longrightarrow>\n  x (rho (Suc r' + Suc ?k7) ?pp7) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have P4:\"\\<forall>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "fix pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "from commG"], ["proof (chain)\npicking this:\n  SHOcommGlobal Ate_M HOs SHOs", "have \"\\<exists>r'' > r'. card (HOs r'' pp) > T\""], ["proof (prove)\nusing this:\n  SHOcommGlobal Ate_M HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<exists>r''>r'. T < card (HOs r'' pp)", "by (auto simp: Ate_SHOMachine_def Ate_commGlobal_def)"], ["proof (state)\nthis:\n  \\<exists>r''>r'. T < card (HOs r'' pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "then"], ["proof (chain)\npicking this:\n  \\<exists>r''>r'. T < card (HOs r'' pp)", "obtain k where \"Suc r' + k > r'\" and t:\"card (HOs (Suc r' + k) pp) > T\""], ["proof (prove)\nusing this:\n  \\<exists>r''>r'. T < card (HOs r'' pp)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>r' < Suc r' + k; T < card (HOs (Suc r' + k) pp)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: less_imp_Suc_add)"], ["proof (state)\nthis:\n  r' < Suc r' + k\n  T < card (HOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "moreover"], ["proof (state)\nthis:\n  r' < Suc r' + k\n  T < card (HOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>pp\n      where nxt: \"nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n                                  (rho (Suc r' + Suc k) pp)\"\n        and mu: \"\\<mu>pp \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n                                  (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>pp.\n        \\<lbrakk>nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp)\n                  \\<mu>pp (rho (Suc r' + Suc k) pp);\n         \\<mu>pp\n         \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n                (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "moreover"], ["proof (state)\nthis:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "have \"x (rho (Suc r' + Suc k) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "from commR"], ["proof (chain)\npicking this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)", "have \"(SHOcommPerRd::((Proc, 'val::linorder pstate, 'val::linorder) SHOMachine)\n                                \\<Rightarrow> (Proc HO) \\<Rightarrow> (Proc HO) \\<Rightarrow> bool) \n                Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\""], ["proof (prove)\nusing this:\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n\ngoal (1 subgoal):\n 1. SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))", ".."], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "moreover"], ["proof (state)\nthis:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "from mu"], ["proof (chain)\npicking this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)", "have \"HOs (Suc r' + k) pp = {q. \\<mu>pp q \\<noteq> None}\""], ["proof (prove)\nusing this:\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. HOs (Suc r' + k) pp = {q. \\<mu>pp q \\<noteq> None}", "by (auto simp: SHOmsgVectors_def)"], ["proof (state)\nthis:\n  HOs (Suc r' + k) pp = {q. \\<mu>pp q \\<noteq> None}\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "with nxt t"], ["proof (chain)\npicking this:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  T < card (HOs (Suc r' + k) pp)\n  HOs (Suc r' + k) pp = {q. \\<mu>pp q \\<noteq> None}", "have threshold_T: \"card {q. \\<mu>pp q \\<noteq> None} > T\"\n        and xsmall: \"x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\""], ["proof (prove)\nusing this:\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  T < card (HOs (Suc r' + k) pp)\n  HOs (Suc r' + k) pp = {q. \\<mu>pp q \\<noteq> None}\n\ngoal (1 subgoal):\n 1. T < card {q. \\<mu>pp q \\<noteq> None} &&&\n    x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "moreover"], ["proof (state)\nthis:\n  T < card {q. \\<mu>pp q \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "from P2"], ["proof (chain)\npicking this:\n  E - \\<alpha>\n  < card\n     {qq. sendMsg Ate_M (Suc r' + ?k7) qq ?pp7 (rho (Suc r' + ?k7) qq) = v}", "have \"E - \\<alpha> < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\""], ["proof (prove)\nusing this:\n  E - \\<alpha>\n  < card\n     {qq. sendMsg Ate_M (Suc r' + ?k7) qq ?pp7 (rho (Suc r' + ?k7) qq) = v}\n\ngoal (1 subgoal):\n 1. E - \\<alpha>\n    < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}", "."], ["proof (state)\nthis:\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "ultimately"], ["proof (chain)\npicking this:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n  T < card {q. \\<mu>pp q \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}", "have \"mostOftenRcvd \\<mu>pp = {v}\""], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n  T < card {q. \\<mu>pp q \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>pp = {v}", "using nxt mu"], ["proof (prove)\nusing this:\n  SHOcommPerRd Ate_M (HOs (Suc r' + k)) (SHOs (Suc r' + k))\n  T < card {q. \\<mu>pp q \\<noteq> None}\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  E - \\<alpha>\n  < card {qq. sendMsg Ate_M (Suc r' + k) qq pp (rho (Suc r' + k) qq) = v}\n  nextState Ate_M (Suc r' + k) pp (rho (Suc r' + k) pp) \\<mu>pp\n   (rho (Suc r' + Suc k) pp)\n  \\<mu>pp\n  \\<in> SHOmsgVectors Ate_M (Suc r' + k) pp (rho (Suc r' + k))\n         (HOs (Suc r' + k) pp) (SHOs (Suc r' + k) pp)\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>pp = {v}", "by (auto dest!: mostOftenRcvd_v)"], ["proof (state)\nthis:\n  mostOftenRcvd \\<mu>pp = {v}\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "with xsmall"], ["proof (chain)\npicking this:\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  mostOftenRcvd \\<mu>pp = {v}", "show ?thesis"], ["proof (prove)\nusing this:\n  x (rho (Suc r' + Suc k) pp) = Min (mostOftenRcvd \\<mu>pp)\n  mostOftenRcvd \\<mu>pp = {v}\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k) pp) = v", "by auto"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc k) pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "thus \"\\<exists>k. x (rho (Suc r' + Suc k) pp) = v\""], ["proof (prove)\nusing this:\n  x (rho (Suc r' + Suc k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", ".."], ["proof (state)\nthis:\n  \\<exists>k. x (rho (Suc r' + Suc k) pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have P5a: \"\\<forall>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v", "fix pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v", "from P4"], ["proof (chain)\npicking this:\n  \\<forall>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v", "obtain rk where\n      xrrv: \"x (rho (Suc r' + Suc rk) pp) = v\" (is \"x (rho ?rr pp) = v\")"], ["proof (prove)\nusing this:\n  \\<forall>pp. \\<exists>k. x (rho (Suc r' + Suc k) pp) = v\n\ngoal (1 subgoal):\n 1. (\\<And>rk.\n        x (rho (Suc r' + Suc rk) pp) = v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc rk) pp) = v\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v", "have \"\\<forall>k. x (rho (?rr + k) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. x (rho (Suc r' + Suc rk + k) pp) = v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. x (rho (Suc r' + Suc rk + k) pp) = v", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. x (rho (Suc r' + Suc rk + k) pp) = v", "show \"x (rho (?rr + k) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc rk + k) pp) = v", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. x (rho (Suc r' + Suc rk + 0) pp) = v\n 2. \\<And>k.\n       x (rho (Suc r' + Suc rk + k) pp) = v \\<Longrightarrow>\n       x (rho (Suc r' + Suc rk + Suc k) pp) = v", "from xrrv"], ["proof (chain)\npicking this:\n  x (rho (Suc r' + Suc rk) pp) = v", "show \"x (rho (?rr + 0) pp) = v\""], ["proof (prove)\nusing this:\n  x (rho (Suc r' + Suc rk) pp) = v\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc rk + 0) pp) = v", "by simp"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc rk + 0) pp) = v\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       x (rho (Suc r' + Suc rk + k) pp) = v \\<Longrightarrow>\n       x (rho (Suc r' + Suc rk + Suc k) pp) = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       x (rho (Suc r' + Suc rk + k) pp) = v \\<Longrightarrow>\n       x (rho (Suc r' + Suc rk + Suc k) pp) = v", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       x (rho (Suc r' + Suc rk + k) pp) = v \\<Longrightarrow>\n       x (rho (Suc r' + Suc rk + Suc k) pp) = v", "assume ih: \"x (rho (?rr + k) pp) = v\""], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc rk + k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       x (rho (Suc r' + Suc rk + k) pp) = v \\<Longrightarrow>\n       x (rho (Suc r' + Suc rk + Suc k) pp) = v", "obtain k' where rrk: \"Suc r' + k' = ?rr + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        Suc r' + k' = Suc r' + Suc rk + k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc r' + k' = Suc r' + Suc rk + k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       x (rho (Suc r' + Suc rk + k) pp) = v \\<Longrightarrow>\n       x (rho (Suc r' + Suc rk + Suc k) pp) = v", "show \"x (rho (?rr + Suc k) pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc rk + Suc k) pp) = v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v \\<Longrightarrow> False", "assume nv: \"x (rho (?rr + Suc k) pp) \\<noteq> v\""], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v \\<Longrightarrow> False", "with rrk ih"], ["proof (chain)\npicking this:\n  Suc r' + k' = Suc r' + Suc rk + k\n  x (rho (Suc r' + Suc rk + k) pp) = v\n  x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v", "have \"x (rho (Suc r' + Suc k') pp) \\<noteq> x (rho (Suc r' + k') pp)\""], ["proof (prove)\nusing this:\n  Suc r' + k' = Suc r' + Suc rk + k\n  x (rho (Suc r' + Suc rk + k) pp) = v\n  x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k') pp) \\<noteq> x (rho (Suc r' + k') pp)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc k') pp) \\<noteq> x (rho (Suc r' + k') pp)\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v \\<Longrightarrow> False", "hence \"x (rho (Suc r' + Suc k') pp) = v\""], ["proof (prove)\nusing this:\n  x (rho (Suc r' + Suc k') pp) \\<noteq> x (rho (Suc r' + k') pp)\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc k') pp) = v", "by (rule P3)"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc k') pp) = v\n\ngoal (1 subgoal):\n 1. x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v \\<Longrightarrow> False", "with rrk nv"], ["proof (chain)\npicking this:\n  Suc r' + k' = Suc r' + Suc rk + k\n  x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v\n  x (rho (Suc r' + Suc k') pp) = v", "show False"], ["proof (prove)\nusing this:\n  Suc r' + k' = Suc r' + Suc rk + k\n  x (rho (Suc r' + Suc rk + Suc k) pp) \\<noteq> v\n  x (rho (Suc r' + Suc k') pp) = v\n\ngoal (1 subgoal):\n 1. False", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc rk + Suc k) pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (rho (Suc r' + Suc rk + k) pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k. x (rho (Suc r' + Suc rk + k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<And>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v", "thus \"\\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v\""], ["proof (prove)\nusing this:\n  \\<forall>k. x (rho (Suc r' + Suc rk + k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v", "by blast"], ["proof (state)\nthis:\n  \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from P5a"], ["proof (chain)\npicking this:\n  \\<forall>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v", "have \"\\<exists>F. \\<forall>pp k. x (rho (F pp + k) pp) = v\""], ["proof (prove)\nusing this:\n  \\<forall>pp. \\<exists>rr. \\<forall>k. x (rho (rr + k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>F. \\<forall>pp k. x (rho (F pp + k) pp) = v", "by (rule choice)"], ["proof (state)\nthis:\n  \\<exists>F. \\<forall>pp k. x (rho (F pp + k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "then"], ["proof (chain)\npicking this:\n  \\<exists>F. \\<forall>pp k. x (rho (F pp + k) pp) = v", "obtain R::\"(Proc \\<Rightarrow> nat)\"\n    where imgR: \"R ` (UNIV::Proc set) \\<noteq> {}\"\n      and R: \"\\<forall>pp k. x (rho (R pp + k) pp) = v\""], ["proof (prove)\nusing this:\n  \\<exists>F. \\<forall>pp k. x (rho (F pp + k) pp) = v\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>range R \\<noteq> {};\n         \\<forall>pp k. x (rho (R pp + k) pp) = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  range R \\<noteq> {}\n  \\<forall>pp k. x (rho (R pp + k) pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define rr where \"rr = Max (R ` UNIV)\""], ["proof (state)\nthis:\n  rr = Max (range R)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have P5: \"\\<forall>r' > rr. \\<forall>pp. x (rho r' pp) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r'>rr. \\<forall>pp. x (rho r' pp) = v", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r' pp. rr < r' \\<Longrightarrow> x (rho r' pp) = v", "fix r' pp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r' pp. rr < r' \\<Longrightarrow> x (rho r' pp) = v", "assume r': \"r' > rr\""], ["proof (state)\nthis:\n  rr < r'\n\ngoal (1 subgoal):\n 1. \\<And>r' pp. rr < r' \\<Longrightarrow> x (rho r' pp) = v", "hence \"r' > R pp\""], ["proof (prove)\nusing this:\n  rr < r'\n\ngoal (1 subgoal):\n 1. R pp < r'", "by (auto simp: rr_def)"], ["proof (state)\nthis:\n  R pp < r'\n\ngoal (1 subgoal):\n 1. \\<And>r' pp. rr < r' \\<Longrightarrow> x (rho r' pp) = v", "then"], ["proof (chain)\npicking this:\n  R pp < r'", "obtain i where \"r' = R pp + i\""], ["proof (prove)\nusing this:\n  R pp < r'\n\ngoal (1 subgoal):\n 1. (\\<And>i. r' = R pp + i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: less_imp_Suc_add)"], ["proof (state)\nthis:\n  r' = R pp + i\n\ngoal (1 subgoal):\n 1. \\<And>r' pp. rr < r' \\<Longrightarrow> x (rho r' pp) = v", "with R"], ["proof (chain)\npicking this:\n  \\<forall>pp k. x (rho (R pp + k) pp) = v\n  r' = R pp + i", "show \"x (rho r' pp) = v\""], ["proof (prove)\nusing this:\n  \\<forall>pp k. x (rho (R pp + k) pp) = v\n  r' = R pp + i\n\ngoal (1 subgoal):\n 1. x (rho r' pp) = v", "by auto"], ["proof (state)\nthis:\n  x (rho r' pp) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>r'>rr. \\<forall>pp. x (rho r' pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from commG"], ["proof (chain)\npicking this:\n  SHOcommGlobal Ate_M HOs SHOs", "have \"\\<exists>r' > rr. card (SHOs r' p \\<inter> HOs r' p) > E\""], ["proof (prove)\nusing this:\n  SHOcommGlobal Ate_M HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<exists>r'>rr. E < card (SHOs r' p \\<inter> HOs r' p)", "by (auto simp: Ate_SHOMachine_def Ate_commGlobal_def)"], ["proof (state)\nthis:\n  \\<exists>r'>rr. E < card (SHOs r' p \\<inter> HOs r' p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "with P5"], ["proof (chain)\npicking this:\n  \\<forall>r'>rr. \\<forall>pp. x (rho r' pp) = v\n  \\<exists>r'>rr. E < card (SHOs r' p \\<inter> HOs r' p)", "obtain r'\n    where \"r' > rr\"\n      and \"card (SHOs r' p \\<inter> HOs r' p) > E\"\n      and \"\\<forall>pp. sendMsg Ate_M r' pp p (rho r' pp) = v\""], ["proof (prove)\nusing this:\n  \\<forall>r'>rr. \\<forall>pp. x (rho r' pp) = v\n  \\<exists>r'>rr. E < card (SHOs r' p \\<inter> HOs r' p)\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>rr < r'; E < card (SHOs r' p \\<inter> HOs r' p);\n         \\<forall>pp. sendMsg Ate_M r' pp p (rho r' pp) = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ate_SHOMachine_def Ate_sendMsg_def)"], ["proof (state)\nthis:\n  rr < r'\n  E < card (SHOs r' p \\<inter> HOs r' p)\n  \\<forall>pp. sendMsg Ate_M r' pp p (rho r' pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "moreover"], ["proof (state)\nthis:\n  rr < r'\n  E < card (SHOs r' p \\<inter> HOs r' p)\n  \\<forall>pp. sendMsg Ate_M r' pp p (rho r' pp) = v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun Ate_M rho HOs SHOs", "obtain \\<mu>p\n    where nxt: \"nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\"\n      and mu: \"\\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)\""], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p);\n         \\<mu>p\n         \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p)\n                (SHOs r' p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from mu"], ["proof (chain)\npicking this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)", "have \"card (SHOs r' p \\<inter> HOs r' p)\n        \\<le> card {q. \\<mu>p q = Some (sendMsg Ate_M r' q p (rho r' q))}\""], ["proof (prove)\nusing this:\n  \\<mu>p \\<in> SHOmsgVectors Ate_M r' p (rho r') (HOs r' p) (SHOs r' p)\n\ngoal (1 subgoal):\n 1. card (SHOs r' p \\<inter> HOs r' p)\n    \\<le> card {q. \\<mu>p q = Some (sendMsg Ate_M r' q p (rho r' q))}", "by (auto simp: SHOmsgVectors_def intro: card_mono)"], ["proof (state)\nthis:\n  card (SHOs r' p \\<inter> HOs r' p)\n  \\<le> card {q. \\<mu>p q = Some (sendMsg Ate_M r' q p (rho r' q))}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "ultimately"], ["proof (chain)\npicking this:\n  rr < r'\n  E < card (SHOs r' p \\<inter> HOs r' p)\n  \\<forall>pp. sendMsg Ate_M r' pp p (rho r' pp) = v\n  card (SHOs r' p \\<inter> HOs r' p)\n  \\<le> card {q. \\<mu>p q = Some (sendMsg Ate_M r' q p (rho r' q))}", "have threshold_E: \"card {q. \\<mu>p q = Some v} > E\""], ["proof (prove)\nusing this:\n  rr < r'\n  E < card (SHOs r' p \\<inter> HOs r' p)\n  \\<forall>pp. sendMsg Ate_M r' pp p (rho r' pp) = v\n  card (SHOs r' p \\<inter> HOs r' p)\n  \\<le> card {q. \\<mu>p q = Some (sendMsg Ate_M r' q p (rho r' q))}\n\ngoal (1 subgoal):\n 1. E < card {q. \\<mu>p q = Some v}", "by auto"], ["proof (state)\nthis:\n  E < card {q. \\<mu>p q = Some v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "with nxt"], ["proof (chain)\npicking this:\n  nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\n  E < card {q. \\<mu>p q = Some v}", "show ?thesis"], ["proof (prove)\nusing this:\n  nextState Ate_M r' p (rho r' p) \\<mu>p (rho (Suc r') p)\n  E < card {q. \\<mu>p q = Some v}\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "by (auto simp: Ate_SHOMachine_def nextState_def Ate_nextState_def)"], ["proof (state)\nthis:\n  \\<exists>r v. decide (rho r p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\\ate{} Solves Weak Consensus\\<close>"], ["", "text \\<open>\n  Summing up, all (coarse-grained) runs of \\ate{} for\n  HO and SHO collections that satisfy the communication predicate \n  satisfy the Weak Consensus property.\n\\<close>"], ["", "theorem ate_weak_consensus:\n  assumes run: \"SHORun Ate_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ate_M HOs SHOs\"\n  shows \"weak_consensus (x \\<circ> (rho 0)) decide rho\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_consensus (x \\<circ> rho 0) decide rho", "unfolding weak_consensus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        (\\<forall>p. (x \\<circ> rho 0) p = v) \\<longrightarrow>\n        (\\<forall>n p w.\n            decide (rho n p) = Some w \\<longrightarrow> w = v)) \\<and>\n    (\\<forall>m n p q v w.\n        decide (rho m p) = Some v \\<and>\n        decide (rho n q) = Some w \\<longrightarrow>\n        v = w) \\<and>\n    (\\<forall>p. \\<exists>n. decide (rho n p) \\<noteq> None)", "using assms"], ["proof (prove)\nusing this:\n  SHORun Ate_M rho HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  SHOcommGlobal Ate_M HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        (\\<forall>p. (x \\<circ> rho 0) p = v) \\<longrightarrow>\n        (\\<forall>n p w.\n            decide (rho n p) = Some w \\<longrightarrow> w = v)) \\<and>\n    (\\<forall>m n p q v w.\n        decide (rho m p) = Some v \\<and>\n        decide (rho n q) = Some w \\<longrightarrow>\n        v = w) \\<and>\n    (\\<forall>p. \\<exists>n. decide (rho n p) \\<noteq> None)", "by (auto elim: ate_validity ate_agreement ate_termination)"], ["", "text \\<open>\n  By the reduction theorem, the correctness of the algorithm carries over\n  to the fine-grained model of runs.\n\\<close>"], ["", "theorem ate_weak_consensus_fg:\n  assumes run: \"fg_run Ate_M rho HOs SHOs (\\<lambda>r q. undefined)\"\n      and commR: \"\\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\"\n      and commG: \"SHOcommGlobal Ate_M HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide (state \\<circ> rho)\"\n    (is \"weak_consensus ?inits _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide\n     (state \\<circ> rho)", "proof (rule local_property_reduction[OF run weak_consensus_is_local])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ate_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "fix crun"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ate_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "assume crun: \"CSHORun Ate_M crun HOs SHOs (\\<lambda>r q. undefined)\"\n     and init: \"crun 0 = state (rho 0)\""], ["proof (state)\nthis:\n  CSHORun Ate_M crun HOs SHOs (\\<lambda>r q. undefined)\n  crun 0 = state (rho 0)\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ate_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "from crun"], ["proof (chain)\npicking this:\n  CSHORun Ate_M crun HOs SHOs (\\<lambda>r q. undefined)", "have \"SHORun Ate_M crun HOs SHOs\""], ["proof (prove)\nusing this:\n  CSHORun Ate_M crun HOs SHOs (\\<lambda>r q. undefined)\n\ngoal (1 subgoal):\n 1. SHORun Ate_M crun HOs SHOs", "by (unfold SHORun_def)"], ["proof (state)\nthis:\n  SHORun Ate_M crun HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ate_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "from this commR commG"], ["proof (chain)\npicking this:\n  SHORun Ate_M crun HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  SHOcommGlobal Ate_M HOs SHOs", "have \"weak_consensus (x \\<circ> (crun 0)) decide crun\""], ["proof (prove)\nusing this:\n  SHORun Ate_M crun HOs SHOs\n  \\<forall>r. SHOcommPerRd Ate_M (HOs r) (SHOs r)\n  SHOcommGlobal Ate_M HOs SHOs\n\ngoal (1 subgoal):\n 1. weak_consensus (x \\<circ> crun 0) decide crun", "by (rule ate_weak_consensus)"], ["proof (state)\nthis:\n  weak_consensus (x \\<circ> crun 0) decide crun\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun Ate_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus (\\<lambda>p. x (state (rho 0) p))\n                          decide crho", "with init"], ["proof (chain)\npicking this:\n  crun 0 = state (rho 0)\n  weak_consensus (x \\<circ> crun 0) decide crun", "show \"weak_consensus ?inits decide crun\""], ["proof (prove)\nusing this:\n  crun 0 = state (rho 0)\n  weak_consensus (x \\<circ> crun 0) decide crun\n\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide crun", "by (simp add: o_def)"], ["proof (state)\nthis:\n  weak_consensus (\\<lambda>p. x (state (rho 0) p)) decide crun\n\ngoal:\nNo subgoals!", "qed"], ["", "end   \\<comment> \\<open>context @{text \"ate_parameters\"}\\<close>"], ["", "end"], ["", "(* theory AteProof *)"]]}