{"file_name": "/home/qj213/afp-2021-10-22/thys/Heard_Of/eigbyz/EigbyzProof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Heard_Of", "problem_names": ["lemma not_leaf_length:\n  assumes l: \"\\<not>(is_leaf l)\"\n  shows \"length_lbl l \\<le> f\"", "lemma nil_is_Label: \"[] \\<in> Label\"", "lemma card_set_lbl: \"card (set_lbl l) = length_lbl l\"", "lemma Rep_Label_root_node [simp]: \"Rep_Label root_node = []\"", "lemma root_node_length [simp]: \"length_lbl root_node = 0\"", "lemma root_node_not_leaf: \"\\<not>(is_leaf root_node)\"", "lemma butlast_rep_in_label:\n  assumes l:\"l \\<noteq> root_node\"\n  shows \"butlast (Rep_Label l) \\<in> Label\"", "lemma Rep_Label_append:\n  assumes l: \"\\<not>(is_leaf l)\"\n  shows \"(Rep_Label l @ [p] \\<in> Label) = (p \\<notin> set_lbl l)\"\n     (is \"?lhs = ?rhs\" is \"(?l' \\<in> _) = _\")", "lemma label_children:\n  assumes c: \"c \\<in> children l\"\n  shows \"\\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]\"", "lemma children_length:\n  assumes \"l \\<in> children h\"\n  shows \"length_lbl l = Suc (length_lbl h)\"", "lemma children_not_root:\n  assumes \"root_node \\<in> children l\"\n  shows \"P\"", "lemma children_butlast_lbl:\n  assumes \"c \\<in> children l\"\n  shows \"butlast_lbl c = l\"", "lemma root_iff_no_child: \"(l = root_node) = (\\<forall>l'. l \\<notin> children l')\"", "lemma children_last_set:\n  assumes l: \"\\<not>(is_leaf l)\"\n  shows \"last_lbl ` (children l) = UNIV - set_lbl l\"", "lemma last_lbl_inj_on_children:\"inj_on last_lbl (children l)\"", "lemma card_children:\n  assumes \"\\<not>(is_leaf l)\"\n  shows \"card (children l) = N - (length_lbl l)\"", "lemma sho_correct_vals:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and l': \"l' \\<in> children l\"\n      and shop: \"last_lbl l' \\<in> SHOs (length_lbl l) p \\<inter> HOs (length_lbl l) p\"\n                (is \"?q \\<in> SHOs (?len l) p \\<inter> _\")\n  shows \"vals (rho (?len l') p) l' = vals (rho (?len l) ?q) l\"", "lemma keep_vals:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n  shows \"vals (rho (length_lbl l + n) p) l = vals (rho (length_lbl l) p) l\"\n     (is \"?v n = ?vl\")", "lemma lynch_6_15:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n  and l': \"l' \\<in> children l\"\n  and skr: \"last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n  shows \"vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l') q) l'\"", "lemma lynch_6_16_a:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and l: \"l \\<in> children t\"\n      and skrl: \"last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\"\n      and l': \"l' \\<in> children l\"\n      and skrl':\"last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n    shows \"vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l\"", "lemma lynch_6_16_c:\n  assumes commR: \"EIG_commPerRd (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n                 (is \"EIG_commPerRd (HOs ?r) _\")\n      and l: \"\\<not>(is_leaf l)\"\n  shows \"card {l' \\<in> children l. last_lbl l' \\<in> SKr (HOs ?r) (SHOs ?r)}\n         > card (children l) div 2\"\n    (is \"card ?lhs > _\")", "lemma newvals_skr_uniform:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"EIG_commPerRd (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n                 (is \"EIG_commPerRd (HOs ?r) _\")\n      and notleaf: \"\\<not>(is_leaf l)\"\n      and unif: \"\\<And>l'. \\<lbrakk>l' \\<in> children l;\n                   last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n                  \\<rbrakk> \\<Longrightarrow> newvals (rho (Suc f) p) l' = v\"\n  shows \"newvals (rho (Suc f) p) l = v\"", "lemma lynch_6_16_d:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and notroot: \"l \\<in> children t\"\n      and skr: \"last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\"\n            (is \"_ \\<in> SKr (HOs (?len t)) _\")\n  shows \"newvals (rho (Suc f) p) l = fixupval (vals (rho (?len l) p) l)\"\n    (is \"?P l\")", "lemma children_in_subtree:\n  assumes \"l \\<in> children h\"\n  shows \"l \\<in> subtrees h\"", "lemma subtrees_refl [iff]: \"l \\<in> subtrees l\"", "lemma subtrees_root [iff]: \"l \\<in> subtrees root_node\"", "lemma subtrees_trans:\n  assumes \"l'' \\<in> subtrees l'\" and \"l' \\<in> subtrees l\"\n  shows \"l'' \\<in> subtrees l\"", "lemma subtrees_antisym:\n  assumes \"l \\<in> subtrees l'\" and \"l' \\<in> subtrees l\"\n  shows \"l' = l\"", "lemma subtrees_tree:\n  assumes l': \"l \\<in> subtrees l'\" and l'': \"l \\<in> subtrees l''\"\n  shows \"l' \\<in> subtrees l'' \\<or> l'' \\<in> subtrees l'\"", "lemma subtrees_cases:\n  assumes l': \"l' \\<in> subtrees l\"\n      and self: \"l' = l \\<Longrightarrow> P\"\n      and child: \"\\<And>c. \\<lbrakk> c \\<in> children l; l' \\<in> subtrees c \\<rbrakk> \\<Longrightarrow> P\"\n  shows \"P\"", "lemma subtrees_leaf:\n  assumes l: \"is_leaf l\" and l': \"l' \\<in> subtrees l\"\n  shows \"l' = l\"", "lemma children_subtrees_equal:\n  assumes c: \"c \\<in> children l\" and c': \"c' \\<in> children l\"\n      and sub: \"c' \\<in> subtrees c\"\n  shows \"c' = c\"", "lemma lynch_6_18_a:\n  assumes \"SHORun EIG_M rho HOs SHOs\"\n      and \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and \"l \\<in> children t\"\n      and \"last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\"\n  shows \"common rho l\"", "lemma lynch_6_18_b:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n  shows \"covering {l. \\<exists>t. l \\<in> children t \\<and> last_lbl l \\<in> (SK HOs SHOs)}\"", "lemma lynch_6_19_a:\n  assumes cov: \"subcovering C l\"\n      and l: \"l \\<notin> C\"\n      and e: \"e \\<in> children l\"\n  shows \"subcovering C e\"", "lemma lynch_6_19_b:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and cov: \"subcovering C l\"\n      and com: \"\\<forall>l' \\<in> C. common rho l'\"\n  shows \"common rho l\"", "lemma lynch_6_20:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n  shows \"common rho root_node\"", "lemma decide:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n  shows \"decide (rho r p) = \n         (if r < Suc f then None\n          else Some (newvals (rho (Suc f) p) root_node))\"\n     (is \"?P r\")", "theorem Agreement:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n      and commR:  \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and p: \"decide (rho m p) = Some v\"\n      and q: \"decide (rho n q) = Some w\"\n  shows \"v = w\"", "theorem Validity:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and initv: \"\\<forall>q. the (vals (rho 0 q) root_node) = v\"\n      and dp: \"decide (rho r p) = Some w\"\n  shows \"v = w\"", "theorem Termination:\n  assumes \"SHORun EIG_M rho HOs SHOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\"", "theorem eig_weak_consensus:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. the (vals (rho 0 p) root_node)) decide rho\"", "theorem eig_weak_consensus_fg:\n  assumes run: \"fg_run EIG_M rho HOs SHOs (\\<lambda>r q. undefined)\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. the (vals (state (rho 0) p) root_node))\n                        decide (state \\<circ> rho)\"\n    (is \"weak_consensus ?inits _ _\")"], "translations": [["", "lemma not_leaf_length:\n  assumes l: \"\\<not>(is_leaf l)\"\n  shows \"length_lbl l \\<le> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_lbl l \\<le> f", "using l length_lbl[of l]"], ["proof (prove)\nusing this:\n  \\<not> is_leaf l\n  length_lbl l \\<le> Suc f\n\ngoal (1 subgoal):\n 1. length_lbl l \\<le> f", "by (simp add: is_leaf_def)"], ["", "lemma nil_is_Label: \"[] \\<in> Label\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> Label", "by (auto simp: Label_def)"], ["", "lemma card_set_lbl: \"card (set_lbl l) = length_lbl l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set_lbl l) = length_lbl l", "unfolding set_lbl_def length_lbl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (Rep_Label l)) = length (Rep_Label l)", "using Rep_Label[of l, unfolded Label_def]"], ["proof (prove)\nusing this:\n  Rep_Label l \\<in> {xs. length xs \\<le> Suc f \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. card (set (Rep_Label l)) = length (Rep_Label l)", "by (auto elim: distinct_card)"], ["", "lemma Rep_Label_root_node [simp]: \"Rep_Label root_node = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Label root_node = []", "using nil_is_Label"], ["proof (prove)\nusing this:\n  [] \\<in> Label\n\ngoal (1 subgoal):\n 1. Rep_Label root_node = []", "by (simp add: root_node_def Abs_Label_inverse)"], ["", "lemma root_node_length [simp]: \"length_lbl root_node = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_lbl root_node = 0", "by (simp add: length_lbl_def)"], ["", "lemma root_node_not_leaf: \"\\<not>(is_leaf root_node)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_leaf root_node", "by (simp add: is_leaf_def)"], ["", "text \\<open>Removing the last element of a non-root label gives a label.\\<close>"], ["", "lemma butlast_rep_in_label:\n  assumes l:\"l \\<noteq> root_node\"\n  shows \"butlast (Rep_Label l) \\<in> Label\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (Rep_Label l) \\<in> Label", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. butlast (Rep_Label l) \\<in> Label", "have \"Rep_Label l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Label l \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_Label l = [] \\<Longrightarrow> False", "assume \"Rep_Label l = []\""], ["proof (state)\nthis:\n  Rep_Label l = []\n\ngoal (1 subgoal):\n 1. Rep_Label l = [] \\<Longrightarrow> False", "hence \"Rep_Label l = Rep_Label root_node\""], ["proof (prove)\nusing this:\n  Rep_Label l = []\n\ngoal (1 subgoal):\n 1. Rep_Label l = Rep_Label root_node", "by simp"], ["proof (state)\nthis:\n  Rep_Label l = Rep_Label root_node\n\ngoal (1 subgoal):\n 1. Rep_Label l = [] \\<Longrightarrow> False", "with l"], ["proof (chain)\npicking this:\n  l \\<noteq> root_node\n  Rep_Label l = Rep_Label root_node", "show \"False\""], ["proof (prove)\nusing this:\n  l \\<noteq> root_node\n  Rep_Label l = Rep_Label root_node\n\ngoal (1 subgoal):\n 1. False", "by (simp only: Rep_Label_inject)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Rep_Label l \\<noteq> []\n\ngoal (1 subgoal):\n 1. butlast (Rep_Label l) \\<in> Label", "with Rep_Label[of l]"], ["proof (chain)\npicking this:\n  Rep_Label l \\<in> Label\n  Rep_Label l \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_Label l \\<in> Label\n  Rep_Label l \\<noteq> []\n\ngoal (1 subgoal):\n 1. butlast (Rep_Label l) \\<in> Label", "by (auto simp: Label_def elim: distinct_butlast)"], ["proof (state)\nthis:\n  butlast (Rep_Label l) \\<in> Label\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The label of a child is well-formed.\n\\<close>"], ["", "lemma Rep_Label_append:\n  assumes l: \"\\<not>(is_leaf l)\"\n  shows \"(Rep_Label l @ [p] \\<in> Label) = (p \\<notin> set_lbl l)\"\n     (is \"?lhs = ?rhs\" is \"(?l' \\<in> _) = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Rep_Label l @ [p] \\<in> Label) = (p \\<notin> set_lbl l)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Rep_Label l @ [p] \\<in> Label \\<Longrightarrow> p \\<notin> set_lbl l\n 2. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "assume lhs: \"?lhs\""], ["proof (state)\nthis:\n  Rep_Label l @ [p] \\<in> Label\n\ngoal (2 subgoals):\n 1. Rep_Label l @ [p] \\<in> Label \\<Longrightarrow> p \\<notin> set_lbl l\n 2. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "thus ?rhs"], ["proof (prove)\nusing this:\n  Rep_Label l @ [p] \\<in> Label\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l", "by (auto simp: Label_def set_lbl_def)"], ["proof (state)\nthis:\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "assume p: \"?rhs\""], ["proof (state)\nthis:\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "from l[THEN not_leaf_length]"], ["proof (chain)\npicking this:\n  length_lbl l \\<le> f", "have \"length ?l' \\<le> Suc f\""], ["proof (prove)\nusing this:\n  length_lbl l \\<le> f\n\ngoal (1 subgoal):\n 1. length (Rep_Label l @ [p]) \\<le> Suc f", "by (simp add: length_lbl_def)"], ["proof (state)\nthis:\n  length (Rep_Label l @ [p]) \\<le> Suc f\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "moreover"], ["proof (state)\nthis:\n  length (Rep_Label l @ [p]) \\<le> Suc f\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "from Rep_Label[of l]"], ["proof (chain)\npicking this:\n  Rep_Label l \\<in> Label", "have \"distinct (Rep_Label l)\""], ["proof (prove)\nusing this:\n  Rep_Label l \\<in> Label\n\ngoal (1 subgoal):\n 1. distinct (Rep_Label l)", "by (simp add: Label_def)"], ["proof (state)\nthis:\n  distinct (Rep_Label l)\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "with p"], ["proof (chain)\npicking this:\n  p \\<notin> set_lbl l\n  distinct (Rep_Label l)", "have \"distinct ?l'\""], ["proof (prove)\nusing this:\n  p \\<notin> set_lbl l\n  distinct (Rep_Label l)\n\ngoal (1 subgoal):\n 1. distinct (Rep_Label l @ [p])", "by (simp add: set_lbl_def)"], ["proof (state)\nthis:\n  distinct (Rep_Label l @ [p])\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l \\<Longrightarrow> Rep_Label l @ [p] \\<in> Label", "ultimately"], ["proof (chain)\npicking this:\n  length (Rep_Label l @ [p]) \\<le> Suc f\n  distinct (Rep_Label l @ [p])", "show ?lhs"], ["proof (prove)\nusing this:\n  length (Rep_Label l @ [p]) \\<le> Suc f\n  distinct (Rep_Label l @ [p])\n\ngoal (1 subgoal):\n 1. Rep_Label l @ [p] \\<in> Label", "by (simp add: Label_def)"], ["proof (state)\nthis:\n  Rep_Label l @ [p] \\<in> Label\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The label of a child is the label of the parent, extended by a process.\n\\<close>"], ["", "lemma label_children:\n  assumes c: \"c \\<in> children l\"\n  shows \"\\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]", "from c"], ["proof (chain)\npicking this:\n  c \\<in> children l", "obtain p \n    where p: \"p \\<notin> set_lbl l\" and l: \"\\<not>(is_leaf l)\"\n      and c: \"c = Abs_Label (Rep_Label l @ [p])\""], ["proof (prove)\nusing this:\n  c \\<in> children l\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<notin> set_lbl l; \\<not> is_leaf l;\n         c = Abs_Label (Rep_Label l @ [p])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: children_def)"], ["proof (state)\nthis:\n  p \\<notin> set_lbl l\n  \\<not> is_leaf l\n  c = Abs_Label (Rep_Label l @ [p])\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]", "with Rep_Label_append[OF l]"], ["proof (chain)\npicking this:\n  (Rep_Label l @ [?p] \\<in> Label) = (?p \\<notin> set_lbl l)\n  p \\<notin> set_lbl l\n  \\<not> is_leaf l\n  c = Abs_Label (Rep_Label l @ [p])", "show ?thesis"], ["proof (prove)\nusing this:\n  (Rep_Label l @ [?p] \\<in> Label) = (?p \\<notin> set_lbl l)\n  p \\<notin> set_lbl l\n  \\<not> is_leaf l\n  c = Abs_Label (Rep_Label l @ [p])\n\ngoal (1 subgoal):\n 1. \\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]", "by (auto simp: Abs_Label_inverse)"], ["proof (state)\nthis:\n  \\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The label of any child node is one longer than the label of its parent.\n\\<close>"], ["", "lemma children_length:\n  assumes \"l \\<in> children h\"\n  shows \"length_lbl l = Suc (length_lbl h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_lbl l = Suc (length_lbl h)", "using label_children[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>p. p \\<notin> set_lbl h \\<and> Rep_Label l = Rep_Label h @ [p]\n\ngoal (1 subgoal):\n 1. length_lbl l = Suc (length_lbl h)", "by (auto simp: length_lbl_def)"], ["", "text \\<open>The root node is never a child.\\<close>"], ["", "lemma children_not_root:\n  assumes \"root_node \\<in> children l\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using label_children[OF assms] Abs_Label_inverse[OF nil_is_Label]"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     p \\<notin> set_lbl l \\<and> Rep_Label root_node = Rep_Label l @ [p]\n  Rep_Label (Abs_Label []) = []\n\ngoal (1 subgoal):\n 1. P", "by (auto simp: root_node_def)"], ["", "text \\<open>\n  The label of a child with the last element removed is the label of\n  the parent.\n\\<close>"], ["", "lemma children_butlast_lbl:\n  assumes \"c \\<in> children l\"\n  shows \"butlast_lbl c = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast_lbl c = l", "using label_children[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>p. p \\<notin> set_lbl l \\<and> Rep_Label c = Rep_Label l @ [p]\n\ngoal (1 subgoal):\n 1. butlast_lbl c = l", "by (auto simp: butlast_lbl_def Rep_Label_inverse)"], ["", "text \\<open>\n  The root node is not a child, and it is the only such node.\n\\<close>"], ["", "lemma root_iff_no_child: \"(l = root_node) = (\\<forall>l'. l \\<notin> children l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l = root_node) = (\\<forall>l'. l \\<notin> children l')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. l = root_node \\<Longrightarrow> \\<forall>l'. l \\<notin> children l'\n 2. \\<forall>l'. l \\<notin> children l' \\<Longrightarrow> l = root_node", "assume \"l = root_node\""], ["proof (state)\nthis:\n  l = root_node\n\ngoal (2 subgoals):\n 1. l = root_node \\<Longrightarrow> \\<forall>l'. l \\<notin> children l'\n 2. \\<forall>l'. l \\<notin> children l' \\<Longrightarrow> l = root_node", "thus \"\\<forall>l'. l \\<notin> children l'\""], ["proof (prove)\nusing this:\n  l = root_node\n\ngoal (1 subgoal):\n 1. \\<forall>l'. l \\<notin> children l'", "by (auto elim: children_not_root)"], ["proof (state)\nthis:\n  \\<forall>l'. l \\<notin> children l'\n\ngoal (1 subgoal):\n 1. \\<forall>l'. l \\<notin> children l' \\<Longrightarrow> l = root_node", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>l'. l \\<notin> children l' \\<Longrightarrow> l = root_node", "assume rhs: \"\\<forall>l'. l \\<notin> children l'\""], ["proof (state)\nthis:\n  \\<forall>l'. l \\<notin> children l'\n\ngoal (1 subgoal):\n 1. \\<forall>l'. l \\<notin> children l' \\<Longrightarrow> l = root_node", "show \"l = root_node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = root_node", "proof (rule rev_exhaust[of \"Rep_Label l\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. Rep_Label l = [] \\<Longrightarrow> l = root_node\n 2. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "assume \"Rep_Label l = []\""], ["proof (state)\nthis:\n  Rep_Label l = []\n\ngoal (2 subgoals):\n 1. Rep_Label l = [] \\<Longrightarrow> l = root_node\n 2. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "hence \"Rep_Label l = Rep_Label root_node\""], ["proof (prove)\nusing this:\n  Rep_Label l = []\n\ngoal (1 subgoal):\n 1. Rep_Label l = Rep_Label root_node", "by simp"], ["proof (state)\nthis:\n  Rep_Label l = Rep_Label root_node\n\ngoal (2 subgoals):\n 1. Rep_Label l = [] \\<Longrightarrow> l = root_node\n 2. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_Label l = Rep_Label root_node\n\ngoal (1 subgoal):\n 1. l = root_node", "by (simp only: Rep_Label_inject)"], ["proof (state)\nthis:\n  l = root_node\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "fix l' q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "assume l': \"Rep_Label l = l' @ [q]\""], ["proof (state)\nthis:\n  Rep_Label l = l' @ [q]\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "let ?l' = \"Abs_Label l'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "from Rep_Label[of l] l'"], ["proof (chain)\npicking this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = l' @ [q]", "have \"l' \\<in> Label\""], ["proof (prove)\nusing this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = l' @ [q]\n\ngoal (1 subgoal):\n 1. l' \\<in> Label", "by (simp add: Label_def)"], ["proof (state)\nthis:\n  l' \\<in> Label\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "hence repl': \"Rep_Label ?l' = l'\""], ["proof (prove)\nusing this:\n  l' \\<in> Label\n\ngoal (1 subgoal):\n 1. Rep_Label (Abs_Label l') = l'", "by (rule Abs_Label_inverse)"], ["proof (state)\nthis:\n  Rep_Label (Abs_Label l') = l'\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "from Rep_Label[of l] l'"], ["proof (chain)\npicking this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = l' @ [q]", "have \"l' @ [q] \\<in> Label\""], ["proof (prove)\nusing this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = l' @ [q]\n\ngoal (1 subgoal):\n 1. l' @ [q] \\<in> Label", "by (simp add: Label_def)"], ["proof (state)\nthis:\n  l' @ [q] \\<in> Label\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "with l'"], ["proof (chain)\npicking this:\n  Rep_Label l = l' @ [q]\n  l' @ [q] \\<in> Label", "have \"Rep_Label l = Rep_Label (Abs_Label (l' @ [q]))\""], ["proof (prove)\nusing this:\n  Rep_Label l = l' @ [q]\n  l' @ [q] \\<in> Label\n\ngoal (1 subgoal):\n 1. Rep_Label l = Rep_Label (Abs_Label (l' @ [q]))", "by (simp add: Abs_Label_inverse)"], ["proof (state)\nthis:\n  Rep_Label l = Rep_Label (Abs_Label (l' @ [q]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "hence \"l = Abs_Label (l' @ [q])\""], ["proof (prove)\nusing this:\n  Rep_Label l = Rep_Label (Abs_Label (l' @ [q]))\n\ngoal (1 subgoal):\n 1. l = Abs_Label (l' @ [q])", "by (simp add: Rep_Label_inject)"], ["proof (state)\nthis:\n  l = Abs_Label (l' @ [q])\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "moreover"], ["proof (state)\nthis:\n  l = Abs_Label (l' @ [q])\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "from Rep_Label[of l] l'"], ["proof (chain)\npicking this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = l' @ [q]", "have \"length l' < Suc f\" \"q \\<notin> set l'\""], ["proof (prove)\nusing this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = l' @ [q]\n\ngoal (1 subgoal):\n 1. length l' < Suc f &&& q \\<notin> set l'", "by (auto simp: Label_def)"], ["proof (state)\nthis:\n  length l' < Suc f\n  q \\<notin> set l'\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "moreover"], ["proof (state)\nthis:\n  length l' < Suc f\n  q \\<notin> set l'\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "note repl'"], ["proof (state)\nthis:\n  Rep_Label (Abs_Label l') = l'\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "ultimately"], ["proof (chain)\npicking this:\n  l = Abs_Label (l' @ [q])\n  length l' < Suc f\n  q \\<notin> set l'\n  Rep_Label (Abs_Label l') = l'", "have \"l \\<in> children ?l'\""], ["proof (prove)\nusing this:\n  l = Abs_Label (l' @ [q])\n  length l' < Suc f\n  q \\<notin> set l'\n  Rep_Label (Abs_Label l') = l'\n\ngoal (1 subgoal):\n 1. l \\<in> children (Abs_Label l')", "by (auto simp: children_def is_leaf_def length_lbl_def set_lbl_def)"], ["proof (state)\nthis:\n  l \\<in> children (Abs_Label l')\n\ngoal (1 subgoal):\n 1. \\<And>ys y. Rep_Label l = ys @ [y] \\<Longrightarrow> l = root_node", "with rhs"], ["proof (chain)\npicking this:\n  \\<forall>l'. l \\<notin> children l'\n  l \\<in> children (Abs_Label l')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l'. l \\<notin> children l'\n  l \\<in> children (Abs_Label l')\n\ngoal (1 subgoal):\n 1. l = root_node", "by blast"], ["proof (state)\nthis:\n  l = root_node\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l = root_node\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If some label \\<open>l\\<close> is not a leaf, then the set of processes that\n  appear at the end of the labels of its children is the set of all \n  processes that do not appear in \\<open>l\\<close>.\n\\<close>"], ["", "lemma children_last_set:\n  assumes l: \"\\<not>(is_leaf l)\"\n  shows \"last_lbl ` (children l) = UNIV - set_lbl l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_lbl ` children l = UNIV - set_lbl l", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. last_lbl ` children l \\<subseteq> UNIV - set_lbl l\n 2. UNIV - set_lbl l \\<subseteq> last_lbl ` children l", "show \"last_lbl ` (children l) \\<subseteq> UNIV - set_lbl l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_lbl ` children l \\<subseteq> UNIV - set_lbl l", "by (auto dest: label_children simp: last_lbl_def)"], ["proof (state)\nthis:\n  last_lbl ` children l \\<subseteq> UNIV - set_lbl l\n\ngoal (1 subgoal):\n 1. UNIV - set_lbl l \\<subseteq> last_lbl ` children l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. UNIV - set_lbl l \\<subseteq> last_lbl ` children l", "show \"UNIV - set_lbl l \\<subseteq> last_lbl ` (children l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV - set_lbl l \\<subseteq> last_lbl ` children l", "proof (auto simp: image_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> set_lbl l \\<Longrightarrow>\n       \\<exists>xa\\<in>children l. x = last_lbl xa", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> set_lbl l \\<Longrightarrow>\n       \\<exists>xa\\<in>children l. x = last_lbl xa", "assume p: \"p \\<notin> set_lbl l\""], ["proof (state)\nthis:\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> set_lbl l \\<Longrightarrow>\n       \\<exists>xa\\<in>children l. x = last_lbl xa", "with l"], ["proof (chain)\npicking this:\n  \\<not> is_leaf l\n  p \\<notin> set_lbl l", "have c: \"Abs_Label (Rep_Label l @ [p]) \\<in> children l\""], ["proof (prove)\nusing this:\n  \\<not> is_leaf l\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. Abs_Label (Rep_Label l @ [p]) \\<in> children l", "by (auto simp: children_def)"], ["proof (state)\nthis:\n  Abs_Label (Rep_Label l @ [p]) \\<in> children l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> set_lbl l \\<Longrightarrow>\n       \\<exists>xa\\<in>children l. x = last_lbl xa", "with Rep_Label_append[OF l] p"], ["proof (chain)\npicking this:\n  (Rep_Label l @ [?p] \\<in> Label) = (?p \\<notin> set_lbl l)\n  p \\<notin> set_lbl l\n  Abs_Label (Rep_Label l @ [p]) \\<in> children l", "show \"\\<exists>c \\<in> children l. p = last_lbl c\""], ["proof (prove)\nusing this:\n  (Rep_Label l @ [?p] \\<in> Label) = (?p \\<notin> set_lbl l)\n  p \\<notin> set_lbl l\n  Abs_Label (Rep_Label l @ [p]) \\<in> children l\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>children l. p = last_lbl c", "by (force simp: last_lbl_def Abs_Label_inverse)"], ["proof (state)\nthis:\n  \\<exists>c\\<in>children l. p = last_lbl c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UNIV - set_lbl l \\<subseteq> last_lbl ` children l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The function returning the last element of a label is injective on the\n  set of children of some given label.\n\\<close>"], ["", "lemma last_lbl_inj_on_children:\"inj_on last_lbl (children l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on last_lbl (children l)", "proof (auto simp: inj_on_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> children l; y \\<in> children l;\n        last_lbl x = last_lbl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix c c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> children l; y \\<in> children l;\n        last_lbl x = last_lbl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume c: \"c \\<in> children l\" and c': \"c' \\<in> children l\"\n     and eq: \"last_lbl c = last_lbl c'\""], ["proof (state)\nthis:\n  c \\<in> children l\n  c' \\<in> children l\n  last_lbl c = last_lbl c'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> children l; y \\<in> children l;\n        last_lbl x = last_lbl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from c c'"], ["proof (chain)\npicking this:\n  c \\<in> children l\n  c' \\<in> children l", "obtain p p'\n    where p: \"Rep_Label c = Rep_Label l @ [p]\"\n      and p': \"Rep_Label c' = Rep_Label l @ [p']\""], ["proof (prove)\nusing this:\n  c \\<in> children l\n  c' \\<in> children l\n\ngoal (1 subgoal):\n 1. (\\<And>p p'.\n        \\<lbrakk>Rep_Label c = Rep_Label l @ [p];\n         Rep_Label c' = Rep_Label l @ [p']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: label_children)"], ["proof (state)\nthis:\n  Rep_Label c = Rep_Label l @ [p]\n  Rep_Label c' = Rep_Label l @ [p']\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> children l; y \\<in> children l;\n        last_lbl x = last_lbl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from p p' eq"], ["proof (chain)\npicking this:\n  Rep_Label c = Rep_Label l @ [p]\n  Rep_Label c' = Rep_Label l @ [p']\n  last_lbl c = last_lbl c'", "have \"p = p'\""], ["proof (prove)\nusing this:\n  Rep_Label c = Rep_Label l @ [p]\n  Rep_Label c' = Rep_Label l @ [p']\n  last_lbl c = last_lbl c'\n\ngoal (1 subgoal):\n 1. p = p'", "by (simp add: last_lbl_def)"], ["proof (state)\nthis:\n  p = p'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> children l; y \\<in> children l;\n        last_lbl x = last_lbl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with p p'"], ["proof (chain)\npicking this:\n  Rep_Label c = Rep_Label l @ [p]\n  Rep_Label c' = Rep_Label l @ [p']\n  p = p'", "have \"Rep_Label c = Rep_Label c'\""], ["proof (prove)\nusing this:\n  Rep_Label c = Rep_Label l @ [p]\n  Rep_Label c' = Rep_Label l @ [p']\n  p = p'\n\ngoal (1 subgoal):\n 1. Rep_Label c = Rep_Label c'", "by simp"], ["proof (state)\nthis:\n  Rep_Label c = Rep_Label c'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> children l; y \\<in> children l;\n        last_lbl x = last_lbl y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"c = c'\""], ["proof (prove)\nusing this:\n  Rep_Label c = Rep_Label c'\n\ngoal (1 subgoal):\n 1. c = c'", "by (simp add: Rep_Label_inject)"], ["proof (state)\nthis:\n  c = c'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The number of children of any non-leaf label \\<open>l\\<close> is the\n  number of processes that do not appear in \\<open>l\\<close>.\n\\<close>"], ["", "lemma card_children:\n  assumes \"\\<not>(is_leaf l)\"\n  shows \"card (children l) = N - (length_lbl l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "from assms"], ["proof (chain)\npicking this:\n  \\<not> is_leaf l", "have \"last_lbl ` (children l) = UNIV - set_lbl l\""], ["proof (prove)\nusing this:\n  \\<not> is_leaf l\n\ngoal (1 subgoal):\n 1. last_lbl ` children l = UNIV - set_lbl l", "by (rule children_last_set)"], ["proof (state)\nthis:\n  last_lbl ` children l = UNIV - set_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "moreover"], ["proof (state)\nthis:\n  last_lbl ` children l = UNIV - set_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "have \"card (UNIV - set_lbl l) = card (UNIV::Proc set) - card (set_lbl l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV - set_lbl l) = N - card (set_lbl l)", "by (auto simp: card_Diff_subset_Int)"], ["proof (state)\nthis:\n  card (UNIV - set_lbl l) = N - card (set_lbl l)\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "moreover"], ["proof (state)\nthis:\n  card (UNIV - set_lbl l) = N - card (set_lbl l)\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "from last_lbl_inj_on_children"], ["proof (chain)\npicking this:\n  inj_on last_lbl (children ?l)", "have \"card (children l) = card (last_lbl ` children l)\""], ["proof (prove)\nusing this:\n  inj_on last_lbl (children ?l)\n\ngoal (1 subgoal):\n 1. card (children l) = card (last_lbl ` children l)", "by (rule sym[OF card_image])"], ["proof (state)\nthis:\n  card (children l) = card (last_lbl ` children l)\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "moreover"], ["proof (state)\nthis:\n  card (children l) = card (last_lbl ` children l)\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "note card_set_lbl[of l]"], ["proof (state)\nthis:\n  card (set_lbl l) = length_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "ultimately"], ["proof (chain)\npicking this:\n  last_lbl ` children l = UNIV - set_lbl l\n  card (UNIV - set_lbl l) = N - card (set_lbl l)\n  card (children l) = card (last_lbl ` children l)\n  card (set_lbl l) = length_lbl l", "show ?thesis"], ["proof (prove)\nusing this:\n  last_lbl ` children l = UNIV - set_lbl l\n  card (UNIV - set_lbl l) = N - card (set_lbl l)\n  card (children l) = card (last_lbl ` children l)\n  card (set_lbl l) = length_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) = N - length_lbl l", "by auto"], ["proof (state)\nthis:\n  card (children l) = N - length_lbl l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Suppose a non-root label \\<open>l'\\<close> of length \\<open>r+1\\<close> ending in \\<open>q\\<close>, \n  and suppose that \\<open>q\\<close> is well heard by process \\<open>p\\<close> in round\n  \\<open>r\\<close>. Then the value with which \\<open>p\\<close> decorates \\<open>l\\<close> is the one\n  that \\<open>q\\<close> associates to the parent of \\<open>l\\<close>.\n\\<close>"], ["", "lemma sho_correct_vals:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and l': \"l' \\<in> children l\"\n      and shop: \"last_lbl l' \\<in> SHOs (length_lbl l) p \\<inter> HOs (length_lbl l) p\"\n                (is \"?q \\<in> SHOs (?len l) p \\<inter> _\")\n  shows \"vals (rho (?len l') p) l' = vals (rho (?len l) ?q) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' =\n    vals (rho (length_lbl l) (last_lbl l')) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' =\n    vals (rho (length_lbl l) (last_lbl l')) l", "let ?r = \"?len l\""], ["proof (state)\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' =\n    vals (rho (length_lbl l) (last_lbl l')) l", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "obtain \\<mu>p\n    where nxt: \"nextState EIG_M ?r p (rho ?r p) \\<mu>p (rho (Suc ?r) p)\"\n      and mu: \"\\<mu>p \\<in> SHOmsgVectors EIG_M ?r p (rho ?r) (HOs ?r p) (SHOs ?r p)\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        \\<lbrakk>nextState EIG_M (length_lbl l) p (rho (length_lbl l) p)\n                  \\<mu>p (rho (Suc (length_lbl l)) p);\n         \\<mu>p\n         \\<in> SHOmsgVectors EIG_M (length_lbl l) p (rho (length_lbl l))\n                (HOs (length_lbl l) p) (SHOs (length_lbl l) p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: EIG_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState EIG_M (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)\n  \\<mu>p\n  \\<in> SHOmsgVectors EIG_M (length_lbl l) p (rho (length_lbl l))\n         (HOs (length_lbl l) p) (SHOs (length_lbl l) p)\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' =\n    vals (rho (length_lbl l) (last_lbl l')) l", "with shop"], ["proof (chain)\npicking this:\n  last_lbl l' \\<in> SHOs (length_lbl l) p \\<inter> HOs (length_lbl l) p\n  nextState EIG_M (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)\n  \\<mu>p\n  \\<in> SHOmsgVectors EIG_M (length_lbl l) p (rho (length_lbl l))\n         (HOs (length_lbl l) p) (SHOs (length_lbl l) p)", "have msl:\"\\<mu>p ?q = Some (vals (rho ?r ?q))\""], ["proof (prove)\nusing this:\n  last_lbl l' \\<in> SHOs (length_lbl l) p \\<inter> HOs (length_lbl l) p\n  nextState EIG_M (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)\n  \\<mu>p\n  \\<in> SHOmsgVectors EIG_M (length_lbl l) p (rho (length_lbl l))\n         (HOs (length_lbl l) p) (SHOs (length_lbl l) p)\n\ngoal (1 subgoal):\n 1. \\<mu>p (last_lbl l') = Some (vals (rho (length_lbl l) (last_lbl l')))", "by (auto simp: EIG_SHOMachine_def EIG_sendMsg_def SHOmsgVectors_def)"], ["proof (state)\nthis:\n  \\<mu>p (last_lbl l') = Some (vals (rho (length_lbl l) (last_lbl l')))\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' =\n    vals (rho (length_lbl l) (last_lbl l')) l", "from nxt length_lbl[of l'] children_length[OF l']"], ["proof (chain)\npicking this:\n  nextState EIG_M (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)\n  length_lbl l' \\<le> Suc f\n  length_lbl l' = Suc (length_lbl l)", "have \"extend_vals ?r p (rho ?r p) \\<mu>p (rho (Suc ?r) p)\""], ["proof (prove)\nusing this:\n  nextState EIG_M (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)\n  length_lbl l' \\<le> Suc f\n  length_lbl l' = Suc (length_lbl l)\n\ngoal (1 subgoal):\n 1. extend_vals (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n     (rho (Suc (length_lbl l)) p)", "by (auto simp: EIG_SHOMachine_def nextState_def EIG_nextState_def\n                   next_main_def next_end_def)"], ["proof (state)\nthis:\n  extend_vals (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' =\n    vals (rho (length_lbl l) (last_lbl l')) l", "with msl l'"], ["proof (chain)\npicking this:\n  \\<mu>p (last_lbl l') = Some (vals (rho (length_lbl l) (last_lbl l')))\n  l' \\<in> children l\n  extend_vals (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu>p (last_lbl l') = Some (vals (rho (length_lbl l) (last_lbl l')))\n  l' \\<in> children l\n  extend_vals (length_lbl l) p (rho (length_lbl l) p) \\<mu>p\n   (rho (Suc (length_lbl l)) p)\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' =\n    vals (rho (length_lbl l) (last_lbl l')) l", "by (auto simp: extend_vals_def children_length children_butlast_lbl)"], ["proof (state)\nthis:\n  vals (rho (length_lbl l') p) l' =\n  vals (rho (length_lbl l) (last_lbl l')) l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A process fixes the value \\<open>vals l\\<close> of a label at state\n  \\<open>length_lbl l\\<close>, and then never modifies the value.\n\\<close>"], ["", "(* currently nowhere used *)"], ["", "lemma keep_vals:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n  shows \"vals (rho (length_lbl l + n) p) l = vals (rho (length_lbl l) p) l\"\n     (is \"?v n = ?vl\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l + n) p) l = vals (rho (length_lbl l) p) l", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. vals (rho (length_lbl l + 0) p) l = vals (rho (length_lbl l) p) l\n 2. \\<And>n.\n       vals (rho (length_lbl l + n) p) l =\n       vals (rho (length_lbl l) p) l \\<Longrightarrow>\n       vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "show \"?v 0 = ?vl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l + 0) p) l = vals (rho (length_lbl l) p) l", "by simp"], ["proof (state)\nthis:\n  vals (rho (length_lbl l + 0) p) l = vals (rho (length_lbl l) p) l\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       vals (rho (length_lbl l + n) p) l =\n       vals (rho (length_lbl l) p) l \\<Longrightarrow>\n       vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       vals (rho (length_lbl l + n) p) l =\n       vals (rho (length_lbl l) p) l \\<Longrightarrow>\n       vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       vals (rho (length_lbl l + n) p) l =\n       vals (rho (length_lbl l) p) l \\<Longrightarrow>\n       vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "assume ih: \"?v n = ?vl\""], ["proof (state)\nthis:\n  vals (rho (length_lbl l + n) p) l = vals (rho (length_lbl l) p) l\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       vals (rho (length_lbl l + n) p) l =\n       vals (rho (length_lbl l) p) l \\<Longrightarrow>\n       vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "let ?r = \"length_lbl l + n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       vals (rho (length_lbl l + n) p) l =\n       vals (rho (length_lbl l) p) l \\<Longrightarrow>\n       vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "obtain \\<mu>p\n    where nxt: \"nextState EIG_M ?r p (rho ?r p) \\<mu>p (rho (Suc ?r) p)\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        nextState EIG_M (length_lbl l + n) p (rho (length_lbl l + n) p)\n         \\<mu>p (rho (Suc (length_lbl l + n)) p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: EIG_SHOMachine_def SHORun_eq SHOnextConfig_eq)"], ["proof (state)\nthis:\n  nextState EIG_M (length_lbl l + n) p (rho (length_lbl l + n) p) \\<mu>p\n   (rho (Suc (length_lbl l + n)) p)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       vals (rho (length_lbl l + n) p) l =\n       vals (rho (length_lbl l) p) l \\<Longrightarrow>\n       vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "with ih"], ["proof (chain)\npicking this:\n  vals (rho (length_lbl l + n) p) l = vals (rho (length_lbl l) p) l\n  nextState EIG_M (length_lbl l + n) p (rho (length_lbl l + n) p) \\<mu>p\n   (rho (Suc (length_lbl l + n)) p)", "show \"?v (Suc n) = ?vl\""], ["proof (prove)\nusing this:\n  vals (rho (length_lbl l + n) p) l = vals (rho (length_lbl l) p) l\n  nextState EIG_M (length_lbl l + n) p (rho (length_lbl l + n) p) \\<mu>p\n   (rho (Suc (length_lbl l + n)) p)\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l", "by (auto simp: EIG_SHOMachine_def nextState_def EIG_nextState_def\n                   next_main_def next_end_def extend_vals_def)"], ["proof (state)\nthis:\n  vals (rho (length_lbl l + Suc n) p) l = vals (rho (length_lbl l) p) l\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lynch's Lemmas and Theorems\\<close>"], ["", "text \\<open>\n  If some process is safely heard by all processes at round \\<open>r\\<close>,\n  then all processes agree on the value associated to labels of length \n  \\<open>r+1\\<close> ending in that process.\n\\<close>"], ["", "lemma lynch_6_15:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n  and l': \"l' \\<in> children l\"\n  and skr: \"last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n  shows \"vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l') q) l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l') q) l'", "using assms"], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  l' \\<in> children l\n  last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l') q) l'", "unfolding SKr_def"], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  l' \\<in> children l\n  last_lbl l'\n  \\<in> {q. \\<forall>p.\n               q \\<in> HOs (length_lbl l) p \\<inter> SHOs (length_lbl l) p}\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l') q) l'", "by (auto simp: sho_correct_vals)"], ["", "text \\<open>\n  Suppose that \\<open>l\\<close> is a non-root label whose last element was well\n  heard by all processes at round \\<open>r\\<close>, and that \\<open>l'\\<close> is a\n  child of \\<open>l\\<close> corresponding to process \\<open>q\\<close> that is also\n  well heard by all processes at round \\<open>r+1\\<close>. Then the values\n  associated with \\<open>l\\<close> and \\<open>l'\\<close> by any process \\<open>p\\<close>\n  are identical.\n\\<close>"], ["", "lemma lynch_6_16_a:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and l: \"l \\<in> children t\"\n      and skrl: \"last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\"\n      and l': \"l' \\<in> children l\"\n      and skrl':\"last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n    shows \"vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l", "using assms"], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  l \\<in> children t\n  last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\n  l' \\<in> children l\n  last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l", "by (auto simp: SKr_def sho_correct_vals)"], ["", "text \\<open>\n  For any non-leaf label \\<open>l\\<close>, more than half of its children end with a \n  process that is well heard by everyone at round \\<open>length_lbl l\\<close>.\n\\<close>"], ["", "lemma lynch_6_16_c:\n  assumes commR: \"EIG_commPerRd (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n                 (is \"EIG_commPerRd (HOs ?r) _\")\n      and l: \"\\<not>(is_leaf l)\"\n  shows \"card {l' \\<in> children l. last_lbl l' \\<in> SKr (HOs ?r) (SHOs ?r)}\n         > card (children l) div 2\"\n    (is \"card ?lhs > _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "let ?skr = \"SKr (HOs ?r) (SHOs ?r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "have \"last_lbl ` ?lhs = ?skr - set_lbl l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_lbl `\n    {l' \\<in> children l.\n     last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n    SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. last_lbl `\n    {l' \\<in> children l.\n     last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n    \\<subseteq> SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n 2. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "from children_last_set[OF l]"], ["proof (chain)\npicking this:\n  last_lbl ` children l = UNIV - set_lbl l", "show \"last_lbl ` ?lhs \\<subseteq> ?skr - set_lbl l\""], ["proof (prove)\nusing this:\n  last_lbl ` children l = UNIV - set_lbl l\n\ngoal (1 subgoal):\n 1. last_lbl `\n    {l' \\<in> children l.\n     last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n    \\<subseteq> SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l", "by (auto simp: children_length)"], ["proof (state)\nthis:\n  last_lbl `\n  {l' \\<in> children l.\n   last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  \\<subseteq> SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "assume p: \"p \\<in> ?skr\" \"p \\<notin> set_lbl l\""], ["proof (state)\nthis:\n  p \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "with  children_last_set[OF l]"], ["proof (chain)\npicking this:\n  last_lbl ` children l = UNIV - set_lbl l\n  p \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n  p \\<notin> set_lbl l", "have \"p \\<in> last_lbl ` children l\""], ["proof (prove)\nusing this:\n  last_lbl ` children l = UNIV - set_lbl l\n  p \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. p \\<in> last_lbl ` children l", "by auto"], ["proof (state)\nthis:\n  p \\<in> last_lbl ` children l\n\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "with p"], ["proof (chain)\npicking this:\n  p \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n  p \\<notin> set_lbl l\n  p \\<in> last_lbl ` children l", "have \"p \\<in> last_lbl ` ?lhs\""], ["proof (prove)\nusing this:\n  p \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n  p \\<notin> set_lbl l\n  p \\<in> last_lbl ` children l\n\ngoal (1 subgoal):\n 1. p \\<in> last_lbl `\n            {l' \\<in> children l.\n             last_lbl l'\n             \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "by (auto simp: image_def children_length)"], ["proof (state)\nthis:\n  p \\<in> last_lbl `\n          {l' \\<in> children l.\n           last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?p3 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l));\n   ?p3 \\<notin> set_lbl l\\<rbrakk>\n  \\<Longrightarrow> ?p3\n                    \\<in> last_lbl `\n                          {l' \\<in> children l.\n                           last_lbl l'\n                           \\<in> SKr (HOs (length_lbl l))\n                                  (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "thus \"?skr - set_lbl l \\<subseteq> last_lbl ` ?lhs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?p3 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l));\n   ?p3 \\<notin> set_lbl l\\<rbrakk>\n  \\<Longrightarrow> ?p3\n                    \\<in> last_lbl `\n                          {l' \\<in> children l.\n                           last_lbl l'\n                           \\<in> SKr (HOs (length_lbl l))\n                                  (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n    \\<subseteq> last_lbl `\n                {l' \\<in> children l.\n                 last_lbl l'\n                 \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "by auto"], ["proof (state)\nthis:\n  SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n  \\<subseteq> last_lbl `\n              {l' \\<in> children l.\n               last_lbl l'\n               \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last_lbl `\n  {l' \\<in> children l.\n   last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n  SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "moreover"], ["proof (state)\nthis:\n  last_lbl `\n  {l' \\<in> children l.\n   last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n  SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "from last_lbl_inj_on_children[of l]"], ["proof (chain)\npicking this:\n  inj_on last_lbl (children l)", "have \"inj_on last_lbl ?lhs\""], ["proof (prove)\nusing this:\n  inj_on last_lbl (children l)\n\ngoal (1 subgoal):\n 1. inj_on last_lbl\n     {l' \\<in> children l.\n      last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj_on last_lbl\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "ultimately"], ["proof (chain)\npicking this:\n  last_lbl `\n  {l' \\<in> children l.\n   last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n  SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n  inj_on last_lbl\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "have \"card ?lhs = card (?skr - set_lbl l)\""], ["proof (prove)\nusing this:\n  last_lbl `\n  {l' \\<in> children l.\n   last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n  SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l\n  inj_on last_lbl\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. card\n     {l' \\<in> children l.\n      last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n    card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l)", "by (auto dest: card_image)"], ["proof (state)\nthis:\n  card\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l)\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "also"], ["proof (state)\nthis:\n  card\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))} =\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l)\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "have \"\\<dots> \\<ge> (card ?skr) - (card (set_lbl l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - card (set_lbl l)\n    \\<le> card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l)", "by (simp add: diff_card_le_card_Diff)"], ["proof (state)\nthis:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - card (set_lbl l)\n  \\<le> card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)) - set_lbl l)\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "finally"], ["proof (chain)\npicking this:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - card (set_lbl l)\n  \\<le> card\n         {l' \\<in> children l.\n          last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "have \"card ?lhs \\<ge> (card ?skr) - ?r\""], ["proof (prove)\nusing this:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - card (set_lbl l)\n  \\<le> card\n         {l' \\<in> children l.\n          last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n    \\<le> card\n           {l' \\<in> children l.\n            last_lbl l'\n            \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "using card_set_lbl[of l]"], ["proof (prove)\nusing this:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - card (set_lbl l)\n  \\<le> card\n         {l' \\<in> children l.\n          last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  card (set_lbl l) = length_lbl l\n\ngoal (1 subgoal):\n 1. card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n    \\<le> card\n           {l' \\<in> children l.\n            last_lbl l'\n            \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "by simp"], ["proof (state)\nthis:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n  \\<le> card\n         {l' \\<in> children l.\n          last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "moreover"], ["proof (state)\nthis:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n  \\<le> card\n         {l' \\<in> children l.\n          last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "from commR"], ["proof (chain)\npicking this:\n  EIG_commPerRd (HOs (length_lbl l)) (SHOs (length_lbl l))", "have \"card ?skr > (N + f) div 2\""], ["proof (prove)\nusing this:\n  EIG_commPerRd (HOs (length_lbl l)) (SHOs (length_lbl l))\n\ngoal (1 subgoal):\n 1. (N + f) div 2 < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)))", "by (auto simp: EIG_commPerRd_def)"], ["proof (state)\nthis:\n  (N + f) div 2 < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)))\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "with not_leaf_length[OF l] f"], ["proof (chain)\npicking this:\n  length_lbl l \\<le> f\n  f < N\n  (N + f) div 2 < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)))", "have \"(card ?skr) - ?r > (N - ?r) div 2\""], ["proof (prove)\nusing this:\n  length_lbl l \\<le> f\n  f < N\n  (N + f) div 2 < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l)))\n\ngoal (1 subgoal):\n 1. (N - length_lbl l) div 2\n    < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l", "by auto"], ["proof (state)\nthis:\n  (N - length_lbl l) div 2\n  < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "with card_children[OF l]"], ["proof (chain)\npicking this:\n  card (children l) = N - length_lbl l\n  (N - length_lbl l) div 2\n  < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l", "have \"(card ?skr) - ?r > card (children l) div 2\""], ["proof (prove)\nusing this:\n  card (children l) = N - length_lbl l\n  (N - length_lbl l) div 2\n  < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l", "by simp"], ["proof (state)\nthis:\n  card (children l) div 2\n  < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "ultimately"], ["proof (chain)\npicking this:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n  \\<le> card\n         {l' \\<in> children l.\n          last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  card (children l) div 2\n  < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l", "show ?thesis"], ["proof (prove)\nusing this:\n  card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n  \\<le> card\n         {l' \\<in> children l.\n          last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  card (children l) div 2\n  < card (SKr (HOs (length_lbl l)) (SHOs (length_lbl l))) - length_lbl l\n\ngoal (1 subgoal):\n 1. card (children l) div 2\n    < card\n       {l' \\<in> children l.\n        last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}", "by simp"], ["proof (state)\nthis:\n  card (children l) div 2\n  < card\n     {l' \\<in> children l.\n      last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If \\<open>l\\<close> is a non-leaf label such that all of its children corresponding\n  to well-heard processes at round \\<open>length_lbl l\\<close> have a uniform\n  \\<open>newvals\\<close> decoration at round \\<open>f+1\\<close>, then \\<open>l\\<close>\n  itself is decorated with that same value.\n\\<close>"], ["", "lemma newvals_skr_uniform:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"EIG_commPerRd (HOs (length_lbl l)) (SHOs (length_lbl l))\"\n                 (is \"EIG_commPerRd (HOs ?r) _\")\n      and notleaf: \"\\<not>(is_leaf l)\"\n      and unif: \"\\<And>l'. \\<lbrakk>l' \\<in> children l;\n                   last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n                  \\<rbrakk> \\<Longrightarrow> newvals (rho (Suc f) p) l' = v\"\n  shows \"newvals (rho (Suc f) p) l = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "from unif"], ["proof (chain)\npicking this:\n  \\<lbrakk>?l' \\<in> children l;\n   last_lbl ?l'\n   \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l' = v", "have \"card {l' \\<in> children l. last_lbl l' \\<in> SKr (HOs ?r) (SHOs ?r)}\n      \\<le> card {l' \\<in> children l. newvals (rho (Suc f) p) l' = v}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?l' \\<in> children l;\n   last_lbl ?l'\n   \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l' = v\n\ngoal (1 subgoal):\n 1. card\n     {l' \\<in> children l.\n      last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n    \\<le> card {l' \\<in> children l. newvals (rho (Suc f) p) l' = v}", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  \\<le> card {l' \\<in> children l. newvals (rho (Suc f) p) l' = v}\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "with lynch_6_16_c[of HOs l SHOs, OF commR notleaf]"], ["proof (chain)\npicking this:\n  card (children l) div 2\n  < card\n     {l' \\<in> children l.\n      last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  card\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  \\<le> card {l' \\<in> children l. newvals (rho (Suc f) p) l' = v}", "have maj: \"has_majority v (newvals (rho (Suc f) p)) (children l)\""], ["proof (prove)\nusing this:\n  card (children l) div 2\n  < card\n     {l' \\<in> children l.\n      last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  card\n   {l' \\<in> children l.\n    last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))}\n  \\<le> card {l' \\<in> children l. newvals (rho (Suc f) p) l' = v}\n\ngoal (1 subgoal):\n 1. has_majority v (newvals (rho (Suc f) p)) (children l)", "by (simp add: has_majority_def)"], ["proof (state)\nthis:\n  has_majority v (newvals (rho (Suc f) p)) (children l)\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "have \"check_newvals (rho (Suc f) p)\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. check_newvals (rho (Suc f) p)", "by (auto simp: EIG_SHOMachine_def SHORun_eq SHOnextConfig_eq\n                   nextState_def EIG_nextState_def next_end_def)"], ["proof (state)\nthis:\n  check_newvals (rho (Suc f) p)\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "with maj notleaf"], ["proof (chain)\npicking this:\n  has_majority v (newvals (rho (Suc f) p)) (children l)\n  \\<not> is_leaf l\n  check_newvals (rho (Suc f) p)", "obtain w \n    where wmaj: \"has_majority w (newvals (rho (Suc f) p)) (children l)\"\n      and wupd: \"newvals (rho (Suc f) p) l = w\""], ["proof (prove)\nusing this:\n  has_majority v (newvals (rho (Suc f) p)) (children l)\n  \\<not> is_leaf l\n  check_newvals (rho (Suc f) p)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>has_majority w (newvals (rho (Suc f) p)) (children l);\n         newvals (rho (Suc f) p) l = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: check_newvals_def)"], ["proof (state)\nthis:\n  has_majority w (newvals (rho (Suc f) p)) (children l)\n  newvals (rho (Suc f) p) l = w\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "from maj wmaj"], ["proof (chain)\npicking this:\n  has_majority v (newvals (rho (Suc f) p)) (children l)\n  has_majority w (newvals (rho (Suc f) p)) (children l)", "have \"w = v\""], ["proof (prove)\nusing this:\n  has_majority v (newvals (rho (Suc f) p)) (children l)\n  has_majority w (newvals (rho (Suc f) p)) (children l)\n\ngoal (1 subgoal):\n 1. w = v", "by (auto simp: has_majority_def elim: abs_majoritiesE')"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "with wupd"], ["proof (chain)\npicking this:\n  newvals (rho (Suc f) p) l = w\n  w = v", "show ?thesis"], ["proof (prove)\nusing this:\n  newvals (rho (Suc f) p) l = w\n  w = v\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = v", "by simp"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l = v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A node whose label \\<open>l\\<close> ends with a process which is well heard\n  at round \\<open>length_lbl l\\<close> will have its \\<open>newvals\\<close> field set\n  (at round \\<open>f+1\\<close>) to the ``fixed-up'' value given by \\<open>vals\\<close>.\n\\<close>"], ["", "lemma lynch_6_16_d:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and notroot: \"l \\<in> children t\"\n      and skr: \"last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\"\n            (is \"_ \\<in> SKr (HOs (?len t)) _\")\n  shows \"newvals (rho (Suc f) p) l = fixupval (vals (rho (?len l) p) l)\"\n    (is \"?P l\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = fixupval (vals (rho (length_lbl l) p) l)", "using notroot skr"], ["proof (prove)\nusing this:\n  l \\<in> children t\n  last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = fixupval (vals (rho (length_lbl l) p) l)", "proof (induct \"Suc f - (?len l)\" arbitrary: l t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l t.\n       \\<lbrakk>0 = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)\n 2. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "fix l t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l t.\n       \\<lbrakk>0 = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)\n 2. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "assume \"0 = Suc f - ?len l\""], ["proof (state)\nthis:\n  0 = Suc f - length_lbl l\n\ngoal (2 subgoals):\n 1. \\<And>l t.\n       \\<lbrakk>0 = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)\n 2. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "with length_lbl[of l]"], ["proof (chain)\npicking this:\n  length_lbl l \\<le> Suc f\n  0 = Suc f - length_lbl l", "have leaf: \"is_leaf l\""], ["proof (prove)\nusing this:\n  length_lbl l \\<le> Suc f\n  0 = Suc f - length_lbl l\n\ngoal (1 subgoal):\n 1. is_leaf l", "by (simp add: is_leaf_def)"], ["proof (state)\nthis:\n  is_leaf l\n\ngoal (2 subgoals):\n 1. \\<And>l t.\n       \\<lbrakk>0 = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)\n 2. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "have \"check_newvals (rho (Suc f) p)\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. check_newvals (rho (Suc f) p)", "by (auto simp: EIG_SHOMachine_def SHORun_eq SHOnextConfig_eq\n                   nextState_def EIG_nextState_def next_end_def)"], ["proof (state)\nthis:\n  check_newvals (rho (Suc f) p)\n\ngoal (2 subgoals):\n 1. \\<And>l t.\n       \\<lbrakk>0 = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)\n 2. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "with leaf"], ["proof (chain)\npicking this:\n  is_leaf l\n  check_newvals (rho (Suc f) p)", "show \"?P l\""], ["proof (prove)\nusing this:\n  is_leaf l\n  check_newvals (rho (Suc f) p)\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = fixupval (vals (rho (length_lbl l) p) l)", "by (auto simp: check_newvals_def is_leaf_def)"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l = fixupval (vals (rho (length_lbl l) p) l)\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "fix k l t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "assume ih: \"\\<And> l' t'.\n                \\<lbrakk>k = Suc f - length_lbl l'; l' \\<in> children t';\n                 last_lbl l' \\<in> SKr (HOs (?len t')) (SHOs (?len t'))\\<rbrakk>\n                \\<Longrightarrow> ?P l'\"\n    and flk: \"Suc k = Suc f - ?len l\"\n    and notroot: \"l \\<in> children t\"\n    and skr: \"last_lbl l \\<in> SKr (HOs (?len t)) (SHOs (?len t))\""], ["proof (state)\nthis:\n  \\<lbrakk>k = Suc f - length_lbl ?l'1; ?l'1 \\<in> children ?t'1;\n   last_lbl ?l'1\n   \\<in> SKr (HOs (length_lbl ?t'1)) (SHOs (length_lbl ?t'1))\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l'1 =\n                    fixupval (vals (rho (length_lbl ?l'1) p) ?l'1)\n  Suc k = Suc f - length_lbl l\n  l \\<in> children t\n  last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "let ?v = \"fixupval (vals (rho (?len l) p) l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "from flk"], ["proof (chain)\npicking this:\n  Suc k = Suc f - length_lbl l", "have notlf: \"\\<not>(is_leaf l)\""], ["proof (prove)\nusing this:\n  Suc k = Suc f - length_lbl l\n\ngoal (1 subgoal):\n 1. \\<not> is_leaf l", "by (simp add: is_leaf_def)"], ["proof (state)\nthis:\n  \\<not> is_leaf l\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "{"], ["proof (state)\nthis:\n  \\<not> is_leaf l\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "fix l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "assume l': \"l' \\<in> children l\"\n       and skr': \"last_lbl l' \\<in> SKr (HOs (?len l)) (SHOs (?len l))\""], ["proof (state)\nthis:\n  l' \\<in> children l\n  last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "from run notroot skr l' skr'"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs\n  l \\<in> children t\n  last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\n  l' \\<in> children l\n  last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))", "have \"vals (rho (?len l') p) l' = vals (rho (?len l) p) l\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  l \\<in> children t\n  last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\n  l' \\<in> children l\n  last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l", "by (rule lynch_6_16_a)"], ["proof (state)\nthis:\n  vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "moreover"], ["proof (state)\nthis:\n  vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "from flk l'"], ["proof (chain)\npicking this:\n  Suc k = Suc f - length_lbl l\n  l' \\<in> children l", "have \"k = Suc f - ?len l'\""], ["proof (prove)\nusing this:\n  Suc k = Suc f - length_lbl l\n  l' \\<in> children l\n\ngoal (1 subgoal):\n 1. k = Suc f - length_lbl l'", "by (simp add: children_length)"], ["proof (state)\nthis:\n  k = Suc f - length_lbl l'\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "from this l' skr'"], ["proof (chain)\npicking this:\n  k = Suc f - length_lbl l'\n  l' \\<in> children l\n  last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))", "have \"?P l'\""], ["proof (prove)\nusing this:\n  k = Suc f - length_lbl l'\n  l' \\<in> children l\n  last_lbl l' \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')", "by (rule ih)"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "ultimately"], ["proof (chain)\npicking this:\n  vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')", "have \"newvals (rho (Suc f) p) l' = ?v\""], ["proof (prove)\nusing this:\n  vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l) p) l)", "using notroot l'"], ["proof (prove)\nusing this:\n  vals (rho (length_lbl l') p) l' = vals (rho (length_lbl l) p) l\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')\n  l \\<in> children t\n  l' \\<in> children l\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l) p) l)", "by (simp add: children_length)"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l) p) l)\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l'3 \\<in> children l;\n   last_lbl ?l'3\n   \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l'3 =\n                    fixupval (vals (rho (length_lbl l) p) l)\n\ngoal (1 subgoal):\n 1. \\<And>x l t.\n       \\<lbrakk>\\<And>l t.\n                   \\<lbrakk>x = Suc f - length_lbl l; l \\<in> children t;\n                    last_lbl l\n                    \\<in> SKr (HOs (length_lbl t))\n                           (SHOs (length_lbl t))\\<rbrakk>\n                   \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                                     fixupval\n(vals (rho (length_lbl l) p) l);\n        Suc x = Suc f - length_lbl l; l \\<in> children t;\n        last_lbl l\n        \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\\<rbrakk>\n       \\<Longrightarrow> newvals (rho (Suc f) p) l =\n                         fixupval (vals (rho (length_lbl l) p) l)", "with run commR notlf"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  \\<not> is_leaf l\n  \\<lbrakk>?l'3 \\<in> children l;\n   last_lbl ?l'3\n   \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l'3 =\n                    fixupval (vals (rho (length_lbl l) p) l)", "show \"?P l\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  \\<not> is_leaf l\n  \\<lbrakk>?l'3 \\<in> children l;\n   last_lbl ?l'3\n   \\<in> SKr (HOs (length_lbl l)) (SHOs (length_lbl l))\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l'3 =\n                    fixupval (vals (rho (length_lbl l) p) l)\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = fixupval (vals (rho (length_lbl l) p) l)", "by (auto intro: newvals_skr_uniform)"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l = fixupval (vals (rho (length_lbl l) p) l)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Following Lynch~\\cite{lynch:distributed}, we introduce some more useful\n  concepts for reasoning about the data structure.\n\\<close>"], ["", "text \\<open>\n  A label is \\emph{common} if all processes agree on the final value it is\n  decorated with.\n\\<close>"], ["", "definition common where\n  \"common rho l \\<equiv> \n   \\<forall>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l\""], ["", "text \\<open>\n  The subtrees of a given label are all its possible extensions.\n\\<close>"], ["", "definition subtrees where\n  \"subtrees h \\<equiv> { l . \\<exists>t. Rep_Label l = (Rep_Label h) @ t }\""], ["", "lemma children_in_subtree:\n  assumes \"l \\<in> children h\"\n  shows \"l \\<in> subtrees h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> subtrees h", "using label_children[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>p. p \\<notin> set_lbl h \\<and> Rep_Label l = Rep_Label h @ [p]\n\ngoal (1 subgoal):\n 1. l \\<in> subtrees h", "by (auto simp: subtrees_def)"], ["", "lemma subtrees_refl [iff]: \"l \\<in> subtrees l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> subtrees l", "by (auto simp: subtrees_def)"], ["", "lemma subtrees_root [iff]: \"l \\<in> subtrees root_node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> subtrees root_node", "by (auto simp: subtrees_def)"], ["", "lemma subtrees_trans:\n  assumes \"l'' \\<in> subtrees l'\" and \"l' \\<in> subtrees l\"\n  shows \"l'' \\<in> subtrees l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l'' \\<in> subtrees l", "using assms"], ["proof (prove)\nusing this:\n  l'' \\<in> subtrees l'\n  l' \\<in> subtrees l\n\ngoal (1 subgoal):\n 1. l'' \\<in> subtrees l", "by (auto simp: subtrees_def)"], ["", "lemma subtrees_antisym:\n  assumes \"l \\<in> subtrees l'\" and \"l' \\<in> subtrees l\"\n  shows \"l' = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' = l", "using assms"], ["proof (prove)\nusing this:\n  l \\<in> subtrees l'\n  l' \\<in> subtrees l\n\ngoal (1 subgoal):\n 1. l' = l", "by (auto simp: subtrees_def Rep_Label_inject)"], ["", "lemma subtrees_tree:\n  assumes l': \"l \\<in> subtrees l'\" and l'': \"l \\<in> subtrees l''\"\n  shows \"l' \\<in> subtrees l'' \\<or> l'' \\<in> subtrees l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> subtrees l'' \\<or> l'' \\<in> subtrees l'", "using assms"], ["proof (prove)\nusing this:\n  l \\<in> subtrees l'\n  l \\<in> subtrees l''\n\ngoal (1 subgoal):\n 1. l' \\<in> subtrees l'' \\<or> l'' \\<in> subtrees l'", "proof (auto simp: subtrees_def append_eq_append_conv2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t us.\n       \\<lbrakk>Rep_Label l = Rep_Label l'' @ us @ t;\n        \\<forall>t. Rep_Label l'' \\<noteq> Rep_Label l' @ t;\n        Rep_Label l'' @ us = Rep_Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. Rep_Label l' = Rep_Label l'' @ t", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t us.\n       \\<lbrakk>Rep_Label l = Rep_Label l'' @ us @ t;\n        \\<forall>t. Rep_Label l'' \\<noteq> Rep_Label l' @ t;\n        Rep_Label l'' @ us = Rep_Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. Rep_Label l' = Rep_Label l'' @ t", "assume \"Rep_Label l'' @ xs = Rep_Label l'\""], ["proof (state)\nthis:\n  Rep_Label l'' @ xs = Rep_Label l'\n\ngoal (1 subgoal):\n 1. \\<And>t us.\n       \\<lbrakk>Rep_Label l = Rep_Label l'' @ us @ t;\n        \\<forall>t. Rep_Label l'' \\<noteq> Rep_Label l' @ t;\n        Rep_Label l'' @ us = Rep_Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. Rep_Label l' = Rep_Label l'' @ t", "hence \"Rep_Label l' = Rep_Label l'' @ xs\""], ["proof (prove)\nusing this:\n  Rep_Label l'' @ xs = Rep_Label l'\n\ngoal (1 subgoal):\n 1. Rep_Label l' = Rep_Label l'' @ xs", "by (rule sym)"], ["proof (state)\nthis:\n  Rep_Label l' = Rep_Label l'' @ xs\n\ngoal (1 subgoal):\n 1. \\<And>t us.\n       \\<lbrakk>Rep_Label l = Rep_Label l'' @ us @ t;\n        \\<forall>t. Rep_Label l'' \\<noteq> Rep_Label l' @ t;\n        Rep_Label l'' @ us = Rep_Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. Rep_Label l' = Rep_Label l'' @ t", "thus \"\\<exists>ys. Rep_Label l' = Rep_Label l'' @ ys\""], ["proof (prove)\nusing this:\n  Rep_Label l' = Rep_Label l'' @ xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys. Rep_Label l' = Rep_Label l'' @ ys", ".."], ["proof (state)\nthis:\n  \\<exists>ys. Rep_Label l' = Rep_Label l'' @ ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subtrees_cases:\n  assumes l': \"l' \\<in> subtrees l\"\n      and self: \"l' = l \\<Longrightarrow> P\"\n      and child: \"\\<And>c. \\<lbrakk> c \\<in> children l; l' \\<in> subtrees c \\<rbrakk> \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from l'"], ["proof (chain)\npicking this:\n  l' \\<in> subtrees l", "obtain t where t: \"Rep_Label l' = (Rep_Label l) @ t\""], ["proof (prove)\nusing this:\n  l' \\<in> subtrees l\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        Rep_Label l' = Rep_Label l @ t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subtrees_def)"], ["proof (state)\nthis:\n  Rep_Label l' = Rep_Label l @ t\n\ngoal (1 subgoal):\n 1. P", "have \"l' = l \\<or> (\\<exists>c \\<in> children l. l' \\<in> subtrees c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = [] \\<Longrightarrow>\n    l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)\n 2. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "assume \"t = []\""], ["proof (state)\nthis:\n  t = []\n\ngoal (2 subgoals):\n 1. t = [] \\<Longrightarrow>\n    l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)\n 2. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "with t"], ["proof (chain)\npicking this:\n  Rep_Label l' = Rep_Label l @ t\n  t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_Label l' = Rep_Label l @ t\n  t = []\n\ngoal (1 subgoal):\n 1. l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "by (simp add: Rep_Label_inject)"], ["proof (state)\nthis:\n  l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "fix p t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "assume cons: \"t = p # t'\""], ["proof (state)\nthis:\n  t = p # t'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "from Rep_Label[of l'] t"], ["proof (chain)\npicking this:\n  Rep_Label l' \\<in> Label\n  Rep_Label l' = Rep_Label l @ t", "have \"length (Rep_Label l @ t) \\<le> Suc f\""], ["proof (prove)\nusing this:\n  Rep_Label l' \\<in> Label\n  Rep_Label l' = Rep_Label l @ t\n\ngoal (1 subgoal):\n 1. length (Rep_Label l @ t) \\<le> Suc f", "by (simp add: Label_def)"], ["proof (state)\nthis:\n  length (Rep_Label l @ t) \\<le> Suc f\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "with cons"], ["proof (chain)\npicking this:\n  t = p # t'\n  length (Rep_Label l @ t) \\<le> Suc f", "have notleaf: \"\\<not>(is_leaf l)\""], ["proof (prove)\nusing this:\n  t = p # t'\n  length (Rep_Label l @ t) \\<le> Suc f\n\ngoal (1 subgoal):\n 1. \\<not> is_leaf l", "by (auto simp: is_leaf_def length_lbl_def)"], ["proof (state)\nthis:\n  \\<not> is_leaf l\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "let ?c = \"Abs_Label (Rep_Label l @ [p])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "from t cons Rep_Label[of l']"], ["proof (chain)\npicking this:\n  Rep_Label l' = Rep_Label l @ t\n  t = p # t'\n  Rep_Label l' \\<in> Label", "have p: \"p \\<notin> set_lbl l\""], ["proof (prove)\nusing this:\n  Rep_Label l' = Rep_Label l @ t\n  t = p # t'\n  Rep_Label l' \\<in> Label\n\ngoal (1 subgoal):\n 1. p \\<notin> set_lbl l", "by (auto simp: Label_def set_lbl_def)"], ["proof (state)\nthis:\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "with notleaf"], ["proof (chain)\npicking this:\n  \\<not> is_leaf l\n  p \\<notin> set_lbl l", "have c: \"?c \\<in> children l\""], ["proof (prove)\nusing this:\n  \\<not> is_leaf l\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. Abs_Label (Rep_Label l @ [p]) \\<in> children l", "by (auto simp: children_def)"], ["proof (state)\nthis:\n  Abs_Label (Rep_Label l @ [p]) \\<in> children l\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "moreover"], ["proof (state)\nthis:\n  Abs_Label (Rep_Label l @ [p]) \\<in> children l\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "from notleaf p"], ["proof (chain)\npicking this:\n  \\<not> is_leaf l\n  p \\<notin> set_lbl l", "have \"Rep_Label l @ [p] \\<in> Label\""], ["proof (prove)\nusing this:\n  \\<not> is_leaf l\n  p \\<notin> set_lbl l\n\ngoal (1 subgoal):\n 1. Rep_Label l @ [p] \\<in> Label", "by (simp add: Rep_Label_append)"], ["proof (state)\nthis:\n  Rep_Label l @ [p] \\<in> Label\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "hence \"Rep_Label ?c = (Rep_Label l @ [p])\""], ["proof (prove)\nusing this:\n  Rep_Label l @ [p] \\<in> Label\n\ngoal (1 subgoal):\n 1. Rep_Label (Abs_Label (Rep_Label l @ [p])) = Rep_Label l @ [p]", "by (simp add: Abs_Label_inverse)"], ["proof (state)\nthis:\n  Rep_Label (Abs_Label (Rep_Label l @ [p])) = Rep_Label l @ [p]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "with cons t"], ["proof (chain)\npicking this:\n  t = p # t'\n  Rep_Label l' = Rep_Label l @ t\n  Rep_Label (Abs_Label (Rep_Label l @ [p])) = Rep_Label l @ [p]", "have \"l' \\<in> subtrees ?c\""], ["proof (prove)\nusing this:\n  t = p # t'\n  Rep_Label l' = Rep_Label l @ t\n  Rep_Label (Abs_Label (Rep_Label l @ [p])) = Rep_Label l @ [p]\n\ngoal (1 subgoal):\n 1. l' \\<in> subtrees (Abs_Label (Rep_Label l @ [p]))", "by (auto simp: subtrees_def)"], ["proof (state)\nthis:\n  l' \\<in> subtrees (Abs_Label (Rep_Label l @ [p]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       t = a # list \\<Longrightarrow>\n       l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "ultimately"], ["proof (chain)\npicking this:\n  Abs_Label (Rep_Label l @ [p]) \\<in> children l\n  l' \\<in> subtrees (Abs_Label (Rep_Label l @ [p]))", "show ?thesis"], ["proof (prove)\nusing this:\n  Abs_Label (Rep_Label l @ [p]) \\<in> children l\n  l' \\<in> subtrees (Abs_Label (Rep_Label l @ [p]))\n\ngoal (1 subgoal):\n 1. l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)", "by blast"], ["proof (state)\nthis:\n  l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  l' = l \\<or> (\\<exists>c\\<in>children l. l' \\<in> subtrees c)\n\ngoal (1 subgoal):\n 1. P", "by (auto elim!: self child)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subtrees_leaf:\n  assumes l: \"is_leaf l\" and l': \"l' \\<in> subtrees l\"\n  shows \"l' = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' = l", "using l'"], ["proof (prove)\nusing this:\n  l' \\<in> subtrees l\n\ngoal (1 subgoal):\n 1. l' = l", "proof (rule subtrees_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. l' = l \\<Longrightarrow> l' = l\n 2. \\<And>c.\n       \\<lbrakk>c \\<in> children l; l' \\<in> subtrees c\\<rbrakk>\n       \\<Longrightarrow> l' = l", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. l' = l \\<Longrightarrow> l' = l\n 2. \\<And>c.\n       \\<lbrakk>c \\<in> children l; l' \\<in> subtrees c\\<rbrakk>\n       \\<Longrightarrow> l' = l", "assume \"c \\<in> children l\"  \\<comment> \\<open>impossible\\<close>"], ["proof (state)\nthis:\n  c \\<in> children l\n\ngoal (2 subgoals):\n 1. l' = l \\<Longrightarrow> l' = l\n 2. \\<And>c.\n       \\<lbrakk>c \\<in> children l; l' \\<in> subtrees c\\<rbrakk>\n       \\<Longrightarrow> l' = l", "with l"], ["proof (chain)\npicking this:\n  is_leaf l\n  c \\<in> children l", "show ?thesis"], ["proof (prove)\nusing this:\n  is_leaf l\n  c \\<in> children l\n\ngoal (1 subgoal):\n 1. l' = l", "by (simp add: children_def)"], ["proof (state)\nthis:\n  l' = l\n\ngoal (1 subgoal):\n 1. l' = l \\<Longrightarrow> l' = l", "qed"], ["", "lemma children_subtrees_equal:\n  assumes c: \"c \\<in> children l\" and c': \"c' \\<in> children l\"\n      and sub: \"c' \\<in> subtrees c\"\n  shows \"c' = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c' = c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c' = c", "from assms"], ["proof (chain)\npicking this:\n  c \\<in> children l\n  c' \\<in> children l\n  c' \\<in> subtrees c", "have \"Rep_Label c' = Rep_Label c\""], ["proof (prove)\nusing this:\n  c \\<in> children l\n  c' \\<in> children l\n  c' \\<in> subtrees c\n\ngoal (1 subgoal):\n 1. Rep_Label c' = Rep_Label c", "by (auto simp: subtrees_def dest!: label_children)"], ["proof (state)\nthis:\n  Rep_Label c' = Rep_Label c\n\ngoal (1 subgoal):\n 1. c' = c", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_Label c' = Rep_Label c\n\ngoal (1 subgoal):\n 1. c' = c", "by (simp add: Rep_Label_inject)"], ["proof (state)\nthis:\n  c' = c\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A set \\<open>C\\<close> of labels is a \\emph{subcovering} w.r.t. label \\<open>l\\<close>\n  if for all leaf subtrees \\<open>s\\<close> of \\<open>l\\<close> there\n  exists some label \\<open>h \\<in> C\\<close> such that \\<open>s\\<close> is a subtree of\n  \\<open>h\\<close> and \\<open>h\\<close> is a subtree of \\<open>l\\<close>.\n\\<close>"], ["", "definition subcovering where\n \"subcovering C l \\<equiv> \n  \\<forall>s \\<in> subtrees l. is_leaf s \\<longrightarrow> (\\<exists>h \\<in> C. h \\<in> subtrees l \\<and> s \\<in> subtrees h)\""], ["", "text \\<open>\n  A \\emph{covering} is a subcovering w.r.t. the root node.\n\\<close>"], ["", "abbreviation covering where\n  \"covering C \\<equiv> subcovering C root_node\""], ["", "text \\<open>\n  The set of labels whose last element is well heard by all processes\n  throughout the execution forms a covering, and all these labels are common.\n\\<close>"], ["", "lemma lynch_6_18_a:\n  assumes \"SHORun EIG_M rho HOs SHOs\"\n      and \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and \"l \\<in> children t\"\n      and \"last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\"\n  shows \"common rho l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common rho l", "using assms"], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  l \\<in> children t\n  last_lbl l \\<in> SKr (HOs (length_lbl t)) (SHOs (length_lbl t))\n\ngoal (1 subgoal):\n 1. common rho l", "by (auto simp: common_def lynch_6_16_d lynch_6_15\n           intro: arg_cong[where f=\"fixupval\"])"], ["", "lemma lynch_6_18_b:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n  shows \"covering {l. \\<exists>t. l \\<in> children t \\<and> last_lbl l \\<in> (SK HOs SHOs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering\n     {l. \\<exists>t. l \\<in> children t \\<and> last_lbl l \\<in> SK HOs SHOs}", "proof (clarsimp simp: subcovering_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "assume \"is_leaf l\""], ["proof (state)\nthis:\n  is_leaf l\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "with card_set_lbl[of l]"], ["proof (chain)\npicking this:\n  card (set_lbl l) = length_lbl l\n  is_leaf l", "have \"card (set_lbl l) = Suc f\""], ["proof (prove)\nusing this:\n  card (set_lbl l) = length_lbl l\n  is_leaf l\n\ngoal (1 subgoal):\n 1. card (set_lbl l) = Suc f", "by (simp add: is_leaf_def)"], ["proof (state)\nthis:\n  card (set_lbl l) = Suc f\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "with commG"], ["proof (chain)\npicking this:\n  EIG_commGlobal HOs SHOs\n  card (set_lbl l) = Suc f", "have \"N < card (SK HOs SHOs) + card (set_lbl l)\""], ["proof (prove)\nusing this:\n  EIG_commGlobal HOs SHOs\n  card (set_lbl l) = Suc f\n\ngoal (1 subgoal):\n 1. N < card (SK HOs SHOs) + card (set_lbl l)", "by (simp add: EIG_commGlobal_def)"], ["proof (state)\nthis:\n  N < card (SK HOs SHOs) + card (set_lbl l)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "hence \"\\<exists>q \\<in> set_lbl l . q \\<in> SK HOs SHOs\""], ["proof (prove)\nusing this:\n  N < card (SK HOs SHOs) + card (set_lbl l)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set_lbl l. q \\<in> SK HOs SHOs", "by (auto dest: majorities_intersect)"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set_lbl l. q \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "then"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set_lbl l. q \\<in> SK HOs SHOs", "obtain l1 q l2 where\n    l: \"Rep_Label l = (l1 @ [q]) @ l2\" and q: \"q \\<in> SK HOs SHOs\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set_lbl l. q \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>l1 q l2.\n        \\<lbrakk>Rep_Label l = (l1 @ [q]) @ l2; q \\<in> SK HOs SHOs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_lbl_def"], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set (Rep_Label l). q \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>l1 q l2.\n        \\<lbrakk>Rep_Label l = (l1 @ [q]) @ l2; q \\<in> SK HOs SHOs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: split_list_propE)"], ["proof (state)\nthis:\n  Rep_Label l = (l1 @ [q]) @ l2\n  q \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "let ?h = \"Abs_Label (l1 @ [q])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "from Rep_Label[of l] l"], ["proof (chain)\npicking this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = (l1 @ [q]) @ l2", "have \"l1 @ [q] \\<in> Label\""], ["proof (prove)\nusing this:\n  Rep_Label l \\<in> Label\n  Rep_Label l = (l1 @ [q]) @ l2\n\ngoal (1 subgoal):\n 1. l1 @ [q] \\<in> Label", "by (simp add: Label_def)"], ["proof (state)\nthis:\n  l1 @ [q] \\<in> Label\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "hence reph: \"Rep_Label ?h = l1 @ [q]\""], ["proof (prove)\nusing this:\n  l1 @ [q] \\<in> Label\n\ngoal (1 subgoal):\n 1. Rep_Label (Abs_Label (l1 @ [q])) = l1 @ [q]", "by (rule Abs_Label_inverse)"], ["proof (state)\nthis:\n  Rep_Label (Abs_Label (l1 @ [q])) = l1 @ [q]\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "hence \"length_lbl ?h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Rep_Label (Abs_Label (l1 @ [q])) = l1 @ [q]\n\ngoal (1 subgoal):\n 1. length_lbl (Abs_Label (l1 @ [q])) \\<noteq> 0", "by (simp add: length_lbl_def)"], ["proof (state)\nthis:\n  length_lbl (Abs_Label (l1 @ [q])) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "hence \"?h \\<noteq> root_node\""], ["proof (prove)\nusing this:\n  length_lbl (Abs_Label (l1 @ [q])) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Abs_Label (l1 @ [q]) \\<noteq> root_node", "by auto"], ["proof (state)\nthis:\n  Abs_Label (l1 @ [q]) \\<noteq> root_node\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "then"], ["proof (chain)\npicking this:\n  Abs_Label (l1 @ [q]) \\<noteq> root_node", "obtain t where t: \"?h \\<in> children t\""], ["proof (prove)\nusing this:\n  Abs_Label (l1 @ [q]) \\<noteq> root_node\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        Abs_Label (l1 @ [q]) \\<in> children t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: root_iff_no_child)"], ["proof (state)\nthis:\n  Abs_Label (l1 @ [q]) \\<in> children t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "moreover"], ["proof (state)\nthis:\n  Abs_Label (l1 @ [q]) \\<in> children t\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "from reph q"], ["proof (chain)\npicking this:\n  Rep_Label (Abs_Label (l1 @ [q])) = l1 @ [q]\n  q \\<in> SK HOs SHOs", "have \"last_lbl ?h \\<in> SK HOs SHOs\""], ["proof (prove)\nusing this:\n  Rep_Label (Abs_Label (l1 @ [q])) = l1 @ [q]\n  q \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. last_lbl (Abs_Label (l1 @ [q])) \\<in> SK HOs SHOs", "by (simp add: last_lbl_def)"], ["proof (state)\nthis:\n  last_lbl (Abs_Label (l1 @ [q])) \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "moreover"], ["proof (state)\nthis:\n  last_lbl (Abs_Label (l1 @ [q])) \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "from reph l"], ["proof (chain)\npicking this:\n  Rep_Label (Abs_Label (l1 @ [q])) = l1 @ [q]\n  Rep_Label l = (l1 @ [q]) @ l2", "have \"l \\<in> subtrees ?h\""], ["proof (prove)\nusing this:\n  Rep_Label (Abs_Label (l1 @ [q])) = l1 @ [q]\n  Rep_Label l = (l1 @ [q]) @ l2\n\ngoal (1 subgoal):\n 1. l \\<in> subtrees (Abs_Label (l1 @ [q]))", "by (simp add: subtrees_def)"], ["proof (state)\nthis:\n  l \\<in> subtrees (Abs_Label (l1 @ [q]))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       is_leaf s \\<Longrightarrow>\n       \\<exists>h.\n          (\\<exists>t. h \\<in> children t) \\<and>\n          last_lbl h \\<in> SK HOs SHOs \\<and> s \\<in> subtrees h", "ultimately"], ["proof (chain)\npicking this:\n  Abs_Label (l1 @ [q]) \\<in> children t\n  last_lbl (Abs_Label (l1 @ [q])) \\<in> SK HOs SHOs\n  l \\<in> subtrees (Abs_Label (l1 @ [q]))", "show \"\\<exists>h. (\\<exists>t. h \\<in> children t) \\<and> last_lbl h \\<in> SK HOs SHOs \\<and> l \\<in> subtrees h\""], ["proof (prove)\nusing this:\n  Abs_Label (l1 @ [q]) \\<in> children t\n  last_lbl (Abs_Label (l1 @ [q])) \\<in> SK HOs SHOs\n  l \\<in> subtrees (Abs_Label (l1 @ [q]))\n\ngoal (1 subgoal):\n 1. \\<exists>h.\n       (\\<exists>t. h \\<in> children t) \\<and>\n       last_lbl h \\<in> SK HOs SHOs \\<and> l \\<in> subtrees h", "by blast"], ["proof (state)\nthis:\n  \\<exists>h.\n     (\\<exists>t. h \\<in> children t) \\<and>\n     last_lbl h \\<in> SK HOs SHOs \\<and> l \\<in> subtrees h\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If \\<open>C\\<close> covers the subtree rooted at label \\<open>l\\<close> and if\n  \\<open>l \\<notin> C\\<close> then \\<open>C\\<close> also covers subtrees rooted at\n  \\<open>l\\<close>'s children.\n\\<close>"], ["", "lemma lynch_6_19_a:\n  assumes cov: \"subcovering C l\"\n      and l: \"l \\<notin> C\"\n      and e: \"e \\<in> children l\"\n  shows \"subcovering C e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subcovering C e", "proof (clarsimp simp: subcovering_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "assume s: \"s \\<in> subtrees e\" and leaf: \"is_leaf s\""], ["proof (state)\nthis:\n  s \\<in> subtrees e\n  is_leaf s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "from s children_in_subtree[OF e]"], ["proof (chain)\npicking this:\n  s \\<in> subtrees e\n  e \\<in> subtrees l", "have \"s \\<in> subtrees l\""], ["proof (prove)\nusing this:\n  s \\<in> subtrees e\n  e \\<in> subtrees l\n\ngoal (1 subgoal):\n 1. s \\<in> subtrees l", "by (rule subtrees_trans)"], ["proof (state)\nthis:\n  s \\<in> subtrees l\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "with leaf cov"], ["proof (chain)\npicking this:\n  is_leaf s\n  subcovering C l\n  s \\<in> subtrees l", "obtain h where h: \"h \\<in> C\" \"h \\<in> subtrees l\" \"s \\<in> subtrees h\""], ["proof (prove)\nusing this:\n  is_leaf s\n  subcovering C l\n  s \\<in> subtrees l\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> C; h \\<in> subtrees l; s \\<in> subtrees h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subcovering_def)"], ["proof (state)\nthis:\n  h \\<in> C\n  h \\<in> subtrees l\n  s \\<in> subtrees h\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "with l"], ["proof (chain)\npicking this:\n  l \\<notin> C\n  h \\<in> C\n  h \\<in> subtrees l\n  s \\<in> subtrees h", "obtain e' where e': \"e' \\<in> children l\" \"h \\<in> subtrees e'\""], ["proof (prove)\nusing this:\n  l \\<notin> C\n  h \\<in> C\n  h \\<in> subtrees l\n  s \\<in> subtrees h\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> children l; h \\<in> subtrees e'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: subtrees_cases)"], ["proof (state)\nthis:\n  e' \\<in> children l\n  h \\<in> subtrees e'\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "from \\<open>s \\<in> subtrees h\\<close> \\<open>h \\<in> subtrees e'\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> subtrees h\n  h \\<in> subtrees e'", "have \"s \\<in> subtrees e'\""], ["proof (prove)\nusing this:\n  s \\<in> subtrees h\n  h \\<in> subtrees e'\n\ngoal (1 subgoal):\n 1. s \\<in> subtrees e'", "by (rule subtrees_trans)"], ["proof (state)\nthis:\n  s \\<in> subtrees e'\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "with s"], ["proof (chain)\npicking this:\n  s \\<in> subtrees e\n  s \\<in> subtrees e'", "have \"e \\<in> subtrees e' \\<or> e' \\<in> subtrees e\""], ["proof (prove)\nusing this:\n  s \\<in> subtrees e\n  s \\<in> subtrees e'\n\ngoal (1 subgoal):\n 1. e \\<in> subtrees e' \\<or> e' \\<in> subtrees e", "by (rule subtrees_tree)"], ["proof (state)\nthis:\n  e \\<in> subtrees e' \\<or> e' \\<in> subtrees e\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "with e e'"], ["proof (chain)\npicking this:\n  e \\<in> children l\n  e' \\<in> children l\n  h \\<in> subtrees e'\n  e \\<in> subtrees e' \\<or> e' \\<in> subtrees e", "have \"e' = e\""], ["proof (prove)\nusing this:\n  e \\<in> children l\n  e' \\<in> children l\n  h \\<in> subtrees e'\n  e \\<in> subtrees e' \\<or> e' \\<in> subtrees e\n\ngoal (1 subgoal):\n 1. e' = e", "by (auto dest: children_subtrees_equal)"], ["proof (state)\nthis:\n  e' = e\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> subtrees e; is_leaf s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h\\<in>C.\n                            h \\<in> subtrees e \\<and> s \\<in> subtrees h", "with e' h"], ["proof (chain)\npicking this:\n  e' \\<in> children l\n  h \\<in> subtrees e'\n  h \\<in> C\n  h \\<in> subtrees l\n  s \\<in> subtrees h\n  e' = e", "show \"\\<exists>h\\<in>C. h \\<in> subtrees e \\<and> s \\<in> subtrees h\""], ["proof (prove)\nusing this:\n  e' \\<in> children l\n  h \\<in> subtrees e'\n  h \\<in> C\n  h \\<in> subtrees l\n  s \\<in> subtrees h\n  e' = e\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>C. h \\<in> subtrees e \\<and> s \\<in> subtrees h", "by blast"], ["proof (state)\nthis:\n  \\<exists>h\\<in>C. h \\<in> subtrees e \\<and> s \\<in> subtrees h\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If there is a subcovering \\<open>C\\<close> for a label \\<open>l\\<close> such that all labels\n  in \\<open>C\\<close> are common, then \\<open>l\\<close> itself is common as well.\n\\<close>"], ["", "lemma lynch_6_19_b:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and cov: \"subcovering C l\"\n      and com: \"\\<forall>l' \\<in> C. common rho l'\"\n  shows \"common rho l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common rho l", "using cov"], ["proof (prove)\nusing this:\n  subcovering C l\n\ngoal (1 subgoal):\n 1. common rho l", "proof (induct \"Suc f - length_lbl l\" arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "assume 0: \"0 = Suc f - length_lbl l\"\n    and C: \"subcovering C l\""], ["proof (state)\nthis:\n  0 = Suc f - length_lbl l\n  subcovering C l\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "from 0 length_lbl[of l]"], ["proof (chain)\npicking this:\n  0 = Suc f - length_lbl l\n  length_lbl l \\<le> Suc f", "have \"is_leaf l\""], ["proof (prove)\nusing this:\n  0 = Suc f - length_lbl l\n  length_lbl l \\<le> Suc f\n\ngoal (1 subgoal):\n 1. is_leaf l", "by (simp add: is_leaf_def)"], ["proof (state)\nthis:\n  is_leaf l\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "with C"], ["proof (chain)\npicking this:\n  subcovering C l\n  is_leaf l", "obtain h where h: \"h \\<in> C\" \"h \\<in> subtrees l\" \"l \\<in> subtrees h\""], ["proof (prove)\nusing this:\n  subcovering C l\n  is_leaf l\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> C; h \\<in> subtrees l; l \\<in> subtrees h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subcovering_def)"], ["proof (state)\nthis:\n  h \\<in> C\n  h \\<in> subtrees l\n  l \\<in> subtrees h\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "hence \"l \\<in> C\""], ["proof (prove)\nusing this:\n  h \\<in> C\n  h \\<in> subtrees l\n  l \\<in> subtrees h\n\ngoal (1 subgoal):\n 1. l \\<in> C", "by (auto dest: subtrees_antisym)"], ["proof (state)\nthis:\n  l \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>0 = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "with com"], ["proof (chain)\npicking this:\n  \\<forall>l'\\<in>C. common rho l'\n  l \\<in> C", "show \"common rho l\""], ["proof (prove)\nusing this:\n  \\<forall>l'\\<in>C. common rho l'\n  l \\<in> C\n\ngoal (1 subgoal):\n 1. common rho l", ".."], ["proof (state)\nthis:\n  common rho l\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "fix k l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "assume k: \"Suc k = Suc f - length_lbl l\"\n     and C: \"subcovering C l\"\n     and ih: \"\\<And>l'. \\<lbrakk>k = Suc f - length_lbl l'; subcovering C l'\\<rbrakk> \\<Longrightarrow> common rho l'\""], ["proof (state)\nthis:\n  Suc k = Suc f - length_lbl l\n  subcovering C l\n  \\<lbrakk>k = Suc f - length_lbl ?l'; subcovering C ?l'\\<rbrakk>\n  \\<Longrightarrow> common rho ?l'\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>x = Suc f - length_lbl l;\n                    subcovering C l\\<rbrakk>\n                   \\<Longrightarrow> common rho l;\n        Suc x = Suc f - length_lbl l; subcovering C l\\<rbrakk>\n       \\<Longrightarrow> common rho l", "show \"common rho l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common rho l", "proof (cases \"l \\<in> C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l \\<in> C \\<Longrightarrow> common rho l\n 2. l \\<notin> C \\<Longrightarrow> common rho l", "case True"], ["proof (state)\nthis:\n  l \\<in> C\n\ngoal (2 subgoals):\n 1. l \\<in> C \\<Longrightarrow> common rho l\n 2. l \\<notin> C \\<Longrightarrow> common rho l", "with com"], ["proof (chain)\npicking this:\n  \\<forall>l'\\<in>C. common rho l'\n  l \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l'\\<in>C. common rho l'\n  l \\<in> C\n\ngoal (1 subgoal):\n 1. common rho l", ".."], ["proof (state)\nthis:\n  common rho l\n\ngoal (1 subgoal):\n 1. l \\<notin> C \\<Longrightarrow> common rho l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<notin> C \\<Longrightarrow> common rho l", "case False"], ["proof (state)\nthis:\n  l \\<notin> C\n\ngoal (1 subgoal):\n 1. l \\<notin> C \\<Longrightarrow> common rho l", "with C"], ["proof (chain)\npicking this:\n  subcovering C l\n  l \\<notin> C", "have \"\\<forall>e \\<in> children l. subcovering C e\""], ["proof (prove)\nusing this:\n  subcovering C l\n  l \\<notin> C\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>children l. subcovering C e", "by (blast intro: lynch_6_19_a)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>children l. subcovering C e\n\ngoal (1 subgoal):\n 1. l \\<notin> C \\<Longrightarrow> common rho l", "moreover"], ["proof (state)\nthis:\n  \\<forall>e\\<in>children l. subcovering C e\n\ngoal (1 subgoal):\n 1. l \\<notin> C \\<Longrightarrow> common rho l", "from k"], ["proof (chain)\npicking this:\n  Suc k = Suc f - length_lbl l", "have \"\\<forall>e \\<in> children l. k = Suc f - length_lbl e\""], ["proof (prove)\nusing this:\n  Suc k = Suc f - length_lbl l\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>children l. k = Suc f - length_lbl e", "by (auto simp: children_length)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>children l. k = Suc f - length_lbl e\n\ngoal (1 subgoal):\n 1. l \\<notin> C \\<Longrightarrow> common rho l", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>children l. subcovering C e\n  \\<forall>e\\<in>children l. k = Suc f - length_lbl e", "have com_ch: \"\\<forall>e \\<in> children l. common rho e\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>children l. subcovering C e\n  \\<forall>e\\<in>children l. k = Suc f - length_lbl e\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>children l. common rho e", "by (blast intro: ih)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>children l. common rho e\n\ngoal (1 subgoal):\n 1. l \\<notin> C \\<Longrightarrow> common rho l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. common rho l", "proof (clarsimp simp: common_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "from k"], ["proof (chain)\npicking this:\n  Suc k = Suc f - length_lbl l", "have notleaf: \"\\<not>(is_leaf l)\""], ["proof (prove)\nusing this:\n  Suc k = Suc f - length_lbl l\n\ngoal (1 subgoal):\n 1. \\<not> is_leaf l", "by (simp add: is_leaf_def)"], ["proof (state)\nthis:\n  \\<not> is_leaf l\n\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "let ?r = \"Suc f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "from com_ch"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>children l. common rho e", "have \"\\<forall>e \\<in> children l. newvals (rho ?r p) e = newvals (rho ?r q) e\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>children l. common rho e\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>children l.\n       newvals (rho (Suc f) p) e = newvals (rho (Suc f) q) e", "by (auto simp: common_def)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>children l.\n     newvals (rho (Suc f) p) e = newvals (rho (Suc f) q) e\n\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "hence \"\\<forall>w. {e \\<in> children l. newvals (rho ?r p) e = w}\n               = {e \\<in> children l. newvals (rho ?r q) e = w}\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>children l.\n     newvals (rho (Suc f) p) e = newvals (rho (Suc f) q) e\n\ngoal (1 subgoal):\n 1. \\<forall>w.\n       {e \\<in> children l. newvals (rho (Suc f) p) e = w} =\n       {e \\<in> children l. newvals (rho (Suc f) q) e = w}", "by auto"], ["proof (state)\nthis:\n  \\<forall>w.\n     {e \\<in> children l. newvals (rho (Suc f) p) e = w} =\n     {e \\<in> children l. newvals (rho (Suc f) q) e = w}\n\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "moreover"], ["proof (state)\nthis:\n  \\<forall>w.\n     {e \\<in> children l. newvals (rho (Suc f) p) e = w} =\n     {e \\<in> children l. newvals (rho (Suc f) q) e = w}\n\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "have \"check_newvals (rho ?r p)\" \"check_newvals (rho ?r q)\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. check_newvals (rho (Suc f) p) &&& check_newvals (rho (Suc f) q)", "by (auto simp: EIG_SHOMachine_def SHORun_eq SHOnextConfig_eq nextState_def\n                       EIG_nextState_def next_end_def)"], ["proof (state)\nthis:\n  check_newvals (rho (Suc f) p)\n  check_newvals (rho (Suc f) q)\n\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "with notleaf"], ["proof (chain)\npicking this:\n  \\<not> is_leaf l\n  check_newvals (rho (Suc f) p)\n  check_newvals (rho (Suc f) q)", "have\n        \"(\\<exists>w. has_majority w (newvals (rho ?r p)) (children l)\n              \\<and> newvals (rho ?r p) l = w)\n       \\<or> \\<not>(\\<exists>w. has_majority w (newvals (rho ?r p)) (children l))\n              \\<and> newvals (rho ?r p) l = undefined\"\n        \"(\\<exists>w. has_majority w (newvals (rho ?r q)) (children l)\n              \\<and> newvals (rho ?r q) l = w)\n       \\<or> \\<not>(\\<exists>w. has_majority w (newvals (rho ?r q)) (children l))\n              \\<and> newvals (rho ?r q) l = undefined\""], ["proof (prove)\nusing this:\n  \\<not> is_leaf l\n  check_newvals (rho (Suc f) p)\n  check_newvals (rho (Suc f) q)\n\ngoal (1 subgoal):\n 1. (\\<exists>w.\n        has_majority w (newvals (rho (Suc f) p)) (children l) \\<and>\n        newvals (rho (Suc f) p) l = w) \\<or>\n    (\\<nexists>w.\n        has_majority w (newvals (rho (Suc f) p)) (children l)) \\<and>\n    newvals (rho (Suc f) p) l = undefined &&&\n    (\\<exists>w.\n        has_majority w (newvals (rho (Suc f) q)) (children l) \\<and>\n        newvals (rho (Suc f) q) l = w) \\<or>\n    (\\<nexists>w.\n        has_majority w (newvals (rho (Suc f) q)) (children l)) \\<and>\n    newvals (rho (Suc f) q) l = undefined", "by (auto simp: check_newvals_def)"], ["proof (state)\nthis:\n  (\\<exists>w.\n      has_majority w (newvals (rho (Suc f) p)) (children l) \\<and>\n      newvals (rho (Suc f) p) l = w) \\<or>\n  (\\<nexists>w.\n      has_majority w (newvals (rho (Suc f) p)) (children l)) \\<and>\n  newvals (rho (Suc f) p) l = undefined\n  (\\<exists>w.\n      has_majority w (newvals (rho (Suc f) q)) (children l) \\<and>\n      newvals (rho (Suc f) q) l = w) \\<or>\n  (\\<nexists>w.\n      has_majority w (newvals (rho (Suc f) q)) (children l)) \\<and>\n  newvals (rho (Suc f) q) l = undefined\n\ngoal (1 subgoal):\n 1. \\<And>p q. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>w.\n     {e \\<in> children l. newvals (rho (Suc f) p) e = w} =\n     {e \\<in> children l. newvals (rho (Suc f) q) e = w}\n  (\\<exists>w.\n      has_majority w (newvals (rho (Suc f) p)) (children l) \\<and>\n      newvals (rho (Suc f) p) l = w) \\<or>\n  (\\<nexists>w.\n      has_majority w (newvals (rho (Suc f) p)) (children l)) \\<and>\n  newvals (rho (Suc f) p) l = undefined\n  (\\<exists>w.\n      has_majority w (newvals (rho (Suc f) q)) (children l) \\<and>\n      newvals (rho (Suc f) q) l = w) \\<or>\n  (\\<nexists>w.\n      has_majority w (newvals (rho (Suc f) q)) (children l)) \\<and>\n  newvals (rho (Suc f) q) l = undefined", "show \"newvals (rho ?r p) l = newvals (rho ?r q) l\""], ["proof (prove)\nusing this:\n  \\<forall>w.\n     {e \\<in> children l. newvals (rho (Suc f) p) e = w} =\n     {e \\<in> children l. newvals (rho (Suc f) q) e = w}\n  (\\<exists>w.\n      has_majority w (newvals (rho (Suc f) p)) (children l) \\<and>\n      newvals (rho (Suc f) p) l = w) \\<or>\n  (\\<nexists>w.\n      has_majority w (newvals (rho (Suc f) p)) (children l)) \\<and>\n  newvals (rho (Suc f) p) l = undefined\n  (\\<exists>w.\n      has_majority w (newvals (rho (Suc f) q)) (children l) \\<and>\n      newvals (rho (Suc f) q) l = w) \\<or>\n  (\\<nexists>w.\n      has_majority w (newvals (rho (Suc f) q)) (children l)) \\<and>\n  newvals (rho (Suc f) q) l = undefined\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l", "by (auto simp: has_majority_def elim: abs_majoritiesE')"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l = newvals (rho (Suc f) q) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  common rho l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  common rho l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The root of the tree is a common node.\\<close>"], ["", "lemma lynch_6_20:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n  shows \"common rho root_node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. common rho root_node", "using run lynch_6_18_b[OF assms]"], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  covering\n   {l. \\<exists>t. l \\<in> children t \\<and> last_lbl l \\<in> SK HOs SHOs}\n\ngoal (1 subgoal):\n 1. common rho root_node", "proof (rule lynch_6_19_b, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l' t.\n       \\<lbrakk>SHORun EIG_M rho HOs SHOs;\n        covering\n         {l. \\<exists>t.\n                l \\<in> children t \\<and> last_lbl l \\<in> SK HOs SHOs};\n        l' \\<in> children t; last_lbl l' \\<in> SK HOs SHOs\\<rbrakk>\n       \\<Longrightarrow> common rho l'", "fix l t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l' t.\n       \\<lbrakk>SHORun EIG_M rho HOs SHOs;\n        covering\n         {l. \\<exists>t.\n                l \\<in> children t \\<and> last_lbl l \\<in> SK HOs SHOs};\n        l' \\<in> children t; last_lbl l' \\<in> SK HOs SHOs\\<rbrakk>\n       \\<Longrightarrow> common rho l'", "assume \"l \\<in> children t\" \"last_lbl l \\<in> SK HOs SHOs\""], ["proof (state)\nthis:\n  l \\<in> children t\n  last_lbl l \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>l' t.\n       \\<lbrakk>SHORun EIG_M rho HOs SHOs;\n        covering\n         {l. \\<exists>t.\n                l \\<in> children t \\<and> last_lbl l \\<in> SK HOs SHOs};\n        l' \\<in> children t; last_lbl l' \\<in> SK HOs SHOs\\<rbrakk>\n       \\<Longrightarrow> common rho l'", "thus \"common rho l\""], ["proof (prove)\nusing this:\n  l \\<in> children t\n  last_lbl l \\<in> SK HOs SHOs\n\ngoal (1 subgoal):\n 1. common rho l", "by (auto simp: SK_def elim: lynch_6_18_a[OF run commR])"], ["proof (state)\nthis:\n  common rho l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A decision is taken only at state \\<open>f+1\\<close> and then stays stable.\n\\<close>"], ["", "lemma decide:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n  shows \"decide (rho r p) = \n         (if r < Suc f then None\n          else Some (newvals (rho (Suc f) p) root_node))\"\n     (is \"?P r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. decide (rho r p) =\n    (if r < Suc f then None else Some (newvals (rho (Suc f) p) root_node))", "proof (induct r)"], ["proof (state)\ngoal (2 subgoals):\n 1. decide (rho 0 p) =\n    (if 0 < Suc f then None else Some (newvals (rho (Suc f) p) root_node))\n 2. \\<And>r.\n       decide (rho r p) =\n       (if r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node)) \\<Longrightarrow>\n       decide (rho (Suc r) p) =\n       (if Suc r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node))", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "show \"?P 0\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. decide (rho 0 p) =\n    (if 0 < Suc f then None else Some (newvals (rho (Suc f) p) root_node))", "by (auto simp: EIG_SHOMachine_def SHORun_eq HOinitConfig_eq\n                   initState_def EIG_initState_def)"], ["proof (state)\nthis:\n  decide (rho 0 p) =\n  (if 0 < Suc f then None else Some (newvals (rho (Suc f) p) root_node))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       decide (rho r p) =\n       (if r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node)) \\<Longrightarrow>\n       decide (rho (Suc r) p) =\n       (if Suc r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       decide (rho r p) =\n       (if r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node)) \\<Longrightarrow>\n       decide (rho (Suc r) p) =\n       (if Suc r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node))", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       decide (rho r p) =\n       (if r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node)) \\<Longrightarrow>\n       decide (rho (Suc r) p) =\n       (if Suc r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node))", "assume ih: \"?P r\""], ["proof (state)\nthis:\n  decide (rho r p) =\n  (if r < Suc f then None else Some (newvals (rho (Suc f) p) root_node))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       decide (rho r p) =\n       (if r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node)) \\<Longrightarrow>\n       decide (rho (Suc r) p) =\n       (if Suc r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node))", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "obtain \\<mu>p\n    where \"EIG_nextState r p (rho r p) \\<mu>p (rho (Suc r) p)\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>p.\n        EIG_nextState r p (rho r p) \\<mu>p (rho (Suc r) p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: EIG_SHOMachine_def SHORun_eq SHOnextConfig_eq \n                   nextState_def)"], ["proof (state)\nthis:\n  EIG_nextState r p (rho r p) \\<mu>p (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       decide (rho r p) =\n       (if r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node)) \\<Longrightarrow>\n       decide (rho (Suc r) p) =\n       (if Suc r < Suc f then None\n        else Some (newvals (rho (Suc f) p) root_node))", "thus \"?P (Suc r)\""], ["proof (prove)\nusing this:\n  EIG_nextState r p (rho r p) \\<mu>p (rho (Suc r) p)\n\ngoal (1 subgoal):\n 1. decide (rho (Suc r) p) =\n    (if Suc r < Suc f then None\n     else Some (newvals (rho (Suc f) p) root_node))", "proof (auto simp: EIG_nextState_def next_main_def next_end_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r < f; r \\<noteq> f; rho (Suc r) p = rho r p\\<rbrakk>\n    \\<Longrightarrow> decide (rho r p) =\n                      Some (newvals (rho (Suc f) p) root_node)", "assume \"\\<not>(r < f)\" \"r \\<noteq> f\""], ["proof (state)\nthis:\n  \\<not> r < f\n  r \\<noteq> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> r < f; r \\<noteq> f; rho (Suc r) p = rho r p\\<rbrakk>\n    \\<Longrightarrow> decide (rho r p) =\n                      Some (newvals (rho (Suc f) p) root_node)", "with ih"], ["proof (chain)\npicking this:\n  decide (rho r p) =\n  (if r < Suc f then None else Some (newvals (rho (Suc f) p) root_node))\n  \\<not> r < f\n  r \\<noteq> f", "show \"decide (rho r p) = Some (newvals (rho (Suc f) p) root_node)\""], ["proof (prove)\nusing this:\n  decide (rho r p) =\n  (if r < Suc f then None else Some (newvals (rho (Suc f) p) root_node))\n  \\<not> r < f\n  r \\<noteq> f\n\ngoal (1 subgoal):\n 1. decide (rho r p) = Some (newvals (rho (Suc f) p) root_node)", "by simp"], ["proof (state)\nthis:\n  decide (rho r p) = Some (newvals (rho (Suc f) p) root_node)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decide (rho (Suc r) p) =\n  (if Suc r < Suc f then None else Some (newvals (rho (Suc f) p) root_node))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proof of Agreement, Validity, and Termination\\<close>"], ["", "text \\<open>\n  The Agreement property is an immediate consequence of lemma \\<open>lynch_6_20\\<close>.\n\\<close>"], ["", "theorem Agreement:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n      and commR:  \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and p: \"decide (rho m p) = Some v\"\n      and q: \"decide (rho n q) = Some w\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "using p q lynch_6_20[OF run commG commR]"], ["proof (prove)\nusing this:\n  decide (rho m p) = Some v\n  decide (rho n q) = Some w\n  common rho root_node\n\ngoal (1 subgoal):\n 1. v = w", "by (auto simp: decide[OF run] common_def)"], ["", "text \\<open>\n  We now show the Validity property: if all processes initially\n  propose the same value \\<open>v\\<close>, then no other value may be decided.\n\n  By lemma \\<open>sho_correct_vals\\<close>, value \\<open>v\\<close> must propagate to\n  all children of the root that are well heard at round \\<open>0\\<close>, and\n  lemma \\<open>lynch_6_16_d\\<close> implies that \\<open>v\\<close> is the value assigned\n  to all these children by \\<open>newvals\\<close>. Finally, lemma\n  \\<open>newvals_skr_uniform\\<close> lets us conclude.\n\\<close>"], ["", "theorem Validity:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and initv: \"\\<forall>q. the (vals (rho 0 q) root_node) = v\"\n      and dp: \"decide (rho r p) = Some w\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "have v: \"\\<forall>q. vals (rho 0 q) root_node = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q. vals (rho 0 q) root_node = Some v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q. vals (rho 0 q) root_node = Some v", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q. vals (rho 0 q) root_node = Some v", "from run"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs", "have \"vals (rho 0 q) root_node \\<noteq> None\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. vals (rho 0 q) root_node \\<noteq> None", "by (auto simp: EIG_SHOMachine_def SHORun_eq HOinitConfig_eq\n                     initState_def EIG_initState_def)"], ["proof (state)\nthis:\n  vals (rho 0 q) root_node \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>q. vals (rho 0 q) root_node = Some v", "then"], ["proof (chain)\npicking this:\n  vals (rho 0 q) root_node \\<noteq> None", "obtain w where w: \"vals (rho 0 q) root_node = Some w\""], ["proof (prove)\nusing this:\n  vals (rho 0 q) root_node \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        vals (rho 0 q) root_node = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vals (rho 0 q) root_node = Some w\n\ngoal (1 subgoal):\n 1. \\<And>q. vals (rho 0 q) root_node = Some v", "from initv"], ["proof (chain)\npicking this:\n  \\<forall>q. the (vals (rho 0 q) root_node) = v", "have \"the (vals (rho 0 q) root_node) = v\""], ["proof (prove)\nusing this:\n  \\<forall>q. the (vals (rho 0 q) root_node) = v\n\ngoal (1 subgoal):\n 1. the (vals (rho 0 q) root_node) = v", ".."], ["proof (state)\nthis:\n  the (vals (rho 0 q) root_node) = v\n\ngoal (1 subgoal):\n 1. \\<And>q. vals (rho 0 q) root_node = Some v", "with w"], ["proof (chain)\npicking this:\n  vals (rho 0 q) root_node = Some w\n  the (vals (rho 0 q) root_node) = v", "show \"vals (rho 0 q) root_node = Some v\""], ["proof (prove)\nusing this:\n  vals (rho 0 q) root_node = Some w\n  the (vals (rho 0 q) root_node) = v\n\ngoal (1 subgoal):\n 1. vals (rho 0 q) root_node = Some v", "by simp"], ["proof (state)\nthis:\n  vals (rho 0 q) root_node = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q. vals (rho 0 q) root_node = Some v\n\ngoal (1 subgoal):\n 1. v = w", "let ?len = length_lbl"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "let ?r = \"Suc f\""], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "fix l'"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "assume l': \"l' \\<in> children root_node\"\n       and skr: \"last_lbl l' \\<in> SKr (HOs 0) (SHOs 0)\""], ["proof (state)\nthis:\n  l' \\<in> children root_node\n  last_lbl l' \\<in> SKr (HOs 0) (SHOs 0)\n\ngoal (1 subgoal):\n 1. v = w", "with run v"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>q. vals (rho 0 q) root_node = Some v\n  l' \\<in> children root_node\n  last_lbl l' \\<in> SKr (HOs 0) (SHOs 0)", "have \"vals (rho (?len l') p) l' = Some v\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>q. vals (rho 0 q) root_node = Some v\n  l' \\<in> children root_node\n  last_lbl l' \\<in> SKr (HOs 0) (SHOs 0)\n\ngoal (1 subgoal):\n 1. vals (rho (length_lbl l') p) l' = Some v", "by (auto dest: sho_correct_vals simp: SKr_def)"], ["proof (state)\nthis:\n  vals (rho (length_lbl l') p) l' = Some v\n\ngoal (1 subgoal):\n 1. v = w", "moreover"], ["proof (state)\nthis:\n  vals (rho (length_lbl l') p) l' = Some v\n\ngoal (1 subgoal):\n 1. v = w", "from run commR l' skr"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  l' \\<in> children root_node\n  last_lbl l' \\<in> SKr (HOs 0) (SHOs 0)", "have \"newvals (rho ?r p) l' = fixupval (vals (rho (?len l') p) l')\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  l' \\<in> children root_node\n  last_lbl l' \\<in> SKr (HOs 0) (SHOs 0)\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')", "by (auto intro: lynch_6_16_d)"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')\n\ngoal (1 subgoal):\n 1. v = w", "ultimately"], ["proof (chain)\npicking this:\n  vals (rho (length_lbl l') p) l' = Some v\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')", "have \"newvals (rho ?r p) l' = v\""], ["proof (prove)\nusing this:\n  vals (rho (length_lbl l') p) l' = Some v\n  newvals (rho (Suc f) p) l' = fixupval (vals (rho (length_lbl l') p) l')\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) l' = v", "by simp"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) l' = v\n\ngoal (1 subgoal):\n 1. v = w", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?l'2 \\<in> children root_node;\n   last_lbl ?l'2 \\<in> SKr (HOs 0) (SHOs 0)\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l'2 = v\n\ngoal (1 subgoal):\n 1. v = w", "with run commR root_node_not_leaf"], ["proof (chain)\npicking this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  \\<not> is_leaf root_node\n  \\<lbrakk>?l'2 \\<in> children root_node;\n   last_lbl ?l'2 \\<in> SKr (HOs 0) (SHOs 0)\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l'2 = v", "have \"newvals (rho ?r p) root_node = v\""], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  \\<not> is_leaf root_node\n  \\<lbrakk>?l'2 \\<in> children root_node;\n   last_lbl ?l'2 \\<in> SKr (HOs 0) (SHOs 0)\\<rbrakk>\n  \\<Longrightarrow> newvals (rho (Suc f) p) ?l'2 = v\n\ngoal (1 subgoal):\n 1. newvals (rho (Suc f) p) root_node = v", "by (auto intro: newvals_skr_uniform)"], ["proof (state)\nthis:\n  newvals (rho (Suc f) p) root_node = v\n\ngoal (1 subgoal):\n 1. v = w", "with dp"], ["proof (chain)\npicking this:\n  decide (rho r p) = Some w\n  newvals (rho (Suc f) p) root_node = v", "show ?thesis"], ["proof (prove)\nusing this:\n  decide (rho r p) = Some w\n  newvals (rho (Suc f) p) root_node = v\n\ngoal (1 subgoal):\n 1. v = w", "by (simp add: decide[OF run])"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Termination is trivial for \\eigbyz{}.\\<close>"], ["", "theorem Termination:\n  assumes \"SHORun EIG_M rho HOs SHOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "using assms"], ["proof (prove)\nusing this:\n  SHORun EIG_M rho HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "by (auto simp: decide)"], ["", "subsection \\<open>\\eigbyz{} Solves Weak Consensus\\<close>"], ["", "text \\<open>\n  Summing up, all (coarse-grained) runs of \\eigbyz{} for\n  HO and SHO collections that satisfy the communication predicate \n  satisfy the Weak Consensus property.\n\\<close>"], ["", "theorem eig_weak_consensus:\n  assumes run: \"SHORun EIG_M rho HOs SHOs\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. the (vals (rho 0 p) root_node)) decide rho\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. the (vals (rho 0 p) root_node)) decide rho", "unfolding weak_consensus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        (\\<forall>p. the (vals (rho 0 p) root_node) = v) \\<longrightarrow>\n        (\\<forall>n p w.\n            decide (rho n p) = Some w \\<longrightarrow> w = v)) \\<and>\n    (\\<forall>m n p q v w.\n        decide (rho m p) = Some v \\<and>\n        decide (rho n q) = Some w \\<longrightarrow>\n        v = w) \\<and>\n    (\\<forall>p. \\<exists>n. decide (rho n p) \\<noteq> None)", "using Validity[OF run commR]\n        Agreement[OF run commG commR]\n        Termination[OF run]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>q. the (vals (rho 0 q) root_node) = ?v;\n   decide (rho ?r ?p) = Some ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  \\<lbrakk>decide (rho ?m ?p) = Some ?v;\n   decide (rho ?n ?q) = Some ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n  \\<exists>r v. decide (rho r ?p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<forall>v.\n        (\\<forall>p. the (vals (rho 0 p) root_node) = v) \\<longrightarrow>\n        (\\<forall>n p w.\n            decide (rho n p) = Some w \\<longrightarrow> w = v)) \\<and>\n    (\\<forall>m n p q v w.\n        decide (rho m p) = Some v \\<and>\n        decide (rho n q) = Some w \\<longrightarrow>\n        v = w) \\<and>\n    (\\<forall>p. \\<exists>n. decide (rho n p) \\<noteq> None)", "by auto"], ["", "text \\<open>\n  By the reduction theorem, the correctness of the algorithm carries over\n  to the fine-grained model of runs.\n\\<close>"], ["", "theorem eig_weak_consensus_fg:\n  assumes run: \"fg_run EIG_M rho HOs SHOs (\\<lambda>r q. undefined)\"\n      and commR: \"\\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\"\n      and commG: \"EIG_commGlobal HOs SHOs\"\n  shows \"weak_consensus (\\<lambda>p. the (vals (state (rho 0) p) root_node))\n                        decide (state \\<circ> rho)\"\n    (is \"weak_consensus ?inits _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. the (vals (state (rho 0) p) root_node))\n     decide (state \\<circ> rho)", "proof (rule local_property_reduction[OF run weak_consensus_is_local])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun EIG_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus\n                          (\\<lambda>p.\n                              the (vals (state (rho 0) p) root_node))\n                          decide crho", "fix crun"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun EIG_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus\n                          (\\<lambda>p.\n                              the (vals (state (rho 0) p) root_node))\n                          decide crho", "assume crun: \"CSHORun EIG_M crun HOs SHOs (\\<lambda>r q. undefined)\"\n     and init: \"crun 0 = state (rho 0)\""], ["proof (state)\nthis:\n  CSHORun EIG_M crun HOs SHOs (\\<lambda>r q. undefined)\n  crun 0 = state (rho 0)\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun EIG_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus\n                          (\\<lambda>p.\n                              the (vals (state (rho 0) p) root_node))\n                          decide crho", "from crun"], ["proof (chain)\npicking this:\n  CSHORun EIG_M crun HOs SHOs (\\<lambda>r q. undefined)", "have \"SHORun EIG_M crun HOs SHOs\""], ["proof (prove)\nusing this:\n  CSHORun EIG_M crun HOs SHOs (\\<lambda>r q. undefined)\n\ngoal (1 subgoal):\n 1. SHORun EIG_M crun HOs SHOs", "by (unfold SHORun_def)"], ["proof (state)\nthis:\n  SHORun EIG_M crun HOs SHOs\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun EIG_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus\n                          (\\<lambda>p.\n                              the (vals (state (rho 0) p) root_node))\n                          decide crho", "from this commR commG"], ["proof (chain)\npicking this:\n  SHORun EIG_M crun HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  EIG_commGlobal HOs SHOs", "have \"weak_consensus (\\<lambda>p. the (vals (crun 0 p) root_node)) decide crun\""], ["proof (prove)\nusing this:\n  SHORun EIG_M crun HOs SHOs\n  \\<forall>r. EIG_commPerRd (HOs r) (SHOs r)\n  EIG_commGlobal HOs SHOs\n\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. the (vals (crun 0 p) root_node)) decide crun", "by (rule eig_weak_consensus)"], ["proof (state)\nthis:\n  weak_consensus (\\<lambda>p. the (vals (crun 0 p) root_node)) decide crun\n\ngoal (1 subgoal):\n 1. \\<And>crho.\n       \\<lbrakk>CSHORun EIG_M crho HOs SHOs (\\<lambda>r q. undefined);\n        crho 0 = state (rho 0)\\<rbrakk>\n       \\<Longrightarrow> weak_consensus\n                          (\\<lambda>p.\n                              the (vals (state (rho 0) p) root_node))\n                          decide crho", "with init"], ["proof (chain)\npicking this:\n  crun 0 = state (rho 0)\n  weak_consensus (\\<lambda>p. the (vals (crun 0 p) root_node)) decide crun", "show \"weak_consensus ?inits decide crun\""], ["proof (prove)\nusing this:\n  crun 0 = state (rho 0)\n  weak_consensus (\\<lambda>p. the (vals (crun 0 p) root_node)) decide crun\n\ngoal (1 subgoal):\n 1. weak_consensus (\\<lambda>p. the (vals (state (rho 0) p) root_node))\n     decide crun", "by (simp add: o_def)"], ["proof (state)\nthis:\n  weak_consensus (\\<lambda>p. the (vals (state (rho 0) p) root_node)) decide\n   crun\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}