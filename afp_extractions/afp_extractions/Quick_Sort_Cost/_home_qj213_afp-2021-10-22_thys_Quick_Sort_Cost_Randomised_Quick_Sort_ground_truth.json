{"file_name": "/home/qj213/afp-2021-10-22/thys/Quick_Sort_Cost/Randomised_Quick_Sort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Quick_Sort_Cost", "problem_names": ["lemma delete_index_altdef: \"delete_index n xs = take n xs @ drop (Suc n) xs\"", "lemma delete_index_ge_length: \"n \\<ge> length xs \\<Longrightarrow> delete_index n xs = xs\"", "lemma length_delete_index [simp]: \"n < length xs \\<Longrightarrow> length (delete_index n xs) = length xs - 1\"", "lemma delete_index_Cons: \n  \"delete_index n (x # xs) = (if n = 0 then xs else x # delete_index (n - 1) xs)\"", "lemma insert_set_delete_index:\n  \"n < length xs \\<Longrightarrow> insert (xs ! n) (set (delete_index n xs)) = set xs\"", "lemma add_mset_delete_index: \n  \"i < length xs \\<Longrightarrow> add_mset (xs ! i) (mset (delete_index i xs)) = mset xs\"", "lemma nth_delete_index: \n  \"i < length xs \\<Longrightarrow> n < length xs \\<Longrightarrow> \n     delete_index n xs ! i = (if i < n then xs ! i else xs ! Suc i)\"", "lemma set_delete_index_distinct:\n  assumes \"distinct xs\" \"n < length xs\"\n  shows   \"set (delete_index n xs) = set xs - {xs ! n}\"", "lemma distinct_delete_index [simp, intro]: \n  assumes \"distinct xs\"\n  shows   \"distinct (delete_index n xs)\"", "lemma mset_delete_index [simp]: \n  \"i < length xs \\<Longrightarrow> mset (delete_index i xs) = mset xs - {# xs!i #}\"", "lemma rquicksort_Nil [simp]: \"rquicksort R [] = return_pmf ([], 0)\"", "lemma set_pmf_of_set_lessThan_length [simp]:\n  \"xs \\<noteq> [] \\<Longrightarrow> set_pmf (pmf_of_set {..<length xs}) = {..<length xs}\"", "theorem rquicksort_correct:\n  assumes \"trans R\" and \"total_on (set xs) R\" and \"\\<forall>x\\<in>set xs. (x,x) \\<in> R\"\n  assumes \"(ys, n) \\<in> set_pmf (rquicksort R xs)\"\n  shows   \"sorted_wrt R ys \\<and> mset ys = mset xs\"", "lemma finite_set_pmf_rqs_cost [intro!]: \"finite (set_pmf (rqs_cost n))\"", "theorem snd_rquicksort:\n  assumes \"linorder_on A R\" and \"set xs \\<subseteq> A\" and \"distinct xs\"\n  shows   \"map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\"", "lemmas rqs_cost_exp_0 = rqs_cost_exp.simps(1)", "lemmas rqs_cost_exp_Suc [simp del] = rqs_cost_exp.simps(2)", "lemma rqs_cost_exp_Suc_0 [simp]: \"rqs_cost_exp (Suc 0) = 0\"", "theorem expectation_rqs_cost: \"measure_pmf.expectation (rqs_cost n) real = rqs_cost_exp n\"", "lemma rqs_cost_exp_Suc':\n  \"rqs_cost_exp (Suc n) = real n + 2 / real (Suc n) * (\\<Sum>i\\<le>n. rqs_cost_exp i)\"", "theorem rqs_cost_exp_eq [code]: \"rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n\"", "lemma asymp_equiv_harm [asymp_equiv_intros]: \"harm \\<sim>[at_top] (\\<lambda>n. ln (real n))\"", "lemma harm_mono: \"m \\<le> n \\<Longrightarrow> harm m \\<le> (harm n :: real)\"", "lemma harm_Suc_0 [simp]: \"harm (Suc 0) = 1\"", "lemma harm_ge_1: \"n > 0 \\<Longrightarrow> harm n \\<ge> (1::real)\"", "lemma mono_rqs_cost_exp: \"mono rqs_cost_exp\"", "lemma rqs_cost_exp_leI: \"m \\<le> n \\<Longrightarrow> rqs_cost_exp m \\<le> rqs_cost_exp n\"", "lemma rquicksort'_Nil [simp]: \"rquicksort' R [] = return_pmf ([], 0)\"", "lemma lesss_Cons:\n  \"lesss R x (y # ys) = \n     (if (y, x) \\<in> R \\<and> (x, y) \\<notin> R then y # lesss R x ys else lesss R x ys)\"", "lemma length_lesss_le [intro]: \"length (lesss R x xs) \\<le> length xs\"", "lemma length_lesss_less [intro]:\n  assumes \"x \\<in> set xs\"\n  shows   \"length (lesss R x xs) < length xs\"", "lemma greaters_Cons:\n  \"greaters R x (y # ys) = \n     (if (x, y) \\<in> R \\<and> (y, x) \\<notin> R then y # greaters R x ys else greaters R x ys)\"", "lemma length_greaters_le [intro]: \"length (greaters R x xs) \\<le> length xs\"", "lemma length_greaters_less [intro]:\n  assumes \"x \\<in> set xs\"\n  shows   \"length (greaters R x xs) < length xs\"", "lemma rqs'_cost_nonempty:\n  \"xs \\<noteq> [] \\<Longrightarrow> rqs'_cost R xs = \n     do {\n       i \\<leftarrow> pmf_of_set {..<length xs};\n       let x = xs ! i;\n       n1 \\<leftarrow> rqs'_cost R (lesss R x xs);\n       n2 \\<leftarrow> rqs'_cost R (greaters R x xs);\n       return_pmf (length xs - 1 + n1 + n2)\n     }\"", "lemma finite_set_pmf_rqs'_cost [simp, intro]:\n  \"finite (set_pmf (rqs'_cost R xs))\"", "lemma expectation_pair_pmf_fst [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  shows \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) = measure_pmf.expectation p f\"", "lemma expectation_pair_pmf_snd [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  shows \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) = measure_pmf.expectation q f\"", "lemma length_lesss_le_sorted:\n  assumes \"sorted_wrt R xs\" \"i < length xs\"\n  shows   \"length (lesss R (xs ! i) xs) \\<le> i\"", "lemma length_greaters_le_sorted:\n  assumes \"sorted_wrt R xs\" \"i < length xs\"\n  shows   \"length (greaters R (xs ! i) xs) \\<le> length xs - i - 1\"", "lemma length_lesss_le':\n  assumes \"i < length xs\" \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\"", "lemma length_greaters_le':\n  assumes \"i < length xs\" \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1\"", "theorem rqs'_cost_expectation_le:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"measure_pmf.expectation (rqs'_cost R xs) real \\<le> rqs_cost_exp (length xs)\""], "translations": [["", "lemma delete_index_altdef: \"delete_index n xs = take n xs @ drop (Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_index n xs = take n xs @ drop (Suc n) xs", "by (induction n xs rule: delete_index.induct) simp_all"], ["", "lemma delete_index_ge_length: \"n \\<ge> length xs \\<Longrightarrow> delete_index n xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> n \\<Longrightarrow> delete_index n xs = xs", "by (simp add: delete_index_altdef)"], ["", "lemma length_delete_index [simp]: \"n < length xs \\<Longrightarrow> length (delete_index n xs) = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    length (delete_index n xs) = length xs - 1", "by (simp add: delete_index_altdef)"], ["", "lemma delete_index_Cons: \n  \"delete_index n (x # xs) = (if n = 0 then xs else x # delete_index (n - 1) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_index n (x # xs) =\n    (if n = 0 then xs else x # delete_index (n - 1) xs)", "by (cases n) simp_all"], ["", "lemma insert_set_delete_index:\n  \"n < length xs \\<Longrightarrow> insert (xs ! n) (set (delete_index n xs)) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length xs \\<Longrightarrow>\n    insert (xs ! n) (set (delete_index n xs)) = set xs", "by (induction n xs rule: delete_index.induct) auto"], ["", "lemma add_mset_delete_index: \n  \"i < length xs \\<Longrightarrow> add_mset (xs ! i) (mset (delete_index i xs)) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    add_mset (xs ! i) (mset (delete_index i xs)) = mset xs", "by (induction i xs rule: delete_index.induct) simp_all"], ["", "lemma nth_delete_index: \n  \"i < length xs \\<Longrightarrow> n < length xs \\<Longrightarrow> \n     delete_index n xs ! i = (if i < n then xs ! i else xs ! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; n < length xs\\<rbrakk>\n    \\<Longrightarrow> delete_index n xs ! i =\n                      (if i < n then xs ! i else xs ! Suc i)", "by (auto simp: delete_index_altdef nth_append min_def)"], ["", "lemma set_delete_index_distinct:\n  assumes \"distinct xs\" \"n < length xs\"\n  shows   \"set (delete_index n xs) = set xs - {xs ! n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (delete_index n xs) = set xs - {xs ! n}", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  n < length xs\n\ngoal (1 subgoal):\n 1. set (delete_index n xs) = set xs - {xs ! n}", "by (induction n xs rule: delete_index.induct) fastforce+"], ["", "lemma distinct_delete_index [simp, intro]: \n  assumes \"distinct xs\"\n  shows   \"distinct (delete_index n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (delete_index n xs)", "proof (cases \"n < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> distinct (delete_index n xs)\n 2. \\<not> n < length xs \\<Longrightarrow> distinct (delete_index n xs)", "case True"], ["proof (state)\nthis:\n  n < length xs\n\ngoal (2 subgoals):\n 1. n < length xs \\<Longrightarrow> distinct (delete_index n xs)\n 2. \\<not> n < length xs \\<Longrightarrow> distinct (delete_index n xs)", "with assms"], ["proof (chain)\npicking this:\n  distinct xs\n  n < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n  n < length xs\n\ngoal (1 subgoal):\n 1. distinct (delete_index n xs)", "by (induction n xs rule: delete_index.induct) (auto simp: set_delete_index_distinct)"], ["proof (state)\nthis:\n  distinct (delete_index n xs)\n\ngoal (1 subgoal):\n 1. \\<not> n < length xs \\<Longrightarrow> distinct (delete_index n xs)", "qed (simp_all add: delete_index_ge_length assms)"], ["", "lemma mset_delete_index [simp]: \n  \"i < length xs \\<Longrightarrow> mset (delete_index i xs) = mset xs - {# xs!i #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    mset (delete_index i xs) = mset xs - {#xs ! i#}", "by (induction i xs rule: delete_index.induct) simp_all"], ["", "subsection \\<open>Definition\\<close>"], ["", "text \\<open>\n  The following is a functional randomised version of QuickSort that also records the number \n  of comparisons that were made. The randomisation is in the selection of the pivot element: \n  In each step, the next pivot is chosen uniformly at random from all remaining list elements.\n\n  The function takes the ordering relation to use as a first argument in the form of a set of \n  pairs.\n\\<close>"], ["", "function rquicksort :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> nat) pmf\" where\n  \"rquicksort R xs = \n     (if xs = [] then \n        return_pmf ([], 0)\n      else\n        do {\n          i \\<leftarrow> pmf_of_set {..<length xs};\n          let x = xs ! i;\n          case partition (\\<lambda>y. (y,x) \\<in> R) (delete_index i xs) of\n            (ls, rs) \\<Rightarrow> do {\n              (ls, n1) \\<leftarrow> rquicksort R ls;\n              (rs, n2) \\<leftarrow> rquicksort R rs;\n              return_pmf (ls @ [x] @ rs, length xs - 1 + n1 + n2)\n            }\n        })\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>R xs. x = (R, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>R xs Ra xsa.\n       (R, xs) = (Ra, xsa) \\<Longrightarrow>\n       (if xs = [] then return_pmf ([], 0)\n        else pmf_of_set {..<length xs} \\<bind>\n             (\\<lambda>i.\n                 let x = xs ! i\n                 in case partition (\\<lambda>y. (y, x) \\<in> R)\n                          (delete_index i xs) of\n                    (ls, rs) \\<Rightarrow>\n                      rquicksort_sumC (R, ls) \\<bind>\n                      (\\<lambda>(ls, n1).\n                          rquicksort_sumC (R, rs) \\<bind>\n                          (\\<lambda>(rs, n2).\n                              return_pmf\n                               (ls @ [x] @ rs,\n                                length xs - 1 + n1 + n2))))) =\n       (if xsa = [] then return_pmf ([], 0)\n        else pmf_of_set {..<length xsa} \\<bind>\n             (\\<lambda>i.\n                 let x = xsa ! i\n                 in case partition (\\<lambda>y. (y, x) \\<in> Ra)\n                          (delete_index i xsa) of\n                    (ls, rs) \\<Rightarrow>\n                      rquicksort_sumC (Ra, ls) \\<bind>\n                      (\\<lambda>(ls, n1).\n                          rquicksort_sumC (Ra, rs) \\<bind>\n                          (\\<lambda>(rs, n2).\n                              return_pmf\n                               (ls @ [x] @ rs, length xsa - 1 + n1 + n2)))))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All rquicksort_dom", "proof (relation \"Wellfounded.measure (length \\<circ> snd)\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. wf (Wellfounded.measure (length \\<circ> snd))\n 2. \\<And>R xs x xa xb y.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x;\n        (xb, y) =\n        partition (\\<lambda>y. (y, xa) \\<in> R) (delete_index x xs)\\<rbrakk>\n       \\<Longrightarrow> ((R, xb), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)\n 3. \\<And>R xs x xa xb y xc xd ya.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x;\n        (xb, y) =\n        partition (\\<lambda>y. (y, xa) \\<in> R) (delete_index x xs);\n        xc \\<in> set_pmf (rquicksort R xb); (xd, ya) = xc;\n        rquicksort_dom (R, xb)\\<rbrakk>\n       \\<Longrightarrow> ((R, y), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)", "show \"wf (Wellfounded.measure (length \\<circ> snd))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (Wellfounded.measure (length \\<circ> snd))", "by simp"], ["proof (state)\nthis:\n  wf (Wellfounded.measure (length \\<circ> snd))\n\ngoal (2 subgoals):\n 1. \\<And>R xs x xa xb y.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x;\n        (xb, y) =\n        partition (\\<lambda>y. (y, xa) \\<in> R) (delete_index x xs)\\<rbrakk>\n       \\<Longrightarrow> ((R, xb), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)\n 2. \\<And>R xs x xa xb y xc xd ya.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x;\n        (xb, y) =\n        partition (\\<lambda>y. (y, xa) \\<in> R) (delete_index x xs);\n        xc \\<in> set_pmf (rquicksort R xb); (xd, ya) = xc;\n        rquicksort_dom (R, xb)\\<rbrakk>\n       \\<Longrightarrow> ((R, y), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)", "qed (subst (asm) set_pmf_of_set; force intro!: le_less_trans[OF length_filter_le])+"], ["", "declare rquicksort.simps [simp del]"], ["", "lemma rquicksort_Nil [simp]: \"rquicksort R [] = return_pmf ([], 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rquicksort R [] = return_pmf ([], 0)", "by (simp add: rquicksort.simps)"], ["", "subsection \\<open>Correctness proof\\<close>"], ["", "lemma set_pmf_of_set_lessThan_length [simp]:\n  \"xs \\<noteq> [] \\<Longrightarrow> set_pmf (pmf_of_set {..<length xs}) = {..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    set_pmf (pmf_of_set {..<length xs}) = {..<length xs}", "by (subst set_pmf_of_set) auto"], ["", "text \\<open>\n  We can now prove that any list that can be returned by QuickSort is sorted w.\\,r.\\,t.\\ the \n  given relation. (as long as that relation is reflexive, transitive, and total)\n\\<close>"], ["", "theorem rquicksort_correct:\n  assumes \"trans R\" and \"total_on (set xs) R\" and \"\\<forall>x\\<in>set xs. (x,x) \\<in> R\"\n  assumes \"(ys, n) \\<in> set_pmf (rquicksort R xs)\"\n  shows   \"sorted_wrt R ys \\<and> mset ys = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "using assms(2-)"], ["proof (prove)\nusing this:\n  total_on (set xs) R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n  (ys, n) \\<in> set_pmf (rquicksort R xs)\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "proof (induction xs arbitrary: ys n rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs ys n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   total_on (set ys) R \\<longrightarrow>\n                   (\\<forall>x\\<in>set ys. (x, x) \\<in> R) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa)\n                       \\<in> set_pmf (rquicksort R ys) \\<longrightarrow>\n                       Linorder_Relations.sorted_wrt R x \\<and>\n                       mset x = mset ys);\n        total_on (set xs) R; \\<forall>x\\<in>set xs. (x, x) \\<in> R;\n        (ys, n) \\<in> set_pmf (rquicksort R xs)\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R ys \\<and>\n                         mset ys = mset xs", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     total_on (set ys) R \\<longrightarrow>\n     (\\<forall>x\\<in>set ys. (x, x) \\<in> R) \\<longrightarrow>\n     (\\<forall>x xa.\n         (x, xa) \\<in> set_pmf (rquicksort R ys) \\<longrightarrow>\n         Linorder_Relations.sorted_wrt R x \\<and> mset x = mset ys)\n  total_on (set xs) R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n  (ys, n) \\<in> set_pmf (rquicksort R xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs ys n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   total_on (set ys) R \\<longrightarrow>\n                   (\\<forall>x\\<in>set ys. (x, x) \\<in> R) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa)\n                       \\<in> set_pmf (rquicksort R ys) \\<longrightarrow>\n                       Linorder_Relations.sorted_wrt R x \\<and>\n                       mset x = mset ys);\n        total_on (set xs) R; \\<forall>x\\<in>set xs. (x, x) \\<in> R;\n        (ys, n) \\<in> set_pmf (rquicksort R xs)\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R ys \\<and>\n                         mset ys = mset xs", "have IH: \"sorted_wrt R zs\" \"mset zs = mset ys\" \n    if \"(zs, n) \\<in> set_pmf (rquicksort R ys)\" \"length ys < length xs\" \"set ys \\<subseteq> set xs\" for zs ys n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R zs &&& mset zs = mset ys", "using that \"1.IH\" total_on_subset[OF \"1.prems\"(1) that(3)] \"1.prems\"(2)"], ["proof (prove)\nusing this:\n  (zs, n) \\<in> set_pmf (rquicksort R ys)\n  length ys < length xs\n  set ys \\<subseteq> set xs\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     total_on (set ys) R \\<longrightarrow>\n     (\\<forall>x\\<in>set ys. (x, x) \\<in> R) \\<longrightarrow>\n     (\\<forall>x xa.\n         (x, xa) \\<in> set_pmf (rquicksort R ys) \\<longrightarrow>\n         Linorder_Relations.sorted_wrt R x \\<and> mset x = mset ys)\n  total_on (set ys) R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R zs &&& mset zs = mset ys", "by blast+"], ["proof (state)\nthis:\n  \\<lbrakk>(?zs, ?n) \\<in> set_pmf (rquicksort R ?ys);\n   length ?ys < length xs; set ?ys \\<subseteq> set xs\\<rbrakk>\n  \\<Longrightarrow> Linorder_Relations.sorted_wrt R ?zs\n  \\<lbrakk>(?zs, ?n) \\<in> set_pmf (rquicksort R ?ys);\n   length ?ys < length xs; set ?ys \\<subseteq> set xs\\<rbrakk>\n  \\<Longrightarrow> mset ?zs = mset ?ys\n\ngoal (1 subgoal):\n 1. \\<And>xs ys n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   total_on (set ys) R \\<longrightarrow>\n                   (\\<forall>x\\<in>set ys. (x, x) \\<in> R) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       (x, xa)\n                       \\<in> set_pmf (rquicksort R ys) \\<longrightarrow>\n                       Linorder_Relations.sorted_wrt R x \\<and>\n                       mset x = mset ys);\n        total_on (set xs) R; \\<forall>x\\<in>set xs. (x, x) \\<in> R;\n        (ys, n) \\<in> set_pmf (rquicksort R xs)\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R ys \\<and>\n                         mset ys = mset xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "with \"1.prems\""], ["proof (chain)\npicking this:\n  total_on (set xs) R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n  (ys, n) \\<in> set_pmf (rquicksort R xs)\n  xs \\<noteq> []", "obtain ls rs n1 n2 i where *:\n       \"i < length xs\" \"(ls, n1) \\<in> set_pmf (rquicksort R [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R])\"\n       \"(rs, n2) \\<in> set_pmf (rquicksort R [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<notin> R])\"\n       \"ys = ls @ [xs ! i] @ rs\""], ["proof (prove)\nusing this:\n  total_on (set xs) R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n  (ys, n) \\<in> set_pmf (rquicksort R xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>i ls n1 rs n2.\n        \\<lbrakk>i < length xs;\n         (ls, n1)\n         \\<in> set_pmf\n                (rquicksort R\n                  (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n                    (delete_index i xs)));\n         (rs, n2)\n         \\<in> set_pmf\n                (rquicksort R\n                  (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n                    (delete_index i xs)));\n         ys = ls @ [xs ! i] @ rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) rquicksort.simps[of _ xs]) (auto simp: Let_def o_def)"], ["proof (state)\nthis:\n  i < length xs\n  (ls, n1)\n  \\<in> set_pmf\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))\n  (rs, n2)\n  \\<in> set_pmf\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n             (delete_index i xs)))\n  ys = ls @ [xs ! i] @ rs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "note ys = \\<open>ys = ls @ [xs ! i] @ rs\\<close>"], ["proof (state)\nthis:\n  ys = ls @ [xs ! i] @ rs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "define ls' where \"ls' = [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R]\""], ["proof (state)\nthis:\n  ls' = filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "define rs' where \"rs' = [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<notin> R]\""], ["proof (state)\nthis:\n  rs' = filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "from \\<open>i < length xs\\<close>"], ["proof (chain)\npicking this:\n  i < length xs", "have less: \"length ls' < length xs\" \"length rs' < length xs\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. length ls' < length xs &&& length rs' < length xs", "unfolding ls'_def rs'_def"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))\n    < length xs &&&\n    length (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))\n    < length xs", "by (intro le_less_trans[OF length_filter_le]; force)+"], ["proof (state)\nthis:\n  length ls' < length xs\n  length rs' < length xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "have ls: \"(ls, n1) \\<in> set_pmf (rquicksort R ls')\" and rs: \"(rs, n2) \\<in> set_pmf (rquicksort R rs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ls, n1) \\<in> set_pmf (rquicksort R ls') &&&\n    (rs, n2) \\<in> set_pmf (rquicksort R rs')", "using *"], ["proof (prove)\nusing this:\n  i < length xs\n  (ls, n1)\n  \\<in> set_pmf\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))\n  (rs, n2)\n  \\<in> set_pmf\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n             (delete_index i xs)))\n  ys = ls @ [xs ! i] @ rs\n\ngoal (1 subgoal):\n 1. (ls, n1) \\<in> set_pmf (rquicksort R ls') &&&\n    (rs, n2) \\<in> set_pmf (rquicksort R rs')", "unfolding ls'_def rs'_def"], ["proof (prove)\nusing this:\n  i < length xs\n  (ls, n1)\n  \\<in> set_pmf\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))\n  (rs, n2)\n  \\<in> set_pmf\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n             (delete_index i xs)))\n  ys = ls @ [xs ! i] @ rs\n\ngoal (1 subgoal):\n 1. (ls, n1)\n    \\<in> set_pmf\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n               (delete_index i xs))) &&&\n    (rs, n2)\n    \\<in> set_pmf\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n               (delete_index i xs)))", "by blast+"], ["proof (state)\nthis:\n  (ls, n1) \\<in> set_pmf (rquicksort R ls')\n  (rs, n2) \\<in> set_pmf (rquicksort R rs')\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "have subset: \"set ls' \\<subseteq> set xs\" \"set rs' \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ls' \\<subseteq> set xs &&& set rs' \\<subseteq> set xs", "using insert_set_delete_index[of i xs] \\<open>i < length xs\\<close>"], ["proof (prove)\nusing this:\n  i < length xs \\<Longrightarrow>\n  insert (xs ! i) (set (delete_index i xs)) = set xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. set ls' \\<subseteq> set xs &&& set rs' \\<subseteq> set xs", "by (auto simp: ls'_def rs'_def)"], ["proof (state)\nthis:\n  set ls' \\<subseteq> set xs\n  set rs' \\<subseteq> set xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "have sorted: \"sorted_wrt R ls\" \"sorted_wrt R rs\" \n     and mset: \"mset ls = mset ls'\" \"mset rs = mset rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Linorder_Relations.sorted_wrt R ls &&&\n     Linorder_Relations.sorted_wrt R rs) &&&\n    mset ls = mset ls' &&& mset rs = mset rs'", "by (rule IH[of ls n1 ls'] IH[of rs n2 rs'] less ls rs subset)+"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ls\n  Linorder_Relations.sorted_wrt R rs\n  mset ls = mset ls'\n  mset rs = mset rs'\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "have ls_le: \"(x, xs ! i) \\<in> R\" if \"x \\<in> set ls\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<in> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<in> R", "from that"], ["proof (chain)\npicking this:\n  x \\<in> set ls", "have \"x \\<in># mset ls\""], ["proof (prove)\nusing this:\n  x \\<in> set ls\n\ngoal (1 subgoal):\n 1. x \\<in># mset ls", "by simp"], ["proof (state)\nthis:\n  x \\<in># mset ls\n\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<in> R", "also"], ["proof (state)\nthis:\n  x \\<in># mset ls\n\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<in> R", "note mset(1)"], ["proof (state)\nthis:\n  mset ls = mset ls'\n\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<in> R", "finally"], ["proof (chain)\npicking this:\n  x \\<in># mset ls'", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in># mset ls'\n\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<in> R", "by (simp add: ls'_def)"], ["proof (state)\nthis:\n  (x, xs ! i) \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> set ls \\<Longrightarrow> (?x, xs ! i) \\<in> R\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "have rs_ge: \"(x, xs ! i) \\<notin> R\" \"(xs ! i, x) \\<in> R\" if \"x \\<in> set rs\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<notin> R &&& (xs ! i, x) \\<in> R", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, xs ! i) \\<notin> R\n 2. (xs ! i, x) \\<in> R", "from that"], ["proof (chain)\npicking this:\n  x \\<in> set rs", "have \"x \\<in># mset rs\""], ["proof (prove)\nusing this:\n  x \\<in> set rs\n\ngoal (1 subgoal):\n 1. x \\<in># mset rs", "by simp"], ["proof (state)\nthis:\n  x \\<in># mset rs\n\ngoal (2 subgoals):\n 1. (x, xs ! i) \\<notin> R\n 2. (xs ! i, x) \\<in> R", "also"], ["proof (state)\nthis:\n  x \\<in># mset rs\n\ngoal (2 subgoals):\n 1. (x, xs ! i) \\<notin> R\n 2. (xs ! i, x) \\<in> R", "note mset(2)"], ["proof (state)\nthis:\n  mset rs = mset rs'\n\ngoal (2 subgoals):\n 1. (x, xs ! i) \\<notin> R\n 2. (xs ! i, x) \\<in> R", "finally"], ["proof (chain)\npicking this:\n  x \\<in># mset rs'", "have x: \"x \\<in> set rs'\""], ["proof (prove)\nusing this:\n  x \\<in># mset rs'\n\ngoal (1 subgoal):\n 1. x \\<in> set rs'", "by simp"], ["proof (state)\nthis:\n  x \\<in> set rs'\n\ngoal (2 subgoals):\n 1. (x, xs ! i) \\<notin> R\n 2. (xs ! i, x) \\<in> R", "thus \"(x, xs ! i) \\<notin> R\""], ["proof (prove)\nusing this:\n  x \\<in> set rs'\n\ngoal (1 subgoal):\n 1. (x, xs ! i) \\<notin> R", "by (simp_all add: rs'_def)"], ["proof (state)\nthis:\n  (x, xs ! i) \\<notin> R\n\ngoal (1 subgoal):\n 1. (xs ! i, x) \\<in> R", "from x and subset and \\<open>i < length xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set rs'\n  set ls' \\<subseteq> set xs\n  set rs' \\<subseteq> set xs\n  i < length xs", "have \"x \\<in> set xs\" \"xs ! i \\<in> set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set rs'\n  set ls' \\<subseteq> set xs\n  set rs' \\<subseteq> set xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs &&& xs ! i \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n  xs ! i \\<in> set xs\n\ngoal (1 subgoal):\n 1. (xs ! i, x) \\<in> R", "with \"1.prems\" and \\<open>(x, xs ! i) \\<notin> R\\<close>"], ["proof (chain)\npicking this:\n  total_on (set xs) R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n  (ys, n) \\<in> set_pmf (rquicksort R xs)\n  (x, xs ! i) \\<notin> R\n  x \\<in> set xs\n  xs ! i \\<in> set xs", "show \"(xs ! i, x) \\<in> R\""], ["proof (prove)\nusing this:\n  total_on (set xs) R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n  (ys, n) \\<in> set_pmf (rquicksort R xs)\n  (x, xs ! i) \\<notin> R\n  x \\<in> set xs\n  xs ! i \\<in> set xs\n\ngoal (1 subgoal):\n 1. (xs ! i, x) \\<in> R", "unfolding total_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs.\n     \\<forall>y\\<in>set xs.\n        x \\<noteq> y \\<longrightarrow> (x, y) \\<in> R \\<or> (y, x) \\<in> R\n  \\<forall>x\\<in>set xs. (x, x) \\<in> R\n  (ys, n) \\<in> set_pmf (rquicksort R xs)\n  (x, xs ! i) \\<notin> R\n  x \\<in> set xs\n  xs ! i \\<in> set xs\n\ngoal (1 subgoal):\n 1. (xs ! i, x) \\<in> R", "by (cases \"xs ! i = x\") auto"], ["proof (state)\nthis:\n  (xs ! i, x) \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> set rs \\<Longrightarrow> (?x, xs ! i) \\<notin> R\n  ?x \\<in> set rs \\<Longrightarrow> (xs ! i, ?x) \\<in> R\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "have \"sorted_wrt R ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ys", "unfolding ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (ls @ [xs ! i] @ rs)", "by (intro sorted_wrt_append \\<open>trans R\\<close> sorted_wrt_singleton sorted)\n         (auto intro: rs_ge ls_le transD[OF \\<open>trans R\\<close>, of _ \"xs!i\"])"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ys\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "moreover"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ys\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "have \"mset ys = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ys = mset xs", "unfolding ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (ls @ [xs ! i] @ rs) = mset xs", "using \\<open>i < length xs\\<close>"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. mset (ls @ [xs ! i] @ rs) = mset xs", "by (simp add: mset ls'_def rs'_def add_mset_delete_index)"], ["proof (state)\nthis:\n  mset ys = mset xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "ultimately"], ["proof (chain)\npicking this:\n  Linorder_Relations.sorted_wrt R ys\n  mset ys = mset xs", "show ?thesis"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R ys\n  mset ys = mset xs\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", ".."], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs", "qed (insert \"1.prems\", simp_all)"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R ys \\<and> mset ys = mset xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Cost analysis\\<close>"], ["", "text \\<open>\n  The following distribution describes the number of comparisons made by randomised \n  QuickSort in terms of the list length. (This is only valid if all list elements are distinct)\n\n  A succinct explanation of this cost analysis is given by Jacek Cicho\\'{n}~\\cite{cichon}.\n\\<close>"], ["", "fun rqs_cost :: \"nat \\<Rightarrow> nat pmf\" where\n  \"rqs_cost 0 = return_pmf 0\"\n| \"rqs_cost (Suc n) = \n     do {i \\<leftarrow> pmf_of_set {..n}; a \\<leftarrow> rqs_cost i; b \\<leftarrow> rqs_cost (n - i); return_pmf (n + a + b)}\""], ["", "lemma finite_set_pmf_rqs_cost [intro!]: \"finite (set_pmf (rqs_cost n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (rqs_cost n))", "by (induction n rule: rqs_cost.induct) simp_all"], ["", "text \\<open>\n  We connect the @{const rqs_cost} function to the @{const rquicksort} function by showing that\n  projecting out the number of comparisons from a run of @{const rquicksort} on a list with distinct\n  elements yields the same distribution as @{const rqs_cost} for the length of that list.\n\\<close>"], ["", "theorem snd_rquicksort:\n  assumes \"linorder_on A R\" and \"set xs \\<subseteq> A\" and \"distinct xs\"\n  shows   \"map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "using assms(2-)"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> A\n  distinct xs\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "proof (induction xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     set ys \\<subseteq> A \\<longrightarrow>\n     distinct ys \\<longrightarrow>\n     map_pmf snd (rquicksort R ys) = rqs_cost (length ys)\n  set xs \\<subseteq> A\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "have IH: \"map_pmf snd (rquicksort R ys) = rqs_cost (length ys)\"\n    if \"length ys < length xs\" \"mset ys \\<subseteq># mset xs\" for ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "from set_mset_mono[OF that(2)]"], ["proof (chain)\npicking this:\n  set_mset (mset ys) \\<subseteq> set_mset (mset xs)", "have \"set ys \\<subseteq> set xs\""], ["proof (prove)\nusing this:\n  set_mset (mset ys) \\<subseteq> set_mset (mset xs)\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set xs", "by simp"], ["proof (state)\nthis:\n  set ys \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "also"], ["proof (state)\nthis:\n  set ys \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "note \\<open>set xs \\<subseteq> A\\<close>"], ["proof (state)\nthis:\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "finally"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> A", "have \"set ys \\<subseteq> A\""], ["proof (prove)\nusing this:\n  set ys \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> A", "."], ["proof (state)\nthis:\n  set ys \\<subseteq> A\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "moreover"], ["proof (state)\nthis:\n  set ys \\<subseteq> A\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "from \\<open>distinct xs\\<close> and that(2)"], ["proof (chain)\npicking this:\n  distinct xs\n  mset ys \\<subseteq># mset xs", "have \"distinct ys\""], ["proof (prove)\nusing this:\n  distinct xs\n  mset ys \\<subseteq># mset xs\n\ngoal (1 subgoal):\n 1. distinct ys", "by (rule distinct_mset_mono)"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "ultimately"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> A\n  distinct ys", "show ?thesis"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> A\n  distinct ys\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "using that and \"1.IH\""], ["proof (prove)\nusing this:\n  set ys \\<subseteq> A\n  distinct ys\n  length ys < length xs\n  mset ys \\<subseteq># mset xs\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     set ys \\<subseteq> A \\<longrightarrow>\n     distinct ys \\<longrightarrow>\n     map_pmf snd (rquicksort R ys) = rqs_cost (length ys)\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R ys) = rqs_cost (length ys)", "by blast"], ["proof (state)\nthis:\n  map_pmf snd (rquicksort R ys) = rqs_cost (length ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length xs; mset ?ys \\<subseteq># mset xs\\<rbrakk>\n  \\<Longrightarrow> map_pmf snd (rquicksort R ?ys) = rqs_cost (length ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "define n where \"n = length xs\""], ["proof (state)\nthis:\n  n = length xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "define cnt where \"cnt = (\\<lambda>i. length [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R])\""], ["proof (state)\nthis:\n  cnt =\n  (\\<lambda>i.\n      length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "have cnt_altdef: \"cnt i = linorder_rank R (set xs) (xs ! i)\" if i: \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "have \"cnt i = length [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnt i =\n    length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))", "by (simp add: cnt_def)"], ["proof (state)\nthis:\n  cnt i =\n  length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "also"], ["proof (state)\nthis:\n  cnt i =\n  length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "have \"\\<dots> = card (set [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) =\n    card\n     (set (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))", "by (intro distinct_card [symmetric] distinct_filter distinct_delete_index \"1.prems\")"], ["proof (state)\nthis:\n  length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) =\n  card (set (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) =\n  card (set (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "have \"set [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R] = \n                      {x \\<in> set xs-{xs!i}. (x, xs ! i) \\<in> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) =\n    {x \\<in> set xs - {xs ! i}. (x, xs ! i) \\<in> R}", "using \"1.prems\" and i"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> A\n  distinct xs\n  i < n\n\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) =\n    {x \\<in> set xs - {xs ! i}. (x, xs ! i) \\<in> R}", "by (simp add: set_delete_index_distinct n_def)"], ["proof (state)\nthis:\n  set (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) =\n  {x \\<in> set xs - {xs ! i}. (x, xs ! i) \\<in> R}\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "also"], ["proof (state)\nthis:\n  set (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) =\n  {x \\<in> set xs - {xs ! i}. (x, xs ! i) \\<in> R}\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "have \"card \\<dots> = linorder_rank R (set xs) (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x \\<in> set xs - {xs ! i}. (x, xs ! i) \\<in> R} =\n    linorder_rank R (set xs) (xs ! i)", "by (simp add: linorder_rank_def)"], ["proof (state)\nthis:\n  card {x \\<in> set xs - {xs ! i}. (x, xs ! i) \\<in> R} =\n  linorder_rank R (set xs) (xs ! i)\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "finally"], ["proof (chain)\npicking this:\n  cnt i = linorder_rank R (set xs) (xs ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  cnt i = linorder_rank R (set xs) (xs ! i)\n\ngoal (1 subgoal):\n 1. cnt i = linorder_rank R (set xs) (xs ! i)", "."], ["proof (state)\nthis:\n  cnt i = linorder_rank R (set xs) (xs ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> cnt ?i = linorder_rank R (set xs) (xs ! ?i)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "from \"1.prems\""], ["proof (chain)\npicking this:\n  set xs \\<subseteq> A\n  distinct xs", "have \"bij_betw ((!) xs) {..<n} (set xs)\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> A\n  distinct xs\n\ngoal (1 subgoal):\n 1. bij_betw ((!) xs) {..<n} (set xs)", "by (intro bij_betw_byWitness[where f' = \"index xs\"]) (auto simp: n_def index_nth_id)"], ["proof (state)\nthis:\n  bij_betw ((!) xs) {..<n} (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "moreover"], ["proof (state)\nthis:\n  bij_betw ((!) xs) {..<n} (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "have \"bij_betw (linorder_rank R (set xs)) (set xs) {..<card (set xs)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R (set xs)) (set xs) {..<card (set xs)}", "using assms(1)"], ["proof (prove)\nusing this:\n  linorder_on A R\n\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R (set xs)) (set xs) {..<card (set xs)}", "by (rule bij_betw_linorder_rank) (insert \"1.prems\", auto)"], ["proof (state)\nthis:\n  bij_betw (linorder_rank R (set xs)) (set xs) {..<card (set xs)}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "ultimately"], ["proof (chain)\npicking this:\n  bij_betw ((!) xs) {..<n} (set xs)\n  bij_betw (linorder_rank R (set xs)) (set xs) {..<card (set xs)}", "have \"bij_betw (linorder_rank R (set xs) \\<circ> (\\<lambda>i. xs ! i)) {..<n} {..<card (set xs)}\""], ["proof (prove)\nusing this:\n  bij_betw ((!) xs) {..<n} (set xs)\n  bij_betw (linorder_rank R (set xs)) (set xs) {..<card (set xs)}\n\ngoal (1 subgoal):\n 1. bij_betw (linorder_rank R (set xs) \\<circ> (!) xs) {..<n}\n     {..<card (set xs)}", "by (rule bij_betw_trans)"], ["proof (state)\nthis:\n  bij_betw (linorder_rank R (set xs) \\<circ> (!) xs) {..<n}\n   {..<card (set xs)}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "hence bij: \"bij_betw (\\<lambda>i. linorder_rank R (set xs) (xs ! i)) {..<n} {..<n}\""], ["proof (prove)\nusing this:\n  bij_betw (linorder_rank R (set xs) \\<circ> (!) xs) {..<n}\n   {..<card (set xs)}\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>i. linorder_rank R (set xs) (xs ! i)) {..<n} {..<n}", "using \"1.prems\""], ["proof (prove)\nusing this:\n  bij_betw (linorder_rank R (set xs) \\<circ> (!) xs) {..<n}\n   {..<card (set xs)}\n  set xs \\<subseteq> A\n  distinct xs\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>i. linorder_rank R (set xs) (xs ! i)) {..<n} {..<n}", "by (simp add: n_def o_def distinct_card)"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>i. linorder_rank R (set xs) (xs ! i)) {..<n} {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   set ys \\<subseteq> A \\<longrightarrow>\n                   distinct ys \\<longrightarrow>\n                   map_pmf snd (rquicksort R ys) = rqs_cost (length ys);\n        set xs \\<subseteq> A; distinct xs\\<rbrakk>\n       \\<Longrightarrow> map_pmf snd (rquicksort R xs) =\n                         rqs_cost (length xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "hence \"n > 0\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < n", "by (simp add: n_def)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "hence [simp]: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by (intro notI) auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "from False"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"map_pmf snd (rquicksort R xs) = \n             pmf_of_set {..<length xs} \\<bind> \n               (\\<lambda>i. map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n                  (pair_pmf (map_pmf snd (rquicksort R [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R]))\n                            (map_pmf snd (rquicksort R [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<notin> R]))))\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R xs) =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n         (pair_pmf\n           (map_pmf snd\n             (rquicksort R\n               (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n                 (delete_index i xs))))\n           (map_pmf snd\n             (rquicksort R\n               (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n                 (delete_index i xs))))))", "by (subst rquicksort.simps)\n         (simp add: map_bind_pmf bind_map_pmf Let_def case_prod_unfold o_def pair_pmf_def)"], ["proof (state)\nthis:\n  map_pmf snd (rquicksort R xs) =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n       (pair_pmf\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n               (delete_index i xs))))\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n               (delete_index i xs))))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "also"], ["proof (state)\nthis:\n  map_pmf snd (rquicksort R xs) =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n       (pair_pmf\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n               (delete_index i xs))))\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n               (delete_index i xs))))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "have \"\\<dots> = pmf_of_set {..<length xs} \\<bind> \n                      (\\<lambda>i. map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n                         (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n         (pair_pmf\n           (map_pmf snd\n             (rquicksort R\n               (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n                 (delete_index i xs))))\n           (map_pmf snd\n             (rquicksort R\n               (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n                 (delete_index i xs)))))) =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n         (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i))))", "proof (intro bind_pmf_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> set_pmf (pmf_of_set {..<length xs})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "with \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  i \\<in> set_pmf (pmf_of_set {..<length xs})", "have i: \"i < length xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  i \\<in> set_pmf (pmf_of_set {..<length xs})\n\ngoal (1 subgoal):\n 1. i < length xs", "by auto"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "from i"], ["proof (chain)\npicking this:\n  i < length xs", "have \"map_pmf snd (rquicksort R [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<notin> R]) = \n                              rqs_cost (length [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<notin> R])\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. map_pmf snd\n     (rquicksort R\n       (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n    rqs_cost\n     (length\n       (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)))", "by (intro IH) \n           (auto intro!: le_less_trans[OF length_filter_le] simp: mset_filter \n                 intro: subset_mset.order.trans multiset_filter_subset diff_subset_eq_self)"], ["proof (state)\nthis:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost\n   (length\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "also"], ["proof (state)\nthis:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost\n   (length\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "have \"length [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<notin> R] = n - 1 - cnt i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)) =\n    n - 1 - cnt i", "unfolding n_def cnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)) =\n    length xs - 1 -\n    length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))", "using sum_length_filter_compl[of \"\\<lambda>y. (y, xs ! i) \\<in> R\" \"delete_index i xs\"] i"], ["proof (prove)\nusing this:\n  length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)) +\n  length (filter (\\<lambda>x. (x, xs ! i) \\<notin> R) (delete_index i xs)) =\n  length (delete_index i xs)\n  i < length xs\n\ngoal (1 subgoal):\n 1. length\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)) =\n    length xs - 1 -\n    length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))", "by simp"], ["proof (state)\nthis:\n  length (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs)) =\n  n - 1 - cnt i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "finally"], ["proof (chain)\npicking this:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost (n - 1 - cnt i)", "have \"map_pmf snd (rquicksort R [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<notin> R]) = \n                      rqs_cost (n - 1 - cnt i)\""], ["proof (prove)\nusing this:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost (n - 1 - cnt i)\n\ngoal (1 subgoal):\n 1. map_pmf snd\n     (rquicksort R\n       (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n    rqs_cost (n - 1 - cnt i)", "."], ["proof (state)\nthis:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost (n - 1 - cnt i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "moreover"], ["proof (state)\nthis:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost (n - 1 - cnt i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "have \"map_pmf snd (rquicksort R [y\\<leftarrow>delete_index i xs. (y, xs ! i) \\<in> R]) = \n                       rqs_cost (cnt i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf snd\n     (rquicksort R\n       (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))) =\n    rqs_cost (cnt i)", "unfolding cnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf snd\n     (rquicksort R\n       (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))) =\n    rqs_cost\n     (length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))", "using i"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. map_pmf snd\n     (rquicksort R\n       (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))) =\n    rqs_cost\n     (length (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs)))", "by (intro IH) \n           (auto intro!: le_less_trans[OF length_filter_le] simp: mset_filter \n                 intro: subset_mset.order.trans multiset_filter_subset diff_subset_eq_self)"], ["proof (state)\nthis:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))) =\n  rqs_cost (cnt i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set {..<length xs}) \\<Longrightarrow>\n       map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n        (pair_pmf\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<in> R)\n                (delete_index x xs))))\n          (map_pmf snd\n            (rquicksort R\n              (filter (\\<lambda>y. (y, xs ! x) \\<notin> R)\n                (delete_index x xs))))) =\n       map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n        (pair_pmf (rqs_cost (cnt x)) (rqs_cost (n - 1 - cnt x)))", "ultimately"], ["proof (chain)\npicking this:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost (n - 1 - cnt i)\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))) =\n  rqs_cost (cnt i)", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<notin> R) (delete_index i xs))) =\n  rqs_cost (n - 1 - cnt i)\n  map_pmf snd\n   (rquicksort R\n     (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))) =\n  rqs_cost (cnt i)\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n     (pair_pmf\n       (map_pmf snd\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))))\n       (map_pmf snd\n         (rquicksort R\n           (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n             (delete_index i xs))))) =\n    map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n     (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i)))", "by (simp only: n_def)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n   (pair_pmf\n     (map_pmf snd\n       (rquicksort R\n         (filter (\\<lambda>y. (y, xs ! i) \\<in> R) (delete_index i xs))))\n     (map_pmf snd\n       (rquicksort R\n         (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n           (delete_index i xs))))) =\n  map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n   (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n       (pair_pmf\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n               (delete_index i xs))))\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n               (delete_index i xs)))))) =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n       (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "also"], ["proof (state)\nthis:\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. length xs - 1 + fst z + snd z)\n       (pair_pmf\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<in> R)\n               (delete_index i xs))))\n         (map_pmf snd\n           (rquicksort R\n             (filter (\\<lambda>y. (y, xs ! i) \\<notin> R)\n               (delete_index i xs)))))) =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n       (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "have \"\\<dots> = map_pmf cnt (pmf_of_set {..<n}) \\<bind> \n          (\\<lambda>i. map_pmf (\\<lambda>z. n - 1 + fst z + snd z) (pair_pmf (rqs_cost i) (rqs_cost (n - 1 - i))))\"\n      (is \"_ = bind_pmf _ ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n         (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i)))) =\n    map_pmf cnt (pmf_of_set {..<n}) \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n         (pair_pmf (rqs_cost i) (rqs_cost (n - 1 - i))))", "by (simp add: bind_map_pmf n_def)"], ["proof (state)\nthis:\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n       (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i)))) =\n  map_pmf cnt (pmf_of_set {..<n}) \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n       (pair_pmf (rqs_cost i) (rqs_cost (n - 1 - i))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "also"], ["proof (state)\nthis:\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n       (pair_pmf (rqs_cost (cnt i)) (rqs_cost (n - 1 - cnt i)))) =\n  map_pmf cnt (pmf_of_set {..<n}) \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n       (pair_pmf (rqs_cost i) (rqs_cost (n - 1 - i))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "have \"map_pmf cnt (pmf_of_set {..<n}) = \n                 map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i)) (pmf_of_set {..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf cnt (pmf_of_set {..<n}) =\n    map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i))\n     (pmf_of_set {..<n})", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. map_pmf cnt (pmf_of_set {..<n}) =\n    map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i))\n     (pmf_of_set {..<n})", "by (intro map_pmf_cong refl, subst (asm) set_pmf_of_set) (auto simp: cnt_altdef)"], ["proof (state)\nthis:\n  map_pmf cnt (pmf_of_set {..<n}) =\n  map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i))\n   (pmf_of_set {..<n})\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "also"], ["proof (state)\nthis:\n  map_pmf cnt (pmf_of_set {..<n}) =\n  map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i))\n   (pmf_of_set {..<n})\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "from \\<open>n > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < n", "have \"\\<dots> = pmf_of_set {..<n}\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i))\n     (pmf_of_set {..<n}) =\n    pmf_of_set {..<n}", "by (intro map_pmf_of_set_bij_betw bij) auto"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i))\n   (pmf_of_set {..<n}) =\n  pmf_of_set {..<n}\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>i. linorder_rank R (set xs) (xs ! i))\n   (pmf_of_set {..<n}) =\n  pmf_of_set {..<n}\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "have \"pmf_of_set {..<n} \\<bind> ?f = rqs_cost n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set {..<n} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n         (pair_pmf (rqs_cost i) (rqs_cost (n - 1 - i)))) =\n    rqs_cost n", "by (cases n) (simp_all add: lessThan_Suc_atMost bind_map_pmf map_bind_pmf pair_pmf_def)"], ["proof (state)\nthis:\n  pmf_of_set {..<n} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>z. n - 1 + fst z + snd z)\n       (pair_pmf (rqs_cost i) (rqs_cost (n - 1 - i)))) =\n  rqs_cost n\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "finally"], ["proof (chain)\npicking this:\n  map_pmf snd (rquicksort R xs) = rqs_cost n", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf snd (rquicksort R xs) = rqs_cost n\n\ngoal (1 subgoal):\n 1. map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "by (simp add: n_def)"], ["proof (state)\nthis:\n  map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    map_pmf snd (rquicksort R xs) = rqs_cost (length xs)", "qed simp_all"], ["proof (state)\nthis:\n  map_pmf snd (rquicksort R xs) = rqs_cost (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Expected cost\\<close>"], ["", "text \\<open>\n  It is relatively straightforward to see that the following recursive function \n  (sometimes called the `QuickSort equation') describes the expectation of @{const rqs_cost}, \n  i.e. the expected number of comparisons of QuickSort when run on a list with distinct elements.\n\\<close>"], ["", "fun rqs_cost_exp :: \"nat \\<Rightarrow> real\" where\n  \"rqs_cost_exp 0 = 0\"\n| \"rqs_cost_exp (Suc n) = real n + (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)\""], ["", "lemmas rqs_cost_exp_0 = rqs_cost_exp.simps(1)"], ["", "lemmas rqs_cost_exp_Suc [simp del] = rqs_cost_exp.simps(2)"], ["", "lemma rqs_cost_exp_Suc_0 [simp]: \"rqs_cost_exp (Suc 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc 0) = 0", "by (simp add: rqs_cost_exp_Suc)"], ["", "text \\<open>\n  The following theorem shows that @{const rqs_cost_exp} is indeed the expectation of \n  @{const rqs_cost}.\n\\<close>"], ["", "theorem expectation_rqs_cost: \"measure_pmf.expectation (rqs_cost n) real = rqs_cost_exp n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs_cost n) real = rqs_cost_exp n", "proof (induction n rule: rqs_cost.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "case (2 n)"], ["proof (state)\nthis:\n  ?x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n  measure_pmf.expectation (rqs_cost ?x) real = rqs_cost_exp ?x\n  \\<lbrakk>?x \\<in> set_pmf (pmf_of_set {..n});\n   ?xa \\<in> set_pmf (rqs_cost ?x)\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - ?x)) real =\n                    rqs_cost_exp (n - ?x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "note IH = \"2.IH\""], ["proof (state)\nthis:\n  ?x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n  measure_pmf.expectation (rqs_cost ?x) real = rqs_cost_exp ?x\n  \\<lbrakk>?x \\<in> set_pmf (pmf_of_set {..n});\n   ?xa \\<in> set_pmf (rqs_cost ?x)\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - ?x)) real =\n                    rqs_cost_exp (n - ?x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "have \"measure_pmf.expectation (rqs_cost (Suc n)) real = \n          (\\<Sum>a\\<le>n. inverse (real (Suc n)) *\n              measure_pmf.expectation (rqs_cost a \\<bind> (\\<lambda>aa. rqs_cost (n - a) \\<bind>\n                 (\\<lambda>b. return_pmf (n + aa + b)))) real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs_cost (Suc n)) real =\n    (\\<Sum>a\\<le>n.\n        inverse (real (Suc n)) *\n        measure_pmf.expectation\n         (rqs_cost a \\<bind>\n          (\\<lambda>aa.\n              rqs_cost (n - a) \\<bind>\n              (\\<lambda>b. return_pmf (n + aa + b))))\n         real)", "unfolding rqs_cost.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (pmf_of_set {..n} \\<bind>\n      (\\<lambda>i.\n          rqs_cost i \\<bind>\n          (\\<lambda>a.\n              rqs_cost (n - i) \\<bind>\n              (\\<lambda>b. return_pmf (n + a + b)))))\n     real =\n    (\\<Sum>a\\<le>n.\n        inverse (real (Suc n)) *\n        measure_pmf.expectation\n         (rqs_cost a \\<bind>\n          (\\<lambda>aa.\n              rqs_cost (n - a) \\<bind>\n              (\\<lambda>b. return_pmf (n + aa + b))))\n         real)", "by (subst pmf_expectation_bind_pmf_of_set) auto"], ["proof (state)\nthis:\n  measure_pmf.expectation (rqs_cost (Suc n)) real =\n  (\\<Sum>a\\<le>n.\n      inverse (real (Suc n)) *\n      measure_pmf.expectation\n       (rqs_cost a \\<bind>\n        (\\<lambda>aa.\n            rqs_cost (n - a) \\<bind> (\\<lambda>b. return_pmf (n + aa + b))))\n       real)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (rqs_cost (Suc n)) real =\n  (\\<Sum>a\\<le>n.\n      inverse (real (Suc n)) *\n      measure_pmf.expectation\n       (rqs_cost a \\<bind>\n        (\\<lambda>aa.\n            rqs_cost (n - a) \\<bind> (\\<lambda>b. return_pmf (n + aa + b))))\n       real)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "have \"\\<dots> = (\\<Sum>i\\<le>n. inverse (real (Suc n)) * (real n + rqs_cost_exp i + rqs_cost_exp (n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<le>n.\n        inverse (real (Suc n)) *\n        measure_pmf.expectation\n         (rqs_cost a \\<bind>\n          (\\<lambda>aa.\n              rqs_cost (n - a) \\<bind>\n              (\\<lambda>b. return_pmf (n + aa + b))))\n         real) =\n    (\\<Sum>i\\<le>n.\n        inverse (real (Suc n)) *\n        (real n + rqs_cost_exp i + rqs_cost_exp (n - i)))", "proof (intro sum.cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> {..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "have \"rqs_cost i \\<bind> (\\<lambda>a. rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + a + b))) = \n            map_pmf (\\<lambda>(a,b). n + a + b) (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost i \\<bind>\n    (\\<lambda>a.\n        rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + a + b))) =\n    map_pmf (\\<lambda>(a, b). n + a + b)\n     (pair_pmf (rqs_cost i) (rqs_cost (n - i)))", "by (simp add: pair_pmf_def map_bind_pmf)"], ["proof (state)\nthis:\n  rqs_cost i \\<bind>\n  (\\<lambda>a.\n      rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + a + b))) =\n  map_pmf (\\<lambda>(a, b). n + a + b)\n   (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "also"], ["proof (state)\nthis:\n  rqs_cost i \\<bind>\n  (\\<lambda>a.\n      rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + a + b))) =\n  map_pmf (\\<lambda>(a, b). n + a + b)\n   (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "have \"measure_pmf.expectation \\<dots> real = \n                 measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i))) \n                   (\\<lambda>z. real n + (real (fst z) + real (snd z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (map_pmf (\\<lambda>(a, b). n + a + b)\n       (pair_pmf (rqs_cost i) (rqs_cost (n - i))))\n     real =\n    measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n     (\\<lambda>z. real n + (real (fst z) + real (snd z)))", "by (subst integral_map_pmf) (simp add: case_prod_unfold add_ac)"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>(a, b). n + a + b)\n     (pair_pmf (rqs_cost i) (rqs_cost (n - i))))\n   real =\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real n + (real (fst z) + real (snd z)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>(a, b). n + a + b)\n     (pair_pmf (rqs_cost i) (rqs_cost (n - i))))\n   real =\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real n + (real (fst z) + real (snd z)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "have \"\\<dots> = real n + measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n                      (\\<lambda>z. real (fst z) + real (snd z))\" (is \"_ = _ + ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n     (\\<lambda>z. real n + (real (fst z) + real (snd z))) =\n    real n +\n    measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n     (\\<lambda>z. real (fst z) + real (snd z))", "by (subst Bochner_Integration.integral_add) (auto intro!: integrable_measure_pmf_finite)"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real n + (real (fst z) + real (snd z))) =\n  real n +\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real (fst z) + real (snd z))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real n + (real (fst z) + real (snd z))) =\n  real n +\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real (fst z) + real (snd z))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "have \"?A = measure_pmf.expectation (map_pmf fst (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real +\n                    measure_pmf.expectation (map_pmf snd (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n     (\\<lambda>z. real (fst z) + real (snd z)) =\n    measure_pmf.expectation\n     (map_pmf fst (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real +\n    measure_pmf.expectation\n     (map_pmf snd (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real", "unfolding integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n     (\\<lambda>z. real (fst z) + real (snd z)) =\n    measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n     (\\<lambda>x. real (fst x)) +\n    measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n     (\\<lambda>x. real (snd x))", "by (subst Bochner_Integration.integral_add) (auto intro!: integrable_measure_pmf_finite)"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real (fst z) + real (snd z)) =\n  measure_pmf.expectation\n   (map_pmf fst (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real +\n  measure_pmf.expectation\n   (map_pmf snd (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf (rqs_cost i) (rqs_cost (n - i)))\n   (\\<lambda>z. real (fst z) + real (snd z)) =\n  measure_pmf.expectation\n   (map_pmf fst (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real +\n  measure_pmf.expectation\n   (map_pmf snd (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "have \"\\<dots> = measure_pmf.expectation (rqs_cost i) real +\n                    measure_pmf.expectation (rqs_cost (n - i)) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (map_pmf fst (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real +\n    measure_pmf.expectation\n     (map_pmf snd (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real =\n    measure_pmf.expectation (rqs_cost i) real +\n    measure_pmf.expectation (rqs_cost (n - i)) real", "unfolding map_fst_pair_pmf map_snd_pair_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs_cost i) real +\n    measure_pmf.expectation (rqs_cost (n - i)) real =\n    measure_pmf.expectation (rqs_cost i) real +\n    measure_pmf.expectation (rqs_cost (n - i)) real", ".."], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (map_pmf fst (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real +\n  measure_pmf.expectation\n   (map_pmf snd (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real =\n  measure_pmf.expectation (rqs_cost i) real +\n  measure_pmf.expectation (rqs_cost (n - i)) real\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (map_pmf fst (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real +\n  measure_pmf.expectation\n   (map_pmf snd (pair_pmf (rqs_cost i) (rqs_cost (n - i)))) real =\n  measure_pmf.expectation (rqs_cost i) real +\n  measure_pmf.expectation (rqs_cost (n - i)) real\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "from 1"], ["proof (chain)\npicking this:\n  i \\<in> {..n}", "have \"\\<dots> = rqs_cost_exp i + rqs_cost_exp (n - i)\""], ["proof (prove)\nusing this:\n  i \\<in> {..n}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs_cost i) real +\n    measure_pmf.expectation (rqs_cost (n - i)) real =\n    rqs_cost_exp i + rqs_cost_exp (n - i)", "by (simp_all add: IH)"], ["proof (state)\nthis:\n  measure_pmf.expectation (rqs_cost i) real +\n  measure_pmf.expectation (rqs_cost (n - i)) real =\n  rqs_cost_exp i + rqs_cost_exp (n - i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..n} \\<Longrightarrow>\n       inverse (real (Suc n)) *\n       measure_pmf.expectation\n        (rqs_cost x \\<bind>\n         (\\<lambda>aa.\n             rqs_cost (n - x) \\<bind>\n             (\\<lambda>b. return_pmf (n + aa + b))))\n        real =\n       inverse (real (Suc n)) *\n       (real n + rqs_cost_exp x + rqs_cost_exp (n - x))", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation\n   (rqs_cost i \\<bind>\n    (\\<lambda>a.\n        rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + a + b))))\n   real =\n  real n + (rqs_cost_exp i + rqs_cost_exp (n - i))", "show ?case"], ["proof (prove)\nusing this:\n  measure_pmf.expectation\n   (rqs_cost i \\<bind>\n    (\\<lambda>a.\n        rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + a + b))))\n   real =\n  real n + (rqs_cost_exp i + rqs_cost_exp (n - i))\n\ngoal (1 subgoal):\n 1. inverse (real (Suc n)) *\n    measure_pmf.expectation\n     (rqs_cost i \\<bind>\n      (\\<lambda>aa.\n          rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + aa + b))))\n     real =\n    inverse (real (Suc n)) *\n    (real n + rqs_cost_exp i + rqs_cost_exp (n - i))", "by simp"], ["proof (state)\nthis:\n  inverse (real (Suc n)) *\n  measure_pmf.expectation\n   (rqs_cost i \\<bind>\n    (\\<lambda>aa.\n        rqs_cost (n - i) \\<bind> (\\<lambda>b. return_pmf (n + aa + b))))\n   real =\n  inverse (real (Suc n)) * (real n + rqs_cost_exp i + rqs_cost_exp (n - i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<le>n.\n      inverse (real (Suc n)) *\n      measure_pmf.expectation\n       (rqs_cost a \\<bind>\n        (\\<lambda>aa.\n            rqs_cost (n - a) \\<bind> (\\<lambda>b. return_pmf (n + aa + b))))\n       real) =\n  (\\<Sum>i\\<le>n.\n      inverse (real (Suc n)) *\n      (real n + rqs_cost_exp i + rqs_cost_exp (n - i)))\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<le>n.\n      inverse (real (Suc n)) *\n      measure_pmf.expectation\n       (rqs_cost a \\<bind>\n        (\\<lambda>aa.\n            rqs_cost (n - a) \\<bind> (\\<lambda>b. return_pmf (n + aa + b))))\n       real) =\n  (\\<Sum>i\\<le>n.\n      inverse (real (Suc n)) *\n      (real n + rqs_cost_exp i + rqs_cost_exp (n - i)))\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "have \"\\<dots> = (\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) + \n                    (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        inverse (real (Suc n)) *\n        (real n + rqs_cost_exp i + rqs_cost_exp (n - i))) =\n    (\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) +\n    (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)", "by (simp add: sum.distrib field_simps sum_distrib_left sum_distrib_right \n          sum_divide_distrib [symmetric] del: of_nat_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      inverse (real (Suc n)) *\n      (real n + rqs_cost_exp i + rqs_cost_exp (n - i))) =\n  (\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) +\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      inverse (real (Suc n)) *\n      (real n + rqs_cost_exp i + rqs_cost_exp (n - i))) =\n  (\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) +\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "have \"(\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) = real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) = real n", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) = real n\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. inverse (real (Suc n)) * real n) = real n\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "have \"\\<dots> + (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n) = rqs_cost_exp (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n +\n    (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n) =\n    rqs_cost_exp (Suc n)", "by (simp add: rqs_cost_exp_Suc)"], ["proof (state)\nthis:\n  real n +\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n) =\n  rqs_cost_exp (Suc n)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0\n 2. \\<And>n.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set_pmf (pmf_of_set {..n}) \\<Longrightarrow>\n                   measure_pmf.expectation (rqs_cost x) real =\n                   rqs_cost_exp x;\n        \\<And>x xa.\n           \\<lbrakk>x \\<in> set_pmf (pmf_of_set {..n});\n            xa \\<in> set_pmf (rqs_cost x)\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation (rqs_cost (n - x))\n                              real =\n                             rqs_cost_exp (n - x)\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs_cost (Suc n)) real =\n                         rqs_cost_exp (Suc n)", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (rqs_cost (Suc n)) real = rqs_cost_exp (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (rqs_cost (Suc n)) real = rqs_cost_exp (Suc n)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs_cost (Suc n)) real = rqs_cost_exp (Suc n)", "."], ["proof (state)\nthis:\n  measure_pmf.expectation (rqs_cost (Suc n)) real = rqs_cost_exp (Suc n)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs_cost 0) real = rqs_cost_exp 0", "qed simp_all"], ["", "text \\<open>\n  We will now obtain a closed-form solution for @{const rqs_cost_exp}. First of all, we can \n  reindex the right-most sum in the recursion step and obtain:\n\\<close>"], ["", "lemma rqs_cost_exp_Suc':\n  \"rqs_cost_exp (Suc n) = real n + 2 / real (Suc n) * (\\<Sum>i\\<le>n. rqs_cost_exp i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "have \"rqs_cost_exp (Suc n) = real n + (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n +\n    (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)", "by (rule rqs_cost_exp_Suc)"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc n) =\n  real n +\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "also"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc n) =\n  real n +\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) / real (Suc n)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "have \"(\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) = (\\<Sum>i\\<le>n. rqs_cost_exp i) + (\\<Sum>i\\<le>n. rqs_cost_exp (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) =\n    sum rqs_cost_exp {..n} + (\\<Sum>i\\<le>n. rqs_cost_exp (n - i))", "by (simp add: sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) =\n  sum rqs_cost_exp {..n} + (\\<Sum>i\\<le>n. rqs_cost_exp (n - i))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) =\n  sum rqs_cost_exp {..n} + (\\<Sum>i\\<le>n. rqs_cost_exp (n - i))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "have \"(\\<Sum>i\\<le>n. rqs_cost_exp (n - i)) = (\\<Sum>i\\<le>n. rqs_cost_exp i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. rqs_cost_exp (n - i)) = sum rqs_cost_exp {..n}", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>i. n - i\" \"\\<lambda>i. n - i\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. rqs_cost_exp (n - i)) = sum rqs_cost_exp {..n}\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. rqs_cost_exp (n - i)) = sum rqs_cost_exp {..n}\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "have \"\\<dots> + \\<dots> = 2 * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum rqs_cost_exp {..n} + sum rqs_cost_exp {..n} =\n    2 * sum rqs_cost_exp {..n}", "by simp"], ["proof (state)\nthis:\n  sum rqs_cost_exp {..n} + sum rqs_cost_exp {..n} =\n  2 * sum rqs_cost_exp {..n}\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "also"], ["proof (state)\nthis:\n  sum rqs_cost_exp {..n} + sum rqs_cost_exp {..n} =\n  2 * sum rqs_cost_exp {..n}\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "have \"\\<dots> / real (Suc n) = 2 / real (Suc n) * (\\<Sum>i\\<le>n. rqs_cost_exp i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * sum rqs_cost_exp {..n} / real (Suc n) =\n    2 / real (Suc n) * sum rqs_cost_exp {..n}", "by simp"], ["proof (state)\nthis:\n  2 * sum rqs_cost_exp {..n} / real (Suc n) =\n  2 / real (Suc n) * sum rqs_cost_exp {..n}\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "finally"], ["proof (chain)\npicking this:\n  rqs_cost_exp (Suc n) = real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  rqs_cost_exp (Suc n) = real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) =\n    real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}", "."], ["proof (state)\nthis:\n  rqs_cost_exp (Suc n) = real n + 2 / real (Suc n) * sum rqs_cost_exp {..n}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we can apply some standard techniques to transform this equation into a simple\n  linear recurrence, which we can then solve easily in terms of harmonic numbers:\n\\<close>"], ["", "theorem rqs_cost_exp_eq [code]: \"rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "define F where \"F = (\\<lambda>n. rqs_cost_exp n / (real n + 1))\""], ["proof (state)\nthis:\n  F = (\\<lambda>n. rqs_cost_exp n / (real n + 1))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have [simp]: \"F 0 = 0\" \"F (Suc 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F 0 = 0 &&& F (Suc 0) = 0", "by (simp_all add: F_def)"], ["proof (state)\nthis:\n  F 0 = 0\n  F (Suc 0) = 0\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have F_Suc: \"F (Suc m) = F m + real (2*m) / (real ((m+1)*(m+2)))\" if \"m > 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "proof (cases m)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "case (Suc n)"], ["proof (state)\nthis:\n  m = Suc n\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "have A: \"rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) = \n            real ((n+1)*(n+2)) + 2 * (\\<Sum>i\\<le>n. rqs_cost_exp i) + 2 * rqs_cost_exp (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) =\n    real ((n + 1) * (n + 2)) + 2 * sum rqs_cost_exp {..n} +\n    2 * rqs_cost_exp (Suc n)", "by (subst rqs_cost_exp_Suc') (simp_all add: field_simps)"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) =\n  real ((n + 1) * (n + 2)) + 2 * sum rqs_cost_exp {..n} +\n  2 * rqs_cost_exp (Suc n)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "have B: \"rqs_cost_exp (Suc n) * real (Suc n) = real (n*(n+1)) + 2 * (\\<Sum>i\\<le>n. rqs_cost_exp i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc n) * real (Suc n) =\n    real (n * (n + 1)) + 2 * sum rqs_cost_exp {..n}", "by (subst rqs_cost_exp_Suc') (simp_all add: field_simps)"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc n) * real (Suc n) =\n  real (n * (n + 1)) + 2 * sum rqs_cost_exp {..n}\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "have \"rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) - rqs_cost_exp (Suc n) * real (Suc n) =\n            real ((n+1)*(n+2)) - real (n*(n+1)) + 2 * rqs_cost_exp (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) -\n    rqs_cost_exp (Suc n) * real (Suc n) =\n    real ((n + 1) * (n + 2)) - real (n * (n + 1)) + 2 * rqs_cost_exp (Suc n)", "by (subst A, subst B) simp_all"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) -\n  rqs_cost_exp (Suc n) * real (Suc n) =\n  real ((n + 1) * (n + 2)) - real (n * (n + 1)) + 2 * rqs_cost_exp (Suc n)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "also"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) -\n  rqs_cost_exp (Suc n) * real (Suc n) =\n  real ((n + 1) * (n + 2)) - real (n * (n + 1)) + 2 * rqs_cost_exp (Suc n)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "have \"real ((n+1)*(n+2)) - real (n*(n+1)) = real (2*(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real ((n + 1) * (n + 2)) - real (n * (n + 1)) = real (2 * (n + 1))", "by simp"], ["proof (state)\nthis:\n  real ((n + 1) * (n + 2)) - real (n * (n + 1)) = real (2 * (n + 1))\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "finally"], ["proof (chain)\npicking this:\n  rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) -\n  rqs_cost_exp (Suc n) * real (Suc n) =\n  real (2 * (n + 1)) + 2 * rqs_cost_exp (Suc n)", "have \"rqs_cost_exp (Suc (Suc n)) * real (n+2) = rqs_cost_exp (Suc n) * real (n+3) + real (2*(n+1))\""], ["proof (prove)\nusing this:\n  rqs_cost_exp (Suc (Suc n)) * real (Suc (Suc n)) -\n  rqs_cost_exp (Suc n) * real (Suc n) =\n  real (2 * (n + 1)) + 2 * rqs_cost_exp (Suc n)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc (Suc n)) * real (n + 2) =\n    rqs_cost_exp (Suc n) * real (n + 3) + real (2 * (n + 1))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc (Suc n)) * real (n + 2) =\n  rqs_cost_exp (Suc n) * real (n + 3) + real (2 * (n + 1))\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "hence \"rqs_cost_exp (Suc (Suc n)) / real (n+3) = \n             rqs_cost_exp (Suc n) / real (n+2) + real (2*(n+1)) / (real (n+2)*real (n+3))\""], ["proof (prove)\nusing this:\n  rqs_cost_exp (Suc (Suc n)) * real (n + 2) =\n  rqs_cost_exp (Suc n) * real (n + 3) + real (2 * (n + 1))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp (Suc (Suc n)) / real (n + 3) =\n    rqs_cost_exp (Suc n) / real (n + 2) +\n    real (2 * (n + 1)) / (real (n + 2) * real (n + 3))", "by (simp add: divide_simps del: of_nat_Suc of_nat_add)"], ["proof (state)\nthis:\n  rqs_cost_exp (Suc (Suc n)) / real (n + 3) =\n  rqs_cost_exp (Suc n) / real (n + 2) +\n  real (2 * (n + 1)) / (real (n + 2) * real (n + 3))\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n 2. \\<And>nat.\n       m = Suc nat \\<Longrightarrow>\n       F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  rqs_cost_exp (Suc (Suc n)) / real (n + 3) =\n  rqs_cost_exp (Suc n) / real (n + 2) +\n  real (2 * (n + 1)) / (real (n + 2) * real (n + 3))\n\ngoal (1 subgoal):\n 1. F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "by (simp add: F_def algebra_simps Suc)"], ["proof (state)\nthis:\n  F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))\n\ngoal (1 subgoal):\n 1. m = 0 \\<Longrightarrow>\n    F (Suc m) = F m + real (2 * m) / real ((m + 1) * (m + 2))", "qed simp_all"], ["proof (state)\nthis:\n  0 < ?m \\<Longrightarrow>\n  F (Suc ?m) = F ?m + real (2 * ?m) / real ((?m + 1) * (?m + 2))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have F_eq: \"F n = 2 * (\\<Sum>k=1..n. real (k - 1) / real (k * (k + 1)))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))", "proof (cases \"n \\<ge> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 \\<le> n \\<Longrightarrow>\n    F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))\n 2. \\<not> 1 \\<le> n \\<Longrightarrow>\n    F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))", "case True"], ["proof (state)\nthis:\n  1 \\<le> n\n\ngoal (2 subgoals):\n 1. 1 \\<le> n \\<Longrightarrow>\n    F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))\n 2. \\<not> 1 \\<le> n \\<Longrightarrow>\n    F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))", "by (induction n rule: dec_induct) (simp_all add: F_Suc algebra_simps)"], ["proof (state)\nthis:\n  F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> n \\<Longrightarrow>\n    F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))", "qed (simp_all add: not_le)"], ["proof (state)\nthis:\n  F ?n = 2 * (\\<Sum>k = 1..?n. real (k - 1) / real (k * (k + 1)))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have \"F n = 2 * (\\<Sum>k=1..n. real (k - 1) / real (k * (k + 1)))\" (is \"_ = 2 * ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))", "by (fact F_eq)"], ["proof (state)\nthis:\n  F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "also"], ["proof (state)\nthis:\n  F n = 2 * (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1)))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have \"?S = (\\<Sum>k=1..n. 2 / real (Suc k) - 1 / real k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1))) =\n    (\\<Sum>k = 1..n. 2 / real (Suc k) - 1 / real k)", "by (intro sum.cong) (simp_all add: field_simps of_nat_diff)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1))) =\n  (\\<Sum>k = 1..n. 2 / real (Suc k) - 1 / real k)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. real (k - 1) / real (k * (k + 1))) =\n  (\\<Sum>k = 1..n. 2 / real (Suc k) - 1 / real k)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have \"\\<dots> = 2 * (\\<Sum>k=1..n. inverse (real (Suc k))) - harm n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. 2 / real (Suc k) - 1 / real k) =\n    2 * (\\<Sum>k = 1..n. inverse (real (Suc k))) - harm n", "by (subst sum_subtractf) (simp add: harm_def sum.distrib sum_distrib_left divide_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. 2 / real (Suc k) - 1 / real k) =\n  2 * (\\<Sum>k = 1..n. inverse (real (Suc k))) - harm n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. 2 / real (Suc k) - 1 / real k) =\n  2 * (\\<Sum>k = 1..n. inverse (real (Suc k))) - harm n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have \"(\\<Sum>k=1..n. inverse (real (Suc k))) = (\\<Sum>k=Suc 1..Suc n. inverse (real k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. inverse (real (Suc k))) =\n    (\\<Sum>k = Suc 1..Suc n. inverse (real k))", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>x. x - 1\" Suc]) auto"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. inverse (real (Suc k))) =\n  (\\<Sum>k = Suc 1..Suc n. inverse (real k))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. inverse (real (Suc k))) =\n  (\\<Sum>k = Suc 1..Suc n. inverse (real k))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have \"\\<dots> = harm (Suc n) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = Suc 1..Suc n. inverse (real k)) = harm (Suc n) - 1", "unfolding harm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = Suc 1..Suc n. inverse (real k)) =\n    (\\<Sum>k = 1..Suc n. inverse (real k)) - 1", "by (subst (2) sum.atLeast_Suc_atMost) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>k = Suc 1..Suc n. inverse (real k)) = harm (Suc n) - 1\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "finally"], ["proof (chain)\npicking this:\n  F n = 2 * (2 * (harm (Suc n) - 1) - harm n)", "have \"F n = 2 * harm n + 4 * (1 / (n + 1) - 1)\""], ["proof (prove)\nusing this:\n  F n = 2 * (2 * (harm (Suc n) - 1) - harm n)\n\ngoal (1 subgoal):\n 1. F n = 2 * harm n + 4 * (1 / real (n + 1) - 1)", "by (simp add: harm_Suc field_simps)"], ["proof (state)\nthis:\n  F n = 2 * harm n + 4 * (1 / real (n + 1) - 1)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "also"], ["proof (state)\nthis:\n  F n = 2 * harm n + 4 * (1 / real (n + 1) - 1)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have \"\\<dots> * real (n + 1) = 2 * real (n + 1) * harm n - 4 * real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * harm n + 4 * (1 / real (n + 1) - 1)) * real (n + 1) =\n    2 * real (n + 1) * harm n - 4 * real n", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (2 * harm n + 4 * (1 / real (n + 1) - 1)) * real (n + 1) =\n  2 * real (n + 1) * harm n - 4 * real n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "also"], ["proof (state)\nthis:\n  (2 * harm n + 4 * (1 / real (n + 1) - 1)) * real (n + 1) =\n  2 * real (n + 1) * harm n - 4 * real n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "have \"F n * real (n + 1) = rqs_cost_exp n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F n * real (n + 1) = rqs_cost_exp n", "by (simp add: F_def add_ac)"], ["proof (state)\nthis:\n  F n * real (n + 1) = rqs_cost_exp n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "finally"], ["proof (chain)\npicking this:\n  rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "show ?thesis"], ["proof (prove)\nusing this:\n  rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n", "."], ["proof (state)\nthis:\n  rqs_cost_exp n = 2 * real (n + 1) * harm n - 4 * real n\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO Move *)"], ["", "lemma asymp_equiv_harm [asymp_equiv_intros]: \"harm \\<sim>[at_top] (\\<lambda>n. ln (real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "have \"(\\<lambda>n. harm n - ln (real n)) \\<in> O(\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. harm n - ln (real n)) \\<in> O(\\<lambda>_. 1)", "using euler_mascheroni_LIMSEQ"], ["proof (prove)\nusing this:\n  (\\<lambda>n. harm n - ln (real n))\n  \\<longlonglongrightarrow> euler_mascheroni\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. harm n - ln (real n)) \\<in> O(\\<lambda>_. 1)", "by (intro bigoI_tendsto[where c = euler_mascheroni]) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n. harm n - ln (real n)) \\<in> O(\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. harm n - ln (real n)) \\<in> O(\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "have \"(\\<lambda>_. 1) \\<in> o(\\<lambda>n. ln (real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. 1) \\<in> o(\\<lambda>n. ln (real n))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>_. 1) \\<in> o(\\<lambda>n. ln (real n))\n\ngoal (1 subgoal):\n 1. harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. harm n - ln (real n)) \\<in> o(\\<lambda>n. ln (real n))", "have \"(\\<lambda>n. ln (real n) + (harm n - ln (real n))) \\<sim>[at_top] (\\<lambda>n. ln (real n))\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. harm n - ln (real n)) \\<in> o(\\<lambda>n. ln (real n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ln (real n) +\n        (harm n -\n         ln (real n))) \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "by (subst asymp_equiv_add_right) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      ln (real n) +\n      (harm n - ln (real n))) \\<sim>[sequentially] (\\<lambda>n. ln (real n))\n\ngoal (1 subgoal):\n 1. harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      ln (real n) +\n      (harm n - ln (real n))) \\<sim>[sequentially] (\\<lambda>n. ln (real n))\n\ngoal (1 subgoal):\n 1. harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))", "by simp"], ["proof (state)\nthis:\n  harm \\<sim>[sequentially] (\\<lambda>n. ln (real n))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary rqs_cost_exp_asymp_equiv: \"rqs_cost_exp \\<sim>[at_top] (\\<lambda>n. 2 * n * ln n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "have \"rqs_cost_exp = (\\<lambda>n. 2 * real (n + 1) * harm n - 4 * real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp = (\\<lambda>n. 2 * real (n + 1) * harm n - 4 * real n)", "using rqs_cost_exp_eq"], ["proof (prove)\nusing this:\n  rqs_cost_exp ?n = 2 * real (?n + 1) * harm ?n - 4 * real ?n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp = (\\<lambda>n. 2 * real (n + 1) * harm n - 4 * real n)", ".."], ["proof (state)\nthis:\n  rqs_cost_exp = (\\<lambda>n. 2 * real (n + 1) * harm n - 4 * real n)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "also"], ["proof (state)\nthis:\n  rqs_cost_exp = (\\<lambda>n. 2 * real (n + 1) * harm n - 4 * real n)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "have \"\\<dots> = (\\<lambda>n. 2 * real n * harm n + (2 * harm n - 4 * real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 2 * real (n + 1) * harm n - 4 * real n) =\n    (\\<lambda>n. 2 * real n * harm n + (2 * harm n - 4 * real n))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<lambda>n. 2 * real (n + 1) * harm n - 4 * real n) =\n  (\\<lambda>n. 2 * real n * harm n + (2 * harm n - 4 * real n))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "finally"], ["proof (chain)\npicking this:\n  rqs_cost_exp =\n  (\\<lambda>n. 2 * real n * harm n + (2 * harm n - 4 * real n))", "have \"rqs_cost_exp \\<sim>[at_top] \\<dots>\""], ["proof (prove)\nusing this:\n  rqs_cost_exp =\n  (\\<lambda>n. 2 * real n * harm n + (2 * harm n - 4 * real n))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>n.\n    2 * real n * harm n + (2 * harm n - 4 * real n))", "by simp"], ["proof (state)\nthis:\n  rqs_cost_exp \\<sim>[sequentially] (\\<lambda>n.\n  2 * real n * harm n + (2 * harm n - 4 * real n))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "also"], ["proof (state)\nthis:\n  rqs_cost_exp \\<sim>[sequentially] (\\<lambda>n.\n  2 * real n * harm n + (2 * harm n - 4 * real n))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "have \"\\<dots> \\<sim>[at_top] (\\<lambda>n. 2 * real n * harm n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        2 * real n * harm n +\n        (2 * harm n -\n         4 * real n)) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)", "proof (subst asymp_equiv_add_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. 2 * harm n - 4 * real n)\n    \\<in> o(\\<lambda>n. 2 * real n * harm n)\n 2. (\\<lambda>n.\n        2 * real n *\n        harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)", "have \"(\\<lambda>x. 1 * harm x) \\<in> o(\\<lambda>x. real x * harm x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 1 * harm x) \\<in> o(\\<lambda>x. real x * harm x)", "by (intro landau_o.small_big_mult smallo_real_nat_transfer) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>x. 1 * harm x) \\<in> o(\\<lambda>x. real x * harm x)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. 2 * harm n - 4 * real n)\n    \\<in> o(\\<lambda>n. 2 * real n * harm n)\n 2. (\\<lambda>n.\n        2 * real n *\n        harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>x. 1 * harm x) \\<in> o(\\<lambda>x. real x * harm x)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. 2 * harm n - 4 * real n)\n    \\<in> o(\\<lambda>n. 2 * real n * harm n)\n 2. (\\<lambda>n.\n        2 * real n *\n        harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)", "have \"harm \\<in> \\<omega>(\\<lambda>_. 1 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harm \\<in> \\<omega>(\\<lambda>_. 1)", "by (intro smallomegaI_filterlim_at_top_norm) (auto simp: harm_at_top)"], ["proof (state)\nthis:\n  harm \\<in> \\<omega>(\\<lambda>_. 1)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. 2 * harm n - 4 * real n)\n    \\<in> o(\\<lambda>n. 2 * real n * harm n)\n 2. (\\<lambda>n.\n        2 * real n *\n        harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)", "hence \"(\\<lambda>x. real x * 1) \\<in> o(\\<lambda>x. real x * harm x)\""], ["proof (prove)\nusing this:\n  harm \\<in> \\<omega>(\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. real x * 1) \\<in> o(\\<lambda>x. real x * harm x)", "by (intro landau_o.big_small_mult) (simp_all add: smallomega_iff_smallo)"], ["proof (state)\nthis:\n  (\\<lambda>x. real x * 1) \\<in> o(\\<lambda>x. real x * harm x)\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. 2 * harm n - 4 * real n)\n    \\<in> o(\\<lambda>n. 2 * real n * harm n)\n 2. (\\<lambda>n.\n        2 * real n *\n        harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>x. 1 * harm x) \\<in> o(\\<lambda>x. real x * harm x)\n  (\\<lambda>x. real x * 1) \\<in> o(\\<lambda>x. real x * harm x)", "show \"(\\<lambda>n. 2 * harm n - 4 * real n) \\<in> o(\\<lambda>n. 2 * real n * harm n)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. 1 * harm x) \\<in> o(\\<lambda>x. real x * harm x)\n  (\\<lambda>x. real x * 1) \\<in> o(\\<lambda>x. real x * harm x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 2 * harm n - 4 * real n)\n    \\<in> o(\\<lambda>n. 2 * real n * harm n)", "by (intro sum_in_smallo) simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n. 2 * harm n - 4 * real n)\n  \\<in> o(\\<lambda>n. 2 * real n * harm n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        2 * real n *\n        harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)", "qed simp_all"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      2 * real n * harm n +\n      (2 * harm n -\n       4 * real n)) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      2 * real n * harm n +\n      (2 * harm n -\n       4 * real n)) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * harm n)\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "have \"\\<dots> \\<sim>[at_top] (\\<lambda>n. 2 * real n * ln (real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        2 * real n *\n        harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * ln (real n))", "by (intro asymp_equiv_intros)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      2 * real n *\n      harm n) \\<sim>[sequentially] (\\<lambda>n. 2 * real n * ln (real n))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>c d.\n              c \\<sim>[sequentially] d \\<Longrightarrow>\n              c \\<sim>[sequentially] d;\n   \\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      c \\<sim>[sequentially] d\\<rbrakk>\n  \\<Longrightarrow> rqs_cost_exp \\<sim>[sequentially] (\\<lambda>a.\n                    2 * real a * ln (real a))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>c d.\n              c \\<sim>[sequentially] d \\<Longrightarrow>\n              c \\<sim>[sequentially] d;\n   \\<And>c d.\n      c \\<sim>[sequentially] d \\<Longrightarrow>\n      c \\<sim>[sequentially] d\\<rbrakk>\n  \\<Longrightarrow> rqs_cost_exp \\<sim>[sequentially] (\\<lambda>a.\n                    2 * real a * ln (real a))\n\ngoal (1 subgoal):\n 1. rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))", "."], ["proof (state)\nthis:\n  rqs_cost_exp \\<sim>[sequentially] (\\<lambda>x. 2 * real x * ln (real x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma harm_mono: \"m \\<le> n \\<Longrightarrow> harm m \\<le> (harm n :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> harm m \\<le> harm n", "unfolding harm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow>\n    (\\<Sum>k = 1..m. inverse (real k))\n    \\<le> (\\<Sum>k = 1..n. inverse (real k))", "by (intro sum_mono2) auto"], ["", "lemma harm_Suc_0 [simp]: \"harm (Suc 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harm (Suc 0) = (1::'a)", "by (simp add: harm_def)"], ["", "lemma harm_ge_1: \"n > 0 \\<Longrightarrow> harm n \\<ge> (1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> 1 \\<le> harm n", "using harm_mono[of 1 n]"], ["proof (prove)\nusing this:\n  1 \\<le> n \\<Longrightarrow> harm 1 \\<le> harm n\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> 1 \\<le> harm n", "by simp"], ["", "lemma mono_rqs_cost_exp: \"mono rqs_cost_exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incseq rqs_cost_exp", "proof (rule incseq_SucI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "show \"rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n 2. n \\<noteq> 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n 2. n \\<noteq> 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "have \"0 < (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)", "by simp"], ["proof (state)\nthis:\n  0 < (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n 2. n \\<noteq> 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "also"], ["proof (state)\nthis:\n  0 < (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n 2. n \\<noteq> 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "have \"\\<dots> \\<le> (harm n * 2 * (real n + 1) - 2 * real n) / (real n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n    \\<le> (harm n * 2 * (real n + 1) - 2 * real n) / (real n + 1)", "using False"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n    \\<le> (harm n * 2 * (real n + 1) - 2 * real n) / (real n + 1)", "by (intro divide_right_mono diff_right_mono mult_right_mono) (auto simp: harm_ge_1)"], ["proof (state)\nthis:\n  (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n  \\<le> (harm n * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n 2. n \\<noteq> 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "also"], ["proof (state)\nthis:\n  (1 * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n  \\<le> (harm n * 2 * (real n + 1) - 2 * real n) / (real n + 1)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n 2. n \\<noteq> 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "have \"\\<dots> = rqs_cost_exp (Suc n) - rqs_cost_exp n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (harm n * 2 * (real n + 1) - 2 * real n) / (real n + 1) =\n    rqs_cost_exp (Suc n) - rqs_cost_exp n", "by (simp add: rqs_cost_exp_eq harm_Suc field_simps)"], ["proof (state)\nthis:\n  (harm n * 2 * (real n + 1) - 2 * real n) / (real n + 1) =\n  rqs_cost_exp (Suc n) - rqs_cost_exp n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n 2. n \\<noteq> 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "finally"], ["proof (chain)\npicking this:\n  0 < rqs_cost_exp (Suc n) - rqs_cost_exp n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < rqs_cost_exp (Suc n) - rqs_cost_exp n\n\ngoal (1 subgoal):\n 1. rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "by simp"], ["proof (state)\nthis:\n  rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)", "qed auto"], ["proof (state)\nthis:\n  rqs_cost_exp n \\<le> rqs_cost_exp (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rqs_cost_exp_leI: \"m \\<le> n \\<Longrightarrow> rqs_cost_exp m \\<le> rqs_cost_exp n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> rqs_cost_exp m \\<le> rqs_cost_exp n", "using mono_rqs_cost_exp"], ["proof (prove)\nusing this:\n  incseq rqs_cost_exp\n\ngoal (1 subgoal):\n 1. m \\<le> n \\<Longrightarrow> rqs_cost_exp m \\<le> rqs_cost_exp n", "by (simp add: mono_def)"], ["", "subsection \\<open>Version for lists with repeated elements\\<close>"], ["", "definition threeway_partition where\n  \"threeway_partition x R xs = \n     (filter (\\<lambda>y. (y,x) \\<in> R \\<and> (x,y) \\<notin> R) xs, \n      filter (\\<lambda>y. (x,y) \\<in> R \\<and> (y,x) \\<in> R) xs, \n      filter (\\<lambda>y. (x,y) \\<in> R \\<and> (y,x) \\<notin> R) xs)\""], ["", "text \\<open>\n  The following version of randomised Quicksort uses a three-way partitioning function\n  in order to also achieve expected logarithmic running time on lists with repeated elements.\n\\<close>"], ["", "function rquicksort' :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> ('a list \\<times> nat) pmf\" where\n  \"rquicksort' R xs = \n     (if xs = [] then \n        return_pmf ([], 0)\n      else\n        do {\n          i \\<leftarrow> pmf_of_set {..<length xs};\n          let x = xs ! i;\n          case threeway_partition x R (delete_index i xs) of\n            (ls, es, rs) \\<Rightarrow> do {\n              (ls, n1) \\<leftarrow> rquicksort' R ls;\n              (rs, n2) \\<leftarrow> rquicksort' R rs;\n              return_pmf (ls @ x # es @ rs, length xs - 1 + n1 + n2)\n            }\n        })\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>R xs. x = (R, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>R xs Ra xsa.\n       (R, xs) = (Ra, xsa) \\<Longrightarrow>\n       (if xs = [] then return_pmf ([], 0)\n        else pmf_of_set {..<length xs} \\<bind>\n             (\\<lambda>i.\n                 let x = xs ! i\n                 in case threeway_partition x R (delete_index i xs) of\n                    (ls, es, rs) \\<Rightarrow>\n                      rquicksort'_sumC (R, ls) \\<bind>\n                      (\\<lambda>(ls, n1).\n                          rquicksort'_sumC (R, rs) \\<bind>\n                          (\\<lambda>(rs, n2).\n                              return_pmf\n                               (ls @ x # es @ rs,\n                                length xs - 1 + n1 + n2))))) =\n       (if xsa = [] then return_pmf ([], 0)\n        else pmf_of_set {..<length xsa} \\<bind>\n             (\\<lambda>i.\n                 let x = xsa ! i\n                 in case threeway_partition x Ra (delete_index i xsa) of\n                    (ls, es, rs) \\<Rightarrow>\n                      rquicksort'_sumC (Ra, ls) \\<bind>\n                      (\\<lambda>(ls, n1).\n                          rquicksort'_sumC (Ra, rs) \\<bind>\n                          (\\<lambda>(rs, n2).\n                              return_pmf\n                               (ls @ x # es @ rs,\n                                length xsa - 1 + n1 + n2)))))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All rquicksort'_dom", "proof (relation \"Wellfounded.measure (length \\<circ> snd)\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. wf (Wellfounded.measure (length \\<circ> snd))\n 2. \\<And>R xs x xa xb y xc ya.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x; (xb, y) = threeway_partition xa R (delete_index x xs);\n        (xc, ya) = y\\<rbrakk>\n       \\<Longrightarrow> ((R, xb), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)\n 3. \\<And>R xs x xa xb y xc ya xd xe yb.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x; (xb, y) = threeway_partition xa R (delete_index x xs);\n        (xc, ya) = y; xd \\<in> set_pmf (rquicksort' R xb); (xe, yb) = xd;\n        rquicksort'_dom (R, xb)\\<rbrakk>\n       \\<Longrightarrow> ((R, ya), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)", "show \"wf (Wellfounded.measure (length \\<circ> snd))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (Wellfounded.measure (length \\<circ> snd))", "by simp"], ["proof (state)\nthis:\n  wf (Wellfounded.measure (length \\<circ> snd))\n\ngoal (2 subgoals):\n 1. \\<And>R xs x xa xb y xc ya.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x; (xb, y) = threeway_partition xa R (delete_index x xs);\n        (xc, ya) = y\\<rbrakk>\n       \\<Longrightarrow> ((R, xb), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)\n 2. \\<And>R xs x xa xb y xc ya xd xe yb.\n       \\<lbrakk>xs \\<noteq> []; x \\<in> set_pmf (pmf_of_set {..<length xs});\n        xa = xs ! x; (xb, y) = threeway_partition xa R (delete_index x xs);\n        (xc, ya) = y; xd \\<in> set_pmf (rquicksort' R xb); (xe, yb) = xd;\n        rquicksort'_dom (R, xb)\\<rbrakk>\n       \\<Longrightarrow> ((R, ya), R, xs)\n                         \\<in> Wellfounded.measure (length \\<circ> snd)", "qed (subst (asm) set_pmf_of_set;\n     force intro!: le_less_trans[OF length_filter_le] simp: threeway_partition_def)+"], ["", "declare rquicksort'.simps [simp del]"], ["", "lemma rquicksort'_Nil [simp]: \"rquicksort' R [] = return_pmf ([], 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rquicksort' R [] = return_pmf ([], 0)", "by (simp add: rquicksort'.simps)"], ["", "context\nbegin"], ["", "qualified"], ["", "definition lesss :: \"('a \\<times> 'a) set \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"lesss R x xs = filter (\\<lambda>y. (y, x) \\<in> R \\<and> (x, y) \\<notin> R) xs\""], ["", "qualified"], ["", "definition greaters :: \"('a \\<times> 'a) set \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"greaters R x xs = filter (\\<lambda>y. (x, y) \\<in> R \\<and> (y, x) \\<notin> R) xs\""], ["", "qualified"], ["", "lemma lesss_Cons:\n  \"lesss R x (y # ys) = \n     (if (y, x) \\<in> R \\<and> (x, y) \\<notin> R then y # lesss R x ys else lesss R x ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lesss R x (y # ys) =\n    (if (y, x) \\<in> R \\<and> (x, y) \\<notin> R then y # lesss R x ys\n     else lesss R x ys)", "by (simp add: lesss_def)"], ["", "qualified"], ["", "lemma length_lesss_le [intro]: \"length (lesss R x xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R x xs) \\<le> length xs", "by (simp add: lesss_def)"], ["", "qualified"], ["", "lemma length_lesss_less [intro]:\n  assumes \"x \\<in> set xs\"\n  shows   \"length (lesss R x xs) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R x xs) < length xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. length (lesss R x xs) < length xs", "by (induction xs) (auto simp: lesss_Cons intro: le_less_trans)"], ["", "qualified"], ["", "lemma greaters_Cons:\n  \"greaters R x (y # ys) = \n     (if (x, y) \\<in> R \\<and> (y, x) \\<notin> R then y # greaters R x ys else greaters R x ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. greaters R x (y # ys) =\n    (if (x, y) \\<in> R \\<and> (y, x) \\<notin> R then y # greaters R x ys\n     else greaters R x ys)", "by (simp add: greaters_def)"], ["", "qualified"], ["", "lemma length_greaters_le [intro]: \"length (greaters R x xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R x xs) \\<le> length xs", "by (simp add: greaters_def)"], ["", "qualified"], ["", "lemma length_greaters_less [intro]:\n  assumes \"x \\<in> set xs\"\n  shows   \"length (greaters R x xs) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R x xs) < length xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. length (greaters R x xs) < length xs", "by (induction xs) (auto simp: greaters_Cons intro: le_less_trans)"], ["", "text \\<open>\n  The following function counts the comparisons made by the modified randomised Quicksort.\n\\<close>"], ["", "function rqs'_cost :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> nat pmf\" where\n  \"rqs'_cost R xs = \n     (if xs = [] then \n        return_pmf 0\n      else\n        do {\n          i \\<leftarrow> pmf_of_set {..<length xs};\n          let x = xs ! i;\n          map_pmf (\\<lambda>(n1,n2). length xs - 1 + n1 + n2) \n            (pair_pmf (rqs'_cost R (lesss R x xs)) (rqs'_cost R (greaters R x xs)))\n        })\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>R xs. x = (R, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>R xs Ra xsa.\n       (R, xs) = (Ra, xsa) \\<Longrightarrow>\n       (if xs = [] then return_pmf 0\n        else pmf_of_set {..<length xs} \\<bind>\n             (\\<lambda>i.\n                 let x = xs ! i\n                 in map_pmf (\\<lambda>(n1, y). length xs - 1 + n1 + y)\n                     (pair_pmf (rqs'_cost_sumC (R, lesss R x xs))\n                       (rqs'_cost_sumC (R, greaters R x xs))))) =\n       (if xsa = [] then return_pmf 0\n        else pmf_of_set {..<length xsa} \\<bind>\n             (\\<lambda>i.\n                 let x = xsa ! i\n                 in map_pmf (\\<lambda>(n1, y). length xsa - 1 + n1 + y)\n                     (pair_pmf (rqs'_cost_sumC (Ra, lesss Ra x xsa))\n                       (rqs'_cost_sumC (Ra, greaters Ra x xsa)))))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All rqs'_cost_dom", "by (relation \"Wellfounded.measure (length \\<circ> snd)\") auto"], ["", "declare rqs'_cost.simps [simp del]"], ["", "lemma rqs'_cost_nonempty:\n  \"xs \\<noteq> [] \\<Longrightarrow> rqs'_cost R xs = \n     do {\n       i \\<leftarrow> pmf_of_set {..<length xs};\n       let x = xs ! i;\n       n1 \\<leftarrow> rqs'_cost R (lesss R x xs);\n       n2 \\<leftarrow> rqs'_cost R (greaters R x xs);\n       return_pmf (length xs - 1 + n1 + n2)\n     }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    rqs'_cost R xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        let x = xs ! i\n        in rqs'_cost R (lesss R x xs) \\<bind>\n           (\\<lambda>n1.\n               rqs'_cost R (greaters R x xs) \\<bind>\n               (\\<lambda>n2. return_pmf (length xs - 1 + n1 + n2))))", "by (subst rqs'_cost.simps) (auto simp: pair_pmf_def Let_def map_bind_pmf)"], ["", "lemma finite_set_pmf_rqs'_cost [simp, intro]:\n  \"finite (set_pmf (rqs'_cost R xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_pmf (rqs'_cost R xs))", "by (induction R xs rule: rqs'_cost.induct) (auto simp: rqs'_cost.simps Let_def)"], ["", "(* TODO: Move? *)"], ["", "lemma expectation_pair_pmf_fst [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  shows \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) = measure_pmf.expectation p f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n    measure_pmf.expectation p f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n    measure_pmf.expectation p f", "have \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) = \n          measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n    measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n  measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n    measure_pmf.expectation p f", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n  measure_pmf.expectation (map_pmf fst (pair_pmf p q)) f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n    measure_pmf.expectation p f", "have \"map_pmf fst (pair_pmf p q) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf fst (pair_pmf p q) = p", "by (simp add: map_fst_pair_pmf)"], ["proof (state)\nthis:\n  map_pmf fst (pair_pmf p q) = p\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n    measure_pmf.expectation p f", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n  measure_pmf.expectation p f", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n  measure_pmf.expectation p f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n    measure_pmf.expectation p f", "."], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (fst x)) =\n  measure_pmf.expectation p f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expectation_pair_pmf_snd [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  shows \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) = measure_pmf.expectation q f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n    measure_pmf.expectation q f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n    measure_pmf.expectation q f", "have \"measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) = \n          measure_pmf.expectation (map_pmf snd (pair_pmf p q)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n    measure_pmf.expectation (map_pmf snd (pair_pmf p q)) f", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n  measure_pmf.expectation (map_pmf snd (pair_pmf p q)) f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n    measure_pmf.expectation q f", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n  measure_pmf.expectation (map_pmf snd (pair_pmf p q)) f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n    measure_pmf.expectation q f", "have \"map_pmf snd (pair_pmf p q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf snd (pair_pmf p q) = q", "by (simp add: map_snd_pair_pmf)"], ["proof (state)\nthis:\n  map_pmf snd (pair_pmf p q) = q\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n    measure_pmf.expectation q f", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n  measure_pmf.expectation q f", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n  measure_pmf.expectation q f\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n    measure_pmf.expectation q f", "."], ["proof (state)\nthis:\n  measure_pmf.expectation (pair_pmf p q) (\\<lambda>x. f (snd x)) =\n  measure_pmf.expectation q f\n\ngoal:\nNo subgoals!", "qed"], ["", "qualified"], ["", "lemma length_lesss_le_sorted:\n  assumes \"sorted_wrt R xs\" \"i < length xs\"\n  shows   \"length (lesss R (xs ! i) xs) \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R (xs ! i) xs) \\<le> i", "using assms"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (lesss R (xs ! i) xs) \\<le> i", "by (induction arbitrary: i rule: sorted_wrt.induct)\n                 (force simp: lesss_def nth_Cons le_Suc_eq split: nat.splits)+"], ["", "qualified"], ["", "lemma length_greaters_le_sorted:\n  assumes \"sorted_wrt R xs\" \"i < length xs\"\n  shows   \"length (greaters R (xs ! i) xs) \\<le> length xs - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R (xs ! i) xs) \\<le> length xs - i - 1", "using assms"], ["proof (prove)\nusing this:\n  Linorder_Relations.sorted_wrt R xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. length (greaters R (xs ! i) xs) \\<le> length xs - i - 1", "by (induction arbitrary: i rule: sorted_wrt.induct)\n     (force simp: greaters_def nth_Cons le_Suc_eq split: nat.splits)+"], ["", "qualified"], ["", "lemma length_lesss_le':\n  assumes \"i < length xs\" \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "define x where \"x = insort_wrt R xs ! i\""], ["proof (state)\nthis:\n  x = insort_wrt R xs ! i\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "define less where \"less = (\\<lambda>x y. (x,y) \\<in> R \\<and> (y,x) \\<notin> R)\""], ["proof (state)\nthis:\n  less = (\\<lambda>x y. (x, y) \\<in> R \\<and> (y, x) \\<notin> R)\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "have \"length (lesss R x xs) = size {# y \\<in># mset xs. less y x #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R x xs) = size {#y \\<in># mset xs. less y x#}", "by (simp add: lesss_def size_mset [symmetric] less_def mset_filter del: size_mset)"], ["proof (state)\nthis:\n  length (lesss R x xs) = size {#y \\<in># mset xs. less y x#}\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "also"], ["proof (state)\nthis:\n  length (lesss R x xs) = size {#y \\<in># mset xs. less y x#}\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "have \"mset xs = mset (insort_wrt R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset (insort_wrt R xs)", "by simp"], ["proof (state)\nthis:\n  mset xs = mset (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "also"], ["proof (state)\nthis:\n  mset xs = mset (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "have \"size {#y \\<in># mset (insort_wrt R xs). less y x#} =\n               length (lesss R x (insort_wrt R xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (insort_wrt R xs). less y x#} =\n    length (lesss R x (insort_wrt R xs))", "by (simp only: mset_filter [symmetric] size_mset lesss_def less_def)"], ["proof (state)\nthis:\n  size {#y \\<in># mset (insort_wrt R xs). less y x#} =\n  length (lesss R x (insort_wrt R xs))\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "also"], ["proof (state)\nthis:\n  size {#y \\<in># mset (insort_wrt R xs). less y x#} =\n  length (lesss R x (insort_wrt R xs))\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "have \"\\<dots> \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R x (insort_wrt R xs)) \\<le> i", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) (insort_wrt R xs)) \\<le> i", "by (rule length_lesss_le_sorted) (use assms in auto)"], ["proof (state)\nthis:\n  length (lesss R x (insort_wrt R xs)) \\<le> i\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "finally"], ["proof (chain)\npicking this:\n  length (lesss R x xs) \\<le> i", "show ?thesis"], ["proof (prove)\nusing this:\n  length (lesss R x xs) \\<le> i\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "unfolding x_def"], ["proof (prove)\nusing this:\n  length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "."], ["proof (state)\nthis:\n  length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["", "qualified"], ["", "lemma length_greaters_le':\n  assumes \"i < length xs\" \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "define x where \"x = insort_wrt R xs ! i\""], ["proof (state)\nthis:\n  x = insort_wrt R xs ! i\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "define less where \"less = (\\<lambda>x y. (x,y) \\<in> R \\<and> (y,x) \\<notin> R)\""], ["proof (state)\nthis:\n  less = (\\<lambda>x y. (x, y) \\<in> R \\<and> (y, x) \\<notin> R)\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "have \"length (greaters R x xs) = size {# y \\<in># mset xs. less x y #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R x xs) = size (filter_mset (less x) (mset xs))", "by (simp add: greaters_def size_mset [symmetric] less_def mset_filter del: size_mset)"], ["proof (state)\nthis:\n  length (greaters R x xs) = size (filter_mset (less x) (mset xs))\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "also"], ["proof (state)\nthis:\n  length (greaters R x xs) = size (filter_mset (less x) (mset xs))\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "have \"mset xs = mset (insort_wrt R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset (insort_wrt R xs)", "by simp"], ["proof (state)\nthis:\n  mset xs = mset (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "also"], ["proof (state)\nthis:\n  mset xs = mset (insort_wrt R xs)\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "have \"size {#y \\<in># mset (insort_wrt R xs). less x y#} =\n               length (greaters R x (insort_wrt R xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (filter_mset (less x) (mset (insort_wrt R xs))) =\n    length (greaters R x (insort_wrt R xs))", "by (simp only: mset_filter [symmetric] size_mset greaters_def less_def)"], ["proof (state)\nthis:\n  size (filter_mset (less x) (mset (insort_wrt R xs))) =\n  length (greaters R x (insort_wrt R xs))\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "also"], ["proof (state)\nthis:\n  size (filter_mset (less x) (mset (insort_wrt R xs))) =\n  length (greaters R x (insort_wrt R xs))\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "have \"\\<dots> \\<le> length (insort_wrt R xs) - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R x (insort_wrt R xs))\n    \\<le> length (insort_wrt R xs) - i - 1", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) (insort_wrt R xs))\n    \\<le> length (insort_wrt R xs) - i - 1", "by (rule length_greaters_le_sorted) (use assms in auto)"], ["proof (state)\nthis:\n  length (greaters R x (insort_wrt R xs))\n  \\<le> length (insort_wrt R xs) - i - 1\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "finally"], ["proof (chain)\npicking this:\n  length (greaters R x xs) \\<le> length (insort_wrt R xs) - i - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  length (greaters R x xs) \\<le> length (insort_wrt R xs) - i - 1\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "unfolding x_def"], ["proof (prove)\nusing this:\n  length (greaters R (insort_wrt R xs ! i) xs)\n  \\<le> length (insort_wrt R xs) - i - 1\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "by simp"], ["proof (state)\nthis:\n  length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can show quite easily that the expected number of comparisons in this modified\n  QuickSort is bounded above by the expected number of comparisons on a list of the same length\n  with no repeated elements.\n\\<close>"], ["", "theorem rqs'_cost_expectation_le:\n  assumes \"linorder_on A R\" \"set xs \\<subseteq> A\"\n  shows   \"measure_pmf.expectation (rqs'_cost R xs) real \\<le> rqs_cost_exp (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "using assms"], ["proof (prove)\nusing this:\n  linorder_on A R\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "proof (induction R xs rule: rqs'_cost.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R xs.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>xs \\<noteq> [];\n                    x \\<in> set_pmf (pmf_of_set {..<length xs});\n                    xa = xs ! x; linorder_on A R;\n                    set (lesss R xa xs) \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> measure_pmf.expectation\n(rqs'_cost R (lesss R xa xs)) real\n                                     \\<le> rqs_cost_exp\n      (length (lesss R xa xs));\n        \\<And>x xa.\n           \\<lbrakk>xs \\<noteq> [];\n            x \\<in> set_pmf (pmf_of_set {..<length xs}); xa = xs ! x;\n            linorder_on A R; set (greaters R xa xs) \\<subseteq> A\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation\n                              (rqs'_cost R (greaters R xa xs)) real\n                             \\<le> rqs_cost_exp (length (greaters R xa xs));\n        linorder_on A R; set xs \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs'_cost R xs) real\n                         \\<le> rqs_cost_exp (length xs)", "case (1 R xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<noteq> []; ?x \\<in> set_pmf (pmf_of_set {..<length xs});\n   ?xa = xs ! ?x; linorder_on A R;\n   set (lesss R ?xa xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation (rqs'_cost R (lesss R ?xa xs))\n                     real\n                    \\<le> rqs_cost_exp (length (lesss R ?xa xs))\n  \\<lbrakk>xs \\<noteq> []; ?x \\<in> set_pmf (pmf_of_set {..<length xs});\n   ?xa = xs ! ?x; linorder_on A R;\n   set (greaters R ?xa xs) \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.expectation\n                     (rqs'_cost R (greaters R ?xa xs)) real\n                    \\<le> rqs_cost_exp (length (greaters R ?xa xs))\n  linorder_on A R\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>R xs.\n       \\<lbrakk>\\<And>x xa.\n                   \\<lbrakk>xs \\<noteq> [];\n                    x \\<in> set_pmf (pmf_of_set {..<length xs});\n                    xa = xs ! x; linorder_on A R;\n                    set (lesss R xa xs) \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> measure_pmf.expectation\n(rqs'_cost R (lesss R xa xs)) real\n                                     \\<le> rqs_cost_exp\n      (length (lesss R xa xs));\n        \\<And>x xa.\n           \\<lbrakk>xs \\<noteq> [];\n            x \\<in> set_pmf (pmf_of_set {..<length xs}); xa = xs ! x;\n            linorder_on A R; set (greaters R xa xs) \\<subseteq> A\\<rbrakk>\n           \\<Longrightarrow> measure_pmf.expectation\n                              (rqs'_cost R (greaters R xa xs)) real\n                             \\<le> rqs_cost_exp (length (greaters R xa xs));\n        linorder_on A R; set xs \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.expectation (rqs'_cost R xs) real\n                         \\<le> rqs_cost_exp (length xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "define n where \"n = length xs - 1\""], ["proof (state)\nthis:\n  n = length xs - 1\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have length_eq: \"length xs = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = Suc n", "using False"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. length xs = Suc n", "by (simp add: n_def)"], ["proof (state)\nthis:\n  length xs = Suc n\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "define E where \"E = (\\<lambda>xs. measure_pmf.expectation (rqs'_cost R xs) real)\""], ["proof (state)\nthis:\n  E = (\\<lambda>xs. measure_pmf.expectation (rqs'_cost R xs) real)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "define f where \"f = (\\<lambda>x. rqs_cost_exp (length (lesss R x xs)) +\n                                rqs_cost_exp (length (greaters R x xs)))\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>x.\n      rqs_cost_exp (length (lesss R x xs)) +\n      rqs_cost_exp (length (greaters R x xs)))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"rqs'_cost R xs =\n            do {\n              i \\<leftarrow> pmf_of_set {..<length xs};\n              map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n                (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n                          (rqs'_cost R (greaters R (xs ! i) xs)))\n            }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rqs'_cost R xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n         (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n           (rqs'_cost R (greaters R (xs ! i) xs))))", "using False"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. rqs'_cost R xs =\n    pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n         (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n           (rqs'_cost R (greaters R (xs ! i) xs))))", "by (subst rqs'_cost.simps) (simp_all add: Let_def)"], ["proof (state)\nthis:\n  rqs'_cost R xs =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n       (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n         (rqs'_cost R (greaters R (xs ! i) xs))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  rqs'_cost R xs =\n  pmf_of_set {..<length xs} \\<bind>\n  (\\<lambda>i.\n      map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n       (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n         (rqs'_cost R (greaters R (xs ! i) xs))))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"measure_pmf.expectation \\<dots> real = real n +\n           (\\<Sum>k<length xs. E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) / real (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (pmf_of_set {..<length xs} \\<bind>\n      (\\<lambda>i.\n          map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n           (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n             (rqs'_cost R (greaters R (xs ! i) xs)))))\n     real =\n    real n +\n    (\\<Sum>k<length xs.\n        E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) /\n    real (length xs)", "using False"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (pmf_of_set {..<length xs} \\<bind>\n      (\\<lambda>i.\n          map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n           (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n             (rqs'_cost R (greaters R (xs ! i) xs)))))\n     real =\n    real n +\n    (\\<Sum>k<length xs.\n        E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) /\n    real (length xs)", "by (subst pmf_expectation_bind_pmf_of_set)\n         (auto intro!: finite_imageI finite_cartesian_product simp: case_prod_unfold\n            integrable_measure_pmf_finite sum_divide_distrib [symmetric] field_simps\n            length_eq sum.distrib E_def)"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n         (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n           (rqs'_cost R (greaters R (xs ! i) xs)))))\n   real =\n  real n +\n  (\\<Sum>k<length xs.\n      E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) /\n  real (length xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (pmf_of_set {..<length xs} \\<bind>\n    (\\<lambda>i.\n        map_pmf (\\<lambda>(n1, y). length xs - Suc 0 + n1 + y)\n         (pair_pmf (rqs'_cost R (lesss R (xs ! i) xs))\n           (rqs'_cost R (greaters R (xs ! i) xs)))))\n   real =\n  real n +\n  (\\<Sum>k<length xs.\n      E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) /\n  real (length xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"\\<dots> \\<le> real n + (\\<Sum>k<length xs. f (xs ! k)) / real (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n +\n    (\\<Sum>k<length xs.\n        E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) /\n    real (length xs)\n    \\<le> real n + (\\<Sum>k<length xs. f (xs ! k)) / real (length xs)", "unfolding E_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real n +\n    (\\<Sum>k<length xs.\n        measure_pmf.expectation (rqs'_cost R (lesss R (xs ! k) xs)) real +\n        measure_pmf.expectation (rqs'_cost R (greaters R (xs ! k) xs))\n         real) /\n    real (length xs)\n    \\<le> real n +\n          (\\<Sum>k<length xs.\n              rqs_cost_exp (length (lesss R (xs ! k) xs)) +\n              rqs_cost_exp (length (greaters R (xs ! k) xs))) /\n          real (length xs)", "using False \"1.prems\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  linorder_on A R\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. real n +\n    (\\<Sum>k<length xs.\n        measure_pmf.expectation (rqs'_cost R (lesss R (xs ! k) xs)) real +\n        measure_pmf.expectation (rqs'_cost R (greaters R (xs ! k) xs))\n         real) /\n    real (length xs)\n    \\<le> real n +\n          (\\<Sum>k<length xs.\n              rqs_cost_exp (length (lesss R (xs ! k) xs)) +\n              rqs_cost_exp (length (greaters R (xs ! k) xs))) /\n          real (length xs)", "by (intro add_mono order.refl divide_right_mono sum_mono \"1.IH\"[OF _ _ refl] False)\n         (auto simp: lesss_def greaters_def)"], ["proof (state)\nthis:\n  real n +\n  (\\<Sum>k<length xs.\n      E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) /\n  real (length xs)\n  \\<le> real n + (\\<Sum>k<length xs. f (xs ! k)) / real (length xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  real n +\n  (\\<Sum>k<length xs.\n      E (lesss R (xs ! k) xs) + E (greaters R (xs ! k) xs)) /\n  real (length xs)\n  \\<le> real n + (\\<Sum>k<length xs. f (xs ! k)) / real (length xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"(\\<Sum>k<length xs. f (xs ! k)) = (\\<Sum>x\\<in>#mset xs. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<length xs. f (xs ! k)) =\n    \\<Sum>\\<^sub># (image_mset f (mset xs))", "by (simp only: mset_map [symmetric] sum_mset_sum_list sum_list_sum_nth)\n         (simp_all add: atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Sum>k<length xs. f (xs ! k)) = \\<Sum>\\<^sub># (image_mset f (mset xs))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<length xs. f (xs ! k)) = \\<Sum>\\<^sub># (image_mset f (mset xs))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"mset xs = mset (insort_wrt R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset (insort_wrt R xs)", "by simp"], ["proof (state)\nthis:\n  mset xs = mset (insort_wrt R xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  mset xs = mset (insort_wrt R xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"(\\<Sum>x\\<in>#\\<dots>. f x) = (\\<Sum>i<length xs. f (insort_wrt R xs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f (mset (insort_wrt R xs))) =\n    (\\<Sum>i<length xs. f (insort_wrt R xs ! i))", "by (simp only: mset_map [symmetric] sum_mset_sum_list sum_list_sum_nth)\n         (simp_all add: atLeast0LessThan)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset f (mset (insort_wrt R xs))) =\n  (\\<Sum>i<length xs. f (insort_wrt R xs ! i))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset f (mset (insort_wrt R xs))) =\n  (\\<Sum>i<length xs. f (insort_wrt R xs ! i))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"\\<dots> \\<le> (\\<Sum>i<length xs. rqs_cost_exp i + rqs_cost_exp (length xs - i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs. f (insort_wrt R xs ! i))\n    \\<le> (\\<Sum>i<length xs.\n              rqs_cost_exp i + rqs_cost_exp (length xs - i - 1))", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs.\n        rqs_cost_exp (length (lesss R (insort_wrt R xs ! i) xs)) +\n        rqs_cost_exp (length (greaters R (insort_wrt R xs ! i) xs)))\n    \\<le> (\\<Sum>i<length xs.\n              rqs_cost_exp i + rqs_cost_exp (length xs - i - 1))", "proof (intro sum_mono add_mono rqs_cost_exp_leI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {..<length xs} \\<Longrightarrow>\n       length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\n 2. \\<And>i.\n       i \\<in> {..<length xs} \\<Longrightarrow>\n       length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {..<length xs} \\<Longrightarrow>\n       length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\n 2. \\<And>i.\n       i \\<in> {..<length xs} \\<Longrightarrow>\n       length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "assume i: \"i \\<in> {..<length xs}\""], ["proof (state)\nthis:\n  i \\<in> {..<length xs}\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {..<length xs} \\<Longrightarrow>\n       length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\n 2. \\<And>i.\n       i \\<in> {..<length xs} \\<Longrightarrow>\n       length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "show \"length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "using i \"1.prems\""], ["proof (prove)\nusing this:\n  i \\<in> {..<length xs}\n  linorder_on A R\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. length (lesss R (insort_wrt R xs ! i) xs) \\<le> i", "by (intro length_lesss_le'[where A = A]) auto"], ["proof (state)\nthis:\n  length (lesss R (insort_wrt R xs ! i) xs) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<length xs} \\<Longrightarrow>\n       length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "show \"length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "using i \"1.prems\""], ["proof (prove)\nusing this:\n  i \\<in> {..<length xs}\n  linorder_on A R\n  set xs \\<subseteq> A\n\ngoal (1 subgoal):\n 1. length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1", "by (intro length_greaters_le'[where A = A]) auto"], ["proof (state)\nthis:\n  length (greaters R (insort_wrt R xs ! i) xs) \\<le> length xs - i - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. f (insort_wrt R xs ! i))\n  \\<le> (\\<Sum>i<length xs.\n            rqs_cost_exp i + rqs_cost_exp (length xs - i - 1))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. f (insort_wrt R xs ! i))\n  \\<le> (\\<Sum>i<length xs.\n            rqs_cost_exp i + rqs_cost_exp (length xs - i - 1))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"\\<dots> = (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<length xs. rqs_cost_exp i + rqs_cost_exp (length xs - i - 1)) =\n    (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i))", "by (intro sum.cong) (auto simp: length_eq)"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. rqs_cost_exp i + rqs_cost_exp (length xs - i - 1)) =\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<length xs. rqs_cost_exp i + rqs_cost_exp (length xs - i - 1)) =\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "have \"real n + \\<dots> / real (length xs) = rqs_cost_exp (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n +\n    (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) /\n    real (length xs) =\n    rqs_cost_exp (length xs)", "by (simp add: length_eq rqs_cost_exp.simps(2))"], ["proof (state)\nthis:\n  real n +\n  (\\<Sum>i\\<le>n. rqs_cost_exp i + rqs_cost_exp (n - i)) /\n  real (length xs) =\n  rqs_cost_exp (length xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      real n + x / real (length xs)\n      \\<le> real n + y / real (length xs)) \\<Longrightarrow>\n  measure_pmf.expectation (rqs'_cost R xs) real\n  \\<le> rqs_cost_exp (length xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      real n + x / real (length xs)\n      \\<le> real n + y / real (length xs)) \\<Longrightarrow>\n  measure_pmf.expectation (rqs'_cost R xs) real\n  \\<le> rqs_cost_exp (length xs)\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "by (simp add: divide_right_mono)"], ["proof (state)\nthis:\n  measure_pmf.expectation (rqs'_cost R xs) real\n  \\<le> rqs_cost_exp (length xs)\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    measure_pmf.expectation (rqs'_cost R xs) real\n    \\<le> rqs_cost_exp (length xs)", "qed (auto simp: rqs'_cost.simps)"], ["proof (state)\nthis:\n  measure_pmf.expectation (rqs'_cost R xs) real\n  \\<le> rqs_cost_exp (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}