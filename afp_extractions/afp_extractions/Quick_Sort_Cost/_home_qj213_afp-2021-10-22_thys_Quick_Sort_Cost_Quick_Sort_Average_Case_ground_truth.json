{"file_name": "/home/qj213/afp-2021-10-22/thys/Quick_Sort_Cost/Quick_Sort_Average_Case.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Quick_Sort_Cost", "problem_names": ["theorem mset_quicksort [simp]: \"mset (quicksort R xs) = mset xs\"", "theorem sorted_wrt_quicksort: \n  assumes \"trans R\" and \"total_on (set xs) R\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> (x, x) \\<in> R\"\n  shows   \"sorted_wrt R (quicksort R xs)\"", "lemma fst_quicksort' [simp]: \"fst (quicksort' R xs) = quicksort R xs\"", "lemma snd_quicksort' [simp]: \"snd (quicksort' R xs) = qs_cost R xs\"", "theorem qs_cost_average_conv_rqs_cost:\n  assumes \"finite A\" and \"linorder_on B R\" and \"A \\<subseteq> B\"\n  shows   \"map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) = rqs_cost (card A)\""], "translations": [["", "theorem mset_quicksort [simp]: \"mset (quicksort R xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort R xs) = mset xs", "by (induction R xs rule: quicksort.induct) (simp_all)"], ["", "corollary set_quicksort [simp]: \"set (quicksort R xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (quicksort R xs) = set xs", "by (induction R xs rule: quicksort.induct) auto"], ["", "theorem sorted_wrt_quicksort: \n  assumes \"trans R\" and \"total_on (set xs) R\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> (x, x) \\<in> R\"\n  shows   \"sorted_wrt R (quicksort R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (quicksort R xs)", "using assms"], ["proof (prove)\nusing this:\n  trans R\n  total_on (set xs) R\n  ?x \\<in> set xs \\<Longrightarrow> (?x, ?x) \\<in> R\n\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (quicksort R xs)", "proof (induction R xs rule: quicksort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>trans uu_; total_on (set []) uu_;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> (x, x) \\<in> uu_\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt uu_\n                          (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>trans R;\n                 total_on (set (filter (\\<lambda>y. (y, x) \\<in> R) xs)) R;\n                 \\<And>xa.\n                    xa \\<in> set (filter (\\<lambda>y. (y, x) \\<in> R)\n                                   xs) \\<Longrightarrow>\n                    (xa, xa) \\<in> R\\<rbrakk>\n                \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. (y, x) \\<in> R)\n xs));\n        \\<lbrakk>trans R;\n         total_on (set (filter (\\<lambda>y. (y, x) \\<notin> R) xs)) R;\n         \\<And>xa.\n            xa \\<in> set (filter (\\<lambda>y. (y, x) \\<notin> R)\n                           xs) \\<Longrightarrow>\n            (xa, xa) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. (y, x) \\<notin> R) xs));\n        trans R; total_on (set (x # xs)) R;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> (xa, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                          (quicksort R (x # xs))", "case (2 R x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>trans R;\n   total_on (set (filter (\\<lambda>y. (y, x) \\<in> R) xs)) R;\n   \\<And>xa.\n      xa \\<in> set (filter (\\<lambda>y. (y, x) \\<in> R)\n                     xs) \\<Longrightarrow>\n      (xa, xa) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                     (quicksort R (filter (\\<lambda>y. (y, x) \\<in> R) xs))\n  \\<lbrakk>trans R;\n   total_on (set (filter (\\<lambda>y. (y, x) \\<notin> R) xs)) R;\n   \\<And>xa.\n      xa \\<in> set (filter (\\<lambda>y. (y, x) \\<notin> R)\n                     xs) \\<Longrightarrow>\n      (xa, xa) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                     (quicksort R\n                       (filter (\\<lambda>y. (y, x) \\<notin> R) xs))\n  trans R\n  total_on (set (x # xs)) R\n  ?x \\<in> set (x # xs) \\<Longrightarrow> (?x, ?x) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>trans uu_; total_on (set []) uu_;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> (x, x) \\<in> uu_\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt uu_\n                          (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>trans R;\n                 total_on (set (filter (\\<lambda>y. (y, x) \\<in> R) xs)) R;\n                 \\<And>xa.\n                    xa \\<in> set (filter (\\<lambda>y. (y, x) \\<in> R)\n                                   xs) \\<Longrightarrow>\n                    (xa, xa) \\<in> R\\<rbrakk>\n                \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. (y, x) \\<in> R)\n xs));\n        \\<lbrakk>trans R;\n         total_on (set (filter (\\<lambda>y. (y, x) \\<notin> R) xs)) R;\n         \\<And>xa.\n            xa \\<in> set (filter (\\<lambda>y. (y, x) \\<notin> R)\n                           xs) \\<Longrightarrow>\n            (xa, xa) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. (y, x) \\<notin> R) xs));\n        trans R; total_on (set (x # xs)) R;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> (xa, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                          (quicksort R (x # xs))", "have total: \"(a, b) \\<in> R\" if \"(b, a) \\<notin> R\" \"a \\<in> set (x#xs)\" \"b \\<in> set (x#xs)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> R", "using \"2.prems\" that"], ["proof (prove)\nusing this:\n  trans R\n  total_on (set (x # xs)) R\n  ?x \\<in> set (x # xs) \\<Longrightarrow> (?x, ?x) \\<in> R\n  (b, a) \\<notin> R\n  a \\<in> set (x # xs)\n  b \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> R", "unfolding total_on_def"], ["proof (prove)\nusing this:\n  trans R\n  \\<forall>xa\\<in>set (x # xs).\n     \\<forall>y\\<in>set (x # xs).\n        xa \\<noteq> y \\<longrightarrow>\n        (xa, y) \\<in> R \\<or> (y, xa) \\<in> R\n  ?x \\<in> set (x # xs) \\<Longrightarrow> (?x, ?x) \\<in> R\n  (b, a) \\<notin> R\n  a \\<in> set (x # xs)\n  b \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> R", "by (cases \"a = b\") auto"], ["proof (state)\nthis:\n  \\<lbrakk>(?b, ?a) \\<notin> R; ?a \\<in> set (x # xs);\n   ?b \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> R\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>trans uu_; total_on (set []) uu_;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> (x, x) \\<in> uu_\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt uu_\n                          (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>trans R;\n                 total_on (set (filter (\\<lambda>y. (y, x) \\<in> R) xs)) R;\n                 \\<And>xa.\n                    xa \\<in> set (filter (\\<lambda>y. (y, x) \\<in> R)\n                                   xs) \\<Longrightarrow>\n                    (xa, xa) \\<in> R\\<rbrakk>\n                \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. (y, x) \\<in> R)\n xs));\n        \\<lbrakk>trans R;\n         total_on (set (filter (\\<lambda>y. (y, x) \\<notin> R) xs)) R;\n         \\<And>xa.\n            xa \\<in> set (filter (\\<lambda>y. (y, x) \\<notin> R)\n                           xs) \\<Longrightarrow>\n            (xa, xa) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. (y, x) \\<notin> R) xs));\n        trans R; total_on (set (x # xs)) R;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> (xa, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                          (quicksort R (x # xs))", "have *: \"sorted_wrt R (quicksort R (filter (\\<lambda>y. (y,x) \\<in> R) xs))\"\n          \"sorted_wrt R (quicksort R (filter (\\<lambda>y. (y,x) \\<notin> R) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R\n     (quicksort R (filter (\\<lambda>y. (y, x) \\<in> R) xs)) &&&\n    Linorder_Relations.sorted_wrt R\n     (quicksort R (filter (\\<lambda>y. (y, x) \\<notin> R) xs))", "by ((rule 2 total_on_subset[OF \\<open>total_on (set (x#xs)) R\\<close>]) | force)+"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R\n   (quicksort R (filter (\\<lambda>y. (y, x) \\<in> R) xs))\n  Linorder_Relations.sorted_wrt R\n   (quicksort R (filter (\\<lambda>y. (y, x) \\<notin> R) xs))\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>trans uu_; total_on (set []) uu_;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> (x, x) \\<in> uu_\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt uu_\n                          (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>trans R;\n                 total_on (set (filter (\\<lambda>y. (y, x) \\<in> R) xs)) R;\n                 \\<And>xa.\n                    xa \\<in> set (filter (\\<lambda>y. (y, x) \\<in> R)\n                                   xs) \\<Longrightarrow>\n                    (xa, xa) \\<in> R\\<rbrakk>\n                \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. (y, x) \\<in> R)\n xs));\n        \\<lbrakk>trans R;\n         total_on (set (filter (\\<lambda>y. (y, x) \\<notin> R) xs)) R;\n         \\<And>xa.\n            xa \\<in> set (filter (\\<lambda>y. (y, x) \\<notin> R)\n                           xs) \\<Longrightarrow>\n            (xa, xa) \\<in> R\\<rbrakk>\n        \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. (y, x) \\<notin> R) xs));\n        trans R; total_on (set (x # xs)) R;\n        \\<And>xa.\n           xa \\<in> set (x # xs) \\<Longrightarrow> (xa, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt R\n                          (quicksort R (x # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (quicksort R (x # xs))", "by (auto intro!: sorted_wrt_append sorted_wrt.intros \\<open>trans R\\<close> * \n             intro: transD[OF \\<open>trans R\\<close>] dest!: total simp: total_on_def)"], ["proof (state)\nthis:\n  Linorder_Relations.sorted_wrt R (quicksort R (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>uu_.\n       \\<lbrakk>trans uu_; total_on (set []) uu_;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> (x, x) \\<in> uu_\\<rbrakk>\n       \\<Longrightarrow> Linorder_Relations.sorted_wrt uu_\n                          (quicksort uu_ [])", "qed auto"], ["", "corollary sorted_wrt_quicksort':\n  assumes \"linorder_on A R\" and \"set xs \\<subseteq> A\"\n  shows   \"sorted_wrt R (quicksort R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linorder_Relations.sorted_wrt R (quicksort R xs)", "by (rule sorted_wrt_quicksort)\n     (insert assms, auto simp: linorder_on_def refl_on_def dest: total_on_subset)"], ["", "text \\<open>\n  We now define another version of QuickSort that is identical to the previous one but also \n  counts the number of comparisons that were made.\n\\<close>"], ["", "fun quicksort' :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<times> nat\" where\n  \"quicksort' _ [] = ([], 0)\"\n| \"quicksort' R (x # xs) = (\n     let (ls, rs)  = partition (\\<lambda>y. (y,x) \\<in> R) xs;\n         (ls', n1) = quicksort' R ls;\n         (rs', n2) = quicksort' R rs\n     in\n         (ls' @ [x] @ rs', length xs + n1 + n2))\""], ["", "text \\<open>\n  For convenience, we also define a function that computes only the number of comparisons that \n  were made and not the result list.\n\\<close>"], ["", "fun qs_cost :: \"('a \\<times> 'a) set \\<Rightarrow> 'a list \\<Rightarrow> nat\" where\n  \"qs_cost _ [] = 0\"\n| \"qs_cost R (x # xs) = \n     length xs + qs_cost R (filter (\\<lambda>y. (y,x)\\<in>R) xs) + qs_cost R (filter (\\<lambda>y. (y,x)\\<notin>R) xs)\""], ["", "text \\<open>\n  It is obvious that the original QuickSort and the cost function are the projections \n  of the cost-counting QuickSort.\n\\<close>"], ["", "lemma fst_quicksort' [simp]: \"fst (quicksort' R xs) = quicksort R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (quicksort' R xs) = quicksort R xs", "by (induction R xs rule: quicksort.induct) (simp_all add: case_prod_unfold Let_def o_def)"], ["", "lemma snd_quicksort' [simp]: \"snd (quicksort' R xs) = qs_cost R xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (quicksort' R xs) = qs_cost R xs", "by (induction R xs rule: quicksort.induct) (simp_all add: case_prod_unfold Let_def o_def)"], ["", "subsection \\<open>Analysis\\<close>"], ["", "text \\<open>\n  We will reduce the average-case analysis to showing that it is essentially equivalent to \n  the randomised QuickSort we analysed earlier. Similar, but more direct analyses are given \n  by Hoare~\\cite{hoare} and Sedgewick~\\cite{sedgewick}. \n\n  The proof is relatively straightforward -- but still a bit messy. We show that the cost \n  distribution of QuickSort run on a random permutation of a set of size $n$ is exactly the same \n  as that of randomised QuickSort being run on any fixed list of size $n$ (which we analysed \n  before):  \n\\<close>"], ["", "theorem qs_cost_average_conv_rqs_cost:\n  assumes \"finite A\" and \"linorder_on B R\" and \"A \\<subseteq> B\"\n  shows   \"map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) = rqs_cost (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "using assms(1,3)"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "proof (induction A rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>Ba.\n           \\<lbrakk>Ba \\<subset> A; Ba \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> map_pmf (qs_cost R)\n                              (pmf_of_set (permutations_of_set Ba)) =\n                             rqs_cost (card Ba);\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> map_pmf (qs_cost R)\n                          (pmf_of_set (permutations_of_set A)) =\n                         rqs_cost (card A)", "case (psubset A)"], ["proof (state)\nthis:\n  finite A\n  \\<lbrakk>?B \\<subset> A; ?B \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> map_pmf (qs_cost R)\n                     (pmf_of_set (permutations_of_set ?B)) =\n                    rqs_cost (card ?B)\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>finite A;\n        \\<And>Ba.\n           \\<lbrakk>Ba \\<subset> A; Ba \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> map_pmf (qs_cost R)\n                              (pmf_of_set (permutations_of_set Ba)) =\n                             rqs_cost (card Ba);\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> map_pmf (qs_cost R)\n                          (pmf_of_set (permutations_of_set A)) =\n                         rqs_cost (card A)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "case True"], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)\n 2. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "by (simp add: pmf_of_set_singleton)"], ["proof (state)\nthis:\n  map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n  rqs_cost (card A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "note A = \\<open>finite A\\<close> \\<open>A \\<noteq> {}\\<close>"], ["proof (state)\nthis:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "define n where \"n = card A - 1\""], ["proof (state)\nthis:\n  n = card A - 1\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"pmf_of_set (permutations_of_set A) = \n      do {x \\<leftarrow> pmf_of_set A; xs \\<leftarrow> pmf_of_set (permutations_of_set (A - {x})); return_pmf (x#xs)}\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pmf_of_set (permutations_of_set A) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs. return_pmf (x # xs)))", "by (rule random_permutation_of_set)"], ["proof (state)\nthis:\n  pmf_of_set (permutations_of_set A) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs. return_pmf (x # xs)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set (permutations_of_set A) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs. return_pmf (x # xs)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "have \"map_pmf (qs_cost R) \\<dots> =\n                 do {\n                   x \\<leftarrow> pmf_of_set A;\n                   xs \\<leftarrow> pmf_of_set (permutations_of_set (A - {x}));\n                   return_pmf (length xs + qs_cost R [y\\<leftarrow>xs. (y,x)\\<in>R] + qs_cost R [y\\<leftarrow>xs. (y,x)\\<notin>R])\n                 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R)\n     (pmf_of_set A \\<bind>\n      (\\<lambda>x.\n          pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n          (\\<lambda>xs. return_pmf (x # xs)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs.\n            return_pmf\n             (length xs +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs))))", "by (simp add: map_bind_pmf)"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs. return_pmf (x # xs)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs.\n          return_pmf\n           (length xs + qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n            qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs))))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs. return_pmf (x # xs)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs.\n          return_pmf\n           (length xs + qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n            qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs))))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "have \"\\<dots> = map_pmf (\\<lambda>m. n + m) (\n          do {\n            x \\<leftarrow> pmf_of_set A;\n            xs \\<leftarrow> pmf_of_set (permutations_of_set (A - {x}));\n            return_pmf (qs_cost R [y\\<leftarrow>xs. (y,x)\\<in>R] + qs_cost R [y\\<leftarrow>xs. (y,x)\\<notin>R])\n          })\" (is \"_ = map_pmf _ ?X\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs.\n            return_pmf\n             (length xs +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n    map_pmf ((+) n)\n     (pmf_of_set A \\<bind>\n      (\\<lambda>x.\n          pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n          (\\<lambda>xs.\n              return_pmf\n               (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n                qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))))", "using A"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs.\n            return_pmf\n             (length xs +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n    map_pmf ((+) n)\n     (pmf_of_set A \\<bind>\n      (\\<lambda>x.\n          pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n          (\\<lambda>xs.\n              return_pmf\n               (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n                qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))))", "unfolding n_def map_bind_pmf"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs.\n            return_pmf\n             (length xs +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xa.\n            map_pmf ((+) (card A - 1))\n             (return_pmf\n               (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xa) +\n                qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xa)))))", "by (intro bind_pmf_cong map_pmf_cong refl) (auto simp: length_finite_permutations_of_set)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs.\n          return_pmf\n           (length xs + qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n            qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n  map_pmf ((+) n)\n   (pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs.\n            return_pmf\n             (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs.\n          return_pmf\n           (length xs + qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n            qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n  map_pmf ((+) n)\n   (pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs.\n            return_pmf\n             (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "have \"?X = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      (ls,rs) \\<leftarrow> map_pmf (partition (\\<lambda>y. (y,x)\\<in>R)) \n                                   (pmf_of_set (permutations_of_set (A - {x})));\n                      return_pmf (qs_cost R ls + qs_cost R rs)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n        (\\<lambda>xs.\n            return_pmf\n             (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n              qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)))", "by (simp add: bind_map_pmf o_def)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs.\n          return_pmf\n           (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n            qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pmf_of_set (permutations_of_set (A - {x})) \\<bind>\n      (\\<lambda>xs.\n          return_pmf\n           (qs_cost R (filter (\\<lambda>y. (y, x) \\<in> R) xs) +\n            qs_cost R (filter (\\<lambda>y. (y, x) \\<notin> R) xs)))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "have \"\\<dots> = do {\n                      x \\<leftarrow> pmf_of_set A;\n                      (n1, n2) \\<leftarrow> pair_pmf \n                        (rqs_cost (linorder_rank R A x)) (rqs_cost (n - linorder_rank R A x));\n                      return_pmf (n1 + n2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n         (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n        (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs))) =\n    pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (rqs_cost (linorder_rank R A x))\n         (rqs_cost (n - linorder_rank R A x)) \\<bind>\n        (\\<lambda>(n1, n2). return_pmf (n1 + n2)))", "proof (intro bind_pmf_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> set_pmf (pmf_of_set A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"map_pmf (partition (\\<lambda>y. (y,x)\\<in>R)) (pmf_of_set (permutations_of_set (A - {x})))\n              \\<bind> (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) = \n            map_pmf (\\<lambda>(n1, n2). n1 + n2) (pair_pmf\n              (map_pmf (qs_cost R) (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})))\n              (map_pmf (qs_cost R) (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R}))))\"\n        (is \"_ = map_pmf _ (pair_pmf ?X ?Y)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n     (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n    (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n    map_pmf (\\<lambda>(n1, n2). n1 + n2)\n     (pair_pmf\n       (map_pmf (qs_cost R)\n         (pmf_of_set\n           (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})))\n       (map_pmf (qs_cost R)\n         (pmf_of_set\n           (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R}))))", "by (subst partition_random_permutations)\n           (simp_all add: map_pmf_def case_prod_unfold bind_return_pmf bind_assoc_pmf pair_pmf_def A)"], ["proof (state)\nthis:\n  map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n   (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n  (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n  map_pmf (\\<lambda>(n1, n2). n1 + n2)\n   (pair_pmf\n     (map_pmf (qs_cost R)\n       (pmf_of_set\n         (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})))\n     (map_pmf (qs_cost R)\n       (pmf_of_set\n         (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R}))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n   (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n  (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n  map_pmf (\\<lambda>(n1, n2). n1 + n2)\n   (pair_pmf\n     (map_pmf (qs_cost R)\n       (pmf_of_set\n         (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})))\n     (map_pmf (qs_cost R)\n       (pmf_of_set\n         (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R}))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "{"], ["proof (state)\nthis:\n  map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n   (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n  (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n  map_pmf (\\<lambda>(n1, n2). n1 + n2)\n   (pair_pmf\n     (map_pmf (qs_cost R)\n       (pmf_of_set\n         (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})))\n     (map_pmf (qs_cost R)\n       (pmf_of_set\n         (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R}))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"{xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subseteq> A - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subseteq> A - {x}", "by blast"], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subseteq> A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subseteq> A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"\\<dots> \\<subset> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {x} \\<subset> A", "using 1 A"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A - {x} \\<subset> A", "by auto"], ["proof (state)\nthis:\n  A - {x} \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> A", "have subset: \"{xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> A\""], ["proof (prove)\nusing this:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> A", "."], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"\\<dots> \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B", "by fact"], ["proof (state)\nthis:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> B", "have \"?X = rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<in> R})\""], ["proof (prove)\nusing this:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> B\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R)\n     (pmf_of_set\n       (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n    rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<in> R})", "using subset"], ["proof (prove)\nusing this:\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> B\n  {xa \\<in> A - {x}. (xa, x) \\<in> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R)\n     (pmf_of_set\n       (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n    rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<in> R})", "by (intro psubset.IH) auto"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<in> R})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<in> R})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"card {xa \\<in> A - {x}. (xa, x) \\<in> R} = linorder_rank R A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {xa \\<in> A - {x}. (xa, x) \\<in> R} = linorder_rank R A x", "by (simp add: linorder_rank_def)"], ["proof (state)\nthis:\n  card {xa \\<in> A - {x}. (xa, x) \\<in> R} = linorder_rank R A x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (linorder_rank R A x)", "have \"?X = rqs_cost \\<dots>\""], ["proof (prove)\nusing this:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R)\n     (pmf_of_set\n       (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n    rqs_cost (linorder_rank R A x)", "."], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "}"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "{"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<in> R})) =\n  rqs_cost (linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"{xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subseteq> A - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subseteq> A - {x}", "by blast"], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subseteq> A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subseteq> A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"\\<dots> \\<subset> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {x} \\<subset> A", "using 1 A"], ["proof (prove)\nusing this:\n  x \\<in> set_pmf (pmf_of_set A)\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A - {x} \\<subset> A", "by auto"], ["proof (state)\nthis:\n  A - {x} \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> A", "have subset: \"{xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> A\""], ["proof (prove)\nusing this:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> A", "."], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"\\<dots> \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B", "by fact"], ["proof (state)\nthis:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> B", "have \"?Y = rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<notin> R})\""], ["proof (prove)\nusing this:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> B\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R)\n     (pmf_of_set\n       (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n    rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<notin> R})", "using subset"], ["proof (prove)\nusing this:\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> B\n  {xa \\<in> A - {x}. (xa, x) \\<notin> R} \\<subset> A\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R)\n     (pmf_of_set\n       (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n    rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<notin> R})", "by (intro psubset.IH) auto"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set\n     (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n  rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<notin> R})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set\n     (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n  rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<notin> R})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "{"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set\n     (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n  rqs_cost (card {xa \\<in> A - {x}. (xa, x) \\<notin> R})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"card ({y\\<in>A-{x}. (y,x)\\<in>R} \\<union> {y\\<in>A-{x}. (y,x)\\<notin>R}) = \n                  linorder_rank R A x + card {xa \\<in> A - {x}. (xa, x) \\<notin> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n      {y \\<in> A - {x}. (y, x) \\<notin> R}) =\n    linorder_rank R A x + card {xa \\<in> A - {x}. (xa, x) \\<notin> R}", "unfolding linorder_rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n      {y \\<in> A - {x}. (y, x) \\<notin> R}) =\n    card {y \\<in> A - {x}. (y, x) \\<in> R} +\n    card {xa \\<in> A - {x}. (xa, x) \\<notin> R}", "using A"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card\n     ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n      {y \\<in> A - {x}. (y, x) \\<notin> R}) =\n    card {y \\<in> A - {x}. (y, x) \\<in> R} +\n    card {xa \\<in> A - {x}. (xa, x) \\<notin> R}", "by (intro card_Un_disjoint) auto"], ["proof (state)\nthis:\n  card\n   ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n    {y \\<in> A - {x}. (y, x) \\<notin> R}) =\n  linorder_rank R A x + card {xa \\<in> A - {x}. (xa, x) \\<notin> R}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  card\n   ({y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n    {y \\<in> A - {x}. (y, x) \\<notin> R}) =\n  linorder_rank R A x + card {xa \\<in> A - {x}. (xa, x) \\<notin> R}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"{y\\<in>A-{x}. (y,x)\\<in>R} \\<union> {y\\<in>A-{x}. (y,x)\\<notin>R} = A - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n    {y \\<in> A - {x}. (y, x) \\<notin> R} =\n    A - {x}", "by blast"], ["proof (state)\nthis:\n  {y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n  {y \\<in> A - {x}. (y, x) \\<notin> R} =\n  A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "also"], ["proof (state)\nthis:\n  {y \\<in> A - {x}. (y, x) \\<in> R} \\<union>\n  {y \\<in> A - {x}. (y, x) \\<notin> R} =\n  A - {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "have \"card \\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A - {x}) = n", "using A 1"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n  x \\<in> set_pmf (pmf_of_set A)\n\ngoal (1 subgoal):\n 1. card (A - {x}) = n", "by (simp add: n_def)"], ["proof (state)\nthis:\n  card (A - {x}) = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  n = linorder_rank R A x + card {xa \\<in> A - {x}. (xa, x) \\<notin> R}", "have \"card {xa \\<in> A - {x}. (xa, x) \\<notin> R} = n - linorder_rank R A x\""], ["proof (prove)\nusing this:\n  n = linorder_rank R A x + card {xa \\<in> A - {x}. (xa, x) \\<notin> R}\n\ngoal (1 subgoal):\n 1. card {xa \\<in> A - {x}. (xa, x) \\<notin> R} = n - linorder_rank R A x", "by simp"], ["proof (state)\nthis:\n  card {xa \\<in> A - {x}. (xa, x) \\<notin> R} = n - linorder_rank R A x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "}"], ["proof (state)\nthis:\n  card {xa \\<in> A - {x}. (xa, x) \\<notin> R} = n - linorder_rank R A x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  map_pmf (qs_cost R)\n   (pmf_of_set\n     (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n  rqs_cost (n - linorder_rank R A x)", "have \"?Y = rqs_cost (n - linorder_rank R A x)\""], ["proof (prove)\nusing this:\n  map_pmf (qs_cost R)\n   (pmf_of_set\n     (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n  rqs_cost (n - linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R)\n     (pmf_of_set\n       (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n    rqs_cost (n - linorder_rank R A x)", "."], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set\n     (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n  rqs_cost (n - linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "}"], ["proof (state)\nthis:\n  map_pmf (qs_cost R)\n   (pmf_of_set\n     (permutations_of_set {xa \\<in> A - {x}. (xa, x) \\<notin> R})) =\n  rqs_cost (n - linorder_rank R A x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_pmf (pmf_of_set A) \\<Longrightarrow>\n       map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n        (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n       (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n       pair_pmf (rqs_cost (linorder_rank R A x))\n        (rqs_cost (n - linorder_rank R A x)) \\<bind>\n       (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "finally"], ["proof (chain)\npicking this:\n  map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n   (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n  (\\<lambda>a.\n      case a of\n      (ls, rs) \\<Rightarrow> return_pmf (qs_cost R ls + qs_cost R rs)) =\n  map_pmf (\\<lambda>a. case a of (n1, n2) \\<Rightarrow> n1 + n2)\n   (pair_pmf (rqs_cost (linorder_rank R A x))\n     (rqs_cost (n - linorder_rank R A x)))", "show ?case"], ["proof (prove)\nusing this:\n  map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n   (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n  (\\<lambda>a.\n      case a of\n      (ls, rs) \\<Rightarrow> return_pmf (qs_cost R ls + qs_cost R rs)) =\n  map_pmf (\\<lambda>a. case a of (n1, n2) \\<Rightarrow> n1 + n2)\n   (pair_pmf (rqs_cost (linorder_rank R A x))\n     (rqs_cost (n - linorder_rank R A x)))\n\ngoal (1 subgoal):\n 1. map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n     (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n    (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n    pair_pmf (rqs_cost (linorder_rank R A x))\n     (rqs_cost (n - linorder_rank R A x)) \\<bind>\n    (\\<lambda>(n1, n2). return_pmf (n1 + n2))", "by (simp add: case_prod_unfold map_pmf_def)"], ["proof (state)\nthis:\n  map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n   (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n  (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs)) =\n  pair_pmf (rqs_cost (linorder_rank R A x))\n   (rqs_cost (n - linorder_rank R A x)) \\<bind>\n  (\\<lambda>(n1, n2). return_pmf (n1 + n2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (rqs_cost (linorder_rank R A x))\n       (rqs_cost (n - linorder_rank R A x)) \\<bind>\n      (\\<lambda>(n1, n2). return_pmf (n1 + n2)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      map_pmf (partition (\\<lambda>y. (y, x) \\<in> R))\n       (pmf_of_set (permutations_of_set (A - {x}))) \\<bind>\n      (\\<lambda>(ls, rs). return_pmf (qs_cost R ls + qs_cost R rs))) =\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (rqs_cost (linorder_rank R A x))\n       (rqs_cost (n - linorder_rank R A x)) \\<bind>\n      (\\<lambda>(n1, n2). return_pmf (n1 + n2)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "have \"\\<dots> = do {\n                      i \\<leftarrow> map_pmf (linorder_rank R A) (pmf_of_set A);\n                      (n1, n2) \\<leftarrow> pair_pmf (rqs_cost i) (rqs_cost (n - i));\n                      return_pmf (n1 + n2)\n                    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf_of_set A \\<bind>\n    (\\<lambda>x.\n        pair_pmf (rqs_cost (linorder_rank R A x))\n         (rqs_cost (n - linorder_rank R A x)) \\<bind>\n        (\\<lambda>(n1, n2). return_pmf (n1 + n2))) =\n    map_pmf (linorder_rank R A) (pmf_of_set A) \\<bind>\n    (\\<lambda>i.\n        pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n        (\\<lambda>(n1, n2). return_pmf (n1 + n2)))", "by (simp add: bind_map_pmf)"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (rqs_cost (linorder_rank R A x))\n       (rqs_cost (n - linorder_rank R A x)) \\<bind>\n      (\\<lambda>(n1, n2). return_pmf (n1 + n2))) =\n  map_pmf (linorder_rank R A) (pmf_of_set A) \\<bind>\n  (\\<lambda>i.\n      pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n      (\\<lambda>(n1, n2). return_pmf (n1 + n2)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  pmf_of_set A \\<bind>\n  (\\<lambda>x.\n      pair_pmf (rqs_cost (linorder_rank R A x))\n       (rqs_cost (n - linorder_rank R A x)) \\<bind>\n      (\\<lambda>(n1, n2). return_pmf (n1 + n2))) =\n  map_pmf (linorder_rank R A) (pmf_of_set A) \\<bind>\n  (\\<lambda>i.\n      pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n      (\\<lambda>(n1, n2). return_pmf (n1 + n2)))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "have \"map_pmf (linorder_rank R A) (pmf_of_set A) = pmf_of_set {..<card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (linorder_rank R A) (pmf_of_set A) = pmf_of_set {..<card A}", "by (intro map_pmf_of_set_bij_betw bij_betw_linorder_rank[OF assms(2)] A psubset.prems)"], ["proof (state)\nthis:\n  map_pmf (linorder_rank R A) (pmf_of_set A) = pmf_of_set {..<card A}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  map_pmf (linorder_rank R A) (pmf_of_set A) = pmf_of_set {..<card A}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"card A > 0\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card A", "by (intro Nat.gr0I) auto"], ["proof (state)\nthis:\n  0 < card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "hence \"{..<card A} = {..n}\""], ["proof (prove)\nusing this:\n  0 < card A\n\ngoal (1 subgoal):\n 1. {..<card A} = {..n}", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  {..<card A} = {..n}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  {..<card A} = {..n}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "have \"map_pmf (\\<lambda>m. n + m) (\n                 do {\n                      i \\<leftarrow> pmf_of_set {..n};\n                      (n1, n2) \\<leftarrow> pair_pmf (rqs_cost i) (rqs_cost (n - i));\n                      return_pmf (n1 + n2)\n                    }) = rqs_cost (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf ((+) n)\n     (pmf_of_set {..n} \\<bind>\n      (\\<lambda>i.\n          pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n          (\\<lambda>(n1, n2). return_pmf (n1 + n2)))) =\n    rqs_cost (Suc n)", "by (simp add: pair_pmf_def map_bind_pmf case_prod_unfold\n                    bind_assoc_pmf bind_return_pmf add_ac)"], ["proof (state)\nthis:\n  map_pmf ((+) n)\n   (pmf_of_set {..n} \\<bind>\n    (\\<lambda>i.\n        pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n        (\\<lambda>(n1, n2). return_pmf (n1 + n2)))) =\n  rqs_cost (Suc n)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "also"], ["proof (state)\nthis:\n  map_pmf ((+) n)\n   (pmf_of_set {..n} \\<bind>\n    (\\<lambda>i.\n        pair_pmf (rqs_cost i) (rqs_cost (n - i)) \\<bind>\n        (\\<lambda>(n1, n2). return_pmf (n1 + n2)))) =\n  rqs_cost (Suc n)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "from A"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"card A > 0\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card A", "by (intro Nat.gr0I) auto"], ["proof (state)\nthis:\n  0 < card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "hence \"Suc n = card A\""], ["proof (prove)\nusing this:\n  0 < card A\n\ngoal (1 subgoal):\n 1. Suc n = card A", "by (simp add: n_def)"], ["proof (state)\nthis:\n  Suc n = card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "finally"], ["proof (chain)\npicking this:\n  map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n  rqs_cost (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n  rqs_cost (card A)\n\ngoal (1 subgoal):\n 1. map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n    rqs_cost (card A)", "."], ["proof (state)\nthis:\n  map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n  rqs_cost (card A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A)) =\n  rqs_cost (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We therefore have the same expectation as well. (Note that we showed \n  @{thm rqs_cost_exp_eq [no_vars]} and @{thm rqs_cost_exp_asymp_equiv [no_vars]} before.\n\\<close>"], ["", "corollary expectation_qs_cost: \n  assumes \"finite A\" and \"linorder_on B R\" and \"A \\<subseteq> B\"\n  defines \"random_list \\<equiv> pmf_of_set (permutations_of_set A)\"\n  shows   \"measure_pmf.expectation (map_pmf (qs_cost R) random_list) real = \n             rqs_cost_exp (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (map_pmf (qs_cost R) random_list) real =\n    rqs_cost_exp (card A)", "unfolding random_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (map_pmf (qs_cost R) (pmf_of_set (permutations_of_set A))) real =\n    rqs_cost_exp (card A)", "by (subst qs_cost_average_conv_rqs_cost[OF assms(1-3)]) (simp add: expectation_rqs_cost)"], ["", "end"]]}