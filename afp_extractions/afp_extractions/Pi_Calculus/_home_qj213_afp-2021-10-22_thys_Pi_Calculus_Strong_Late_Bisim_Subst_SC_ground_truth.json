{"file_name": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus/Strong_Late_Bisim_Subst_SC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus", "problem_names": ["lemma matchId:\n  fixes a :: name\n  and   P :: pi\n\n  shows \"[a\\<frown>a]P \\<sim>\\<^sup>s P\"", "lemma mismatchNil:\n  fixes a :: name\n  and   P :: pi\n  \n  shows \"[a\\<noteq>a]P \\<sim>\\<^sup>s \\<zero>\"", "lemma scopeFresh:\n  fixes P :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>P \\<sim>\\<^sup>s P\"", "lemma resComm:\n  fixes P :: pi\n  and   x :: name\n  and   y :: name\n\n  shows \"<\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\"", "lemma sumZero:\n  fixes P :: pi\n  \n  shows \"P \\<oplus> \\<zero> \\<sim>\\<^sup>s P\"", "lemma sumSym:\n  fixes P :: pi\n  and   Q :: pi\n\n  shows \"P \\<oplus> Q \\<sim>\\<^sup>s Q \\<oplus> P\"", "lemma sumAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n  \n  shows \"(P \\<oplus> Q) \\<oplus> R \\<sim>\\<^sup>s P \\<oplus> (Q \\<oplus> R)\"", "lemma sumRes:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<oplus> <\\<nu>x>Q\"", "lemma scopeExtSum:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim>\\<^sup>s P \\<oplus> <\\<nu>x>Q\"", "lemma parZero:\n  fixes P :: pi\n  \n  shows \"P \\<parallel> \\<zero> \\<sim>\\<^sup>s P\"", "lemma parSym:\n  fixes P :: pi\n  and   Q :: pi\n\n  shows \"P \\<parallel> Q \\<sim>\\<^sup>s Q \\<parallel> P\"", "lemma parAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n  \n  shows \"(P \\<parallel> Q) \\<parallel> R \\<sim>\\<^sup>s P \\<parallel> (Q \\<parallel> R)\"", "lemma scopeExtPar:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s P \\<parallel> <\\<nu>x>Q\"", "lemma scopeExtPar':\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> Q\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s (<\\<nu>x>P) \\<parallel> Q\"", "lemma bangSC:\n  fixes P :: pi\n\n  shows \"!P \\<sim>\\<^sup>s P \\<parallel> !P\"", "lemma nilRes:\n  fixes x :: name\n  \n  shows \"<\\<nu>x>\\<zero> \\<sim>\\<^sup>s \\<zero>\"", "lemma resTau:\n  fixes x :: name\n  and   P :: pi\n\n  shows \"<\\<nu>x>(\\<tau>.(P)) \\<sim>\\<^sup>s \\<tau>.(<\\<nu>x>P)\"", "lemma resOutput:\n  fixes x :: name\n  and   a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> b\"\n\n  shows \"<\\<nu>x>(a{b}.(P)) \\<sim>\\<^sup>s a{b}.(<\\<nu>x>P)\"", "lemma resInput:\n  fixes x :: name\n  and   a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> y\"\n\n  shows \"<\\<nu>x>(a<y>.(P)) \\<sim>\\<^sup>s a<y>.(<\\<nu>x>P)\"", "lemma bisimSubstStructCong:\n  fixes P :: pi\n  and   Q :: pi\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n  shows \"P \\<sim>\\<^sup>s Q\""], "translations": [["", "lemma matchId:\n  fixes a :: name\n  and   P :: pi\n\n  shows \"[a\\<frown>a]P \\<sim>\\<^sup>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<frown>a]P \\<sim>\\<^sup>s P", "by(auto simp add: substClosed_def intro: Strong_Late_Bisim_SC.matchId)"], ["", "lemma mismatchNil:\n  fixes a :: name\n  and   P :: pi\n  \n  shows \"[a\\<noteq>a]P \\<sim>\\<^sup>s \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<noteq>a]P \\<sim>\\<^sup>s \\<zero>", "by(auto simp add: substClosed_def intro: Strong_Late_Bisim_SC.mismatchNil)"], ["", "lemma scopeFresh:\n  fixes P :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>P \\<sim>\\<^sup>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim>\\<^sup>s P", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>P[<\\<sigma>>] \\<sim> P[<\\<sigma>>]", "fix s :: \"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>P[<\\<sigma>>] \\<sim> P[<\\<sigma>>]", "have \"\\<exists>c::name. c \\<sharp> (P, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<sharp> (P, s)", "by(blast intro: name_exists_fresh)"], ["proof (state)\nthis:\n  \\<exists>c. c \\<sharp> (P, s)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>P[<\\<sigma>>] \\<sim> P[<\\<sigma>>]", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<sharp> (P, s)", "obtain c::name where cFreshP: \"c \\<sharp> P\" and cFreshs: \"c \\<sharp> s\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<sharp> (P, s)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<sharp> P; c \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(force simp add: fresh_prod)"], ["proof (state)\nthis:\n  c \\<sharp> P\n  c \\<sharp> s\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>P[<\\<sigma>>] \\<sim> P[<\\<sigma>>]", "have \"<\\<nu>x>P = <\\<nu>c>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>P = <\\<nu>c>P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>P = <\\<nu>c>P", "from cFreshP"], ["proof (chain)\npicking this:\n  c \\<sharp> P", "have \"<\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\""], ["proof (prove)\nusing this:\n  c \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P = <\\<nu>c>P", "with cFreshP xFreshP"], ["proof (chain)\npicking this:\n  c \\<sharp> P\n  x \\<sharp> P\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<sharp> P\n  x \\<sharp> P\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P = <\\<nu>c>P", "by(simp add: name_fresh_fresh)"], ["proof (state)\nthis:\n  <\\<nu>x>P = <\\<nu>c>P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x>P = <\\<nu>c>P\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>P[<\\<sigma>>] \\<sim> P[<\\<sigma>>]", "with cFreshP cFreshs"], ["proof (chain)\npicking this:\n  c \\<sharp> P\n  c \\<sharp> s\n  <\\<nu>x>P = <\\<nu>c>P", "show \"(<\\<nu>x>P)[<s>] \\<sim> P[<s>]\""], ["proof (prove)\nusing this:\n  c \\<sharp> P\n  c \\<sharp> s\n  <\\<nu>x>P = <\\<nu>c>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P[<s>] \\<sim> P[<s>]", "by(force intro: Strong_Late_Bisim_SC.scopeFresh)"], ["proof (state)\nthis:\n  <\\<nu>x>P[<s>] \\<sim> P[<s>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resComm:\n  fixes P :: pi\n  and   x :: name\n  and   y :: name\n\n  shows \"<\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "proof(cases \"x=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\n 2. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "assume xeqy: \"x=y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\n 2. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "have \"P \\<sim>\\<^sup>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sim>\\<^sup>s P", "by(rule Strong_Late_Bisim_Subst.reflexive)"], ["proof (state)\nthis:\n  P \\<sim>\\<^sup>s P\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\n 2. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "hence \"<\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P\""], ["proof (prove)\nusing this:\n  P \\<sim>\\<^sup>s P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P", "by(rule resPres)"], ["proof (state)\nthis:\n  <\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\n 2. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "hence \"<\\<nu>x><\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x><\\<nu>x>P\""], ["proof (prove)\nusing this:\n  <\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x><\\<nu>x>P", "by(rule resPres)"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x><\\<nu>x>P\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\n 2. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "with xeqy"], ["proof (chain)\npicking this:\n  x = y\n  <\\<nu>x><\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x><\\<nu>x>P", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n  <\\<nu>x><\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x><\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "by simp"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "assume xineqy: \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "fix s::\"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "have \"\\<exists>c::name. c \\<sharp> (P, s, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<sharp> (P, s, y)", "by(blast intro: name_exists_fresh)"], ["proof (state)\nthis:\n  \\<exists>c. c \\<sharp> (P, s, y)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<sharp> (P, s, y)", "obtain c::name where cFreshP: \"c \\<sharp> P\" and cFreshs: \"c \\<sharp> s\" and cineqy: \"c \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<sharp> (P, s, y)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<sharp> P; c \\<sharp> s; c \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(force simp add: fresh_prod)"], ["proof (state)\nthis:\n  c \\<sharp> P\n  c \\<sharp> s\n  c \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "have \"\\<exists>d::name. d \\<sharp> (P, s, c, x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. d \\<sharp> (P, s, c, x, y)", "by (blast intro: name_exists_fresh)"], ["proof (state)\nthis:\n  \\<exists>d. d \\<sharp> (P, s, c, x, y)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "then"], ["proof (chain)\npicking this:\n  \\<exists>d. d \\<sharp> (P, s, c, x, y)", "obtain d::name where dFreshP: \"d \\<sharp> P\" and dFreshs: \"d \\<sharp> s\" and dineqc: \"d \\<noteq> c\"\n                          and dineqx: \"d \\<noteq> x\" and dineqy: \"d \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<exists>d. d \\<sharp> (P, s, c, x, y)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<sharp> P; d \\<sharp> s; d \\<noteq> c; d \\<noteq> x;\n         d \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(force simp add: fresh_prod)"], ["proof (state)\nthis:\n  d \\<sharp> P\n  d \\<sharp> s\n  d \\<noteq> c\n  d \\<noteq> x\n  d \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "have \"<\\<nu>x><\\<nu>y>P = <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "from cineqy cFreshP"], ["proof (chain)\npicking this:\n  c \\<noteq> y\n  c \\<sharp> P", "have cFreshyP: \"c \\<sharp> <\\<nu>y>P\""], ["proof (prove)\nusing this:\n  c \\<noteq> y\n  c \\<sharp> P\n\ngoal (1 subgoal):\n 1. c \\<sharp> <\\<nu>y>P", "by(simp add: name_fresh_abs)"], ["proof (state)\nthis:\n  c \\<sharp> <\\<nu>y>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "from dFreshP"], ["proof (chain)\npicking this:\n  d \\<sharp> P", "have \"<\\<nu>y>P = <\\<nu>d>([(y, d)] \\<bullet> P)\""], ["proof (prove)\nusing this:\n  d \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>y>P = <\\<nu>d>([(y, d)] \\<bullet> P)", "by(rule alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>y>P = <\\<nu>d>([(y, d)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "moreover"], ["proof (state)\nthis:\n  <\\<nu>y>P = <\\<nu>d>([(y, d)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "from cFreshyP"], ["proof (chain)\npicking this:\n  c \\<sharp> <\\<nu>y>P", "have \"<\\<nu>x><\\<nu>y>P = <\\<nu>c>([(x, c)] \\<bullet> (<\\<nu>y>P))\""], ["proof (prove)\nusing this:\n  c \\<sharp> <\\<nu>y>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P = <\\<nu>c>([(x, c)] \\<bullet> <\\<nu>y>P)", "by(rule alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P = <\\<nu>c>([(x, c)] \\<bullet> <\\<nu>y>P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>y>P = <\\<nu>d>([(y, d)] \\<bullet> P)\n  <\\<nu>x><\\<nu>y>P = <\\<nu>c>([(x, c)] \\<bullet> <\\<nu>y>P)", "show ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>y>P = <\\<nu>d>([(y, d)] \\<bullet> P)\n  <\\<nu>x><\\<nu>y>P = <\\<nu>c>([(x, c)] \\<bullet> <\\<nu>y>P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "using dineqc dineqx"], ["proof (prove)\nusing this:\n  <\\<nu>y>P = <\\<nu>d>([(y, d)] \\<bullet> P)\n  <\\<nu>x><\\<nu>y>P = <\\<nu>c>([(x, c)] \\<bullet> <\\<nu>y>P)\n  d \\<noteq> c\n  d \\<noteq> x\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P =\n    <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "by(simp add: name_calc)"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P =\n  <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P =\n  <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P =\n  <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "have \"<\\<nu>y><\\<nu>x>P = <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "from dineqx dFreshP"], ["proof (chain)\npicking this:\n  d \\<noteq> x\n  d \\<sharp> P", "have dFreshxP: \"d \\<sharp> <\\<nu>x>P\""], ["proof (prove)\nusing this:\n  d \\<noteq> x\n  d \\<sharp> P\n\ngoal (1 subgoal):\n 1. d \\<sharp> <\\<nu>x>P", "by(simp add: name_fresh_abs)"], ["proof (state)\nthis:\n  d \\<sharp> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "from cFreshP"], ["proof (chain)\npicking this:\n  c \\<sharp> P", "have \"<\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\""], ["proof (prove)\nusing this:\n  c \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)", "by(rule alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "from dFreshxP"], ["proof (chain)\npicking this:\n  d \\<sharp> <\\<nu>x>P", "have \"<\\<nu>y><\\<nu>x>P = <\\<nu>d>([(y, d)] \\<bullet> (<\\<nu>x>P))\""], ["proof (prove)\nusing this:\n  d \\<sharp> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P = <\\<nu>d>([(y, d)] \\<bullet> <\\<nu>x>P)", "by(rule alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>y><\\<nu>x>P = <\\<nu>d>([(y, d)] \\<bullet> <\\<nu>x>P)\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n  <\\<nu>y><\\<nu>x>P = <\\<nu>d>([(y, d)] \\<bullet> <\\<nu>x>P)", "have \"<\\<nu>y><\\<nu>x>P = <\\<nu>d><\\<nu>c>([(y, d)] \\<bullet> [(x, c)] \\<bullet> P)\""], ["proof (prove)\nusing this:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n  <\\<nu>y><\\<nu>x>P = <\\<nu>d>([(y, d)] \\<bullet> <\\<nu>x>P)\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(y, d)] \\<bullet> [(x, c)] \\<bullet> P)", "using dineqc cineqy"], ["proof (prove)\nusing this:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n  <\\<nu>y><\\<nu>x>P = <\\<nu>d>([(y, d)] \\<bullet> <\\<nu>x>P)\n  d \\<noteq> c\n  c \\<noteq> y\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(y, d)] \\<bullet> [(x, c)] \\<bullet> P)", "by(simp add: name_calc)"], ["proof (state)\nthis:\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(y, d)] \\<bullet> [(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(y, d)] \\<bullet> [(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "using dineqx dineqc cineqy xineqy"], ["proof (prove)\nusing this:\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(y, d)] \\<bullet> [(x, c)] \\<bullet> P)\n  d \\<noteq> x\n  d \\<noteq> c\n  c \\<noteq> y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>P =\n    <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "by(subst name_perm_compose, simp add: name_calc)"], ["proof (state)\nthis:\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x><\\<nu>y>P[<\\<sigma>>] \\<sim> <\\<nu>y><\\<nu>x>P[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x><\\<nu>y>P =\n  <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)", "show \"(<\\<nu>x><\\<nu>y>P)[<s>] \\<sim> (<\\<nu>y><\\<nu>x>P)[<s>]\""], ["proof (prove)\nusing this:\n  <\\<nu>x><\\<nu>y>P =\n  <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P[<s>] \\<sim> <\\<nu>y><\\<nu>x>P[<s>]", "using cFreshs dFreshs"], ["proof (prove)\nusing this:\n  <\\<nu>x><\\<nu>y>P =\n  <\\<nu>c><\\<nu>d>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n  <\\<nu>y><\\<nu>x>P =\n  <\\<nu>d><\\<nu>c>([(x, c)] \\<bullet> [(y, d)] \\<bullet> P)\n  c \\<sharp> s\n  d \\<sharp> s\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P[<s>] \\<sim> <\\<nu>y><\\<nu>x>P[<s>]", "by(force intro: Strong_Late_Bisim_SC.resComm)"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P[<s>] \\<sim> <\\<nu>y><\\<nu>x>P[<s>]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P \\<sim>\\<^sup>s <\\<nu>y><\\<nu>x>P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumZero:\n  fixes P :: pi\n  \n  shows \"P \\<oplus> \\<zero> \\<sim>\\<^sup>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim>\\<^sup>s P", "by(force simp add: substClosed_def intro: Strong_Late_Bisim_SC.sumZero)"], ["", "lemma sumSym:\n  fixes P :: pi\n  and   Q :: pi\n\n  shows \"P \\<oplus> Q \\<sim>\\<^sup>s Q \\<oplus> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim>\\<^sup>s Q \\<oplus> P", "by(force simp add: substClosed_def intro: Strong_Late_Bisim_SC.sumSym)"], ["", "lemma sumAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n  \n  shows \"(P \\<oplus> Q) \\<oplus> R \\<sim>\\<^sup>s P \\<oplus> (Q \\<oplus> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q) \\<oplus> R \\<sim>\\<^sup>s P \\<oplus> Q \\<oplus> R", "by(force simp add: substClosed_def intro: Strong_Late_Bisim_SC.sumAssoc)"], ["", "lemma sumRes:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<oplus> <\\<nu>x>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "fix s :: \"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "have \"\\<exists>c::name. c \\<sharp> (P, Q, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<sharp> (P, Q, s)", "by(blast intro: name_exists_fresh)"], ["proof (state)\nthis:\n  \\<exists>c. c \\<sharp> (P, Q, s)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<sharp> (P, Q, s)", "obtain c::name where cFreshP: \"c \\<sharp> P\" and cFreshQ: \"c \\<sharp> Q\" and cFreshs: \"c \\<sharp> s\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<sharp> (P, Q, s)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<sharp> P; c \\<sharp> Q; c \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(force simp add: fresh_prod)"], ["proof (state)\nthis:\n  c \\<sharp> P\n  c \\<sharp> Q\n  c \\<sharp> s\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "have \"<\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) =\n    <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) =\n    <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))", "from cFreshP cFreshQ"], ["proof (chain)\npicking this:\n  c \\<sharp> P\n  c \\<sharp> Q", "have \"c \\<sharp> P \\<oplus> Q\""], ["proof (prove)\nusing this:\n  c \\<sharp> P\n  c \\<sharp> Q\n\ngoal (1 subgoal):\n 1. c \\<sharp> P \\<oplus> Q", "by simp"], ["proof (state)\nthis:\n  c \\<sharp> P \\<oplus> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) =\n    <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))", "hence \"<\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> (P \\<oplus> Q))\""], ["proof (prove)\nusing this:\n  c \\<sharp> P \\<oplus> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<oplus> Q)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<oplus> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) =\n    <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))", "thus ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<oplus> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) =\n    <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))", "by(simp add: name_fresh_fresh)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) =\n  <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) =\n  <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) =\n  <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "from cFreshP"], ["proof (chain)\npicking this:\n  c \\<sharp> P", "have \"<\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\""], ["proof (prove)\nusing this:\n  c \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "from cFreshQ"], ["proof (chain)\npicking this:\n  c \\<sharp> Q", "have \"<\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  c \\<sharp> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       <\\<nu>x>P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>(P \\<oplus> Q) =\n  <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)", "show \"(<\\<nu>x>(P \\<oplus> Q))[<s>] \\<sim> (<\\<nu>x>P)[<s>] \\<oplus> (<\\<nu>x>Q)[<s>]\""], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<oplus> Q) =\n  <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q)[<s>] \\<sim>\n    <\\<nu>x>P[<s>] \\<oplus> <\\<nu>x>Q[<s>]", "using cFreshs"], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<oplus> Q) =\n  <\\<nu>c>(([(x, c)] \\<bullet> P) \\<oplus> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>P = <\\<nu>c>([(x, c)] \\<bullet> P)\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n  c \\<sharp> s\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q)[<s>] \\<sim>\n    <\\<nu>x>P[<s>] \\<oplus> <\\<nu>x>Q[<s>]", "by(force intro: Strong_Late_Bisim_SC.sumRes)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q)[<s>] \\<sim> <\\<nu>x>P[<s>] \\<oplus> <\\<nu>x>Q[<s>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeExtSum:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim>\\<^sup>s P \\<oplus> <\\<nu>x>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim>\\<^sup>s P \\<oplus> <\\<nu>x>Q", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "fix s :: \"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "have \"\\<exists>c::name. c \\<sharp> (P, Q, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<sharp> (P, Q, s)", "by(blast intro: name_exists_fresh)"], ["proof (state)\nthis:\n  \\<exists>c. c \\<sharp> (P, Q, s)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<sharp> (P, Q, s)", "obtain c::name where cFreshP: \"c \\<sharp> P\" and cFreshQ: \"c \\<sharp> Q\" and cFreshs: \"c \\<sharp> s\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<sharp> (P, Q, s)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<sharp> P; c \\<sharp> Q; c \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(force simp add: fresh_prod)"], ["proof (state)\nthis:\n  c \\<sharp> P\n  c \\<sharp> Q\n  c \\<sharp> s\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "have \"<\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))", "from cFreshP cFreshQ"], ["proof (chain)\npicking this:\n  c \\<sharp> P\n  c \\<sharp> Q", "have \"c \\<sharp> P \\<oplus> Q\""], ["proof (prove)\nusing this:\n  c \\<sharp> P\n  c \\<sharp> Q\n\ngoal (1 subgoal):\n 1. c \\<sharp> P \\<oplus> Q", "by simp"], ["proof (state)\nthis:\n  c \\<sharp> P \\<oplus> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))", "hence \"<\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> (P \\<oplus> Q))\""], ["proof (prove)\nusing this:\n  c \\<sharp> P \\<oplus> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<oplus> Q)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<oplus> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))", "with xFreshP cFreshP"], ["proof (chain)\npicking this:\n  x \\<sharp> P\n  c \\<sharp> P\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<oplus> Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  c \\<sharp> P\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<oplus> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))", "by(simp add: name_fresh_fresh)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "from cFreshQ"], ["proof (chain)\npicking this:\n  c \\<sharp> Q", "have \"<\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  c \\<sharp> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<oplus> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<oplus> <\\<nu>x>Q[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)", "show \"(<\\<nu>x>(P \\<oplus> Q))[<s>] \\<sim> P[<s>] \\<oplus> (<\\<nu>x>Q)[<s>]\""], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q)[<s>] \\<sim> P[<s>] \\<oplus> <\\<nu>x>Q[<s>]", "using cFreshs cFreshP"], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<oplus> Q) = <\\<nu>c>(P \\<oplus> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n  c \\<sharp> s\n  c \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q)[<s>] \\<sim> P[<s>] \\<oplus> <\\<nu>x>Q[<s>]", "by(force intro: Strong_Late_Bisim_SC.scopeExtSum)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q)[<s>] \\<sim> P[<s>] \\<oplus> <\\<nu>x>Q[<s>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parZero:\n  fixes P :: pi\n  \n  shows \"P \\<parallel> \\<zero> \\<sim>\\<^sup>s P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim>\\<^sup>s P", "by(force simp add: substClosed_def intro: Strong_Late_Bisim_SC.parZero)"], ["", "lemma parSym:\n  fixes P :: pi\n  and   Q :: pi\n\n  shows \"P \\<parallel> Q \\<sim>\\<^sup>s Q \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim>\\<^sup>s Q \\<parallel> P", "by(force simp add: substClosed_def intro: Strong_Late_Bisim_SC.parSym)"], ["", "lemma parAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n  \n  shows \"(P \\<parallel> Q) \\<parallel> R \\<sim>\\<^sup>s P \\<parallel> (Q \\<parallel> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim>\\<^sup>s\n    P \\<parallel> Q \\<parallel> R", "by(force simp add: substClosed_def intro: Strong_Late_Bisim_SC.parAssoc)"], ["", "lemma scopeExtPar:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s P \\<parallel> <\\<nu>x>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s P \\<parallel> <\\<nu>x>Q", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<parallel> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<parallel> <\\<nu>x>Q[<\\<sigma>>]", "fix s :: \"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<parallel> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<parallel> <\\<nu>x>Q[<\\<sigma>>]", "have \"\\<exists>c::name. c \\<sharp> (P, Q, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<sharp> (P, Q, s)", "by(blast intro: name_exists_fresh)"], ["proof (state)\nthis:\n  \\<exists>c. c \\<sharp> (P, Q, s)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<parallel> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<parallel> <\\<nu>x>Q[<\\<sigma>>]", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. c \\<sharp> (P, Q, s)", "obtain c::name where cFreshP: \"c \\<sharp> P\" and cFreshQ: \"c \\<sharp> Q\" and cFreshs: \"c \\<sharp> s\""], ["proof (prove)\nusing this:\n  \\<exists>c. c \\<sharp> (P, Q, s)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<sharp> P; c \\<sharp> Q; c \\<sharp> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(force simp add: fresh_prod)"], ["proof (state)\nthis:\n  c \\<sharp> P\n  c \\<sharp> Q\n  c \\<sharp> s\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<parallel> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<parallel> <\\<nu>x>Q[<\\<sigma>>]", "have \"<\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) =\n    <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) =\n    <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))", "from cFreshP cFreshQ"], ["proof (chain)\npicking this:\n  c \\<sharp> P\n  c \\<sharp> Q", "have \"c \\<sharp> P \\<parallel> Q\""], ["proof (prove)\nusing this:\n  c \\<sharp> P\n  c \\<sharp> Q\n\ngoal (1 subgoal):\n 1. c \\<sharp> P \\<parallel> Q", "by simp"], ["proof (state)\nthis:\n  c \\<sharp> P \\<parallel> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) =\n    <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))", "hence \"<\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>([(x, c)] \\<bullet> (P \\<parallel> Q))\""], ["proof (prove)\nusing this:\n  c \\<sharp> P \\<parallel> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<parallel> Q)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<parallel> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) =\n    <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))", "with xFreshP cFreshP"], ["proof (chain)\npicking this:\n  x \\<sharp> P\n  c \\<sharp> P\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<parallel> Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  c \\<sharp> P\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>([(x, c)] \\<bullet> P \\<parallel> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) =\n    <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))", "by(simp add: name_fresh_fresh)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<parallel> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<parallel> <\\<nu>x>Q[<\\<sigma>>]", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<parallel> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<parallel> <\\<nu>x>Q[<\\<sigma>>]", "from cFreshQ"], ["proof (chain)\npicking this:\n  c \\<sharp> Q", "have \"<\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\""], ["proof (prove)\nusing this:\n  c \\<sharp> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)", "by(simp add: alphaRes)"], ["proof (state)\nthis:\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>(P \\<parallel> Q)[<\\<sigma>>] \\<sim>\n       P[<\\<sigma>>] \\<parallel> <\\<nu>x>Q[<\\<sigma>>]", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)", "show \"(<\\<nu>x>(P \\<parallel> Q))[<s>] \\<sim> P[<s>] \\<parallel> (<\\<nu>x>Q)[<s>]\""], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q)[<s>] \\<sim> P[<s>] \\<parallel> <\\<nu>x>Q[<s>]", "using cFreshs cFreshP"], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<parallel> Q) = <\\<nu>c>(P \\<parallel> ([(x, c)] \\<bullet> Q))\n  <\\<nu>x>Q = <\\<nu>c>([(x, c)] \\<bullet> Q)\n  c \\<sharp> s\n  c \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q)[<s>] \\<sim> P[<s>] \\<parallel> <\\<nu>x>Q[<s>]", "by(force intro: Strong_Late_Bisim_SC.scopeExtPar)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q)[<s>] \\<sim> P[<s>] \\<parallel> <\\<nu>x>Q[<s>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeExtPar':\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshP: \"x \\<sharp> Q\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s (<\\<nu>x>P) \\<parallel> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "have \"<\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>(Q \\<parallel> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>(Q \\<parallel> P)", "by(blast intro: parSym resPres)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>(Q \\<parallel> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>(Q \\<parallel> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "from xFreshP"], ["proof (chain)\npicking this:\n  x \\<sharp> Q", "have \"<\\<nu>x>(Q \\<parallel> P) \\<sim>\\<^sup>s Q \\<parallel> <\\<nu>x>P\""], ["proof (prove)\nusing this:\n  x \\<sharp> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(Q \\<parallel> P) \\<sim>\\<^sup>s Q \\<parallel> <\\<nu>x>P", "by(rule scopeExtPar)"], ["proof (state)\nthis:\n  <\\<nu>x>(Q \\<parallel> P) \\<sim>\\<^sup>s Q \\<parallel> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(Q \\<parallel> P) \\<sim>\\<^sup>s Q \\<parallel> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "have \"Q \\<parallel> <\\<nu>x>P \\<sim>\\<^sup>s (<\\<nu>x>P) \\<parallel> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<parallel> <\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "by(rule parSym)"], ["proof (state)\nthis:\n  Q \\<parallel> <\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>(Q \\<parallel> P)\n  <\\<nu>x>(Q \\<parallel> P) \\<sim>\\<^sup>s Q \\<parallel> <\\<nu>x>P\n  Q \\<parallel> <\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>(Q \\<parallel> P)\n  <\\<nu>x>(Q \\<parallel> P) \\<sim>\\<^sup>s Q \\<parallel> <\\<nu>x>P\n  Q \\<parallel> <\\<nu>x>P \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q", "by (blast intro: transitive)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim>\\<^sup>s <\\<nu>x>P \\<parallel> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bangSC:\n  fixes P :: pi\n\n  shows \"!P \\<sim>\\<^sup>s P \\<parallel> !P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. !P \\<sim>\\<^sup>s P \\<parallel> !P", "by(auto simp add: substClosed_def intro: Strong_Late_Bisim_SC.bangSC)"], ["", "lemma nilRes:\n  fixes x :: name\n  \n  shows \"<\\<nu>x>\\<zero> \\<sim>\\<^sup>s \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero> \\<sim>\\<^sup>s \\<zero>", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>", "fix \\<sigma>::\"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>", "obtain y::name where \"y \\<sharp> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<sharp> \\<sigma> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") auto"], ["proof (state)\nthis:\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>", "have \"<\\<nu>y>\\<zero> \\<sim> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>y>\\<zero> \\<sim> \\<zero>", "by (rule Strong_Late_Bisim_SC.nilRes)"], ["proof (state)\nthis:\n  <\\<nu>y>\\<zero> \\<sim> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>", "with \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> \\<sigma>\n  <\\<nu>y>\\<zero> \\<sim> \\<zero>", "have \"(<\\<nu>y>\\<zero>)[<\\<sigma>>] \\<sim> \\<zero>\""], ["proof (prove)\nusing this:\n  y \\<sharp> \\<sigma>\n  <\\<nu>y>\\<zero> \\<sim> \\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>y>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>", "by simp"], ["proof (state)\nthis:\n  <\\<nu>y>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>. <\\<nu>x>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>", "thus \"(<\\<nu>x>\\<zero>)[<\\<sigma>>] \\<sim> \\<zero>\""], ["proof (prove)\nusing this:\n  <\\<nu>y>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>", "by(subst alphaRes[where c=y]) auto"], ["proof (state)\nthis:\n  <\\<nu>x>\\<zero>[<\\<sigma>>] \\<sim> \\<zero>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resTau:\n  fixes x :: name\n  and   P :: pi\n\n  shows \"<\\<nu>x>(\\<tau>.(P)) \\<sim>\\<^sup>s \\<tau>.(<\\<nu>x>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<tau>.P \\<sim>\\<^sup>s \\<tau>.(<\\<nu>x>P)", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>\\<tau>.P[<\\<sigma>>] \\<sim> \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "fix \\<sigma>::\"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>\\<tau>.P[<\\<sigma>>] \\<sim> \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "obtain y::name where \"y \\<sharp> P\" and \"y \\<sharp> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> P; y \\<sharp> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  y \\<sharp> P\n  y \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>\\<tau>.P[<\\<sigma>>] \\<sim> \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "have \"<\\<nu>y>(\\<tau>.(([(x, y)] \\<bullet> P)[<\\<sigma>>])) \\<sim> \\<tau>.(<\\<nu>y>(([(x, y)] \\<bullet> P)[<\\<sigma>>]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>y>\\<tau>.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n    \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])", "by(rule resTau)"], ["proof (state)\nthis:\n  <\\<nu>y>\\<tau>.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>\\<tau>.P[<\\<sigma>>] \\<sim> \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "with \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> \\<sigma>\n  <\\<nu>y>\\<tau>.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])", "have \"(<\\<nu>y>(\\<tau>.([(x, y)] \\<bullet> P)))[<\\<sigma>>] \\<sim> (\\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P)))[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  y \\<sharp> \\<sigma>\n  <\\<nu>y>\\<tau>.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n    \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]", "by simp"], ["proof (state)\nthis:\n  <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>\\<tau>.P[<\\<sigma>>] \\<sim> \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "with \\<open>y \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> P\n  <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]", "show \"(<\\<nu>x>\\<tau>.(P))[<\\<sigma>>] \\<sim> \\<tau>.((<\\<nu>x>P)[<\\<sigma>>])\""], ["proof (prove)\nusing this:\n  y \\<sharp> P\n  <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<tau>.P[<\\<sigma>>] \\<sim> \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "apply(subst alphaRes[where c=y])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> P;\n     <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> \\<tau>.P\n 2. \\<lbrakk>y \\<sharp> P;\n     <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>y>([(x, y)] \\<bullet>\n                               \\<tau>.P)[<\\<sigma>>] \\<sim>\n                      \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> P;\n     <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>y>([(x, y)] \\<bullet>\n                               \\<tau>.P)[<\\<sigma>>] \\<sim>\n                      \\<tau>.(<\\<nu>x>P[<\\<sigma>>])", "apply(subst alphaRes[where c=y and a=x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> P;\n     <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> P\n 2. \\<lbrakk>y \\<sharp> P;\n     <\\<nu>y>\\<tau>.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>y>([(x, y)] \\<bullet>\n                               \\<tau>.P)[<\\<sigma>>] \\<sim>\n                      \\<tau>.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])", "by simp+"], ["proof (state)\nthis:\n  <\\<nu>x>\\<tau>.P[<\\<sigma>>] \\<sim> \\<tau>.(<\\<nu>x>P[<\\<sigma>>])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resOutput:\n  fixes x :: name\n  and   a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> b\"\n\n  shows \"<\\<nu>x>(a{b}.(P)) \\<sim>\\<^sup>s a{b}.(<\\<nu>x>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim>\\<^sup>s a{b}.(<\\<nu>x>P)", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a{b}.P[<\\<sigma>>] \\<sim>\n       seq_subst_name a\n        \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "fix \\<sigma>::\"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a{b}.P[<\\<sigma>>] \\<sim>\n       seq_subst_name a\n        \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "obtain y::name where \"y \\<sharp> P\" and \"y \\<sharp> \\<sigma>\" and \"y \\<noteq> a\" and \"y \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<sharp> P; y \\<sharp> \\<sigma>; y \\<noteq> a;\n         y \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  y \\<sharp> P\n  y \\<sharp> \\<sigma>\n  y \\<noteq> a\n  y \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a{b}.P[<\\<sigma>>] \\<sim>\n       seq_subst_name a\n        \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "have \"<\\<nu>y>((seq_subst_name a \\<sigma>){seq_subst_name b \\<sigma>}.(([(x, y)] \\<bullet> P)[<\\<sigma>>])) \\<sim> seq_subst_name a \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>y>(([(x, y)] \\<bullet> P)[<\\<sigma>>]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>y>seq_subst_name a\n             \\<sigma>{seq_subst_name b\n                       \\<sigma>}.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n    seq_subst_name a\n     \\<sigma>{seq_subst_name b\n               \\<sigma>}.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])", "using \\<open>y \\<noteq> a\\<close> \\<open>y \\<noteq> b\\<close> \\<open>y \\<sharp> \\<sigma>\\<close> freshSeqSubstName"], ["proof (prove)\nusing this:\n  y \\<noteq> a\n  y \\<noteq> b\n  y \\<sharp> \\<sigma>\n  \\<lbrakk>?x \\<noteq> ?a; ?x \\<sharp> ?s\\<rbrakk>\n  \\<Longrightarrow> ?x \\<noteq> seq_subst_name ?a ?s\n\ngoal (1 subgoal):\n 1. <\\<nu>y>seq_subst_name a\n             \\<sigma>{seq_subst_name b\n                       \\<sigma>}.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n    seq_subst_name a\n     \\<sigma>{seq_subst_name b\n               \\<sigma>}.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])", "by(rule_tac resOutput) auto"], ["proof (state)\nthis:\n  <\\<nu>y>seq_subst_name a\n           \\<sigma>{seq_subst_name b\n                     \\<sigma>}.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  seq_subst_name a\n   \\<sigma>{seq_subst_name b\n             \\<sigma>}.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a{b}.P[<\\<sigma>>] \\<sim>\n       seq_subst_name a\n        \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "with \\<open>y \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> \\<sigma>\n  <\\<nu>y>seq_subst_name a\n           \\<sigma>{seq_subst_name b\n                     \\<sigma>}.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  seq_subst_name a\n   \\<sigma>{seq_subst_name b\n             \\<sigma>}.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])", "have \"(<\\<nu>y>(a{b}.([(x, y)] \\<bullet> P)))[<\\<sigma>>] \\<sim> (a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P)))[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  y \\<sharp> \\<sigma>\n  <\\<nu>y>seq_subst_name a\n           \\<sigma>{seq_subst_name b\n                     \\<sigma>}.(([(x, y)] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  seq_subst_name a\n   \\<sigma>{seq_subst_name b\n             \\<sigma>}.(<\\<nu>y>([(x, y)] \\<bullet> P)[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n    a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]", "by simp"], ["proof (state)\nthis:\n  <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a{b}.P[<\\<sigma>>] \\<sim>\n       seq_subst_name a\n        \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "with \\<open>y \\<sharp> P\\<close> \\<open>y \\<noteq> a\\<close> \\<open>y \\<noteq> b\\<close> \\<open>x \\<noteq> a\\<close> \\<open>x \\<noteq> b\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> P\n  y \\<noteq> a\n  y \\<noteq> b\n  x \\<noteq> a\n  x \\<noteq> b\n  <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]", "show \"(<\\<nu>x>a{b}.(P))[<\\<sigma>>] \\<sim> seq_subst_name a \\<sigma>{seq_subst_name b \\<sigma>}.((<\\<nu>x>P)[<\\<sigma>>])\""], ["proof (prove)\nusing this:\n  y \\<sharp> P\n  y \\<noteq> a\n  y \\<noteq> b\n  x \\<noteq> a\n  x \\<noteq> b\n  <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P[<\\<sigma>>] \\<sim>\n    seq_subst_name a\n     \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "apply(subst alphaRes[where c=y])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> P; y \\<noteq> a; y \\<noteq> b; x \\<noteq> a;\n     x \\<noteq> b;\n     <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> a{b}.P\n 2. \\<lbrakk>y \\<sharp> P; y \\<noteq> a; y \\<noteq> b; x \\<noteq> a;\n     x \\<noteq> b;\n     <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>y>([(x, y)] \\<bullet> a{b}.P)[<\\<sigma>>] \\<sim>\n                      seq_subst_name a\n                       \\<sigma>{seq_subst_name b\n                                 \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<sharp> P; y \\<noteq> a; y \\<noteq> b; x \\<noteq> a;\n     x \\<noteq> b;\n     <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>y>([(x, y)] \\<bullet> a{b}.P)[<\\<sigma>>] \\<sim>\n                      seq_subst_name a\n                       \\<sigma>{seq_subst_name b\n                                 \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])", "apply(subst alphaRes[where c=y and a=x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y \\<sharp> P; y \\<noteq> a; y \\<noteq> b; x \\<noteq> a;\n     x \\<noteq> b;\n     <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y \\<sharp> P\n 2. \\<lbrakk>y \\<sharp> P; y \\<noteq> a; y \\<noteq> b; x \\<noteq> a;\n     x \\<noteq> b;\n     <\\<nu>y>a{b}.([(x, y)] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a{b}.(<\\<nu>y>([(x, y)] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>y>([(x, y)] \\<bullet> a{b}.P)[<\\<sigma>>] \\<sim>\n                      seq_subst_name a\n                       \\<sigma>{seq_subst_name b\n                                 \\<sigma>}.(<\\<nu>y>([(x, y)] \\<bullet>\n               P)[<\\<sigma>>])", "by simp+"], ["proof (state)\nthis:\n  <\\<nu>x>a{b}.P[<\\<sigma>>] \\<sim>\n  seq_subst_name a\n   \\<sigma>{seq_subst_name b \\<sigma>}.(<\\<nu>x>P[<\\<sigma>>])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resInput:\n  fixes x :: name\n  and   a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> y\"\n\n  shows \"<\\<nu>x>(a<y>.(P)) \\<sim>\\<^sup>s a<y>.(<\\<nu>x>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim>\\<^sup>s a<y>.(<\\<nu>x>P)", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "fix \\<sigma>::\"(name \\<times> name) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "obtain x'::name where \"x' \\<sharp> P\" and \"x' \\<sharp> \\<sigma>\" and \"x' \\<noteq> a\" and \"x' \\<noteq> x\" and \"x' \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<sharp> P; x' \\<sharp> \\<sigma>; x' \\<noteq> a;\n         x' \\<noteq> x; x' \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  x' \\<sharp> P\n  x' \\<sharp> \\<sigma>\n  x' \\<noteq> a\n  x' \\<noteq> x\n  x' \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "obtain y'::name where \"y' \\<sharp> P\" and \"y' \\<sharp> \\<sigma>\" and \"y' \\<noteq> a\" and \"y' \\<noteq> x\" and \"y' \\<noteq> y\" and \"x' \\<noteq> y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y' \\<sharp> P; y' \\<sharp> \\<sigma>; y' \\<noteq> a;\n         y' \\<noteq> x; y' \\<noteq> y; x' \\<noteq> y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\", auto)"], ["proof (state)\nthis:\n  y' \\<sharp> P\n  y' \\<sharp> \\<sigma>\n  y' \\<noteq> a\n  y' \\<noteq> x\n  y' \\<noteq> y\n  x' \\<noteq> y'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "have \"<\\<nu>x'>((seq_subst_name a \\<sigma>)<y'>.(([(y, y')] \\<bullet> [(x, x')] \\<bullet> P)[<\\<sigma>>])) \\<sim> seq_subst_name a \\<sigma><y'>.(<\\<nu>x'>(([(y, y')] \\<bullet> [(x, x')] \\<bullet> P)[<\\<sigma>>]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x'>seq_subst_name a\n              \\<sigma><y'>.(([(y, y')] \\<bullet>\n                             [(x, x')] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n    seq_subst_name a\n     \\<sigma><y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                             [(x, x')] \\<bullet> P)[<\\<sigma>>])", "using \\<open>x' \\<noteq> a\\<close> \\<open>x' \\<noteq> y'\\<close> \\<open>x' \\<sharp> \\<sigma>\\<close> \\<open>y' \\<sharp> \\<sigma>\\<close> freshSeqSubstName"], ["proof (prove)\nusing this:\n  x' \\<noteq> a\n  x' \\<noteq> y'\n  x' \\<sharp> \\<sigma>\n  y' \\<sharp> \\<sigma>\n  \\<lbrakk>?x \\<noteq> ?a; ?x \\<sharp> ?s\\<rbrakk>\n  \\<Longrightarrow> ?x \\<noteq> seq_subst_name ?a ?s\n\ngoal (1 subgoal):\n 1. <\\<nu>x'>seq_subst_name a\n              \\<sigma><y'>.(([(y, y')] \\<bullet>\n                             [(x, x')] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n    seq_subst_name a\n     \\<sigma><y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                             [(x, x')] \\<bullet> P)[<\\<sigma>>])", "by(rule_tac resInput) auto"], ["proof (state)\nthis:\n  <\\<nu>x'>seq_subst_name a\n            \\<sigma><y'>.(([(y, y')] \\<bullet>\n                           [(x, x')] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  seq_subst_name a\n   \\<sigma><y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                           [(x, x')] \\<bullet> P)[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "with \\<open>x' \\<sharp> \\<sigma>\\<close> \\<open>y' \\<sharp> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  x' \\<sharp> \\<sigma>\n  y' \\<sharp> \\<sigma>\n  <\\<nu>x'>seq_subst_name a\n            \\<sigma><y'>.(([(y, y')] \\<bullet>\n                           [(x, x')] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  seq_subst_name a\n   \\<sigma><y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                           [(x, x')] \\<bullet> P)[<\\<sigma>>])", "have \"(<\\<nu>x'>(a<y'>.([(y, y')] \\<bullet> [(x, x')] \\<bullet> P)))[<\\<sigma>>] \\<sim> (a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet> [(x, x')] \\<bullet> P)))[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  x' \\<sharp> \\<sigma>\n  y' \\<sharp> \\<sigma>\n  <\\<nu>x'>seq_subst_name a\n            \\<sigma><y'>.(([(y, y')] \\<bullet>\n                           [(x, x')] \\<bullet> P)[<\\<sigma>>]) \\<sim>\n  seq_subst_name a\n   \\<sigma><y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                           [(x, x')] \\<bullet> P)[<\\<sigma>>])\n\ngoal (1 subgoal):\n 1. <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                    [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n    a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet> [(x, x')] \\<bullet> P))[<\\<sigma>>]", "by simp"], ["proof (state)\nthis:\n  <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                  [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet> [(x, x')] \\<bullet> P))[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "with \\<open>x' \\<sharp> P\\<close> \\<open>y' \\<noteq> x\\<close> \\<open>x' \\<noteq> y\\<close> \\<open>y' \\<sharp> P\\<close> \\<open>x' \\<noteq> y'\\<close> \\<open>x' \\<noteq> a\\<close> \\<open>y' \\<noteq> a\\<close> \\<open>x \\<noteq> a\\<close> \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x' \\<sharp> P\n  y' \\<noteq> x\n  x' \\<noteq> y\n  y' \\<sharp> P\n  x' \\<noteq> y'\n  x' \\<noteq> a\n  y' \\<noteq> a\n  x \\<noteq> a\n  x \\<noteq> y\n  <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                  [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet> [(x, x')] \\<bullet> P))[<\\<sigma>>]", "show \"(<\\<nu>x>a<y>.(P))[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]\""], ["proof (prove)\nusing this:\n  x' \\<sharp> P\n  y' \\<noteq> x\n  x' \\<noteq> y\n  y' \\<sharp> P\n  x' \\<noteq> y'\n  x' \\<noteq> a\n  y' \\<noteq> a\n  x \\<noteq> a\n  x \\<noteq> y\n  <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                  [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n  a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet> [(x, x')] \\<bullet> P))[<\\<sigma>>]\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "apply(subst alphaInput[where c=y'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y' \\<sharp> P\n 2. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x>a<y'>.([(y, y')] \\<bullet>\n                                     P)[<\\<sigma>>] \\<sim>\n                      a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x>a<y'>.([(y, y')] \\<bullet>\n                                     P)[<\\<sigma>>] \\<sim>\n                      a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "apply(subst alphaRes[where c=x'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> x' \\<sharp> a<y'>.([(y, y')] \\<bullet> P)\n 2. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>([(x, x')] \\<bullet>\n                                a<y'>.([(y, y')] \\<bullet>\n P))[<\\<sigma>>] \\<sim>\n                      a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "apply(simp add: abs_fresh fresh_left calc_atm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>([(x, x')] \\<bullet>\n                                a<y'>.([(y, y')] \\<bullet>\n P))[<\\<sigma>>] \\<sim>\n                      a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "apply(simp add: eqvts calc_atm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>a<y'>.([(x, x')] \\<bullet>\n[(y, y')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n                      a<y>.(<\\<nu>x>P)[<\\<sigma>>]", "apply(subst alphaRes[where c=x' and a=x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> x' \\<sharp> P\n 2. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>a<y'>.([(x, x')] \\<bullet>\n[(y, y')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n                      a<y>.(<\\<nu>x'>([(x, x')] \\<bullet> P))[<\\<sigma>>]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>a<y'>.([(x, x')] \\<bullet>\n[(y, y')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n                      a<y>.(<\\<nu>x'>([(x, x')] \\<bullet> P))[<\\<sigma>>]", "apply(subst alphaInput[where c=y' and x=y])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> y' \\<sharp> <\\<nu>x'>([(x, x')] \\<bullet> P)\n 2. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>a<y'>.([(x, x')] \\<bullet>\n[(y, y')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n                      a<y'>.([(y, y')] \\<bullet>\n                             <\\<nu>x'>([(x, x')] \\<bullet> P))[<\\<sigma>>]", "apply(simp add: abs_fresh fresh_left calc_atm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>a<y'>.([(x, x')] \\<bullet>\n[(y, y')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n                      a<y'>.([(y, y')] \\<bullet>\n                             <\\<nu>x'>([(x, x')] \\<bullet> P))[<\\<sigma>>]", "apply(simp add: eqvts calc_atm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>a<y'>.([(x, x')] \\<bullet>\n[(y, y')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n                      a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n [(x, x')] \\<bullet> P))[<\\<sigma>>]", "apply(subst perm_compose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<sharp> P; y' \\<noteq> x; x' \\<noteq> y; y' \\<sharp> P;\n     x' \\<noteq> y'; x' \\<noteq> a; y' \\<noteq> a; x \\<noteq> a;\n     x \\<noteq> y;\n     <\\<nu>x'>a<y'>.([(y, y')] \\<bullet>\n                     [(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n     a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n                      [(x, x')] \\<bullet> P))[<\\<sigma>>]\\<rbrakk>\n    \\<Longrightarrow> <\\<nu>x'>a<y'>.(([(x, x')] \\<bullet>\n [(y, y')]) \\<bullet>\n[(x, x')] \\<bullet> P)[<\\<sigma>>] \\<sim>\n                      a<y'>.(<\\<nu>x'>([(y, y')] \\<bullet>\n [(x, x')] \\<bullet> P))[<\\<sigma>>]", "by(simp add: eqvts calc_atm)"], ["proof (state)\nthis:\n  <\\<nu>x>a<y>.P[<\\<sigma>>] \\<sim> a<y>.(<\\<nu>x>P)[<\\<sigma>>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bisimSubstStructCong:\n  fixes P :: pi\n  and   Q :: pi\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n  shows \"P \\<sim>\\<^sup>s Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sim>\\<^sup>s Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<equiv>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. P \\<sim>\\<^sup>s Q", "apply(induct rule: structCong.induct)"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<And>P. P \\<sim>\\<^sup>s P\n 2. \\<And>P Q.\n       \\<lbrakk>P \\<equiv>\\<^sub>s Q; P \\<sim>\\<^sup>s Q\\<rbrakk>\n       \\<Longrightarrow> Q \\<sim>\\<^sup>s P\n 3. \\<And>P Q R.\n       \\<lbrakk>P \\<equiv>\\<^sub>s Q; P \\<sim>\\<^sup>s Q;\n        Q \\<equiv>\\<^sub>s R; Q \\<sim>\\<^sup>s R\\<rbrakk>\n       \\<Longrightarrow> P \\<sim>\\<^sup>s R\n 4. \\<And>P Q. P \\<oplus> Q \\<sim>\\<^sup>s Q \\<oplus> P\n 5. \\<And>P Q R.\n       (P \\<oplus> Q) \\<oplus> R \\<sim>\\<^sup>s P \\<oplus> Q \\<oplus> R\n 6. \\<And>P. P \\<oplus> \\<zero> \\<sim>\\<^sup>s P\n 7. \\<And>P Q. P \\<parallel> Q \\<sim>\\<^sup>s Q \\<parallel> P\n 8. \\<And>P Q R.\n       (P \\<parallel> Q) \\<parallel> R \\<sim>\\<^sup>s\n       P \\<parallel> Q \\<parallel> R\n 9. \\<And>P. P \\<parallel> \\<zero> \\<sim>\\<^sup>s P\n 10. \\<And>a P. [a\\<frown>a]P \\<sim>\\<^sup>s P\nA total of 18 subgoals...", "by(auto intro: reflexive symmetric transitive sumSym sumAssoc sumZero parSym parAssoc parZero\n               nilRes resComm resInput resOutput resTau sumRes scopeExtPar bangSC matchId mismatchId)"], ["", "end"]]}