{"file_name": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus/Agent.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus", "problem_names": ["lemma pt_id:\n  fixes x :: 'a\n    and a :: 'x\n\n  assumes pt: \"pt TYPE('a) TYPE('x)\"\n  and     at: \"at TYPE('x)\"\n  shows \"[(a, a)] \\<bullet> x = x\"", "lemma pt_swap:\n  fixes x :: 'a\n  and a :: 'x\n  and b :: 'x\n\n  assumes pt: \"pt TYPE('a) TYPE('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"[(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x\"", "lemmas name_fresh_abs = fresh_abs_fun_iff[OF pt_name_inst, OF at_name_inst, OF fs_name1]", "lemmas name_bij = at_bij[OF at_name_inst]", "lemmas name_supp_abs = abs_fun_supp[OF pt_name_inst, OF at_name_inst, OF fs_name1]", "lemmas name_abs_eq = abs_fun_eq[OF pt_name_inst, OF at_name_inst]", "lemmas name_supp = at_supp[OF at_name_inst]", "lemmas name_calc = at_calc[OF at_name_inst]", "lemmas name_fresh_fresh = pt_fresh_fresh[OF pt_name_inst, OF at_name_inst]", "lemmas name_fresh_left = pt_fresh_left[OF pt_name_inst, OF at_name_inst]", "lemmas name_fresh_right = pt_fresh_right[OF pt_name_inst, OF at_name_inst]", "lemmas name_id[simp] = pt_id[OF pt_name_inst, OF at_name_inst]", "lemmas name_swap_bij[simp] = pt_swap_bij[OF pt_name_inst, OF at_name_inst]", "lemmas name_swap = pt_swap[OF pt_name_inst, OF at_name_inst]", "lemmas name_rev_per = pt_rev_pi[OF pt_name_inst, OF at_name_inst]", "lemmas name_per_rev = pt_pi_rev[OF pt_name_inst, OF at_name_inst]", "lemmas name_exists_fresh = at_exists_fresh[OF at_name_inst, OF fs_name1]", "lemmas name_perm_compose = pt_perm_compose[OF pt_name_inst, OF at_name_inst]", "lemmas name_fresh[simp] = at_fresh[OF at_name_inst]", "lemma alphaInput:\n  fixes a :: name\n  and   x :: name\n  and   P :: pi\n  and   c :: name\n\n  assumes A1: \"c \\<sharp> P\"\n\n  shows \"a<x>.P = a<c>.([(x, c)] \\<bullet> P)\"", "lemma alphaRes:\n  fixes a :: name\n  and   P :: pi\n  and   c :: name\n  \n  assumes A1: \"c \\<sharp> P\"\n\n  shows \"<\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)\"", "lemma subst_name_eqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   a :: name\n  and   b :: name\n  and   c :: name\n\n  shows \"p \\<bullet> (a[b::=c]) = (p\\<bullet> a)[(p \\<bullet> b)::=(p \\<bullet> c)]\"", "lemma forget:\n  fixes a :: name\n  and   P :: pi\n  and   b :: name\n\n  assumes \"a \\<sharp> P\"\n\n  shows \"P[a::=b] = P\"", "lemma fresh_fact2[rule_format]:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"a \\<noteq> b\"\n\n  shows \"a \\<sharp> P[a::=b]\"", "lemma subst_identity[simp]:\n  fixes P :: pi\n  and   a :: name\n\n  shows \"P[a::=a] = P\"", "lemma renaming:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n  and   c :: name\n\n  assumes \"c \\<sharp> P\"\n\n  shows \"P[a::=b] = ([(c, a)] \\<bullet> P)[c::=b]\"", "lemma fresh_fact1:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n  and   c :: name\n\n  assumes \"a \\<sharp> P\"\n  and     \"a \\<noteq> c\"\n\n  shows \"a \\<sharp> P[b::=c]\"", "lemma eqvt_subs[eqvt]:\n  fixes p :: \"name prm\"\n  and   P :: pi\n  and   a :: name\n  and   b :: name\n\n  shows \"p \\<bullet> (P[a::=b]) = (p \\<bullet> P)[(p \\<bullet> a)::=(p \\<bullet> b)]\"", "lemma substInput[simp]:\n  fixes x :: name\n  and   b :: name\n  and   c :: name\n  and   a :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> b\"\n  and     \"x \\<noteq> c\"\n\n  shows \"(a<x>.P)[b::=c] = (a[b::=c])<x>.(P[b::=c])\"", "lemma injPermSubst:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"b \\<sharp> P\"\n\n  shows \"[(a, b)] \\<bullet> P = P[a::=b]\"", "lemma substRes2:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"b \\<sharp> P\"\n\n  shows \"<\\<nu>a>P = <\\<nu>b>(P[a::=b])\"", "lemma freshRes:\n  fixes P :: pi\n  and   a :: name\n  \n  shows \"a \\<sharp> <\\<nu>a>P\"", "lemma substRes3: \n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"b \\<sharp> P\"\n\n  shows \"(<\\<nu>a>P)[a::=b] = <\\<nu>b>(P[a::=b])\"", "lemma suppSubst:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  shows \"supp(P[a::=b]) \\<subseteq> insert b ((supp P) - {a})\"", "lemma freshSeqSubstName:\n  fixes x :: name\n  and   a :: name\n  and   s :: \"(name \\<times> name) list\"\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<sharp> s\"\n\n  shows \"x \\<noteq> seq_subst_name a s\"", "lemma seqSubstZero[simp]:\n  fixes \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"\\<zero>[<\\<sigma>>] = \\<zero>\"", "lemma seqSubstTau[simp]:\n  fixes P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"(\\<tau>.(P))[<\\<sigma>>] = \\<tau>.(P[<\\<sigma>>])\"", "lemma seqSubstOutput[simp]:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n  \n  shows \"(a{b}.P)[<\\<sigma>>] = (seq_subst_name a \\<sigma>){(seq_subst_name b \\<sigma>)}.(P[<\\<sigma>>])\"", "lemma seqSubstInput[simp]:\n  fixes a :: name\n  and   x :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  assumes \"x \\<sharp> \\<sigma>\"\n \n  shows \"(a<x>.P)[<\\<sigma>>] = (seq_subst_name a \\<sigma>)<x>.(P[<\\<sigma>>])\"", "lemma seqSubstMatch[simp]:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"([a\\<frown>b]P)[<\\<sigma>>] = [(seq_subst_name a \\<sigma>)\\<frown>(seq_subst_name b \\<sigma>)](P[<\\<sigma>>])\"", "lemma seqSubstMismatch[simp]:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"([a\\<noteq>b]P)[<\\<sigma>>] = [(seq_subst_name a \\<sigma>)\\<noteq>(seq_subst_name b \\<sigma>)](P[<\\<sigma>>])\"", "lemma seqSubstSum[simp]:\n  fixes P :: pi\n  and   Q :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"(P \\<oplus> Q)[<\\<sigma>>] = (P[<\\<sigma>>]) \\<oplus> (Q[<\\<sigma>>])\"", "lemma seqSubstPar[simp]:\n  fixes P :: pi\n  and   Q :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"(P \\<parallel> Q)[<\\<sigma>>] = (P[<\\<sigma>>]) \\<parallel> (Q[<\\<sigma>>])\"", "lemma seqSubstRes[simp]:\n  fixes x :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  assumes \"x \\<sharp> \\<sigma>\"\n\n  shows \"(<\\<nu>x>P)[<\\<sigma>>] = <\\<nu>x>(P[<\\<sigma>>])\"", "lemma seqSubstBang[simp]:\n  fixes P :: pi\n  and   s :: \"(name \\<times> name) list\"\n\n  shows \"(!P)[<\\<sigma>>] = !(P[<\\<sigma>>])\"", "lemma seqSubstEqvt[eqvt, simp]:\n  fixes P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n  and   p :: \"name prm\"\n\n  shows \"p \\<bullet> (P[<\\<sigma>>]) = (p \\<bullet> P)[<(p \\<bullet> \\<sigma>)>]\"", "lemma seqSubstAppend[simp]:\n  fixes P  :: pi\n  and   \\<sigma>  :: \"(name \\<times> name) list\"\n  and   \\<sigma>' :: \"(name \\<times> name) list\"\n\n  shows \"P[<(\\<sigma>@\\<sigma>')>] = (P[<\\<sigma>>])[<\\<sigma>'>]\"", "lemma freshSubstChain[intro]:\n  fixes P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n  and   a :: name\n\n  assumes \"a \\<sharp> P\"\n  and     \"a \\<sharp> \\<sigma>\"\n\n  shows \"a \\<sharp> P[<\\<sigma>>]\""], "translations": [["", "lemma pt_id:\n  fixes x :: 'a\n    and a :: 'x\n\n  assumes pt: \"pt TYPE('a) TYPE('x)\"\n  and     at: \"at TYPE('x)\"\n  shows \"[(a, a)] \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, a)] \\<bullet> x = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [(a, a)] \\<bullet> x = x", "have \"x = ([]::'x prm) \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = [] \\<bullet> x", "by(simp add: pt1[OF pt])"], ["proof (state)\nthis:\n  x = [] \\<bullet> x\n\ngoal (1 subgoal):\n 1. [(a, a)] \\<bullet> x = x", "also"], ["proof (state)\nthis:\n  x = [] \\<bullet> x\n\ngoal (1 subgoal):\n 1. [(a, a)] \\<bullet> x = x", "have \"[(a, a)] \\<bullet> x = ([]::'x prm) \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, a)] \\<bullet> x = [] \\<bullet> x", "by(simp add: pt3[OF pt] at_ds1[OF at])"], ["proof (state)\nthis:\n  [(a, a)] \\<bullet> x = [] \\<bullet> x\n\ngoal (1 subgoal):\n 1. [(a, a)] \\<bullet> x = x", "finally"], ["proof (chain)\npicking this:\n  [(a, a)] \\<bullet> x = x", "show ?thesis"], ["proof (prove)\nusing this:\n  [(a, a)] \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. [(a, a)] \\<bullet> x = x", "by simp"], ["proof (state)\nthis:\n  [(a, a)] \\<bullet> x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pt_swap:\n  fixes x :: 'a\n  and a :: 'x\n  and b :: 'x\n\n  assumes pt: \"pt TYPE('a) TYPE('x)\"\n  and     at: \"at TYPE('x)\"\n\n  shows \"[(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x", "by(simp add: pt3[OF pt] at_ds5[OF at])"], ["proof (state)\nthis:\n  [(a, b)] \\<bullet> x = [(b, a)] \\<bullet> x\n\ngoal:\nNo subgoals!", "qed"], ["", "atom_decl name"], ["", "lemmas name_fresh_abs = fresh_abs_fun_iff[OF pt_name_inst, OF at_name_inst, OF fs_name1]"], ["", "lemmas name_bij = at_bij[OF at_name_inst]"], ["", "lemmas name_supp_abs = abs_fun_supp[OF pt_name_inst, OF at_name_inst, OF fs_name1]"], ["", "lemmas name_abs_eq = abs_fun_eq[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_supp = at_supp[OF at_name_inst]"], ["", "lemmas name_calc = at_calc[OF at_name_inst]"], ["", "lemmas name_fresh_fresh = pt_fresh_fresh[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_fresh_left = pt_fresh_left[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_fresh_right = pt_fresh_right[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_id[simp] = pt_id[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_swap_bij[simp] = pt_swap_bij[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_swap = pt_swap[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_rev_per = pt_rev_pi[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_per_rev = pt_pi_rev[OF pt_name_inst, OF at_name_inst]"], ["", "lemmas name_exists_fresh = at_exists_fresh[OF at_name_inst, OF fs_name1]"], ["", "lemmas name_perm_compose = pt_perm_compose[OF pt_name_inst, OF at_name_inst]"], ["", "nominal_datatype pi = PiNil                  (\"\\<zero>\")\n                    | Output name name pi    (\"_{_}._\" [120, 120, 110] 110)\n                    | Tau pi                 (\"\\<tau>._\" [120] 110)\n                    | Input name \"\\<guillemotleft>name\\<guillemotright> pi\" (\"_<_>._\" [120, 120, 110] 110)\n                    | Match name name pi     (\"[_\\<frown>_]_\" [120, 120, 110] 110)\n                    | Mismatch name name pi  (\"[_\\<noteq>_]_\" [120, 120, 110] 110)\n                    | Sum pi pi              (infixr \"\\<oplus>\" 90)\n                    | Par pi pi              (infixr \"\\<parallel>\" 85)\n                    | Res \"\\<guillemotleft>name\\<guillemotright> pi\"        (\"<\\<nu>_>_\" [100, 100] 100)\n                    | Bang pi                (\"!_\" [110] 110)"], ["", "lemmas name_fresh[simp] = at_fresh[OF at_name_inst]"], ["", "lemma alphaInput:\n  fixes a :: name\n  and   x :: name\n  and   P :: pi\n  and   c :: name\n\n  assumes A1: \"c \\<sharp> P\"\n\n  shows \"a<x>.P = a<c>.([(x, c)] \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "proof(cases \"x = c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = c \\<Longrightarrow> a<x>.P = a<c>.([(x, c)] \\<bullet> P)\n 2. x \\<noteq> c \\<Longrightarrow> a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "assume \"x=c\""], ["proof (state)\nthis:\n  x = c\n\ngoal (2 subgoals):\n 1. x = c \\<Longrightarrow> a<x>.P = a<c>.([(x, c)] \\<bullet> P)\n 2. x \\<noteq> c \\<Longrightarrow> a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = c\n\ngoal (1 subgoal):\n 1. a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "by(simp)"], ["proof (state)\nthis:\n  a<x>.P = a<c>.([(x, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. x \\<noteq> c \\<Longrightarrow> a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> c \\<Longrightarrow> a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "assume \"x \\<noteq> c\""], ["proof (state)\nthis:\n  x \\<noteq> c\n\ngoal (1 subgoal):\n 1. x \\<noteq> c \\<Longrightarrow> a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "with A1"], ["proof (chain)\npicking this:\n  c \\<sharp> P\n  x \\<noteq> c", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<sharp> P\n  x \\<noteq> c\n\ngoal (1 subgoal):\n 1. a<x>.P = a<c>.([(x, c)] \\<bullet> P)", "by(simp add: pi.inject alpha name_fresh_left name_calc)"], ["proof (state)\nthis:\n  a<x>.P = a<c>.([(x, c)] \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alphaRes:\n  fixes a :: name\n  and   P :: pi\n  and   c :: name\n  \n  assumes A1: \"c \\<sharp> P\"\n\n  shows \"<\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "proof(cases \"a=c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow> <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)\n 2. a \\<noteq> c \\<Longrightarrow>\n    <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "assume \"a=c\""], ["proof (state)\nthis:\n  a = c\n\ngoal (2 subgoals):\n 1. a = c \\<Longrightarrow> <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)\n 2. a \\<noteq> c \\<Longrightarrow>\n    <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = c\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "by simp"], ["proof (state)\nthis:\n  <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. a \\<noteq> c \\<Longrightarrow>\n    <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> c \\<Longrightarrow>\n    <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "assume \"a \\<noteq> c\""], ["proof (state)\nthis:\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. a \\<noteq> c \\<Longrightarrow>\n    <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "with A1"], ["proof (chain)\npicking this:\n  c \\<sharp> P\n  a \\<noteq> c", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<sharp> P\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)", "by(simp add: pi.inject alpha fresh_left name_calc)"], ["proof (state)\nthis:\n  <\\<nu>a>P = <\\<nu>c>([(a, c)] \\<bullet> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*Substitution*)"], ["", "definition subst_name :: \"name \\<Rightarrow> name \\<Rightarrow> name \\<Rightarrow> name\"   (\"_[_::=_]\" [110, 110, 110] 110)\nwhere\n  \"a[b::=c] \\<equiv> if (a = b) then c else a\""], ["", "declare subst_name_def[simp]"], ["", "lemma subst_name_eqvt[eqvt]:\n  fixes p :: \"name prm\"\n  and   a :: name\n  and   b :: name\n  and   c :: name\n\n  shows \"p \\<bullet> (a[b::=c]) = (p\\<bullet> a)[(p \\<bullet> b)::=(p \\<bullet> c)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> a[b::=c] =\n    (p \\<bullet> a)[(p \\<bullet> b)::=(p \\<bullet> c)]", "by(auto simp add: at_bij[OF at_name_inst])"], ["", "nominal_primrec (freshness_context: \"(c::name, d::name)\")\n  subs :: \"pi \\<Rightarrow> name \\<Rightarrow> name \\<Rightarrow> pi\" (\"_[_::=_]\" [100,100,100] 100)\nwhere\n  \"\\<zero>[c::=d] = \\<zero>\"\n| \"\\<tau>.(P)[c::=d] = \\<tau>.(P[c::=d])\"\n| \"a{b}.P[c::=d] = (a[c::=d]){(b[c::=d])}.(P[c::=d])\"\n| \"\\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk> \\<Longrightarrow> (a<x>.P)[c::=d] = (a[c::=d])<x>.(P[c::=d])\"\n| \"[a\\<frown>b]P[c::=d] = [(a[c::=d])\\<frown>(b[c::=d])](P[c::=d])\"\n| \"[a\\<noteq>b]P[c::=d] = [(a[c::=d])\\<noteq>(b[c::=d])](P[c::=d])\"\n| \"(P \\<oplus> Q)[c::=d] = (P[c::=d]) \\<oplus> (Q[c::=d])\"\n| \"(P \\<parallel> Q)[c::=d] = (P[c::=d]) \\<parallel> (Q[c::=d])\"\n| \"\\<lbrakk>x \\<noteq> c; x \\<noteq> d\\<rbrakk> \\<Longrightarrow> (<\\<nu>x>P)[c::=d] = <\\<nu>x>(P[c::=d])\"\n| \"!P[c::=d] = !(P[c::=d])\""], ["proof (prove)\ngoal (44 subgoals):\n 1. finite (supp \\<zero>)\n 2. finite (supp (\\<lambda>a b P. Output (a[c::=d]) (b[c::=d])))\n 3. finite (supp (\\<lambda>P. Tau))\n 4. finite (supp (\\<lambda>a x P. Input (a[c::=d]) x))\n 5. finite (supp (\\<lambda>a b P. Match (a[c::=d]) (b[c::=d])))\n 6. finite (supp (\\<lambda>a b P. Mismatch (a[c::=d]) (b[c::=d])))\n 7. finite (supp (\\<lambda>P Q. (\\<oplus>)))\n 8. finite (supp (\\<lambda>P Q. (\\<parallel>)))\n 9. finite (supp (\\<lambda>x P. Res x))\n 10. finite (supp (\\<lambda>P. Bang))\nA total of 44 subgoals...", "apply(simp_all add: abs_fresh)"], ["proof (prove)\ngoal (30 subgoals):\n 1. finite (supp \\<zero>)\n 2. finite\n     (supp\n       (\\<lambda>a b P.\n           Output (if a = c then d else a) (if b = c then d else b)))\n 3. finite (supp (\\<lambda>P. Tau))\n 4. finite (supp (\\<lambda>a x P. Input (if a = c then d else a) x))\n 5. finite\n     (supp\n       (\\<lambda>a b P.\n           Match (if a = c then d else a) (if b = c then d else b)))\n 6. finite\n     (supp\n       (\\<lambda>a b P.\n           Mismatch (if a = c then d else a) (if b = c then d else b)))\n 7. finite (supp (\\<lambda>P Q. (\\<oplus>)))\n 8. finite (supp (\\<lambda>P Q. (\\<parallel>)))\n 9. finite (supp (\\<lambda>x P. Res x))\n 10. finite (supp (\\<lambda>P. Bang))\nA total of 30 subgoals...", "apply(finite_guess)+"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x1 x2 y1.\n       \\<lbrakk>x2 \\<sharp> (\\<lambda>a x P.\n                                Input (if a = c then d else a) x);\n        x2 \\<noteq> x1; x2 \\<sharp> (c, d); finite (supp y1)\\<rbrakk>\n       \\<Longrightarrow> x1 = c \\<longrightarrow> x2 \\<noteq> d\n 2. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>a b P.\n  Output (if a = c then d else a) (if b = c then d else b))\n 3. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>P. Tau)\n 4. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>a x P.\n  Input (if a = c then d else a) x)\n 5. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>a b P.\n  Match (if a = c then d else a) (if b = c then d else b))\n 6. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>a b P.\n  Mismatch (if a = c then d else a) (if b = c then d else b))\n 7. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>P Q. (\\<oplus>))\n 8. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>P Q. (\\<parallel>))\n 9. \\<And>a x.\n       \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n       \\<Longrightarrow> x \\<sharp> (\\<lambda>x P. Res x)\n 10. \\<And>a x.\n        \\<lbrakk>x \\<noteq> a; x \\<noteq> c; x \\<noteq> d\\<rbrakk>\n        \\<Longrightarrow> x \\<sharp> (\\<lambda>P. Bang)\nA total of 19 subgoals...", "by(fresh_guess)+"], ["", "lemma forget:\n  fixes a :: name\n  and   P :: pi\n  and   b :: name\n\n  assumes \"a \\<sharp> P\"\n\n  shows \"P[a::=b] = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[a::=b] = P", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> P\n\ngoal (1 subgoal):\n 1. P[a::=b] = P", "by(nominal_induct P avoiding: a b rule: pi.strong_induct)\n  (auto simp add: name_fresh_abs)"], ["", "lemma fresh_fact2[rule_format]:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"a \\<noteq> b\"\n\n  shows \"a \\<sharp> P[a::=b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> P[a::=b]", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<sharp> P[a::=b]", "by(nominal_induct P avoiding: a b rule: pi.strong_induct)\n  (auto simp add: name_fresh_abs)"], ["", "lemma subst_identity[simp]:\n  fixes P :: pi\n  and   a :: name\n\n  shows \"P[a::=a] = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[a::=a] = P", "by(nominal_induct P avoiding: a rule: pi.strong_induct) auto"], ["", "lemma renaming:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n  and   c :: name\n\n  assumes \"c \\<sharp> P\"\n\n  shows \"P[a::=b] = ([(c, a)] \\<bullet> P)[c::=b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[a::=b] = ([(c, a)] \\<bullet> P)[c::=b]", "using assms"], ["proof (prove)\nusing this:\n  c \\<sharp> P\n\ngoal (1 subgoal):\n 1. P[a::=b] = ([(c, a)] \\<bullet> P)[c::=b]", "by(nominal_induct P avoiding: a b c rule: pi.strong_induct)\n  (auto simp add: name_calc name_fresh_abs)"], ["", "lemma fresh_fact1:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n  and   c :: name\n\n  assumes \"a \\<sharp> P\"\n  and     \"a \\<noteq> c\"\n\n  shows \"a \\<sharp> P[b::=c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> P[b::=c]", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> P\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. a \\<sharp> P[b::=c]", "by(nominal_induct P avoiding: a b c rule: pi.strong_induct)\n  (auto simp add: name_fresh_abs)"], ["", "lemma eqvt_subs[eqvt]:\n  fixes p :: \"name prm\"\n  and   P :: pi\n  and   a :: name\n  and   b :: name\n\n  shows \"p \\<bullet> (P[a::=b]) = (p \\<bullet> P)[(p \\<bullet> a)::=(p \\<bullet> b)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> P[a::=b] =\n    (p \\<bullet> P)[(p \\<bullet> a)::=(p \\<bullet> b)]", "by(nominal_induct P avoiding: a b rule: pi.strong_induct)\n  (auto simp add: name_bij)"], ["", "lemma substInput[simp]:\n  fixes x :: name\n  and   b :: name\n  and   c :: name\n  and   a :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> b\"\n  and     \"x \\<noteq> c\"\n\n  shows \"(a<x>.P)[b::=c] = (a[b::=c])<x>.(P[b::=c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "obtain y::name where\"y \\<noteq> a\" and \"y \\<sharp> P\" and \"y \\<noteq> b\" and \"y \\<noteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<noteq> a; y \\<sharp> P; y \\<noteq> b;\n         y \\<noteq> c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(generate_fresh \"name\") (auto simp add: fresh_prod)"], ["proof (state)\nthis:\n  y \\<noteq> a\n  y \\<sharp> P\n  y \\<noteq> b\n  y \\<noteq> c\n\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "from \\<open>y \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> P", "have \"a<x>.P = a<y>.([(x, y)] \\<bullet> P)\""], ["proof (prove)\nusing this:\n  y \\<sharp> P\n\ngoal (1 subgoal):\n 1. a<x>.P = a<y>.([(x, y)] \\<bullet> P)", "by(simp add: alphaInput)"], ["proof (state)\nthis:\n  a<x>.P = a<y>.([(x, y)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "moreover"], ["proof (state)\nthis:\n  a<x>.P = a<y>.([(x, y)] \\<bullet> P)\n\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "have \"(a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])\" (is \"?LHS = ?RHS\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "from \\<open>y \\<sharp> P\\<close> \\<open>y \\<noteq> c\\<close>"], ["proof (chain)\npicking this:\n  y \\<sharp> P\n  y \\<noteq> c", "have \"y \\<sharp> P[b::=c]\""], ["proof (prove)\nusing this:\n  y \\<sharp> P\n  y \\<noteq> c\n\ngoal (1 subgoal):\n 1. y \\<sharp> P[b::=c]", "by(rule fresh_fact1)"], ["proof (state)\nthis:\n  y \\<sharp> P[b::=c]\n\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "hence \"?LHS = (a[b::=c])<y>.([(x, y)] \\<bullet> (P[b::=c]))\""], ["proof (prove)\nusing this:\n  y \\<sharp> P[b::=c]\n\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c])", "by(simp add: alphaInput)"], ["proof (state)\nthis:\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c])\n\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "moreover"], ["proof (state)\nthis:\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c])\n\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "with \\<open>x \\<noteq> b\\<close> \\<open>x \\<noteq> c\\<close> \\<open>y \\<noteq> b\\<close> \\<open>y \\<noteq> c\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> b\n  x \\<noteq> c\n  y \\<noteq> b\n  y \\<noteq> c\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c])", "have \"\\<dots> = ?RHS\""], ["proof (prove)\nusing this:\n  x \\<noteq> b\n  x \\<noteq> c\n  y \\<noteq> b\n  y \\<noteq> c\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c])\n\ngoal (1 subgoal):\n 1. (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c]) =\n    (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "by(auto simp add: eqvt_subs name_calc)"], ["proof (state)\nthis:\n  (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c]) =\n  (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])\n\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "ultimately"], ["proof (chain)\npicking this:\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c])\n  (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c]) =\n  (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "show ?thesis"], ["proof (prove)\nusing this:\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c])\n  (a[b::=c])<y>.([(x, y)] \\<bullet> P[b::=c]) =\n  (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])\n\ngoal (1 subgoal):\n 1. (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "by simp"], ["proof (state)\nthis:\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])\n\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "ultimately"], ["proof (chain)\npicking this:\n  a<x>.P = a<y>.([(x, y)] \\<bullet> P)\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])", "show ?thesis"], ["proof (prove)\nusing this:\n  a<x>.P = a<y>.([(x, y)] \\<bullet> P)\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])\n\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "using \\<open>y \\<noteq> a\\<close> \\<open>y \\<noteq> b\\<close> \\<open>y \\<noteq> c\\<close>"], ["proof (prove)\nusing this:\n  a<x>.P = a<y>.([(x, y)] \\<bullet> P)\n  (a[b::=c])<x>.(P[b::=c]) = (a[b::=c])<y>.(([(x, y)] \\<bullet> P)[b::=c])\n  y \\<noteq> a\n  y \\<noteq> b\n  y \\<noteq> c\n\ngoal (1 subgoal):\n 1. a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])", "by simp"], ["proof (state)\nthis:\n  a<x>.P[b::=c] = (a[b::=c])<x>.(P[b::=c])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma injPermSubst:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"b \\<sharp> P\"\n\n  shows \"[(a, b)] \\<bullet> P = P[a::=b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> P = P[a::=b]", "using assms"], ["proof (prove)\nusing this:\n  b \\<sharp> P\n\ngoal (1 subgoal):\n 1. [(a, b)] \\<bullet> P = P[a::=b]", "by(nominal_induct P avoiding: a b rule: pi.strong_induct)\n  (auto simp add: name_calc name_fresh_abs)"], ["", "lemma substRes2:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"b \\<sharp> P\"\n\n  shows \"<\\<nu>a>P = <\\<nu>b>(P[a::=b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>a>P = <\\<nu>b>P[a::=b]", "proof(case_tac \"a = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]\n 2. a \\<noteq> b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]", "assume \"a = b\""], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]\n 2. a \\<noteq> b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P = <\\<nu>b>P[a::=b]", "by auto"], ["proof (state)\nthis:\n  <\\<nu>a>P = <\\<nu>b>P[a::=b]\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]", "assume \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]", "moreover"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> <\\<nu>a>P = <\\<nu>b>P[a::=b]", "with \\<open>b \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  b \\<sharp> P\n  a \\<noteq> b", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<sharp> P\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P = <\\<nu>b>P[a::=b]", "apply(simp add: pi.inject abs_fun_eq[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> P = [(a, b)] \\<bullet> P[a::=b] \\<and>\n                      a \\<sharp> P[a::=b]", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> P = [(a, b)] \\<bullet> P[a::=b]\n 2. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> P[a::=b]", "apply(simp add: renaming)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> P = [(a, b)] \\<bullet> [(b, a)] \\<bullet> P\n 2. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> P[a::=b]", "apply(simp add: pt_swap[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> P[a::=b]", "apply(simp add: renaming)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> [(b, a)] \\<bullet> P", "apply(simp add: pt_fresh_left[OF pt_name_inst, OF at_name_inst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<sharp> P; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> [(b, a)] \\<bullet> a \\<sharp> P", "by(force simp add: at_calc[OF at_name_inst])"], ["proof (state)\nthis:\n  <\\<nu>a>P = <\\<nu>b>P[a::=b]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma freshRes:\n  fixes P :: pi\n  and   a :: name\n  \n  shows \"a \\<sharp> <\\<nu>a>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> <\\<nu>a>P", "by(simp add: name_fresh_abs)"], ["", "lemma substRes3: \n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  assumes \"b \\<sharp> P\"\n\n  shows \"(<\\<nu>a>P)[a::=b] = <\\<nu>b>(P[a::=b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>a>P[a::=b] = <\\<nu>b>P[a::=b]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>a>P[a::=b] = <\\<nu>b>P[a::=b]", "have \"(<\\<nu>a>P)[a::=b] = <\\<nu>a>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>a>P[a::=b] = <\\<nu>a>P", "using freshRes"], ["proof (prove)\nusing this:\n  ?a \\<sharp> <\\<nu>?a>?P\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P[a::=b] = <\\<nu>a>P", "by(simp add: forget)"], ["proof (state)\nthis:\n  <\\<nu>a>P[a::=b] = <\\<nu>a>P\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P[a::=b] = <\\<nu>b>P[a::=b]", "thus ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>a>P[a::=b] = <\\<nu>a>P\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P[a::=b] = <\\<nu>b>P[a::=b]", "using \\<open>b \\<sharp> P\\<close>"], ["proof (prove)\nusing this:\n  <\\<nu>a>P[a::=b] = <\\<nu>a>P\n  b \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>a>P[a::=b] = <\\<nu>b>P[a::=b]", "by(simp add: substRes2)"], ["proof (state)\nthis:\n  <\\<nu>a>P[a::=b] = <\\<nu>b>P[a::=b]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma suppSubst:\n  fixes P :: pi\n  and   a :: name\n  and   b :: name\n\n  shows \"supp(P[a::=b]) \\<subseteq> insert b ((supp P) - {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (P[a::=b]) \\<subseteq> insert b (supp P - {a})", "apply(nominal_induct P avoiding: a b rule: pi.strong_induct,\n      simp_all add: pi.supp name_supp_abs name_supp supp_prod)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>name1 name2 pi a b.\n       (\\<And>b ba.\n           supp (pi[b::=ba])\n           \\<subseteq> insert ba (supp pi - {b})) \\<Longrightarrow>\n       (name1 = a \\<longrightarrow>\n        name2 \\<noteq> a \\<longrightarrow>\n        supp (pi[a::=b])\n        \\<subseteq> insert b\n                     (insert name2 (insert a (supp pi)) - {a})) \\<and>\n       (name1 \\<noteq> a \\<longrightarrow>\n        (name2 = a \\<longrightarrow>\n         supp (pi[a::=b])\n         \\<subseteq> insert b (insert name1 (supp pi) - {a})) \\<and>\n        (name2 \\<noteq> a \\<longrightarrow>\n         supp (pi[a::=b])\n         \\<subseteq> insert b\n                      (insert name2 (insert name1 (supp pi)) - {a})))\n 2. \\<And>name1 name2 pi a b.\n       \\<lbrakk>name2 \\<noteq> a; name2 \\<noteq> b; name2 \\<noteq> name1;\n        \\<And>b ba.\n           supp (pi[b::=ba]) \\<subseteq> insert ba (supp pi - {b})\\<rbrakk>\n       \\<Longrightarrow> (name1 = a \\<longrightarrow>\n                          supp (pi[a::=b]) - {name2}\n                          \\<subseteq> insert b\n (supp pi - {name2} - {a})) \\<and>\n                         (name1 \\<noteq> a \\<longrightarrow>\n                          supp (pi[a::=b]) - {name2}\n                          \\<subseteq> insert b\n (insert name1 (supp pi - {name2}) - {a}))\n 3. \\<And>name1 name2 pi a b.\n       (\\<And>b ba.\n           supp (pi[b::=ba])\n           \\<subseteq> insert ba (supp pi - {b})) \\<Longrightarrow>\n       (name1 = a \\<longrightarrow>\n        name2 \\<noteq> a \\<longrightarrow>\n        supp (pi[a::=b])\n        \\<subseteq> insert b\n                     (insert name2 (insert a (supp pi)) - {a})) \\<and>\n       (name1 \\<noteq> a \\<longrightarrow>\n        (name2 = a \\<longrightarrow>\n         supp (pi[a::=b])\n         \\<subseteq> insert b (insert name1 (supp pi) - {a})) \\<and>\n        (name2 \\<noteq> a \\<longrightarrow>\n         supp (pi[a::=b])\n         \\<subseteq> insert b\n                      (insert name2 (insert name1 (supp pi)) - {a})))\n 4. \\<And>name1 name2 pi a b.\n       (\\<And>b ba.\n           supp (pi[b::=ba])\n           \\<subseteq> insert ba (supp pi - {b})) \\<Longrightarrow>\n       (name1 = a \\<longrightarrow>\n        name2 \\<noteq> a \\<longrightarrow>\n        supp (pi[a::=b])\n        \\<subseteq> insert b\n                     (insert name2 (insert a (supp pi)) - {a})) \\<and>\n       (name1 \\<noteq> a \\<longrightarrow>\n        (name2 = a \\<longrightarrow>\n         supp (pi[a::=b])\n         \\<subseteq> insert b (insert name1 (supp pi) - {a})) \\<and>\n        (name2 \\<noteq> a \\<longrightarrow>\n         supp (pi[a::=b])\n         \\<subseteq> insert b\n                      (insert name2 (insert name1 (supp pi)) - {a})))\n 5. \\<And>pi1 pi2 a b.\n       \\<lbrakk>\\<And>b ba.\n                   supp (pi1[b::=ba])\n                   \\<subseteq> insert ba (supp pi1 - {b});\n        \\<And>b ba.\n           supp (pi2[b::=ba])\n           \\<subseteq> insert ba (supp pi2 - {b})\\<rbrakk>\n       \\<Longrightarrow> supp (pi1[a::=b])\n                         \\<subseteq> insert b\n(supp pi1 \\<union> supp pi2 - {a}) \\<and>\n                         supp (pi2[a::=b])\n                         \\<subseteq> insert b\n(supp pi1 \\<union> supp pi2 - {a})\n 6. \\<And>pi1 pi2 a b.\n       \\<lbrakk>\\<And>b ba.\n                   supp (pi1[b::=ba])\n                   \\<subseteq> insert ba (supp pi1 - {b});\n        \\<And>b ba.\n           supp (pi2[b::=ba])\n           \\<subseteq> insert ba (supp pi2 - {b})\\<rbrakk>\n       \\<Longrightarrow> supp (pi1[a::=b])\n                         \\<subseteq> insert b\n(supp pi1 \\<union> supp pi2 - {a}) \\<and>\n                         supp (pi2[a::=b])\n                         \\<subseteq> insert b\n(supp pi1 \\<union> supp pi2 - {a})\n 7. \\<And>name pi a b.\n       \\<lbrakk>name \\<noteq> a; name \\<noteq> b;\n        \\<And>b ba.\n           supp (pi[b::=ba]) \\<subseteq> insert ba (supp pi - {b})\\<rbrakk>\n       \\<Longrightarrow> supp (pi[a::=b]) - {name}\n                         \\<subseteq> insert b (supp pi - {name} - {a})", "by(blast)+"], ["", "(******** Sequential substitution *******)"], ["", "primrec seqSubs :: \"pi \\<Rightarrow> (name \\<times> name) list \\<Rightarrow> pi\" (\"_[<_>]\" [100,100] 100) where\n  \"P[<[]>] = P\"\n| \"P[<(x#\\<sigma>)>] = (P[(fst x)::=(snd x)])[<\\<sigma>>]\""], ["", "primrec seq_subst_name :: \"name \\<Rightarrow> (name \\<times> name) list \\<Rightarrow> name\" where\n  \"seq_subst_name a [] = a\"\n| \"seq_subst_name a (x#\\<sigma>) = seq_subst_name (a[(fst x)::=(snd x)]) \\<sigma>\""], ["", "lemma freshSeqSubstName:\n  fixes x :: name\n  and   a :: name\n  and   s :: \"(name \\<times> name) list\"\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<sharp> s\"\n\n  shows \"x \\<noteq> seq_subst_name a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> seq_subst_name a s", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  x \\<sharp> s\n\ngoal (1 subgoal):\n 1. x \\<noteq> seq_subst_name a s", "apply(induct s arbitrary: a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x \\<noteq> a; x \\<sharp> []\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> seq_subst_name a []\n 2. \\<And>a s aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>x \\<noteq> a; x \\<sharp> s\\<rbrakk>\n                   \\<Longrightarrow> x \\<noteq> seq_subst_name a s;\n        x \\<noteq> aa; x \\<sharp> (a # s)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> seq_subst_name aa (a # s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>x \\<noteq> a; x \\<sharp> s\\<rbrakk>\n                   \\<Longrightarrow> x \\<noteq> seq_subst_name a s;\n        x \\<noteq> aa; x \\<sharp> (a # s)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> seq_subst_name aa (a # s)", "apply(case_tac \"aa = fst(a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a s aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>x \\<noteq> a; x \\<sharp> s\\<rbrakk>\n                   \\<Longrightarrow> x \\<noteq> seq_subst_name a s;\n        x \\<noteq> aa; x \\<sharp> (a # s); aa = fst a\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> seq_subst_name aa (a # s)\n 2. \\<And>a s aa.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>x \\<noteq> a; x \\<sharp> s\\<rbrakk>\n                   \\<Longrightarrow> x \\<noteq> seq_subst_name a s;\n        x \\<noteq> aa; x \\<sharp> (a # s); aa \\<noteq> fst a\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> seq_subst_name aa (a # s)", "by (force simp add: fresh_list_cons fresh_prod)+"], ["", "lemma seqSubstZero[simp]:\n  fixes \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"\\<zero>[<\\<sigma>>] = \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero>[<\\<sigma>>] = \\<zero>", "by(induct \\<sigma>, auto)"], ["", "lemma seqSubstTau[simp]:\n  fixes P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"(\\<tau>.(P))[<\\<sigma>>] = \\<tau>.(P[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>.P[<\\<sigma>>] = \\<tau>.(P[<\\<sigma>>])", "by(induct \\<sigma> arbitrary: P, auto)"], ["", "lemma seqSubstOutput[simp]:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n  \n  shows \"(a{b}.P)[<\\<sigma>>] = (seq_subst_name a \\<sigma>){(seq_subst_name b \\<sigma>)}.(P[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a{b}.P[<\\<sigma>>] =\n    seq_subst_name a \\<sigma>{seq_subst_name b \\<sigma>}.(P[<\\<sigma>>])", "by(induct \\<sigma> arbitrary: a b P, auto)"], ["", "lemma seqSubstInput[simp]:\n  fixes a :: name\n  and   x :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  assumes \"x \\<sharp> \\<sigma>\"\n \n  shows \"(a<x>.P)[<\\<sigma>>] = (seq_subst_name a \\<sigma>)<x>.(P[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a<x>.P[<\\<sigma>>] = seq_subst_name a \\<sigma><x>.(P[<\\<sigma>>])", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. a<x>.P[<\\<sigma>>] = seq_subst_name a \\<sigma><x>.(P[<\\<sigma>>])", "by(induct \\<sigma> arbitrary: a x P) (auto simp add: fresh_list_cons fresh_prod)"], ["", "lemma seqSubstMatch[simp]:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"([a\\<frown>b]P)[<\\<sigma>>] = [(seq_subst_name a \\<sigma>)\\<frown>(seq_subst_name b \\<sigma>)](P[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<frown>b]P[<\\<sigma>>] =\n    [seq_subst_name a\n      \\<sigma>\\<frown>seq_subst_name b \\<sigma>](P[<\\<sigma>>])", "by(induct \\<sigma> arbitrary: a b P, auto)"], ["", "lemma seqSubstMismatch[simp]:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"([a\\<noteq>b]P)[<\\<sigma>>] = [(seq_subst_name a \\<sigma>)\\<noteq>(seq_subst_name b \\<sigma>)](P[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<noteq>b]P[<\\<sigma>>] =\n    [seq_subst_name a\n      \\<sigma>\\<noteq>seq_subst_name b \\<sigma>](P[<\\<sigma>>])", "by(induct \\<sigma> arbitrary: a b P, auto)"], ["", "lemma seqSubstSum[simp]:\n  fixes P :: pi\n  and   Q :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"(P \\<oplus> Q)[<\\<sigma>>] = (P[<\\<sigma>>]) \\<oplus> (Q[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q)[<\\<sigma>>] = P[<\\<sigma>>] \\<oplus> Q[<\\<sigma>>]", "by(induct \\<sigma> arbitrary: P Q , auto)"], ["", "lemma seqSubstPar[simp]:\n  fixes P :: pi\n  and   Q :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  shows \"(P \\<parallel> Q)[<\\<sigma>>] = (P[<\\<sigma>>]) \\<parallel> (Q[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q)[<\\<sigma>>] = P[<\\<sigma>>] \\<parallel> Q[<\\<sigma>>]", "by(induct \\<sigma> arbitrary: P Q, auto)"], ["", "lemma seqSubstRes[simp]:\n  fixes x :: name\n  and   P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n\n  assumes \"x \\<sharp> \\<sigma>\"\n\n  shows \"(<\\<nu>x>P)[<\\<sigma>>] = <\\<nu>x>(P[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>P[<\\<sigma>>] = <\\<nu>x>P[<\\<sigma>>]", "using assms"], ["proof (prove)\nusing this:\n  x \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P[<\\<sigma>>] = <\\<nu>x>P[<\\<sigma>>]", "by(induct \\<sigma> arbitrary: x P) (auto simp add: fresh_list_cons fresh_prod)"], ["", "lemma seqSubstBang[simp]:\n  fixes P :: pi\n  and   s :: \"(name \\<times> name) list\"\n\n  shows \"(!P)[<\\<sigma>>] = !(P[<\\<sigma>>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. !P[<\\<sigma>>] = !(P[<\\<sigma>>])", "by(induct \\<sigma> arbitrary: P, auto)"], ["", "lemma seqSubstEqvt[eqvt, simp]:\n  fixes P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n  and   p :: \"name prm\"\n\n  shows \"p \\<bullet> (P[<\\<sigma>>]) = (p \\<bullet> P)[<(p \\<bullet> \\<sigma>)>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> P[<\\<sigma>>] = (p \\<bullet> P)[<(p \\<bullet> \\<sigma>)>]", "by(induct \\<sigma> arbitrary: P, auto simp add: eqvt_subs)"], ["", "lemma seqSubstAppend[simp]:\n  fixes P  :: pi\n  and   \\<sigma>  :: \"(name \\<times> name) list\"\n  and   \\<sigma>' :: \"(name \\<times> name) list\"\n\n  shows \"P[<(\\<sigma>@\\<sigma>')>] = (P[<\\<sigma>>])[<\\<sigma>'>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[<(\\<sigma> @ \\<sigma>')>] = P[<\\<sigma>>][<\\<sigma>'>]", "by(induct \\<sigma> arbitrary: P, auto)"], ["", "lemma freshSubstChain[intro]:\n  fixes P :: pi\n  and   \\<sigma> :: \"(name \\<times> name) list\"\n  and   a :: name\n\n  assumes \"a \\<sharp> P\"\n  and     \"a \\<sharp> \\<sigma>\"\n\n  shows \"a \\<sharp> P[<\\<sigma>>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> P[<\\<sigma>>]", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> P\n  a \\<sharp> \\<sigma>\n\ngoal (1 subgoal):\n 1. a \\<sharp> P[<\\<sigma>>]", "by(induct \\<sigma> arbitrary: a P, auto simp add: fresh_list_cons fresh_prod fresh_fact1)"], ["", "end"]]}