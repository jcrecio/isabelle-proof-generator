{"file_name": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus/Strong_Late_Bisim_SC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus", "problem_names": ["lemma nilBisim[dest]:\n  fixes a :: name\n  and   b :: name\n  and   x :: name\n  and   P :: pi\n\n  shows \"\\<tau>.(P) \\<sim> \\<zero> \\<Longrightarrow> False\"\n  and   \"a<x>.P \\<sim> \\<zero> \\<Longrightarrow> False\"\n  and   \"a{b}.P \\<sim> \\<zero> \\<Longrightarrow> False\"\n  and   \"\\<zero> \\<sim> \\<tau>.(P) \\<Longrightarrow> False\"\n  and   \"\\<zero> \\<sim> a<x>.P \\<Longrightarrow> False\"\n  and   \"\\<zero> \\<sim> a{b}.P \\<Longrightarrow> False\"", "lemma matchId:\n  fixes a :: name\n  and   P :: pi\n\n  shows \"[a\\<frown>a]P \\<sim> P\"", "lemma matchNil:\n  fixes a :: name\n  and   b :: name\n\n  assumes \"a \\<noteq> b\"\n\n  shows \"[a\\<frown>b]P \\<sim> \\<zero>\"", "lemma mismatchId:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"a \\<noteq> b\"\n\n  shows \"[a\\<noteq>b]P \\<sim> P\"", "lemma mismatchNil:\n  fixes a :: name\n  and   P :: pi\n  \n  shows \"[a\\<noteq>a]P \\<sim> \\<zero>\"", "lemma nilRes:\n  fixes x :: name\n\n  shows \"<\\<nu>x>\\<zero> \\<sim> \\<zero>\"", "lemma resComm:\n  fixes x :: name\n  and   y :: name\n  and   P :: pi\n  \n  shows \"<\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P\"", "lemma sumSym:\n  fixes P :: pi\n  and   Q :: pi\n  \n  shows \"P \\<oplus> Q \\<sim> Q \\<oplus> P\"", "lemma sumIdemp:\n  fixes P :: pi\n  \n  shows \"P \\<oplus> P \\<sim> P\"", "lemma sumAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n  \n  shows \"(P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)\"", "lemma sumZero:\n  fixes P :: pi\n  \n  shows \"P \\<oplus> \\<zero> \\<sim> P\"", "lemma parZero:\n  fixes P :: pi\n  \n  shows \"P \\<parallel> \\<zero> \\<sim> P\"", "lemma parSym:\n  fixes P :: pi\n  and   Q :: pi\n\n  shows \"P \\<parallel> Q \\<sim> Q \\<parallel> P\"", "lemma scopeExtPar:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q\"", "lemma scopeExtPar':\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshQ: \"x \\<sharp> Q\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim> (<\\<nu>x>P) \\<parallel> Q\"", "lemma parAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n\n  shows \"(P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)\"", "lemma scopeFresh:\n  fixes x :: name\n  and   P :: pi\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>P \\<sim> P\"", "lemma sumRes:\n  fixes x :: name\n  and   P :: pi\n  and   Q :: pi\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim> (<\\<nu>x>P) \\<oplus> (<\\<nu>x>Q)\"", "lemma scopeExtSum:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n  \n  assumes \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q\"", "lemma bangSC:\n  fixes P :: pi\n\n  shows \"!P \\<sim> P \\<parallel> !P\"", "lemma resNil:\n  fixes x :: name\n  and   y :: name\n  and   P :: pi\n  and   b :: name\n\n  shows \"<\\<nu>x>x<y>.P \\<sim> \\<zero>\"\n  and   \"<\\<nu>x>x{b}.P \\<sim> \\<zero>\"", "lemma resInput:\n  fixes x :: name\n  and   a :: name\n  and   y :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> y\"\n\n  shows \"<\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)\"", "lemma resOutput:\n  fixes x :: name\n  and   a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> b\"\n\n  shows \"<\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)\"", "lemma resTau:\n  fixes x :: name\n  and   P :: pi\n\n  shows \"<\\<nu>x>\\<tau>.(P) \\<sim> \\<tau>.(<\\<nu>x>P)\"", "lemma structCongBisim:\n  fixes P :: pi\n  and   Q :: pi\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n\n  shows \"P \\<sim> Q\""], "translations": [["", "lemma nilBisim[dest]:\n  fixes a :: name\n  and   b :: name\n  and   x :: name\n  and   P :: pi\n\n  shows \"\\<tau>.(P) \\<sim> \\<zero> \\<Longrightarrow> False\"\n  and   \"a<x>.P \\<sim> \\<zero> \\<Longrightarrow> False\"\n  and   \"a{b}.P \\<sim> \\<zero> \\<Longrightarrow> False\"\n  and   \"\\<zero> \\<sim> \\<tau>.(P) \\<Longrightarrow> False\"\n  and   \"\\<zero> \\<sim> a<x>.P \\<Longrightarrow> False\"\n  and   \"\\<zero> \\<sim> a{b}.P \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<tau>.P \\<sim> \\<zero> \\<Longrightarrow> False) &&&\n     (a<x>.P \\<sim> \\<zero> \\<Longrightarrow> False) &&&\n     (a{b}.P \\<sim> \\<zero> \\<Longrightarrow> False)) &&&\n    (\\<zero> \\<sim> \\<tau>.P \\<Longrightarrow> False) &&&\n    (\\<zero> \\<sim> a<x>.P \\<Longrightarrow> False) &&&\n    (\\<zero> \\<sim> a{b}.P \\<Longrightarrow> False)", "by(auto dest: bisimE symmetric)"], ["", "(******** Structural Congruence **********)"], ["", "lemma matchId:\n  fixes a :: name\n  and   P :: pi\n\n  shows \"[a\\<frown>a]P \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<frown>a]P \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<frown>a]P \\<sim> P", "let ?X = \"{([a\\<frown>a]P, P), (P, [a\\<frown>a]P)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<frown>a]P \\<sim> P", "have \"([a\\<frown>a]P, P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([a\\<frown>a]P, P) \\<in> {([a\\<frown>a]P, P), (P, [a\\<frown>a]P)}", "by simp"], ["proof (state)\nthis:\n  ([a\\<frown>a]P, P) \\<in> {([a\\<frown>a]P, P), (P, [a\\<frown>a]P)}\n\ngoal (1 subgoal):\n 1. [a\\<frown>a]P \\<sim> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  ([a\\<frown>a]P, P) \\<in> {([a\\<frown>a]P, P), (P, [a\\<frown>a]P)}\n\ngoal (1 subgoal):\n 1. [a\\<frown>a]P \\<sim> P", "by(coinduct rule: bisimCoinduct) (auto intro: matchIdLeft matchIdRight reflexive)"], ["proof (state)\nthis:\n  [a\\<frown>a]P \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matchNil:\n  fixes a :: name\n  and   b :: name\n\n  assumes \"a \\<noteq> b\"\n\n  shows \"[a\\<frown>b]P \\<sim> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<frown>b]P \\<sim> \\<zero>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<frown>b]P \\<sim> \\<zero>", "let ?X = \"{([a\\<frown>b]P, \\<zero>), (\\<zero>, [a\\<frown>b]P)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<frown>b]P \\<sim> \\<zero>", "have \"([a\\<frown>b]P, \\<zero>) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([a\\<frown>b]P, \\<zero>)\n    \\<in> {([a\\<frown>b]P, \\<zero>), (\\<zero>, [a\\<frown>b]P)}", "by simp"], ["proof (state)\nthis:\n  ([a\\<frown>b]P, \\<zero>)\n  \\<in> {([a\\<frown>b]P, \\<zero>), (\\<zero>, [a\\<frown>b]P)}\n\ngoal (1 subgoal):\n 1. [a\\<frown>b]P \\<sim> \\<zero>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ([a\\<frown>b]P, \\<zero>)\n  \\<in> {([a\\<frown>b]P, \\<zero>), (\\<zero>, [a\\<frown>b]P)}\n\ngoal (1 subgoal):\n 1. [a\\<frown>b]P \\<sim> \\<zero>", "using \\<open>a \\<noteq> b\\<close>"], ["proof (prove)\nusing this:\n  ([a\\<frown>b]P, \\<zero>)\n  \\<in> {([a\\<frown>b]P, \\<zero>), (\\<zero>, [a\\<frown>b]P)}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. [a\\<frown>b]P \\<sim> \\<zero>", "by(coinduct rule: bisimCoinduct) (auto intro: matchNilLeft nilSimRight reflexive)"], ["proof (state)\nthis:\n  [a\\<frown>b]P \\<sim> \\<zero>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mismatchId:\n  fixes a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"a \\<noteq> b\"\n\n  shows \"[a\\<noteq>b]P \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<noteq>b]P \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<noteq>b]P \\<sim> P", "let ?X = \"{([a\\<noteq>b]P, P), (P, [a\\<noteq>b]P)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<noteq>b]P \\<sim> P", "have \"([a\\<noteq>b]P, P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([a\\<noteq>b]P, P) \\<in> {([a\\<noteq>b]P, P), (P, [a\\<noteq>b]P)}", "by simp"], ["proof (state)\nthis:\n  ([a\\<noteq>b]P, P) \\<in> {([a\\<noteq>b]P, P), (P, [a\\<noteq>b]P)}\n\ngoal (1 subgoal):\n 1. [a\\<noteq>b]P \\<sim> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  ([a\\<noteq>b]P, P) \\<in> {([a\\<noteq>b]P, P), (P, [a\\<noteq>b]P)}\n\ngoal (1 subgoal):\n 1. [a\\<noteq>b]P \\<sim> P", "using \\<open>a \\<noteq> b\\<close>"], ["proof (prove)\nusing this:\n  ([a\\<noteq>b]P, P) \\<in> {([a\\<noteq>b]P, P), (P, [a\\<noteq>b]P)}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. [a\\<noteq>b]P \\<sim> P", "by(coinduct rule: bisimCoinduct) (auto intro: mismatchIdLeft mismatchIdRight reflexive)"], ["proof (state)\nthis:\n  [a\\<noteq>b]P \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mismatchNil:\n  fixes a :: name\n  and   P :: pi\n  \n  shows \"[a\\<noteq>a]P \\<sim> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a\\<noteq>a]P \\<sim> \\<zero>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<noteq>a]P \\<sim> \\<zero>", "let ?X = \"{([a\\<noteq>a]P, \\<zero>), (\\<zero>, [a\\<noteq>a]P)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. [a\\<noteq>a]P \\<sim> \\<zero>", "have \"([a\\<noteq>a]P, \\<zero>) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([a\\<noteq>a]P, \\<zero>)\n    \\<in> {([a\\<noteq>a]P, \\<zero>), (\\<zero>, [a\\<noteq>a]P)}", "by simp"], ["proof (state)\nthis:\n  ([a\\<noteq>a]P, \\<zero>)\n  \\<in> {([a\\<noteq>a]P, \\<zero>), (\\<zero>, [a\\<noteq>a]P)}\n\ngoal (1 subgoal):\n 1. [a\\<noteq>a]P \\<sim> \\<zero>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ([a\\<noteq>a]P, \\<zero>)\n  \\<in> {([a\\<noteq>a]P, \\<zero>), (\\<zero>, [a\\<noteq>a]P)}\n\ngoal (1 subgoal):\n 1. [a\\<noteq>a]P \\<sim> \\<zero>", "by(coinduct rule: bisimCoinduct) (auto intro: mismatchNilLeft nilSimRight reflexive)"], ["proof (state)\nthis:\n  [a\\<noteq>a]P \\<sim> \\<zero>\n\ngoal:\nNo subgoals!", "qed"], ["", "(******** The \\<nu>-operator *****************)"], ["", "lemma nilRes:\n  fixes x :: name\n\n  shows \"<\\<nu>x>\\<zero> \\<sim> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero> \\<sim> \\<zero>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero> \\<sim> \\<zero>", "let ?X = \"{(<\\<nu>x>\\<zero>, \\<zero>), (\\<zero>, <\\<nu>x>\\<zero>)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero> \\<sim> \\<zero>", "have \"(<\\<nu>x>\\<zero>, \\<zero>) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x>\\<zero>, \\<zero>)\n    \\<in> {(<\\<nu>x>\\<zero>, \\<zero>), (\\<zero>, <\\<nu>x>\\<zero>)}", "by simp"], ["proof (state)\nthis:\n  (<\\<nu>x>\\<zero>, \\<zero>)\n  \\<in> {(<\\<nu>x>\\<zero>, \\<zero>), (\\<zero>, <\\<nu>x>\\<zero>)}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero> \\<sim> \\<zero>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (<\\<nu>x>\\<zero>, \\<zero>)\n  \\<in> {(<\\<nu>x>\\<zero>, \\<zero>), (\\<zero>, <\\<nu>x>\\<zero>)}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero> \\<sim> \\<zero>", "by(coinduct rule: bisimCoinduct) (auto intro: nilSimRight resNilRight)"], ["proof (state)\nthis:\n  <\\<nu>x>\\<zero> \\<sim> \\<zero>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resComm:\n  fixes x :: name\n  and   y :: name\n  and   P :: pi\n  \n  shows \"<\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P", "let ?X = \"{(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) | x y P. True}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P", "have \"(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P)\n    \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "by auto"], ["proof (state)\nthis:\n  (<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P)\n  \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P)\n  \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P", "proof(coinduct rule: bisimCoinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "case(cSim xyP yxP)"], ["proof (state)\nthis:\n  (xyP, yxP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "{"], ["proof (state)\nthis:\n  (xyP, yxP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "fix x y P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "have \"\\<And>x y P. (<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) \\<in> ?X \\<union> bisim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y P.\n       (<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union>\n             bisim", "by auto"], ["proof (state)\nthis:\n  (<\\<nu>?x><\\<nu>?y>?P, <\\<nu>?y><\\<nu>?x>?P)\n  \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "moreover"], ["proof (state)\nthis:\n  (<\\<nu>?x><\\<nu>?y>?P, <\\<nu>?y><\\<nu>?x>?P)\n  \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "have \"Id \\<subseteq> ?X \\<union> bisim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<subseteq> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                    True} \\<union>\n                   bisim", "by(auto intro: reflexive)"], ["proof (state)\nthis:\n  Id \\<subseteq> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                  True} \\<union>\n                 bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "moreover"], ["proof (state)\nthis:\n  Id \\<subseteq> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                  True} \\<union>\n                 bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "have \"eqvt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "by(force simp add: eqvt_def)"], ["proof (state)\nthis:\n  eqvt {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "hence \"eqvt(?X \\<union> bisim)\""], ["proof (prove)\nusing this:\n  eqvt {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (1 subgoal):\n 1. eqvt\n     ({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim)", "by auto"], ["proof (state)\nthis:\n  eqvt\n   ({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "ultimately"], ["proof (chain)\npicking this:\n  (<\\<nu>?x><\\<nu>?y>?P, <\\<nu>?y><\\<nu>?x>?P)\n  \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim\n  Id \\<subseteq> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                  True} \\<union>\n                 bisim\n  eqvt\n   ({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim)", "have \"<\\<nu>x><\\<nu>y>P \\<leadsto>[(?X \\<union> bisim)] <\\<nu>y><\\<nu>x>P\""], ["proof (prove)\nusing this:\n  (<\\<nu>?x><\\<nu>?y>?P, <\\<nu>?y><\\<nu>?x>?P)\n  \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim\n  Id \\<subseteq> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                  True} \\<union>\n                 bisim\n  eqvt\n   ({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True} \\<union> bisim)\n\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>P \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x\n                                   y P. True} \\<union>\n                                  bisim)] <\\<nu>y><\\<nu>x>P", "by(rule resComm)"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y\n                                 P. True} \\<union>\n                                bisim)] <\\<nu>y><\\<nu>x>P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "}"], ["proof (state)\nthis:\n  <\\<nu>?xa2><\\<nu>?ya2>?Pa2 \\<leadsto>[({(<\\<nu>x><\\<nu>y>P,\n     <\\<nu>y><\\<nu>x>P) |\n    x y P. True} \\<union>\n   bisim)] <\\<nu>?ya2><\\<nu>?xa2>?Pa2\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       R \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                      True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "with \\<open>(xyP, yxP) \\<in> ?X\\<close>"], ["proof (chain)\npicking this:\n  (xyP, yxP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n  <\\<nu>?xa2><\\<nu>?ya2>?Pa2 \\<leadsto>[({(<\\<nu>x><\\<nu>y>P,\n     <\\<nu>y><\\<nu>x>P) |\n    x y P. True} \\<union>\n   bisim)] <\\<nu>?ya2><\\<nu>?xa2>?Pa2", "show ?case"], ["proof (prove)\nusing this:\n  (xyP, yxP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n  <\\<nu>?xa2><\\<nu>?ya2>?Pa2 \\<leadsto>[({(<\\<nu>x><\\<nu>y>P,\n     <\\<nu>y><\\<nu>x>P) |\n    x y P. True} \\<union>\n   bisim)] <\\<nu>?ya2><\\<nu>?xa2>?Pa2\n\ngoal (1 subgoal):\n 1. xyP \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                     True} \\<union>\n                    bisim)] yxP", "by auto"], ["proof (state)\nthis:\n  xyP \\<leadsto>[({(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n                   True} \\<union>\n                  bisim)] yxP\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "case(cSym xyP yxP)"], ["proof (state)\nthis:\n  (xyP, yxP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P.\n              True} \\<Longrightarrow>\n       (S, R) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "thus ?case"], ["proof (prove)\nusing this:\n  (xyP, yxP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal (1 subgoal):\n 1. (yxP, xyP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}", "by auto"], ["proof (state)\nthis:\n  (yxP, xyP) \\<in> {(<\\<nu>x><\\<nu>y>P, <\\<nu>y><\\<nu>x>P) |x y P. True}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>P \\<sim> <\\<nu>y><\\<nu>x>P\n\ngoal:\nNo subgoals!", "qed"], ["", "(******** The +-operator *********)"], ["", "lemma sumSym:\n  fixes P :: pi\n  and   Q :: pi\n  \n  shows \"P \\<oplus> Q \\<sim> Q \\<oplus> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "let ?X = \"{(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "have \"(P \\<oplus> Q, Q \\<oplus> P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q, Q \\<oplus> P)\n    \\<in> {(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}", "by simp"], ["proof (state)\nthis:\n  (P \\<oplus> Q, Q \\<oplus> P)\n  \\<in> {(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<oplus> Q, Q \\<oplus> P)\n  \\<in> {(P \\<oplus> Q, Q \\<oplus> P), (Q \\<oplus> P, P \\<oplus> Q)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> Q \\<sim> Q \\<oplus> P", "by(coinduct rule: bisimCoinduct) (auto intro: reflexive sumSym)"], ["proof (state)\nthis:\n  P \\<oplus> Q \\<sim> Q \\<oplus> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumIdemp:\n  fixes P :: pi\n  \n  shows \"P \\<oplus> P \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> P \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> P \\<sim> P", "let ?X = \"{(P \\<oplus> P, P), (P, P \\<oplus> P)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> P \\<sim> P", "have \"(P \\<oplus> P, P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> P, P) \\<in> {(P \\<oplus> P, P), (P, P \\<oplus> P)}", "by simp"], ["proof (state)\nthis:\n  (P \\<oplus> P, P) \\<in> {(P \\<oplus> P, P), (P, P \\<oplus> P)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> P \\<sim> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<oplus> P, P) \\<in> {(P \\<oplus> P, P), (P, P \\<oplus> P)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> P \\<sim> P", "by(coinduct rule: bisimCoinduct) (auto intro: reflexive sumIdempLeft sumIdempRight)"], ["proof (state)\nthis:\n  P \\<oplus> P \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n  \n  shows \"(P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> (Q \\<oplus> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> Q \\<oplus> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> Q \\<oplus> R", "let ?X = \"{((P \\<oplus> Q) \\<oplus> R, P \\<oplus> (Q \\<oplus> R)), (P \\<oplus> (Q \\<oplus> R), (P \\<oplus> Q) \\<oplus> R)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> Q \\<oplus> R", "have \"((P \\<oplus> Q) \\<oplus> R, P \\<oplus> (Q \\<oplus> R)) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<oplus> Q) \\<oplus> R, P \\<oplus> Q \\<oplus> R)\n    \\<in> {((P \\<oplus> Q) \\<oplus> R, P \\<oplus> Q \\<oplus> R),\n           (P \\<oplus> Q \\<oplus> R, (P \\<oplus> Q) \\<oplus> R)}", "by simp"], ["proof (state)\nthis:\n  ((P \\<oplus> Q) \\<oplus> R, P \\<oplus> Q \\<oplus> R)\n  \\<in> {((P \\<oplus> Q) \\<oplus> R, P \\<oplus> Q \\<oplus> R),\n         (P \\<oplus> Q \\<oplus> R, (P \\<oplus> Q) \\<oplus> R)}\n\ngoal (1 subgoal):\n 1. (P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> Q \\<oplus> R", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((P \\<oplus> Q) \\<oplus> R, P \\<oplus> Q \\<oplus> R)\n  \\<in> {((P \\<oplus> Q) \\<oplus> R, P \\<oplus> Q \\<oplus> R),\n         (P \\<oplus> Q \\<oplus> R, (P \\<oplus> Q) \\<oplus> R)}\n\ngoal (1 subgoal):\n 1. (P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> Q \\<oplus> R", "by(coinduct rule: bisimCoinduct) (auto intro: reflexive sumAssocLeft sumAssocRight)"], ["proof (state)\nthis:\n  (P \\<oplus> Q) \\<oplus> R \\<sim> P \\<oplus> Q \\<oplus> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumZero:\n  fixes P :: pi\n  \n  shows \"P \\<oplus> \\<zero> \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "let ?X = \"{(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "have \"(P \\<oplus> \\<zero>, P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<oplus> \\<zero>, P)\n    \\<in> {(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}", "by simp"], ["proof (state)\nthis:\n  (P \\<oplus> \\<zero>, P)\n  \\<in> {(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<oplus> \\<zero>, P)\n  \\<in> {(P \\<oplus> \\<zero>, P), (P, P \\<oplus> \\<zero>)}\n\ngoal (1 subgoal):\n 1. P \\<oplus> \\<zero> \\<sim> P", "by(coinduct rule: bisimCoinduct) (auto intro: reflexive sumZeroLeft sumZeroRight)"], ["proof (state)\nthis:\n  P \\<oplus> \\<zero> \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "(******** The |-operator *********)"], ["", "lemma parZero:\n  fixes P :: pi\n  \n  shows \"P \\<parallel> \\<zero> \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "let ?X = \"{(P \\<parallel> \\<zero>, P) | P. True} \\<union> {(P, P \\<parallel> \\<zero>) | P . True}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "have \"(P \\<parallel> \\<zero>, P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> \\<zero>, P)\n    \\<in> {(P \\<parallel> \\<zero>, P) |P. True} \\<union>\n          {(P, P \\<parallel> \\<zero>) |P. True}", "by blast"], ["proof (state)\nthis:\n  (P \\<parallel> \\<zero>, P)\n  \\<in> {(P \\<parallel> \\<zero>, P) |P. True} \\<union>\n        {(P, P \\<parallel> \\<zero>) |P. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<parallel> \\<zero>, P)\n  \\<in> {(P \\<parallel> \\<zero>, P) |P. True} \\<union>\n        {(P, P \\<parallel> \\<zero>) |P. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "by(coinduct rule: bisimCoinduct, auto intro: parZeroRight parZeroLeft)"], ["proof (state)\nthis:\n  P \\<parallel> \\<zero> \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parSym:\n  fixes P :: pi\n  and   Q :: pi\n\n  shows \"P \\<parallel> Q \\<sim> Q \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "let ?X = \"{(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) | lst P Q. True}\""], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "have \"(P \\<parallel> Q, Q \\<parallel> P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q, Q \\<parallel> P)\n    \\<in> {(resChain lst (P \\<parallel> Q),\n            resChain lst (Q \\<parallel> P)) |\n           lst P Q. True}", "by(blast intro: resChain.base[THEN sym])"], ["proof (state)\nthis:\n  (P \\<parallel> Q, Q \\<parallel> P)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (P \\<parallel> Q, Q \\<parallel> P)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "proof(coinduct rule: bisimCoinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "case(cSim PQ QP)"], ["proof (state)\nthis:\n  (PQ, QP)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "{"], ["proof (state)\nthis:\n  (PQ, QP)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "fix lst P Q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "have \"\\<And>P Q. (P \\<parallel> Q, Q \\<parallel> P) \\<in> ?X \\<union> bisim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       (P \\<parallel> Q, Q \\<parallel> P)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<union>\n             bisim", "by(blast intro: resChain.base[THEN sym])"], ["proof (state)\nthis:\n  (?P \\<parallel> ?Q, ?Q \\<parallel> ?P)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "moreover"], ["proof (state)\nthis:\n  (?P \\<parallel> ?Q, ?Q \\<parallel> ?P)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "have Res: \"\\<And>x P Q. (P, Q) \\<in> ?X \\<union> bisim \\<Longrightarrow> (<\\<nu>x>P, <\\<nu>x>Q) \\<in> ?X \\<union> bisim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x P Q.\n       (P, Q)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<union>\n             bisim \\<Longrightarrow>\n       (<\\<nu>x>P, <\\<nu>x>Q)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<union>\n             bisim", "by(auto intro: resPres resChain.step[THEN sym])"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "ultimately"], ["proof (chain)\npicking this:\n  (?P \\<parallel> ?Q, ?Q \\<parallel> ?P)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim\n  (?P, ?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim", "have \"P \\<parallel> Q \\<leadsto>[(?X \\<union> bisim)] Q \\<parallel> P\""], ["proof (prove)\nusing this:\n  (?P \\<parallel> ?Q, ?Q \\<parallel> ?P)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim\n  (?P, ?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim\n\ngoal (1 subgoal):\n 1. P \\<parallel>\n    Q \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                    resChain lst (Q \\<parallel> P)) |\n                   lst P Q. True} \\<union>\n                  bisim)] Q \\<parallel> P", "by(rule parSym)"], ["proof (state)\nthis:\n  P \\<parallel>\n  Q \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                  resChain lst (Q \\<parallel> P)) |\n                 lst P Q. True} \\<union>\n                bisim)] Q \\<parallel> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "moreover"], ["proof (state)\nthis:\n  P \\<parallel>\n  Q \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                  resChain lst (Q \\<parallel> P)) |\n                 lst P Q. True} \\<union>\n                bisim)] Q \\<parallel> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "have \"eqvt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt\n     {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst\n      P Q. True}", "by(force simp add: eqvt_def)"], ["proof (state)\nthis:\n  eqvt\n   {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst P\n    Q. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "hence \"eqvt(?X \\<union> bisim)\""], ["proof (prove)\nusing this:\n  eqvt\n   {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst P\n    Q. True}\n\ngoal (1 subgoal):\n 1. eqvt\n     ({(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst\n       P Q. True} \\<union>\n      bisim)", "by auto"], ["proof (state)\nthis:\n  eqvt\n   ({(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst P\n     Q. True} \\<union>\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "ultimately"], ["proof (chain)\npicking this:\n  P \\<parallel>\n  Q \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                  resChain lst (Q \\<parallel> P)) |\n                 lst P Q. True} \\<union>\n                bisim)] Q \\<parallel> P\n  eqvt\n   ({(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst P\n     Q. True} \\<union>\n    bisim)", "have \"resChain lst (P \\<parallel> Q) \\<leadsto>[(?X \\<union> bisim)] resChain lst (Q \\<parallel> P)\""], ["proof (prove)\nusing this:\n  P \\<parallel>\n  Q \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                  resChain lst (Q \\<parallel> P)) |\n                 lst P Q. True} \\<union>\n                bisim)] Q \\<parallel> P\n  eqvt\n   ({(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst P\n     Q. True} \\<union>\n    bisim)\n\ngoal (1 subgoal):\n 1. resChain lst\n     (P \\<parallel>\n      Q) \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] resChain lst (Q \\<parallel> P)", "using Res"], ["proof (prove)\nusing this:\n  P \\<parallel>\n  Q \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                  resChain lst (Q \\<parallel> P)) |\n                 lst P Q. True} \\<union>\n                bisim)] Q \\<parallel> P\n  eqvt\n   ({(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |lst P\n     Q. True} \\<union>\n    bisim)\n  (?P, ?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True} \\<union>\n        bisim\n\ngoal (1 subgoal):\n 1. resChain lst\n     (P \\<parallel>\n      Q) \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] resChain lst (Q \\<parallel> P)", "by(rule resChainI)"], ["proof (state)\nthis:\n  resChain lst\n   (P \\<parallel>\n    Q) \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                     resChain lst (Q \\<parallel> P)) |\n                    lst P Q. True} \\<union>\n                   bisim)] resChain lst (Q \\<parallel> P)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "}"], ["proof (state)\nthis:\n  resChain ?lst2\n   (?Pa2 \\<parallel>\n    ?Qa2) \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                        resChain lst (Q \\<parallel> P)) |\n                       lst P Q. True} \\<union>\n                      bisim)] resChain ?lst2 (?Qa2 \\<parallel> ?Pa2)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       R \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                       resChain lst (Q \\<parallel> P)) |\n                      lst P Q. True} \\<union>\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "with \\<open>(PQ, QP) \\<in> ?X\\<close>"], ["proof (chain)\npicking this:\n  (PQ, QP)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n  resChain ?lst2\n   (?Pa2 \\<parallel>\n    ?Qa2) \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                        resChain lst (Q \\<parallel> P)) |\n                       lst P Q. True} \\<union>\n                      bisim)] resChain ?lst2 (?Qa2 \\<parallel> ?Pa2)", "show ?case"], ["proof (prove)\nusing this:\n  (PQ, QP)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n  resChain ?lst2\n   (?Pa2 \\<parallel>\n    ?Qa2) \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                        resChain lst (Q \\<parallel> P)) |\n                       lst P Q. True} \\<union>\n                      bisim)] resChain ?lst2 (?Qa2 \\<parallel> ?Pa2)\n\ngoal (1 subgoal):\n 1. PQ \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                     resChain lst (Q \\<parallel> P)) |\n                    lst P Q. True} \\<union>\n                   bisim)] QP", "by auto"], ["proof (state)\nthis:\n  PQ \\<leadsto>[({(resChain lst (P \\<parallel> Q),\n                   resChain lst (Q \\<parallel> P)) |\n                  lst P Q. True} \\<union>\n                 bisim)] QP\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "case(cSym PQ QP)"], ["proof (state)\nthis:\n  (PQ, QP)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> {(resChain lst (P \\<parallel> Q),\n               resChain lst (Q \\<parallel> P)) |\n              lst P Q. True}", "thus ?case"], ["proof (prove)\nusing this:\n  (PQ, QP)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n\ngoal (1 subgoal):\n 1. (QP, PQ)\n    \\<in> {(resChain lst (P \\<parallel> Q),\n            resChain lst (Q \\<parallel> P)) |\n           lst P Q. True}", "by auto"], ["proof (state)\nthis:\n  (QP, PQ)\n  \\<in> {(resChain lst (P \\<parallel> Q), resChain lst (Q \\<parallel> P)) |\n         lst P Q. True}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P \\<parallel> Q \\<sim> Q \\<parallel> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeExtPar:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "let ?X = \"{(resChain lst (<\\<nu>x>(P \\<parallel> Q)), resChain lst (P \\<parallel> <\\<nu>x>Q)) | lst x P Q. x \\<sharp> P} \\<union>\n            {(resChain lst (P \\<parallel> <\\<nu>x>Q), resChain lst (<\\<nu>x>(P \\<parallel> Q))) | lst x P Q. x \\<sharp> P}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "let ?Y = \"bisim O (?X \\<union> bisim) O bisim\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "have Res: \"\\<And>P Q x. (P, Q) \\<in> ?X \\<Longrightarrow> (<\\<nu>x>P, <\\<nu>x>Q) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       (P, Q)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (<\\<nu>x>P, <\\<nu>x>Q)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P}", "by(blast intro: resChain.step[THEN sym])"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "from \\<open>x \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> P", "have \"(<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q) \\<in> ?X\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n    \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n            resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n           lst x P Q. x \\<sharp> P} \\<union>\n          {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n            resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n           lst x P Q. x \\<sharp> P}", "by(blast intro: resChain.base[THEN sym])"], ["proof (state)\nthis:\n  (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "moreover"], ["proof (state)\nthis:\n  (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "have EqvtX: \"eqvt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt\n     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n       lst x P Q. x \\<sharp> P} \\<union>\n      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n       lst x P Q. x \\<sharp> P})", "by(fastforce simp add: eqvt_def name_fresh_left name_rev_per)"], ["proof (state)\nthis:\n  eqvt\n   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n     lst x P Q. x \\<sharp> P} \\<union>\n    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n     lst x P Q. x \\<sharp> P})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "ultimately"], ["proof (chain)\npicking this:\n  (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n  eqvt\n   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n     lst x P Q. x \\<sharp> P} \\<union>\n    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n     lst x P Q. x \\<sharp> P})", "show ?thesis"], ["proof (prove)\nusing this:\n  (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n  eqvt\n   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n     lst x P Q. x \\<sharp> P} \\<union>\n    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n     lst x P Q. x \\<sharp> P})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q", "proof(coinduct rule: bisimTransitiveCoinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "case(cSim P Q)"], ["proof (state)\nthis:\n  (P, Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  (P, Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "fix P Q lst x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "assume \"(x::name) \\<sharp> (P::pi)\""], ["proof (state)\nthis:\n  x \\<sharp> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  x \\<sharp> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "have \"Id \\<subseteq> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<subseteq> bisim O\n                   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                     lst x P Q. x \\<sharp> P} \\<union>\n                    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                     lst x P Q. x \\<sharp> P} \\<union>\n                    bisim) O\n                   bisim", "by(blast intro: reflexive)"], ["proof (state)\nthis:\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "from \\<open>eqvt ?X\\<close> bisimEqvt"], ["proof (chain)\npicking this:\n  eqvt\n   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n     lst x P Q. x \\<sharp> P} \\<union>\n    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n     lst x P Q. x \\<sharp> P})\n  eqvt bisim", "have \"eqvt ?Y\""], ["proof (prove)\nusing this:\n  eqvt\n   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n     lst x P Q. x \\<sharp> P} \\<union>\n    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n     lst x P Q. x \\<sharp> P})\n  eqvt bisim\n\ngoal (1 subgoal):\n 1. eqvt\n     (bisim O\n      ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n         resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n        lst x P Q. x \\<sharp> P} \\<union>\n       {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n         resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n        lst x P Q. x \\<sharp> P} \\<union>\n       bisim) O\n      bisim)", "by blast"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "have \"\\<And>P Q x. x \\<sharp> P \\<Longrightarrow> (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q) \\<in> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       x \\<sharp> P \\<Longrightarrow>\n       (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "by(blast intro: resChain.base[THEN sym] reflexive)"], ["proof (state)\nthis:\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (<\\<nu>?x>(?P \\<parallel> ?Q), ?P \\<parallel> <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (<\\<nu>?x>(?P \\<parallel> ?Q), ?P \\<parallel> <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (<\\<nu>?x>(?P \\<parallel> ?Q), ?P \\<parallel> <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "fix P Q x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "have \"<\\<nu>x><\\<nu>y>(P \\<parallel> Q) \\<sim> <\\<nu>y><\\<nu>x>(P \\<parallel> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x><\\<nu>y>(P \\<parallel> Q) \\<sim>\n    <\\<nu>y><\\<nu>x>(P \\<parallel> Q)", "by(rule resComm)"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>(P \\<parallel> Q) \\<sim> <\\<nu>y><\\<nu>x>(P \\<parallel> Q)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x><\\<nu>y>(P \\<parallel> Q) \\<sim> <\\<nu>y><\\<nu>x>(P \\<parallel> Q)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "assume \"x \\<sharp> P\""], ["proof (state)\nthis:\n  x \\<sharp> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "hence \"(<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q) \\<in> ?X\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n    \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n            resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n           lst x P Q. x \\<sharp> P} \\<union>\n          {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n            resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n           lst x P Q. x \\<sharp> P}", "by(fastforce intro: resChain.base[THEN sym])"], ["proof (state)\nthis:\n  (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "hence \"(<\\<nu>y><\\<nu>x>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q)) \\<in> ?X\""], ["proof (prove)\nusing this:\n  (<\\<nu>x>(P \\<parallel> Q), P \\<parallel> <\\<nu>x>Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. (<\\<nu>y><\\<nu>x>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q))\n    \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n            resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n           lst x P Q. x \\<sharp> P} \\<union>\n          {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n            resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n           lst x P Q. x \\<sharp> P}", "by(rule Res)"], ["proof (state)\nthis:\n  (<\\<nu>y><\\<nu>x>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x><\\<nu>y>(P \\<parallel> Q) \\<sim> <\\<nu>y><\\<nu>x>(P \\<parallel> Q)\n  (<\\<nu>y><\\<nu>x>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}", "have  \"(<\\<nu>x><\\<nu>y>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q)) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  <\\<nu>x><\\<nu>y>(P \\<parallel> Q) \\<sim> <\\<nu>y><\\<nu>x>(P \\<parallel> Q)\n  (<\\<nu>y><\\<nu>x>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. (<\\<nu>x><\\<nu>y>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q))\n    \\<in> bisim O\n          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n            lst x P Q. x \\<sharp> P} \\<union>\n           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n            lst x P Q. x \\<sharp> P} \\<union>\n           bisim) O\n          bisim", "by(blast intro: reflexive)"], ["proof (state)\nthis:\n  (<\\<nu>x><\\<nu>y>(P \\<parallel> Q), <\\<nu>y>(P \\<parallel> <\\<nu>x>Q))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  ?xb2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?xb2><\\<nu>?y2>(?Pc2 \\<parallel> ?Qc2),\n   <\\<nu>?y2>(?Pc2 \\<parallel> <\\<nu>?xb2>?Qc2))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  x \\<sharp> P\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (<\\<nu>?x>(?P \\<parallel> ?Q), ?P \\<parallel> <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n  ?xb2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?xb2><\\<nu>?y2>(?Pc2 \\<parallel> ?Qc2),\n   <\\<nu>?y2>(?Pc2 \\<parallel> <\\<nu>?xb2>?Qc2))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim", "have \"<\\<nu>x>(P \\<parallel> Q) \\<leadsto>[?Y] (P \\<parallel> <\\<nu>x>Q)\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (<\\<nu>?x>(?P \\<parallel> ?Q), ?P \\<parallel> <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n  ?xb2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?xb2><\\<nu>?y2>(?Pc2 \\<parallel> ?Qc2),\n   <\\<nu>?y2>(?Pc2 \\<parallel> <\\<nu>?xb2>?Qc2))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel>\n             Q) \\<leadsto>[(bisim O\n                            ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                              lst x P Q. x \\<sharp> P} \\<union>\n                             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                              lst x P Q. x \\<sharp> P} \\<union>\n                             bisim) O\n                            bisim)] P \\<parallel> <\\<nu>x>Q", "by(rule scopeExtParLeft)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel>\n           Q) \\<leadsto>[(bisim O\n                          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           bisim) O\n                          bisim)] P \\<parallel> <\\<nu>x>Q\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel>\n           Q) \\<leadsto>[(bisim O\n                          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           bisim) O\n                          bisim)] P \\<parallel> <\\<nu>x>Q\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "note \\<open>eqvt ?Y\\<close>"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "from Res"], ["proof (chain)\npicking this:\n  (?P, ?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}", "have \"\\<And>P Q x. (P, Q) \\<in> ?Y \\<Longrightarrow> (<\\<nu>x>P, <\\<nu>x>Q) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  (?P, ?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       (P, Q)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim \\<Longrightarrow>\n       (<\\<nu>x>P, <\\<nu>x>Q)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "by(blast intro: resChain.step[THEN sym] dest: resPres)"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>(P \\<parallel>\n           Q) \\<leadsto>[(bisim O\n                          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           bisim) O\n                          bisim)] P \\<parallel> <\\<nu>x>Q\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim", "have \"resChain lst (<\\<nu>x>(P \\<parallel> Q)) \\<leadsto>[?Y] resChain lst (P \\<parallel> <\\<nu>x>Q)\""], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<parallel>\n           Q) \\<leadsto>[(bisim O\n                          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           bisim) O\n                          bisim)] P \\<parallel> <\\<nu>x>Q\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. resChain lst\n     (<\\<nu>x>(P \\<parallel>\n               Q)) \\<leadsto>[(bisim O\n                               ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                                  resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                                 lst x P Q. x \\<sharp> P} \\<union>\n                                {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                                  resChain lst\n                                   (<\\<nu>x>(P \\<parallel> Q))) |\n                                 lst x P Q. x \\<sharp> P} \\<union>\n                                bisim) O\n                               bisim)] resChain lst\n  (P \\<parallel> <\\<nu>x>Q)", "by(rule resChainI)"], ["proof (state)\nthis:\n  resChain lst\n   (<\\<nu>x>(P \\<parallel>\n             Q)) \\<leadsto>[(bisim O\n                             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                               lst x P Q. x \\<sharp> P} \\<union>\n                              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                               lst x P Q. x \\<sharp> P} \\<union>\n                              bisim) O\n                             bisim)] resChain lst (P \\<parallel> <\\<nu>x>Q)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (<\\<nu>?xa2>(?Pb2 \\<parallel>\n                ?Qb2)) \\<leadsto>[(bisim O\n                                   ({(resChain lst\n (<\\<nu>x>(P \\<parallel> Q)),\nresChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    {(resChain lst\n (P \\<parallel> <\\<nu>x>Q),\nresChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    bisim) O\n                                   bisim)] resChain ?lst2\n      (?Pb2 \\<parallel> <\\<nu>?xa2>?Qb2)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (<\\<nu>?xa2>(?Pb2 \\<parallel>\n                ?Qb2)) \\<leadsto>[(bisim O\n                                   ({(resChain lst\n (<\\<nu>x>(P \\<parallel> Q)),\nresChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    {(resChain lst\n (P \\<parallel> <\\<nu>x>Q),\nresChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    bisim) O\n                                   bisim)] resChain ?lst2\n      (?Pb2 \\<parallel> <\\<nu>?xa2>?Qb2)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (<\\<nu>?xa2>(?Pb2 \\<parallel>\n                ?Qb2)) \\<leadsto>[(bisim O\n                                   ({(resChain lst\n (<\\<nu>x>(P \\<parallel> Q)),\nresChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    {(resChain lst\n (P \\<parallel> <\\<nu>x>Q),\nresChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    bisim) O\n                                   bisim)] resChain ?lst2\n      (?Pb2 \\<parallel> <\\<nu>?xa2>?Qb2)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "fix P Q lst x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "assume \"(x::name) \\<sharp> (P::pi)\""], ["proof (state)\nthis:\n  x \\<sharp> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  x \\<sharp> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "have \"Id \\<subseteq> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<subseteq> bisim O\n                   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                     lst x P Q. x \\<sharp> P} \\<union>\n                    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                     lst x P Q. x \\<sharp> P} \\<union>\n                    bisim) O\n                   bisim", "by(blast intro: reflexive)"], ["proof (state)\nthis:\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "from \\<open>eqvt ?X\\<close> bisimEqvt"], ["proof (chain)\npicking this:\n  eqvt\n   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n     lst x P Q. x \\<sharp> P} \\<union>\n    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n     lst x P Q. x \\<sharp> P})\n  eqvt bisim", "have \"eqvt ?Y\""], ["proof (prove)\nusing this:\n  eqvt\n   ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n      resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n     lst x P Q. x \\<sharp> P} \\<union>\n    {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n      resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n     lst x P Q. x \\<sharp> P})\n  eqvt bisim\n\ngoal (1 subgoal):\n 1. eqvt\n     (bisim O\n      ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n         resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n        lst x P Q. x \\<sharp> P} \\<union>\n       {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n         resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n        lst x P Q. x \\<sharp> P} \\<union>\n       bisim) O\n      bisim)", "by blast"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "have \"\\<And>P Q x. x \\<sharp> P \\<Longrightarrow> (P \\<parallel> <\\<nu>x>Q, <\\<nu>x>(P \\<parallel> Q)) \\<in> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       x \\<sharp> P \\<Longrightarrow>\n       (P \\<parallel> <\\<nu>x>Q, <\\<nu>x>(P \\<parallel> Q))\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "by(blast intro: resChain.base[THEN sym] reflexive)"], ["proof (state)\nthis:\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (?P \\<parallel> <\\<nu>?x>?Q, <\\<nu>?x>(?P \\<parallel> ?Q))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (?P \\<parallel> <\\<nu>?x>?Q, <\\<nu>?x>(?P \\<parallel> ?Q))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (?P \\<parallel> <\\<nu>?x>?Q, <\\<nu>?x>(?P \\<parallel> ?Q))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "fix P Q x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "have \"<\\<nu>y><\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x><\\<nu>y>(P \\<parallel> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>y><\\<nu>x>(P \\<parallel> Q) \\<sim>\n    <\\<nu>x><\\<nu>y>(P \\<parallel> Q)", "by(rule resComm)"], ["proof (state)\nthis:\n  <\\<nu>y><\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x><\\<nu>y>(P \\<parallel> Q)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  <\\<nu>y><\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x><\\<nu>y>(P \\<parallel> Q)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "assume \"x \\<sharp> P\""], ["proof (state)\nthis:\n  x \\<sharp> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "hence \"(P \\<parallel> <\\<nu>x>Q, <\\<nu>x>(P \\<parallel> Q)) \\<in> ?X\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. (P \\<parallel> <\\<nu>x>Q, <\\<nu>x>(P \\<parallel> Q))\n    \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n            resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n           lst x P Q. x \\<sharp> P} \\<union>\n          {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n            resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n           lst x P Q. x \\<sharp> P}", "by(fastforce intro: resChain.base[THEN sym])"], ["proof (state)\nthis:\n  (P \\<parallel> <\\<nu>x>Q, <\\<nu>x>(P \\<parallel> Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "hence \"(<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>y><\\<nu>x>(P \\<parallel> Q)) \\<in> ?X\""], ["proof (prove)\nusing this:\n  (P \\<parallel> <\\<nu>x>Q, <\\<nu>x>(P \\<parallel> Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. (<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>y><\\<nu>x>(P \\<parallel> Q))\n    \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n            resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n           lst x P Q. x \\<sharp> P} \\<union>\n          {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n            resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n           lst x P Q. x \\<sharp> P}", "by(rule Res)"], ["proof (state)\nthis:\n  (<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>y><\\<nu>x>(P \\<parallel> Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>y><\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x><\\<nu>y>(P \\<parallel> Q)\n  (<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>y><\\<nu>x>(P \\<parallel> Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}", "have  \"(<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>x><\\<nu>y>(P \\<parallel> Q)) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  <\\<nu>y><\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x><\\<nu>y>(P \\<parallel> Q)\n  (<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>y><\\<nu>x>(P \\<parallel> Q))\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. (<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>x><\\<nu>y>(P \\<parallel> Q))\n    \\<in> bisim O\n          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n            lst x P Q. x \\<sharp> P} \\<union>\n           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n            lst x P Q. x \\<sharp> P} \\<union>\n           bisim) O\n          bisim", "by(blast intro: reflexive)"], ["proof (state)\nthis:\n  (<\\<nu>y>(P \\<parallel> <\\<nu>x>Q), <\\<nu>x><\\<nu>y>(P \\<parallel> Q))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  ?xb2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?y2>(?Pc2 \\<parallel> <\\<nu>?xb2>?Qc2),\n   <\\<nu>?xb2><\\<nu>?y2>(?Pc2 \\<parallel> ?Qc2))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  x \\<sharp> P\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (?P \\<parallel> <\\<nu>?x>?Q, <\\<nu>?x>(?P \\<parallel> ?Q))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n  ?xb2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?y2>(?Pc2 \\<parallel> <\\<nu>?xb2>?Qc2),\n   <\\<nu>?xb2><\\<nu>?y2>(?Pc2 \\<parallel> ?Qc2))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim", "have \"(P \\<parallel> <\\<nu>x>Q) \\<leadsto>[?Y] <\\<nu>x>(P \\<parallel> Q)\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n  Id \\<subseteq> bisim O\n                 ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                    resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                    resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                   lst x P Q. x \\<sharp> P} \\<union>\n                  bisim) O\n                 bisim\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  ?x \\<sharp> ?P \\<Longrightarrow>\n  (?P \\<parallel> <\\<nu>?x>?Q, <\\<nu>?x>(?P \\<parallel> ?Q))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n  ?xb2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?y2>(?Pc2 \\<parallel> <\\<nu>?xb2>?Qc2),\n   <\\<nu>?xb2><\\<nu>?y2>(?Pc2 \\<parallel> ?Qc2))\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. P \\<parallel>\n    <\\<nu>x>Q \\<leadsto>[(bisim O\n                          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                            lst x P Q. x \\<sharp> P} \\<union>\n                           bisim) O\n                          bisim)] <\\<nu>x>(P \\<parallel> Q)", "by(rule scopeExtParRight)"], ["proof (state)\nthis:\n  P \\<parallel>\n  <\\<nu>x>Q \\<leadsto>[(bisim O\n                        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         bisim) O\n                        bisim)] <\\<nu>x>(P \\<parallel> Q)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  P \\<parallel>\n  <\\<nu>x>Q \\<leadsto>[(bisim O\n                        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         bisim) O\n                        bisim)] <\\<nu>x>(P \\<parallel> Q)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "note \\<open>eqvt ?Y\\<close>"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "from Res"], ["proof (chain)\npicking this:\n  (?P, ?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}", "have \"\\<And>P Q x. (P, Q) \\<in> ?Y \\<Longrightarrow> (<\\<nu>x>P, <\\<nu>x>Q) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  (?P, ?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       (P, Q)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim \\<Longrightarrow>\n       (<\\<nu>x>P, <\\<nu>x>Q)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "by(blast intro: resChain.step[THEN sym] dest: resPres)"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  P \\<parallel>\n  <\\<nu>x>Q \\<leadsto>[(bisim O\n                        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         bisim) O\n                        bisim)] <\\<nu>x>(P \\<parallel> Q)\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim", "have \"resChain lst (P \\<parallel> <\\<nu>x>Q) \\<leadsto>[?Y] resChain lst (<\\<nu>x>(P \\<parallel> Q))\""], ["proof (prove)\nusing this:\n  P \\<parallel>\n  <\\<nu>x>Q \\<leadsto>[(bisim O\n                        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                          lst x P Q. x \\<sharp> P} \\<union>\n                         bisim) O\n                        bisim)] <\\<nu>x>(P \\<parallel> Q)\n  eqvt\n   (bisim O\n    ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n       resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n       resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n      lst x P Q. x \\<sharp> P} \\<union>\n     bisim) O\n    bisim)\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. resChain lst\n     (P \\<parallel>\n      <\\<nu>x>Q) \\<leadsto>[(bisim O\n                             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                               lst x P Q. x \\<sharp> P} \\<union>\n                              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                               lst x P Q. x \\<sharp> P} \\<union>\n                              bisim) O\n                             bisim)] resChain lst\n(<\\<nu>x>(P \\<parallel> Q))", "by(rule resChainI)"], ["proof (state)\nthis:\n  resChain lst\n   (P \\<parallel>\n    <\\<nu>x>Q) \\<leadsto>[(bisim O\n                           ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                              resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                             lst x P Q. x \\<sharp> P} \\<union>\n                            {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                              resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                             lst x P Q. x \\<sharp> P} \\<union>\n                            bisim) O\n                           bisim)] resChain lst (<\\<nu>x>(P \\<parallel> Q))\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (?Pb2 \\<parallel>\n    <\\<nu>?xa2>?Qb2) \\<leadsto>[(bisim O\n                                 ({(resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q)),\n                                    resChain lst\n                                     (P \\<parallel> <\\<nu>x>Q)) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                                    resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q))) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  bisim) O\n                                 bisim)] resChain ?lst2\n    (<\\<nu>?xa2>(?Pb2 \\<parallel> ?Qb2))\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                        resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                        resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                       lst x P Q. x \\<sharp> P} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (<\\<nu>?xa2>(?Pb2 \\<parallel>\n                ?Qb2)) \\<leadsto>[(bisim O\n                                   ({(resChain lst\n (<\\<nu>x>(P \\<parallel> Q)),\nresChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    {(resChain lst\n (P \\<parallel> <\\<nu>x>Q),\nresChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    bisim) O\n                                   bisim)] resChain ?lst2\n      (?Pb2 \\<parallel> <\\<nu>?xa2>?Qb2)\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (?Pb2 \\<parallel>\n    <\\<nu>?xa2>?Qb2) \\<leadsto>[(bisim O\n                                 ({(resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q)),\n                                    resChain lst\n                                     (P \\<parallel> <\\<nu>x>Q)) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                                    resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q))) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  bisim) O\n                                 bisim)] resChain ?lst2\n    (<\\<nu>?xa2>(?Pb2 \\<parallel> ?Qb2))", "show ?case"], ["proof (prove)\nusing this:\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (<\\<nu>?xa2>(?Pb2 \\<parallel>\n                ?Qb2)) \\<leadsto>[(bisim O\n                                   ({(resChain lst\n (<\\<nu>x>(P \\<parallel> Q)),\nresChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    {(resChain lst\n (P \\<parallel> <\\<nu>x>Q),\nresChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    bisim) O\n                                   bisim)] resChain ?lst2\n      (?Pb2 \\<parallel> <\\<nu>?xa2>?Qb2)\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (?Pb2 \\<parallel>\n    <\\<nu>?xa2>?Qb2) \\<leadsto>[(bisim O\n                                 ({(resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q)),\n                                    resChain lst\n                                     (P \\<parallel> <\\<nu>x>Q)) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                                    resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q))) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  bisim) O\n                                 bisim)] resChain ?lst2\n    (<\\<nu>?xa2>(?Pb2 \\<parallel> ?Qb2))\n\ngoal (1 subgoal):\n 1. P \\<leadsto>[(bisim O\n                  ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                     resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                    lst x P Q. x \\<sharp> P} \\<union>\n                   {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                     resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                    lst x P Q. x \\<sharp> P} \\<union>\n                   bisim) O\n                  bisim)] Q", "using \\<open>(P, Q) \\<in> ?X\\<close>"], ["proof (prove)\nusing this:\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (<\\<nu>?xa2>(?Pb2 \\<parallel>\n                ?Qb2)) \\<leadsto>[(bisim O\n                                   ({(resChain lst\n (<\\<nu>x>(P \\<parallel> Q)),\nresChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    {(resChain lst\n (P \\<parallel> <\\<nu>x>Q),\nresChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                                     lst x P Q. x \\<sharp> P} \\<union>\n                                    bisim) O\n                                   bisim)] resChain ?lst2\n      (?Pb2 \\<parallel> <\\<nu>?xa2>?Qb2)\n  ?xa2 \\<sharp> ?Pb2 \\<Longrightarrow>\n  resChain ?lst2\n   (?Pb2 \\<parallel>\n    <\\<nu>?xa2>?Qb2) \\<leadsto>[(bisim O\n                                 ({(resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q)),\n                                    resChain lst\n                                     (P \\<parallel> <\\<nu>x>Q)) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                                    resChain lst\n                                     (<\\<nu>x>(P \\<parallel> Q))) |\n                                   lst x P Q. x \\<sharp> P} \\<union>\n                                  bisim) O\n                                 bisim)] resChain ?lst2\n    (<\\<nu>?xa2>(?Pb2 \\<parallel> ?Qb2))\n  (P, Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. P \\<leadsto>[(bisim O\n                  ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                     resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                    lst x P Q. x \\<sharp> P} \\<union>\n                   {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                     resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                    lst x P Q. x \\<sharp> P} \\<union>\n                   bisim) O\n                  bisim)] Q", "by auto"], ["proof (state)\nthis:\n  P \\<leadsto>[(bisim O\n                ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                   resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n                  lst x P Q. x \\<sharp> P} \\<union>\n                 {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                   resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n                  lst x P Q. x \\<sharp> P} \\<union>\n                 bisim) O\n                bisim)] Q\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "case(cSym P Q)"], ["proof (state)\nthis:\n  (P, Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n               resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n              lst x P Q. x \\<sharp> P} \\<union>\n             {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n               resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n              lst x P Q. x \\<sharp> P} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n                resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n                resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n               lst x P Q. x \\<sharp> P} \\<union>\n              bisim) O\n             bisim", "thus ?case"], ["proof (prove)\nusing this:\n  (P, Q)\n  \\<in> {(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n          resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n         lst x P Q. x \\<sharp> P} \\<union>\n        {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n          resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n         lst x P Q. x \\<sharp> P}\n\ngoal (1 subgoal):\n 1. (Q, P)\n    \\<in> bisim O\n          ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n             resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n            lst x P Q. x \\<sharp> P} \\<union>\n           {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n             resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n            lst x P Q. x \\<sharp> P} \\<union>\n           bisim) O\n          bisim", "by auto (blast dest: symmetric transitive intro: resChain.base[THEN sym] reflexive)+"], ["proof (state)\nthis:\n  (Q, P)\n  \\<in> bisim O\n        ({(resChain lst (<\\<nu>x>(P \\<parallel> Q)),\n           resChain lst (P \\<parallel> <\\<nu>x>Q)) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         {(resChain lst (P \\<parallel> <\\<nu>x>Q),\n           resChain lst (<\\<nu>x>(P \\<parallel> Q))) |\n          lst x P Q. x \\<sharp> P} \\<union>\n         bisim) O\n        bisim\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim> P \\<parallel> <\\<nu>x>Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeExtPar':\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n\n  assumes xFreshQ: \"x \\<sharp> Q\"\n\n  shows \"<\\<nu>x>(P \\<parallel> Q) \\<sim> (<\\<nu>x>P) \\<parallel> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "have \"<\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)", "have \"P \\<parallel> Q \\<sim> Q \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<sim> Q \\<parallel> P", "by(rule parSym)"], ["proof (state)\nthis:\n  P \\<parallel> Q \\<sim> Q \\<parallel> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P \\<parallel> Q \\<sim> Q \\<parallel> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)", "by(rule resPres)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "from xFreshQ"], ["proof (chain)\npicking this:\n  x \\<sharp> Q", "have \"<\\<nu>x>(Q \\<parallel> P) \\<sim> Q \\<parallel> (<\\<nu>x>P)\""], ["proof (prove)\nusing this:\n  x \\<sharp> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(Q \\<parallel> P) \\<sim> Q \\<parallel> <\\<nu>x>P", "by(rule scopeExtPar)"], ["proof (state)\nthis:\n  <\\<nu>x>(Q \\<parallel> P) \\<sim> Q \\<parallel> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(Q \\<parallel> P) \\<sim> Q \\<parallel> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "have \"Q \\<parallel> <\\<nu>x>P \\<sim> (<\\<nu>x>P) \\<parallel> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> Q", "by(rule parSym)"], ["proof (state)\nthis:\n  Q \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)\n  <\\<nu>x>(Q \\<parallel> P) \\<sim> Q \\<parallel> <\\<nu>x>P\n  Q \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>(Q \\<parallel> P)\n  <\\<nu>x>(Q \\<parallel> P) \\<sim> Q \\<parallel> <\\<nu>x>P\n  Q \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q", "by(blast intro: transitive)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<sim> <\\<nu>x>P \\<parallel> Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parAssoc:\n  fixes P :: pi\n  and   Q :: pi\n  and   R :: pi\n\n  shows \"(P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> (Q \\<parallel> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "let ?X = \"{(resChain lst ((P \\<parallel> Q) \\<parallel> R), resChain lst (P \\<parallel> (Q \\<parallel> R))) | lst P Q R. True}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "let ?Y = \"bisim O (?X \\<union> bisim) O bisim\""], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "have ResX: \"\\<And>P Q x. (P, Q) \\<in> ?X \\<Longrightarrow> (<\\<nu>x>P, <\\<nu>x>Q) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       (P, Q)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (<\\<nu>x>P, <\\<nu>x>Q)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True}", "by(blast intro: resChain.step[symmetric])"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True} \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "hence ResY: \"\\<And>P Q x. (P, Q) \\<in> ?Y \\<Longrightarrow> (<\\<nu>x>P, <\\<nu>x>Q) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  (?P, ?Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True} \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       (P, Q)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim \\<Longrightarrow>\n       (<\\<nu>x>P, <\\<nu>x>Q)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "by(blast intro: resChain.step[symmetric] dest: resPres)"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "have \"((P \\<parallel> Q) \\<parallel> R, P \\<parallel> (Q \\<parallel> R)) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<parallel> Q) \\<parallel> R, P \\<parallel> Q \\<parallel> R)\n    \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n            resChain lst (P \\<parallel> Q \\<parallel> R)) |\n           lst P Q R. True}", "by(blast intro: resChain.base[symmetric])"], ["proof (state)\nthis:\n  ((P \\<parallel> Q) \\<parallel> R, P \\<parallel> Q \\<parallel> R)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "moreover"], ["proof (state)\nthis:\n  ((P \\<parallel> Q) \\<parallel> R, P \\<parallel> Q \\<parallel> R)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "have \"eqvt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt\n     {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n       resChain lst (P \\<parallel> Q \\<parallel> R)) |\n      lst P Q R. True}", "by(fastforce simp add: eqvt_def)"], ["proof (state)\nthis:\n  eqvt\n   {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n     resChain lst (P \\<parallel> Q \\<parallel> R)) |\n    lst P Q R. True}\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "ultimately"], ["proof (chain)\npicking this:\n  ((P \\<parallel> Q) \\<parallel> R, P \\<parallel> Q \\<parallel> R)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  eqvt\n   {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n     resChain lst (P \\<parallel> Q \\<parallel> R)) |\n    lst P Q R. True}", "show ?thesis"], ["proof (prove)\nusing this:\n  ((P \\<parallel> Q) \\<parallel> R, P \\<parallel> Q \\<parallel> R)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  eqvt\n   {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n     resChain lst (P \\<parallel> Q \\<parallel> R)) |\n    lst P Q R. True}\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R", "proof(coinduct rule: bisimTransitiveCoinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "case(cSim P Q)"], ["proof (state)\nthis:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "fix P Q R lst"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "have \"\\<And>P Q R. ((P \\<parallel> Q) \\<parallel> R, P \\<parallel> (Q \\<parallel> R)) \\<in> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q R.\n       ((P \\<parallel> Q) \\<parallel> R, P \\<parallel> Q \\<parallel> R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "by(blast intro: reflexive resChain.base[symmetric])"], ["proof (state)\nthis:\n  ((?P \\<parallel> ?Q) \\<parallel> ?R, ?P \\<parallel> ?Q \\<parallel> ?R)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  ((?P \\<parallel> ?Q) \\<parallel> ?R, ?P \\<parallel> ?Q \\<parallel> ?R)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "have \"\\<And>P Q x. (P, Q) \\<in> ?Y \\<Longrightarrow> (<\\<nu>x>P, <\\<nu>x>Q) \\<in> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q x.\n       (P, Q)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim \\<Longrightarrow>\n       (<\\<nu>x>P, <\\<nu>x>Q)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "by(blast intro: resChain.step[symmetric] resPres)"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "fix P Q R x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "have \"(<\\<nu>x>((P \\<parallel> Q) \\<parallel> R), <\\<nu>x>(P \\<parallel> (Q \\<parallel> R))) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n     <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n    \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n            resChain lst (P \\<parallel> Q \\<parallel> R)) |\n           lst P Q R. True}", "by(rule_tac ResX) (blast intro: resChain.base[symmetric])"], ["proof (state)\nthis:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "assume \"x \\<sharp> P\""], ["proof (state)\nthis:\n  x \\<sharp> P\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "hence \"<\\<nu>x>(P \\<parallel> (Q \\<parallel> R)) \\<sim> P \\<parallel> <\\<nu>x>(Q \\<parallel> R)\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q \\<parallel> R) \\<sim>\n    P \\<parallel> <\\<nu>x>(Q \\<parallel> R)", "by(rule scopeExtPar)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q \\<parallel> R) \\<sim>\n  P \\<parallel> <\\<nu>x>(Q \\<parallel> R)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  <\\<nu>x>(P \\<parallel> Q \\<parallel> R) \\<sim>\n  P \\<parallel> <\\<nu>x>(Q \\<parallel> R)", "have \"(<\\<nu>x>((P \\<parallel> Q) \\<parallel> R), P \\<parallel> <\\<nu>x>(Q \\<parallel> R)) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  <\\<nu>x>(P \\<parallel> Q \\<parallel> R) \\<sim>\n  P \\<parallel> <\\<nu>x>(Q \\<parallel> R)\n\ngoal (1 subgoal):\n 1. (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n     P \\<parallel> <\\<nu>x>(Q \\<parallel> R))\n    \\<in> bisim O\n          ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n             resChain lst (P \\<parallel> Q \\<parallel> R)) |\n            lst P Q R. True} \\<union>\n           bisim) O\n          bisim", "by(blast intro: reflexive)"], ["proof (state)\nthis:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   P \\<parallel> <\\<nu>x>(Q \\<parallel> R))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  ?x2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?x2>((?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2),\n   ?Pc2 \\<parallel> <\\<nu>?x2>(?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  ?x2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?x2>((?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2),\n   ?Pc2 \\<parallel> <\\<nu>?x2>(?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  ?x2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?x2>((?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2),\n   ?Pc2 \\<parallel> <\\<nu>?x2>(?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "fix P Q R x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "have \"(<\\<nu>x>((P \\<parallel> Q) \\<parallel> R), <\\<nu>x>(P \\<parallel> (Q \\<parallel> R))) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n     <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n    \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n            resChain lst (P \\<parallel> Q \\<parallel> R)) |\n           lst P Q R. True}", "by(rule_tac ResX) (blast intro: resChain.base[symmetric])"], ["proof (state)\nthis:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "assume \"x \\<sharp> R\""], ["proof (state)\nthis:\n  x \\<sharp> R\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "hence \"<\\<nu>x>(P \\<parallel> Q) \\<parallel> R \\<sim> <\\<nu>x>((P \\<parallel> Q) \\<parallel> R)\""], ["proof (prove)\nusing this:\n  x \\<sharp> R\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> Q) \\<parallel> R \\<sim>\n    <\\<nu>x>((P \\<parallel> Q) \\<parallel> R)", "by(metis scopeExtPar' symmetric)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> Q) \\<parallel> R \\<sim>\n  <\\<nu>x>((P \\<parallel> Q) \\<parallel> R)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  <\\<nu>x>(P \\<parallel> Q) \\<parallel> R \\<sim>\n  <\\<nu>x>((P \\<parallel> Q) \\<parallel> R)", "have \"(<\\<nu>x>(P \\<parallel> Q) \\<parallel> R, <\\<nu>x>(P \\<parallel> (Q \\<parallel> R))) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  (<\\<nu>x>((P \\<parallel> Q) \\<parallel> R),\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  <\\<nu>x>(P \\<parallel> Q) \\<parallel> R \\<sim>\n  <\\<nu>x>((P \\<parallel> Q) \\<parallel> R)\n\ngoal (1 subgoal):\n 1. (<\\<nu>x>(P \\<parallel> Q) \\<parallel> R,\n     <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n    \\<in> bisim O\n          ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n             resChain lst (P \\<parallel> Q \\<parallel> R)) |\n            lst P Q R. True} \\<union>\n           bisim) O\n          bisim", "by(blast intro: reflexive)"], ["proof (state)\nthis:\n  (<\\<nu>x>(P \\<parallel> Q) \\<parallel> R,\n   <\\<nu>x>(P \\<parallel> Q \\<parallel> R))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  ?x2 \\<sharp> ?Rb2 \\<Longrightarrow>\n  (<\\<nu>?x2>(?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2,\n   <\\<nu>?x2>(?Pc2 \\<parallel> ?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  ((?P \\<parallel> ?Q) \\<parallel> ?R, ?P \\<parallel> ?Q \\<parallel> ?R)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n  ?x2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?x2>((?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2),\n   ?Pc2 \\<parallel> <\\<nu>?x2>(?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n  ?x2 \\<sharp> ?Rb2 \\<Longrightarrow>\n  (<\\<nu>?x2>(?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2,\n   <\\<nu>?x2>(?Pc2 \\<parallel> ?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim", "have \"(P \\<parallel> Q) \\<parallel> R \\<leadsto>[?Y] P \\<parallel> (Q \\<parallel> R)\""], ["proof (prove)\nusing this:\n  ((?P \\<parallel> ?Q) \\<parallel> ?R, ?P \\<parallel> ?Q \\<parallel> ?R)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n  ?x2 \\<sharp> ?Pc2 \\<Longrightarrow>\n  (<\\<nu>?x2>((?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2),\n   ?Pc2 \\<parallel> <\\<nu>?x2>(?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n  ?x2 \\<sharp> ?Rb2 \\<Longrightarrow>\n  (<\\<nu>?x2>(?Pc2 \\<parallel> ?Qc2) \\<parallel> ?Rb2,\n   <\\<nu>?x2>(?Pc2 \\<parallel> ?Qc2 \\<parallel> ?Rb2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q) \\<parallel>\n    R \\<leadsto>[(bisim O\n                  ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                     resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                    lst P Q R. True} \\<union>\n                   bisim) O\n                  bisim)] P \\<parallel> Q \\<parallel> R", "by(rule parAssocLeft)"], ["proof (state)\nthis:\n  (P \\<parallel> Q) \\<parallel>\n  R \\<leadsto>[(bisim O\n                ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                   resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                  lst P Q R. True} \\<union>\n                 bisim) O\n                bisim)] P \\<parallel> Q \\<parallel> R\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  (P \\<parallel> Q) \\<parallel>\n  R \\<leadsto>[(bisim O\n                ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                   resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                  lst P Q R. True} \\<union>\n                 bisim) O\n                bisim)] P \\<parallel> Q \\<parallel> R\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "from \\<open>eqvt ?X\\<close> bisimEqvt"], ["proof (chain)\npicking this:\n  eqvt\n   {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n     resChain lst (P \\<parallel> Q \\<parallel> R)) |\n    lst P Q R. True}\n  eqvt bisim", "have \"eqvt ?Y\""], ["proof (prove)\nusing this:\n  eqvt\n   {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n     resChain lst (P \\<parallel> Q \\<parallel> R)) |\n    lst P Q R. True}\n  eqvt bisim\n\ngoal (1 subgoal):\n 1. eqvt\n     (bisim O\n      ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n         resChain lst (P \\<parallel> Q \\<parallel> R)) |\n        lst P Q R. True} \\<union>\n       bisim) O\n      bisim)", "by blast"], ["proof (state)\nthis:\n  eqvt\n   (bisim O\n    ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n       resChain lst (P \\<parallel> Q \\<parallel> R)) |\n      lst P Q R. True} \\<union>\n     bisim) O\n    bisim)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  (P \\<parallel> Q) \\<parallel>\n  R \\<leadsto>[(bisim O\n                ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                   resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                  lst P Q R. True} \\<union>\n                 bisim) O\n                bisim)] P \\<parallel> Q \\<parallel> R\n  eqvt\n   (bisim O\n    ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n       resChain lst (P \\<parallel> Q \\<parallel> R)) |\n      lst P Q R. True} \\<union>\n     bisim) O\n    bisim)", "have \"resChain lst ((P \\<parallel> Q) \\<parallel> R) \\<leadsto>[?Y] resChain lst (P \\<parallel> (Q \\<parallel> R))\""], ["proof (prove)\nusing this:\n  (P \\<parallel> Q) \\<parallel>\n  R \\<leadsto>[(bisim O\n                ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                   resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                  lst P Q R. True} \\<union>\n                 bisim) O\n                bisim)] P \\<parallel> Q \\<parallel> R\n  eqvt\n   (bisim O\n    ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n       resChain lst (P \\<parallel> Q \\<parallel> R)) |\n      lst P Q R. True} \\<union>\n     bisim) O\n    bisim)\n\ngoal (1 subgoal):\n 1. resChain lst\n     ((P \\<parallel> Q) \\<parallel>\n      R) \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] resChain lst (P \\<parallel> Q \\<parallel> R)", "using ResY"], ["proof (prove)\nusing this:\n  (P \\<parallel> Q) \\<parallel>\n  R \\<leadsto>[(bisim O\n                ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                   resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                  lst P Q R. True} \\<union>\n                 bisim) O\n                bisim)] P \\<parallel> Q \\<parallel> R\n  eqvt\n   (bisim O\n    ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n       resChain lst (P \\<parallel> Q \\<parallel> R)) |\n      lst P Q R. True} \\<union>\n     bisim) O\n    bisim)\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. resChain lst\n     ((P \\<parallel> Q) \\<parallel>\n      R) \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] resChain lst (P \\<parallel> Q \\<parallel> R)", "by(rule resChainI)"], ["proof (state)\nthis:\n  resChain lst\n   ((P \\<parallel> Q) \\<parallel>\n    R) \\<leadsto>[(bisim O\n                   ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                      resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                     lst P Q R. True} \\<union>\n                    bisim) O\n                   bisim)] resChain lst (P \\<parallel> Q \\<parallel> R)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  resChain ?lst2\n   ((?Pb2 \\<parallel> ?Qb2) \\<parallel>\n    ?Ra2) \\<leadsto>[(bisim O\n                      ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                         resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                        lst P Q R. True} \\<union>\n                       bisim) O\n                      bisim)] resChain ?lst2\n                               (?Pb2 \\<parallel> ?Qb2 \\<parallel> ?Ra2)\n\ngoal (2 subgoals):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       R \\<leadsto>[(bisim O\n                     ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                        resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                       lst P Q R. True} \\<union>\n                      bisim) O\n                     bisim)] S\n 2. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "with \\<open>(P, Q) \\<in> ?X\\<close>"], ["proof (chain)\npicking this:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  resChain ?lst2\n   ((?Pb2 \\<parallel> ?Qb2) \\<parallel>\n    ?Ra2) \\<leadsto>[(bisim O\n                      ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                         resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                        lst P Q R. True} \\<union>\n                       bisim) O\n                      bisim)] resChain ?lst2\n                               (?Pb2 \\<parallel> ?Qb2 \\<parallel> ?Ra2)", "show ?case"], ["proof (prove)\nusing this:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  resChain ?lst2\n   ((?Pb2 \\<parallel> ?Qb2) \\<parallel>\n    ?Ra2) \\<leadsto>[(bisim O\n                      ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                         resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                        lst P Q R. True} \\<union>\n                       bisim) O\n                      bisim)] resChain ?lst2\n                               (?Pb2 \\<parallel> ?Qb2 \\<parallel> ?Ra2)\n\ngoal (1 subgoal):\n 1. P \\<leadsto>[(bisim O\n                  ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                     resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                    lst P Q R. True} \\<union>\n                   bisim) O\n                  bisim)] Q", "by auto"], ["proof (state)\nthis:\n  P \\<leadsto>[(bisim O\n                ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                   resChain lst (P \\<parallel> Q \\<parallel> R)) |\n                  lst P Q R. True} \\<union>\n                 bisim) O\n                bisim)] Q\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "case(cSym P Q)"], ["proof (state)\nthis:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "{"], ["proof (state)\nthis:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "fix P Q R lst"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "have \"P \\<parallel> (Q \\<parallel> R) \\<sim> (R \\<parallel> Q) \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> Q \\<parallel> R \\<sim> (R \\<parallel> Q) \\<parallel> P", "by(metis parPres parSym transitive)"], ["proof (state)\nthis:\n  P \\<parallel> Q \\<parallel> R \\<sim> (R \\<parallel> Q) \\<parallel> P\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  P \\<parallel> Q \\<parallel> R \\<sim> (R \\<parallel> Q) \\<parallel> P\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "have \"((R \\<parallel> Q) \\<parallel> P, R \\<parallel> (Q \\<parallel> P)) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R \\<parallel> Q) \\<parallel> P, R \\<parallel> Q \\<parallel> P)\n    \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n            resChain lst (P \\<parallel> Q \\<parallel> R)) |\n           lst P Q R. True}", "by(blast intro: resChain.base[symmetric])"], ["proof (state)\nthis:\n  ((R \\<parallel> Q) \\<parallel> P, R \\<parallel> Q \\<parallel> P)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "moreover"], ["proof (state)\nthis:\n  ((R \\<parallel> Q) \\<parallel> P, R \\<parallel> Q \\<parallel> P)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "have \"R \\<parallel> (Q \\<parallel> P) \\<sim> (P \\<parallel> Q) \\<parallel> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<parallel> Q \\<parallel> P \\<sim> (P \\<parallel> Q) \\<parallel> R", "by(metis parPres parSym transitive)"], ["proof (state)\nthis:\n  R \\<parallel> Q \\<parallel> P \\<sim> (P \\<parallel> Q) \\<parallel> R\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "ultimately"], ["proof (chain)\npicking this:\n  P \\<parallel> Q \\<parallel> R \\<sim> (R \\<parallel> Q) \\<parallel> P\n  ((R \\<parallel> Q) \\<parallel> P, R \\<parallel> Q \\<parallel> P)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  R \\<parallel> Q \\<parallel> P \\<sim> (P \\<parallel> Q) \\<parallel> R", "have \"(P \\<parallel> (Q \\<parallel> R), (P \\<parallel> Q) \\<parallel> R) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  P \\<parallel> Q \\<parallel> R \\<sim> (R \\<parallel> Q) \\<parallel> P\n  ((R \\<parallel> Q) \\<parallel> P, R \\<parallel> Q \\<parallel> P)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  R \\<parallel> Q \\<parallel> P \\<sim> (P \\<parallel> Q) \\<parallel> R\n\ngoal (1 subgoal):\n 1. (P \\<parallel> Q \\<parallel> R, (P \\<parallel> Q) \\<parallel> R)\n    \\<in> bisim O\n          ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n             resChain lst (P \\<parallel> Q \\<parallel> R)) |\n            lst P Q R. True} \\<union>\n           bisim) O\n          bisim", "by blast"], ["proof (state)\nthis:\n  (P \\<parallel> Q \\<parallel> R, (P \\<parallel> Q) \\<parallel> R)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "hence \"(resChain lst (P \\<parallel> (Q \\<parallel> R)), resChain lst ((P \\<parallel> Q) \\<parallel> R)) \\<in> ?Y\""], ["proof (prove)\nusing this:\n  (P \\<parallel> Q \\<parallel> R, (P \\<parallel> Q) \\<parallel> R)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. (resChain lst (P \\<parallel> Q \\<parallel> R),\n     resChain lst ((P \\<parallel> Q) \\<parallel> R))\n    \\<in> bisim O\n          ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n             resChain lst (P \\<parallel> Q \\<parallel> R)) |\n            lst P Q R. True} \\<union>\n           bisim) O\n          bisim", "using ResY"], ["proof (prove)\nusing this:\n  (P \\<parallel> Q \\<parallel> R, (P \\<parallel> Q) \\<parallel> R)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n  (?P, ?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim \\<Longrightarrow>\n  (<\\<nu>?x>?P, <\\<nu>?x>?Q)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. (resChain lst (P \\<parallel> Q \\<parallel> R),\n     resChain lst ((P \\<parallel> Q) \\<parallel> R))\n    \\<in> bisim O\n          ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n             resChain lst (P \\<parallel> Q \\<parallel> R)) |\n            lst P Q R. True} \\<union>\n           bisim) O\n          bisim", "by(induct lst) auto"], ["proof (state)\nthis:\n  (resChain lst (P \\<parallel> Q \\<parallel> R),\n   resChain lst ((P \\<parallel> Q) \\<parallel> R))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "}"], ["proof (state)\nthis:\n  (resChain ?lst2 (?Pb2 \\<parallel> ?Qb2 \\<parallel> ?Ra2),\n   resChain ?lst2 ((?Pb2 \\<parallel> ?Qb2) \\<parallel> ?Ra2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. \\<And>R S.\n       (R, S)\n       \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n               resChain lst (P \\<parallel> Q \\<parallel> R)) |\n              lst P Q R. True} \\<Longrightarrow>\n       (S, R)\n       \\<in> bisim O\n             ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n                resChain lst (P \\<parallel> Q \\<parallel> R)) |\n               lst P Q R. True} \\<union>\n              bisim) O\n             bisim", "with \\<open>(P, Q) \\<in> ?X\\<close>"], ["proof (chain)\npicking this:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  (resChain ?lst2 (?Pb2 \\<parallel> ?Qb2 \\<parallel> ?Ra2),\n   resChain ?lst2 ((?Pb2 \\<parallel> ?Qb2) \\<parallel> ?Ra2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim", "show ?case"], ["proof (prove)\nusing this:\n  (P, Q)\n  \\<in> {(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n          resChain lst (P \\<parallel> Q \\<parallel> R)) |\n         lst P Q R. True}\n  (resChain ?lst2 (?Pb2 \\<parallel> ?Qb2 \\<parallel> ?Ra2),\n   resChain ?lst2 ((?Pb2 \\<parallel> ?Qb2) \\<parallel> ?Ra2))\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal (1 subgoal):\n 1. (Q, P)\n    \\<in> bisim O\n          ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n             resChain lst (P \\<parallel> Q \\<parallel> R)) |\n            lst P Q R. True} \\<union>\n           bisim) O\n          bisim", "by blast"], ["proof (state)\nthis:\n  (Q, P)\n  \\<in> bisim O\n        ({(resChain lst ((P \\<parallel> Q) \\<parallel> R),\n           resChain lst (P \\<parallel> Q \\<parallel> R)) |\n          lst P Q R. True} \\<union>\n         bisim) O\n        bisim\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (P \\<parallel> Q) \\<parallel> R \\<sim> P \\<parallel> Q \\<parallel> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeFresh:\n  fixes x :: name\n  and   P :: pi\n\n  assumes \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>P \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have \"<\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> \\<zero>", "by(rule parZero[THEN symmetric])"], ["proof (state)\nthis:\n  <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have \"<\\<nu>x>P \\<parallel> \\<zero> \\<sim> \\<zero> \\<parallel> <\\<nu>x>P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<parallel> \\<zero> \\<sim> \\<zero> \\<parallel> <\\<nu>x>P", "by(rule parSym)"], ["proof (state)\nthis:\n  <\\<nu>x>P \\<parallel> \\<zero> \\<sim> \\<zero> \\<parallel> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>P \\<parallel> \\<zero> \\<sim> \\<zero> \\<parallel> <\\<nu>x>P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have \"\\<zero> \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>(\\<zero> \\<parallel> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero> \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>(\\<zero> \\<parallel> P)", "by(rule scopeExtPar[THEN symmetric]) auto"], ["proof (state)\nthis:\n  \\<zero> \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>(\\<zero> \\<parallel> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<zero> \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>(\\<zero> \\<parallel> P)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have \"<\\<nu>x>(\\<zero> \\<parallel> P) \\<sim> <\\<nu>x>(P \\<parallel> \\<zero>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(\\<zero> \\<parallel> P) \\<sim> <\\<nu>x>(P \\<parallel> \\<zero>)", "by(rule resPres[OF parSym])"], ["proof (state)\nthis:\n  <\\<nu>x>(\\<zero> \\<parallel> P) \\<sim> <\\<nu>x>(P \\<parallel> \\<zero>)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(\\<zero> \\<parallel> P) \\<sim> <\\<nu>x>(P \\<parallel> \\<zero>)\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "from \\<open>x \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> P", "have \"<\\<nu>x>(P \\<parallel> \\<zero>) \\<sim> P \\<parallel> <\\<nu>x>\\<zero>\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<parallel> \\<zero>) \\<sim> P \\<parallel> <\\<nu>x>\\<zero>", "by(rule scopeExtPar)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> \\<zero>) \\<sim> P \\<parallel> <\\<nu>x>\\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<parallel> \\<zero>) \\<sim> P \\<parallel> <\\<nu>x>\\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have  \"P \\<parallel> <\\<nu>x>\\<zero> \\<sim> <\\<nu>x>\\<zero> \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> <\\<nu>x>\\<zero> \\<sim> <\\<nu>x>\\<zero> \\<parallel> P", "by(rule parSym)"], ["proof (state)\nthis:\n  P \\<parallel> <\\<nu>x>\\<zero> \\<sim> <\\<nu>x>\\<zero> \\<parallel> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  P \\<parallel> <\\<nu>x>\\<zero> \\<sim> <\\<nu>x>\\<zero> \\<parallel> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have \"<\\<nu>x>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P", "by(rule parPres[OF nilRes])"], ["proof (state)\nthis:\n  <\\<nu>x>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have \"\\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>", "by(rule parSym)"], ["proof (state)\nthis:\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "moreover"], ["proof (state)\nthis:\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "have \"P \\<parallel> \\<zero> \\<sim> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<parallel> \\<zero> \\<sim> P", "by(rule parZero)"], ["proof (state)\nthis:\n  P \\<parallel> \\<zero> \\<sim> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> \\<zero>\n  <\\<nu>x>P \\<parallel> \\<zero> \\<sim> \\<zero> \\<parallel> <\\<nu>x>P\n  \\<zero> \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>(\\<zero> \\<parallel> P)\n  <\\<nu>x>(\\<zero> \\<parallel> P) \\<sim> <\\<nu>x>(P \\<parallel> \\<zero>)\n  <\\<nu>x>(P \\<parallel> \\<zero>) \\<sim> P \\<parallel> <\\<nu>x>\\<zero>\n  P \\<parallel> <\\<nu>x>\\<zero> \\<sim> <\\<nu>x>\\<zero> \\<parallel> P\n  <\\<nu>x>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n  P \\<parallel> \\<zero> \\<sim> P", "show ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>x>P \\<sim> <\\<nu>x>P \\<parallel> \\<zero>\n  <\\<nu>x>P \\<parallel> \\<zero> \\<sim> \\<zero> \\<parallel> <\\<nu>x>P\n  \\<zero> \\<parallel> <\\<nu>x>P \\<sim> <\\<nu>x>(\\<zero> \\<parallel> P)\n  <\\<nu>x>(\\<zero> \\<parallel> P) \\<sim> <\\<nu>x>(P \\<parallel> \\<zero>)\n  <\\<nu>x>(P \\<parallel> \\<zero>) \\<sim> P \\<parallel> <\\<nu>x>\\<zero>\n  P \\<parallel> <\\<nu>x>\\<zero> \\<sim> <\\<nu>x>\\<zero> \\<parallel> P\n  <\\<nu>x>\\<zero> \\<parallel> P \\<sim> \\<zero> \\<parallel> P\n  \\<zero> \\<parallel> P \\<sim> P \\<parallel> \\<zero>\n  P \\<parallel> \\<zero> \\<sim> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<sim> P", "by(metis transitive)"], ["proof (state)\nthis:\n  <\\<nu>x>P \\<sim> P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sumRes:\n  fixes x :: name\n  and   P :: pi\n  and   Q :: pi\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim> (<\\<nu>x>P) \\<oplus> (<\\<nu>x>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "let ?X = \"{(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) | x P Q. True} \\<union>\n            {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) | x P Q. True}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "have \"(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q)\n    \\<in> {(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n           True} \\<union>\n          {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q.\n           True}", "by auto"], ["proof (state)\nthis:\n  (<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q)\n  \\<in> {(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n         True} \\<union>\n        {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q.\n         True}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "moreover"], ["proof (state)\nthis:\n  (<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q)\n  \\<in> {(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n         True} \\<union>\n        {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q.\n         True}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "have \"eqvt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt\n     ({(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n       True} \\<union>\n      {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q. True})", "by(fastforce simp add: eqvt_def)"], ["proof (state)\nthis:\n  eqvt\n   ({(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n     True} \\<union>\n    {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q. True})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "ultimately"], ["proof (chain)\npicking this:\n  (<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q)\n  \\<in> {(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n         True} \\<union>\n        {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q.\n         True}\n  eqvt\n   ({(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n     True} \\<union>\n    {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q. True})", "show ?thesis"], ["proof (prove)\nusing this:\n  (<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q)\n  \\<in> {(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n         True} \\<union>\n        {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q.\n         True}\n  eqvt\n   ({(<\\<nu>x>(P \\<oplus> Q), <\\<nu>x>P \\<oplus> <\\<nu>x>Q) |x P Q.\n     True} \\<union>\n    {(<\\<nu>x>P \\<oplus> <\\<nu>x>Q, <\\<nu>x>(P \\<oplus> Q)) |x P Q. True})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "by(coinduct rule: bisimCoinduct) (fastforce intro: sumResLeft sumResRight reflexive)+"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scopeExtSum:\n  fixes P :: pi\n  and   Q :: pi\n  and   x :: name\n  \n  assumes \"x \\<sharp> P\"\n\n  shows \"<\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q", "have \"<\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q", "by(rule sumRes)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q", "moreover"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q", "from \\<open>x \\<sharp> P\\<close>"], ["proof (chain)\npicking this:\n  x \\<sharp> P", "have \"<\\<nu>x>P \\<oplus> <\\<nu>x>Q \\<sim> P \\<oplus> <\\<nu>x>Q\""], ["proof (prove)\nusing this:\n  x \\<sharp> P\n\ngoal (1 subgoal):\n 1. <\\<nu>x>P \\<oplus> <\\<nu>x>Q \\<sim> P \\<oplus> <\\<nu>x>Q", "by(rule sumPres[OF scopeFresh])"], ["proof (state)\nthis:\n  <\\<nu>x>P \\<oplus> <\\<nu>x>Q \\<sim> P \\<oplus> <\\<nu>x>Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q", "ultimately"], ["proof (chain)\npicking this:\n  <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q\n  <\\<nu>x>P \\<oplus> <\\<nu>x>Q \\<sim> P \\<oplus> <\\<nu>x>Q", "show ?thesis"], ["proof (prove)\nusing this:\n  <\\<nu>x>(P \\<oplus> Q) \\<sim> <\\<nu>x>P \\<oplus> <\\<nu>x>Q\n  <\\<nu>x>P \\<oplus> <\\<nu>x>Q \\<sim> P \\<oplus> <\\<nu>x>Q\n\ngoal (1 subgoal):\n 1. <\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q", "by(rule transitive)"], ["proof (state)\nthis:\n  <\\<nu>x>(P \\<oplus> Q) \\<sim> P \\<oplus> <\\<nu>x>Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bangSC:\n  fixes P :: pi\n\n  shows \"!P \\<sim> P \\<parallel> !P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "let ?X = \"{(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "have \"(!P, P \\<parallel> !P) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (!P, P \\<parallel> !P)\n    \\<in> {(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}", "by simp"], ["proof (state)\nthis:\n  (!P, P \\<parallel> !P)\n  \\<in> {(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}\n\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (!P, P \\<parallel> !P)\n  \\<in> {(!P, P \\<parallel> !P), (P \\<parallel> !P, !P)}\n\ngoal (1 subgoal):\n 1. !P \\<sim> P \\<parallel> !P", "by(coinduct rule: bisimCoinduct) (auto intro: bangLeftSC bangRightSC reflexive)"], ["proof (state)\nthis:\n  !P \\<sim> P \\<parallel> !P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resNil:\n  fixes x :: name\n  and   y :: name\n  and   P :: pi\n  and   b :: name\n\n  shows \"<\\<nu>x>x<y>.P \\<sim> \\<zero>\"\n  and   \"<\\<nu>x>x{b}.P \\<sim> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>x<y>.P \\<sim> \\<zero> &&& <\\<nu>x>x{b}.P \\<sim> \\<zero>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. <\\<nu>x>x<y>.P \\<sim> \\<zero>\n 2. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "let ?X = \"{(<\\<nu>x>x<y>.P, \\<zero>), (\\<zero>, <\\<nu>x>x<y>.P)}\""], ["proof (state)\ngoal (2 subgoals):\n 1. <\\<nu>x>x<y>.P \\<sim> \\<zero>\n 2. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "have \"(<\\<nu>x>x<y>.P, \\<zero>) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x>x<y>.P, \\<zero>)\n    \\<in> {(<\\<nu>x>x<y>.P, \\<zero>), (\\<zero>, <\\<nu>x>x<y>.P)}", "by simp"], ["proof (state)\nthis:\n  (<\\<nu>x>x<y>.P, \\<zero>)\n  \\<in> {(<\\<nu>x>x<y>.P, \\<zero>), (\\<zero>, <\\<nu>x>x<y>.P)}\n\ngoal (2 subgoals):\n 1. <\\<nu>x>x<y>.P \\<sim> \\<zero>\n 2. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "thus \"<\\<nu>x>x<y>.P \\<sim> \\<zero>\""], ["proof (prove)\nusing this:\n  (<\\<nu>x>x<y>.P, \\<zero>)\n  \\<in> {(<\\<nu>x>x<y>.P, \\<zero>), (\\<zero>, <\\<nu>x>x<y>.P)}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>x<y>.P \\<sim> \\<zero>", "by(coinduct rule: bisimCoinduct) (auto simp add: simulation_def)"], ["proof (state)\nthis:\n  <\\<nu>x>x<y>.P \\<sim> \\<zero>\n\ngoal (1 subgoal):\n 1. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "let ?X = \"{(<\\<nu>x>x{b}.P, \\<zero>), (\\<zero>, <\\<nu>x>x{b}.P)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "have \"(<\\<nu>x>x{b}.P, \\<zero>) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x>x{b}.P, \\<zero>)\n    \\<in> {(<\\<nu>x>x{b}.P, \\<zero>), (\\<zero>, <\\<nu>x>x{b}.P)}", "by simp"], ["proof (state)\nthis:\n  (<\\<nu>x>x{b}.P, \\<zero>)\n  \\<in> {(<\\<nu>x>x{b}.P, \\<zero>), (\\<zero>, <\\<nu>x>x{b}.P)}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "thus \"<\\<nu>x>x{b}.P \\<sim> \\<zero>\""], ["proof (prove)\nusing this:\n  (<\\<nu>x>x{b}.P, \\<zero>)\n  \\<in> {(<\\<nu>x>x{b}.P, \\<zero>), (\\<zero>, <\\<nu>x>x{b}.P)}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>x{b}.P \\<sim> \\<zero>", "by(coinduct rule: bisimCoinduct) (auto simp add: simulation_def)"], ["proof (state)\nthis:\n  <\\<nu>x>x{b}.P \\<sim> \\<zero>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resInput:\n  fixes x :: name\n  and   a :: name\n  and   y :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> y\"\n\n  shows \"<\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)", "let ?X = \"{(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) | x a y P. x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n            {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) | x a y P. x \\<noteq> a \\<and> x \\<noteq> y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> a\n  x \\<noteq> y", "have \"(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) \\<in> ?X\""], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P))\n    \\<in> {(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n           x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n          {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n           x \\<noteq> a \\<and> x \\<noteq> y}", "by auto"], ["proof (state)\nthis:\n  (<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n        {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)", "moreover"], ["proof (state)\nthis:\n  (<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n        {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)", "have \"eqvt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt\n     ({(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n       x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n      {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n       x \\<noteq> a \\<and> x \\<noteq> y})", "by(fastforce simp add: eqvt_def pt_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  eqvt\n   ({(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n     x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n    {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n     x \\<noteq> a \\<and> x \\<noteq> y})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)", "ultimately"], ["proof (chain)\npicking this:\n  (<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n        {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y}\n  eqvt\n   ({(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n     x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n    {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n     x \\<noteq> a \\<and> x \\<noteq> y})", "show ?thesis"], ["proof (prove)\nusing this:\n  (<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n        {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n         x \\<noteq> a \\<and> x \\<noteq> y}\n  eqvt\n   ({(<\\<nu>x>a<y>.P, a<y>.(<\\<nu>x>P)) |x a y P.\n     x \\<noteq> a \\<and> x \\<noteq> y} \\<union>\n    {(a<y>.(<\\<nu>x>P), <\\<nu>x>a<y>.P) |x a y P.\n     x \\<noteq> a \\<and> x \\<noteq> y})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)", "by(coinduct rule: bisimCoinduct) (fastforce intro: resInputLeft reflexive resInputRight)+"], ["proof (state)\nthis:\n  <\\<nu>x>a<y>.P \\<sim> a<y>.(<\\<nu>x>P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resOutput:\n  fixes x :: name\n  and   a :: name\n  and   b :: name\n  and   P :: pi\n\n  assumes \"x \\<noteq> a\"\n  and     \"x \\<noteq> b\"\n\n  shows \"<\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)", "let ?X = \"{(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) | x a b P. x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n            {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) | x a b P. x \\<noteq> a \\<and> x \\<noteq> b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)", "from assms"], ["proof (chain)\npicking this:\n  x \\<noteq> a\n  x \\<noteq> b", "have \"(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) \\<in> ?X\""], ["proof (prove)\nusing this:\n  x \\<noteq> a\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. (<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P))\n    \\<in> {(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n           x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n          {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n           x \\<noteq> a \\<and> x \\<noteq> b}", "by blast"], ["proof (state)\nthis:\n  (<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n        {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)", "moreover"], ["proof (state)\nthis:\n  (<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n        {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)", "have \"eqvt ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt\n     ({(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n       x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n      {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n       x \\<noteq> a \\<and> x \\<noteq> b})", "by(fastforce simp add: eqvt_def pt_bij[OF pt_name_inst, OF at_name_inst])"], ["proof (state)\nthis:\n  eqvt\n   ({(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n     x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n    {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n     x \\<noteq> a \\<and> x \\<noteq> b})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)", "ultimately"], ["proof (chain)\npicking this:\n  (<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n        {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b}\n  eqvt\n   ({(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n     x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n    {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n     x \\<noteq> a \\<and> x \\<noteq> b})", "show ?thesis"], ["proof (prove)\nusing this:\n  (<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n        {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n         x \\<noteq> a \\<and> x \\<noteq> b}\n  eqvt\n   ({(<\\<nu>x>a{b}.P, a{b}.(<\\<nu>x>P)) |x a b P.\n     x \\<noteq> a \\<and> x \\<noteq> b} \\<union>\n    {(a{b}.(<\\<nu>x>P), <\\<nu>x>a{b}.P) |x a b P.\n     x \\<noteq> a \\<and> x \\<noteq> b})\n\ngoal (1 subgoal):\n 1. <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)", "by(coinduct rule: bisimCoinduct) (fastforce intro: resOutputLeft resOutputRight reflexive)+"], ["proof (state)\nthis:\n  <\\<nu>x>a{b}.P \\<sim> a{b}.(<\\<nu>x>P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resTau:\n  fixes x :: name\n  and   P :: pi\n\n  shows \"<\\<nu>x>\\<tau>.(P) \\<sim> \\<tau>.(<\\<nu>x>P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<tau>.P \\<sim> \\<tau>.(<\\<nu>x>P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<tau>.P \\<sim> \\<tau>.(<\\<nu>x>P)", "let ?X = \"{(<\\<nu>x>\\<tau>.(P), \\<tau>.(<\\<nu>x>P)), (\\<tau>.(<\\<nu>x>P), <\\<nu>x>\\<tau>.(P))}\""], ["proof (state)\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<tau>.P \\<sim> \\<tau>.(<\\<nu>x>P)", "have \"(<\\<nu>x>\\<tau>.(P), \\<tau>.(<\\<nu>x>P)) \\<in> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<\\<nu>x>\\<tau>.P, \\<tau>.(<\\<nu>x>P))\n    \\<in> {(<\\<nu>x>\\<tau>.P, \\<tau>.(<\\<nu>x>P)),\n           (\\<tau>.(<\\<nu>x>P), <\\<nu>x>\\<tau>.P)}", "by auto"], ["proof (state)\nthis:\n  (<\\<nu>x>\\<tau>.P, \\<tau>.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>\\<tau>.P, \\<tau>.(<\\<nu>x>P)),\n         (\\<tau>.(<\\<nu>x>P), <\\<nu>x>\\<tau>.P)}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<tau>.P \\<sim> \\<tau>.(<\\<nu>x>P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (<\\<nu>x>\\<tau>.P, \\<tau>.(<\\<nu>x>P))\n  \\<in> {(<\\<nu>x>\\<tau>.P, \\<tau>.(<\\<nu>x>P)),\n         (\\<tau>.(<\\<nu>x>P), <\\<nu>x>\\<tau>.P)}\n\ngoal (1 subgoal):\n 1. <\\<nu>x>\\<tau>.P \\<sim> \\<tau>.(<\\<nu>x>P)", "by(coinduct rule: bisimCoinduct) (fastforce intro: resTauLeft resTauRight reflexive)+"], ["proof (state)\nthis:\n  <\\<nu>x>\\<tau>.P \\<sim> \\<tau>.(<\\<nu>x>P)\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive structCong :: \"pi \\<Rightarrow> pi \\<Rightarrow> bool\" (\"_ \\<equiv>\\<^sub>s _\" [70, 70] 70)\nwhere\n  Refl: \"P \\<equiv>\\<^sub>s P\"\n| Sym:  \"P \\<equiv>\\<^sub>s Q \\<Longrightarrow> Q \\<equiv>\\<^sub>s P\"\n| Trans: \"\\<lbrakk>P \\<equiv>\\<^sub>s Q; Q \\<equiv>\\<^sub>s R\\<rbrakk> \\<Longrightarrow> P \\<equiv>\\<^sub>s R\"\n\n| SumComm: \"P \\<oplus> Q \\<equiv>\\<^sub>s Q \\<oplus> P\"\n| SumAssoc: \"(P \\<oplus> Q) \\<oplus> R \\<equiv>\\<^sub>s P \\<oplus> (Q \\<oplus> R)\"\n| SumId: \"P \\<oplus> \\<zero> \\<equiv>\\<^sub>s P\"\n\n| ParComm: \"P \\<parallel> Q \\<equiv>\\<^sub>s Q \\<parallel> P\"\n| ParAssoc: \"(P \\<parallel> Q) \\<parallel> R \\<equiv>\\<^sub>s P \\<parallel> (Q \\<parallel> R)\"\n| ParId: \"P \\<parallel> \\<zero> \\<equiv>\\<^sub>s P\"\n\n| MatchId: \"[a\\<frown>a]P \\<equiv>\\<^sub>s P\"\n\n| ResNil: \"<\\<nu>x>\\<zero> \\<equiv>\\<^sub>s \\<zero>\"\n| ResComm: \"<\\<nu>x><\\<nu>y>P \\<equiv>\\<^sub>s <\\<nu>y><\\<nu>x>P\"\n| ResSum: \"<\\<nu>x>(P \\<oplus> Q) \\<equiv>\\<^sub>s <\\<nu>x>P \\<oplus> <\\<nu>x>Q\"\n| ScopeExtPar: \"x \\<sharp> P \\<Longrightarrow> <\\<nu>x>(P \\<parallel> Q) \\<equiv>\\<^sub>s P \\<parallel> <\\<nu>x>Q\"\n| InputRes: \"\\<lbrakk>x \\<noteq> a; x \\<noteq> y\\<rbrakk> \\<Longrightarrow> <\\<nu>x>a<y>.P \\<equiv>\\<^sub>s a<y>.(<\\<nu>x>P)\"\n| OutputRes: \"\\<lbrakk>x \\<noteq> a; x \\<noteq> b\\<rbrakk> \\<Longrightarrow> <\\<nu>x>a{b}.P \\<equiv>\\<^sub>s a{b}.(<\\<nu>x>P)\"\n| TauRes: \"<\\<nu>x>\\<tau>.(P) \\<equiv>\\<^sub>s \\<tau>.(<\\<nu>x>P)\"\n\n| BangUnfold: \"!P \\<equiv>\\<^sub>s P \\<parallel> !P\""], ["", "lemma structCongBisim:\n  fixes P :: pi\n  and   Q :: pi\n\n  assumes \"P \\<equiv>\\<^sub>s Q\"\n\n  shows \"P \\<sim> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sim> Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<equiv>\\<^sub>s Q\n\ngoal (1 subgoal):\n 1. P \\<sim> Q", "by(induct rule: structCong.induct)\n  (auto intro: reflexive symmetric transitive sumSym sumAssoc sumZero parSym parAssoc parZero\n               nilRes resComm resInput resOutput resTau sumRes scopeExtPar bangSC matchId mismatchId)"], ["", "end"]]}