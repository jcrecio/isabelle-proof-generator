{"file_name": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus/Rel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pi_Calculus", "problem_names": ["lemma eqvtRelI:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   P    :: 'a\n  and   Q    :: 'a\n  and   perm :: \"name prm\"\n\n  assumes \"eqvt Rel\"\n  and     \"(P, Q) \\<in> Rel\"\n\n  shows \"(perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\"", "lemma eqvtRelE:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   P    :: 'a\n  and   Q    :: 'a\n  and   perm :: \"name prm\"\n\n  assumes \"eqvt Rel\"\n  and     \"(perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\"\n\n  shows \"(P, Q) \\<in> Rel\"", "lemma eqvtTrans[intro]:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   Rel' :: \"('a \\<times> 'a) set\"\n\n  assumes EqvtRel:  \"eqvt Rel\"\n  and     EqvtRel': \"eqvt Rel'\"\n\n  shows \"eqvt (Rel O Rel')\"", "lemma eqvtUnion[intro]:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   Rel' :: \"('a \\<times> 'a) set\"\n\n  assumes EqvtRel:  \"eqvt Rel\"\n  and     EqvtRel': \"eqvt Rel'\"\n\n  shows \"eqvt (Rel \\<union> Rel')\"", "lemma eqvtSubstClosed:\n  fixes Rel :: \"(pi \\<times> pi) set\"\n\n  assumes eqvtRel: \"eqvt Rel\"\n\n  shows \"eqvt (substClosed Rel)\"", "lemma substClosedSubset:\n  fixes Rel  :: \"(pi \\<times> pi) set\"\n\n  shows \"substClosed Rel \\<subseteq> Rel\"", "lemma partUnfold:\n  fixes P   :: pi\n  and   Q   :: pi\n  and   \\<sigma>   :: \"(name \\<times> name) list\"\n  and   Rel :: \"(pi \\<times> pi) set\"\n\n  assumes \"(P, Q) \\<in> substClosed Rel\"\n\n  shows \"(P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> substClosed Rel\"", "lemma eqvtBangRel:\n  fixes Rel :: \"(pi \\<times> pi) set\"\n\n  assumes eqvtRel: \"eqvt Rel\"\n\n  shows \"eqvt(bangRel Rel)\"", "lemma BRBangCases[consumes 1, case_names BRBang]:\n  fixes P   :: pi\n  and   Q   :: pi\n  and   Rel :: \"(pi \\<times> pi) set\"\n  and   F   :: \"pi \\<Rightarrow> bool\"\n\n  assumes \"(P, !Q) \\<in> bangRel Rel\"\n  and     \"\\<And>P. (P, Q) \\<in> Rel \\<Longrightarrow> F (!P)\"\n  \n  shows \"F P\"", "lemma BRParCases[consumes 1, case_names BRPar]:\n  fixes P   :: pi\n  and   Q   :: pi\n  and   Rel :: \"(pi \\<times> pi) set\"\n  and   F   :: \"pi \\<Rightarrow> bool\"\n\n  assumes \"(P, Q \\<parallel> !Q) \\<in> bangRel Rel\"\n  and     \"\\<And>P R. \\<lbrakk>(P, Q) \\<in> Rel; (R, !Q) \\<in> bangRel Rel\\<rbrakk> \\<Longrightarrow> F (P \\<parallel> R)\"\n\n  shows \"F P\"", "lemma bangRelSubset:\n  fixes Rel  :: \"(pi \\<times> pi) set\"\n  and   Rel' :: \"(pi \\<times> pi) set\"\n\n  assumes \"(P, Q) \\<in> bangRel Rel\"\n  and     \"\\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (P, Q) \\<in> Rel'\"\n\n  shows \"(P, Q) \\<in> bangRel Rel'\"", "lemma bangRelSymetric: \n  fixes P   :: pi\n  and   Q   :: pi\n  and   Rel :: \"(pi \\<times> pi) set\"\n\n  assumes A:   \"(P, Q) \\<in> bangRel Rel\"\n  and     Sym: \"\\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (Q, P) \\<in> Rel\"\n\n  shows \"(Q, P) \\<in> bangRel Rel\"", "lemma resChainPerm[simp]:\n  fixes perm :: \"name prm\"\n  and   lst  :: \"name list\"\n  and   P    :: pi\n  \n  shows \"perm \\<bullet> (resChain lst P) = resChain (perm \\<bullet> lst) (perm \\<bullet> P)\"", "lemma resChainFresh:\n  fixes a   :: name\n  and   lst :: \"name list\"\n  and   P   :: pi\n\n  assumes \"a \\<sharp> (lst, P)\"\n\n  shows \"a \\<sharp> (resChain lst P)\""], "translations": [["", "lemma eqvtRelI:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   P    :: 'a\n  and   Q    :: 'a\n  and   perm :: \"name prm\"\n\n  assumes \"eqvt Rel\"\n  and     \"(P, Q) \\<in> Rel\"\n\n  shows \"(perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel", "using assms"], ["proof (prove)\nusing this:\n  eqvt Rel\n  (P, Q) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel", "by(auto simp add: eqvt_def)"], ["", "lemma eqvtRelE:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   P    :: 'a\n  and   Q    :: 'a\n  and   perm :: \"name prm\"\n\n  assumes \"eqvt Rel\"\n  and     \"(perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\"\n\n  shows \"(P, Q) \\<in> Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P, Q) \\<in> Rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P, Q) \\<in> Rel", "have \"rev perm \\<bullet> (perm \\<bullet> P) = P\" and \"rev perm \\<bullet> (perm \\<bullet> Q) = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev perm \\<bullet> perm \\<bullet> P = P &&&\n    rev perm \\<bullet> perm \\<bullet> Q = Q", "by(simp add: pt_rev_pi[OF pt_name_inst, OF at_name_inst])+"], ["proof (state)\nthis:\n  rev perm \\<bullet> perm \\<bullet> P = P\n  rev perm \\<bullet> perm \\<bullet> Q = Q\n\ngoal (1 subgoal):\n 1. (P, Q) \\<in> Rel", "with assms"], ["proof (chain)\npicking this:\n  eqvt Rel\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\n  rev perm \\<bullet> perm \\<bullet> P = P\n  rev perm \\<bullet> perm \\<bullet> Q = Q", "show ?thesis"], ["proof (prove)\nusing this:\n  eqvt Rel\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\n  rev perm \\<bullet> perm \\<bullet> P = P\n  rev perm \\<bullet> perm \\<bullet> Q = Q\n\ngoal (1 subgoal):\n 1. (P, Q) \\<in> Rel", "by(force dest: eqvtRelI[of _ _ _ \"rev perm\"])"], ["proof (state)\nthis:\n  (P, Q) \\<in> Rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eqvtTrans[intro]:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   Rel' :: \"('a \\<times> 'a) set\"\n\n  assumes EqvtRel:  \"eqvt Rel\"\n  and     EqvtRel': \"eqvt Rel'\"\n\n  shows \"eqvt (Rel O Rel')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (Rel O Rel')", "using assms"], ["proof (prove)\nusing this:\n  eqvt Rel\n  eqvt Rel'\n\ngoal (1 subgoal):\n 1. eqvt (Rel O Rel')", "by(force simp add: eqvt_def)"], ["", "lemma eqvtUnion[intro]:\n  fixes Rel  :: \"('a::pt_name \\<times> 'a) set\"\n  and   Rel' :: \"('a \\<times> 'a) set\"\n\n  assumes EqvtRel:  \"eqvt Rel\"\n  and     EqvtRel': \"eqvt Rel'\"\n\n  shows \"eqvt (Rel \\<union> Rel')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (Rel \\<union> Rel')", "using assms"], ["proof (prove)\nusing this:\n  eqvt Rel\n  eqvt Rel'\n\ngoal (1 subgoal):\n 1. eqvt (Rel \\<union> Rel')", "by(force simp add: eqvt_def)"], ["", "definition substClosed :: \"(pi \\<times> pi) set \\<Rightarrow> (pi \\<times> pi) set\" where\n  \"substClosed Rel \\<equiv> {(P, Q) | P Q. \\<forall>\\<sigma>. (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel}\""], ["", "lemma eqvtSubstClosed:\n  fixes Rel :: \"(pi \\<times> pi) set\"\n\n  assumes eqvtRel: \"eqvt Rel\"\n\n  shows \"eqvt (substClosed Rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (substClosed Rel)", "proof(simp add: eqvt_def substClosed_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b perma \\<sigma>.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       ((perma \\<bullet> a)[<\\<sigma>>], (perma \\<bullet> b)[<\\<sigma>>])\n       \\<in> Rel", "fix P Q perm s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b perma \\<sigma>.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       ((perma \\<bullet> a)[<\\<sigma>>], (perma \\<bullet> b)[<\\<sigma>>])\n       \\<in> Rel", "assume \"\\<forall>s. (P[<s>], Q[<s>]) \\<in> Rel\""], ["proof (state)\nthis:\n  \\<forall>s. (P[<s>], Q[<s>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. \\<And>a b perma \\<sigma>.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       ((perma \\<bullet> a)[<\\<sigma>>], (perma \\<bullet> b)[<\\<sigma>>])\n       \\<in> Rel", "hence \"(P[<(rev (perm::name prm) \\<bullet> s)>], Q[<(rev perm \\<bullet> s)>]) \\<in> Rel\""], ["proof (prove)\nusing this:\n  \\<forall>s. (P[<s>], Q[<s>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (P[<(rev perm \\<bullet> s)>], Q[<(rev perm \\<bullet> s)>]) \\<in> Rel", "by simp"], ["proof (state)\nthis:\n  (P[<(rev perm \\<bullet> s)>], Q[<(rev perm \\<bullet> s)>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. \\<And>a b perma \\<sigma>.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       ((perma \\<bullet> a)[<\\<sigma>>], (perma \\<bullet> b)[<\\<sigma>>])\n       \\<in> Rel", "with eqvtRel"], ["proof (chain)\npicking this:\n  eqvt Rel\n  (P[<(rev perm \\<bullet> s)>], Q[<(rev perm \\<bullet> s)>]) \\<in> Rel", "have \"(perm \\<bullet> (P[<(rev perm \\<bullet> s)>]), perm \\<bullet> (Q[<(rev perm \\<bullet> s)>])) \\<in> Rel\""], ["proof (prove)\nusing this:\n  eqvt Rel\n  (P[<(rev perm \\<bullet> s)>], Q[<(rev perm \\<bullet> s)>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> P[<(rev perm \\<bullet> s)>],\n     perm \\<bullet> Q[<(rev perm \\<bullet> s)>])\n    \\<in> Rel", "by(rule eqvtRelI)"], ["proof (state)\nthis:\n  (perm \\<bullet> P[<(rev perm \\<bullet> s)>],\n   perm \\<bullet> Q[<(rev perm \\<bullet> s)>])\n  \\<in> Rel\n\ngoal (1 subgoal):\n 1. \\<And>a b perma \\<sigma>.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       ((perma \\<bullet> a)[<\\<sigma>>], (perma \\<bullet> b)[<\\<sigma>>])\n       \\<in> Rel", "thus \"((perm \\<bullet> P)[<s>], (perm \\<bullet> Q)[<s>]) \\<in> Rel\""], ["proof (prove)\nusing this:\n  (perm \\<bullet> P[<(rev perm \\<bullet> s)>],\n   perm \\<bullet> Q[<(rev perm \\<bullet> s)>])\n  \\<in> Rel\n\ngoal (1 subgoal):\n 1. ((perm \\<bullet> P)[<s>], (perm \\<bullet> Q)[<s>]) \\<in> Rel", "by(simp add: name_per_rev)"], ["proof (state)\nthis:\n  ((perm \\<bullet> P)[<s>], (perm \\<bullet> Q)[<s>]) \\<in> Rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma substClosedSubset:\n  fixes Rel  :: \"(pi \\<times> pi) set\"\n\n  shows \"substClosed Rel \\<subseteq> Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substClosed Rel \\<subseteq> Rel", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (a, b) \\<in> Rel", "fix P Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (a, b) \\<in> Rel", "assume \"\\<forall>s. (P[<s>], Q[<s>]) \\<in> Rel\""], ["proof (state)\nthis:\n  \\<forall>s. (P[<s>], Q[<s>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (a, b) \\<in> Rel", "hence \"(P[<[]>], Q[<[]>]) \\<in> Rel\""], ["proof (prove)\nusing this:\n  \\<forall>s. (P[<s>], Q[<s>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (P[<[]>], Q[<[]>]) \\<in> Rel", "by blast"], ["proof (state)\nthis:\n  (P[<[]>], Q[<[]>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>\\<sigma>.\n          (a[<\\<sigma>>], b[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (a, b) \\<in> Rel", "thus \"(P, Q) \\<in> Rel\""], ["proof (prove)\nusing this:\n  (P[<[]>], Q[<[]>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (P, Q) \\<in> Rel", "by simp"], ["proof (state)\nthis:\n  (P, Q) \\<in> Rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partUnfold:\n  fixes P   :: pi\n  and   Q   :: pi\n  and   \\<sigma>   :: \"(name \\<times> name) list\"\n  and   Rel :: \"(pi \\<times> pi) set\"\n\n  assumes \"(P, Q) \\<in> substClosed Rel\"\n\n  shows \"(P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> substClosed Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> substClosed Rel", "using assms"], ["proof (prove)\nusing this:\n  (P, Q) \\<in> substClosed Rel\n\ngoal (1 subgoal):\n 1. (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> substClosed Rel", "proof(auto simp add: substClosed_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>'.\n       \\<forall>\\<sigma>.\n          (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (P[<\\<sigma>>][<\\<sigma>'>], Q[<\\<sigma>>][<\\<sigma>'>]) \\<in> Rel", "fix \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>'.\n       \\<forall>\\<sigma>.\n          (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (P[<\\<sigma>>][<\\<sigma>'>], Q[<\\<sigma>>][<\\<sigma>'>]) \\<in> Rel", "assume \"\\<forall>\\<sigma>. (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel\""], ["proof (state)\nthis:\n  \\<forall>\\<sigma>. (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>'.\n       \\<forall>\\<sigma>.\n          (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (P[<\\<sigma>>][<\\<sigma>'>], Q[<\\<sigma>>][<\\<sigma>'>]) \\<in> Rel", "hence \"(P[<(\\<sigma>@\\<sigma>')>], Q[<(\\<sigma>@\\<sigma>')>]) \\<in> Rel\""], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>. (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (P[<(\\<sigma> @ \\<sigma>')>], Q[<(\\<sigma> @ \\<sigma>')>]) \\<in> Rel", "by blast"], ["proof (state)\nthis:\n  (P[<(\\<sigma> @ \\<sigma>')>], Q[<(\\<sigma> @ \\<sigma>')>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>'.\n       \\<forall>\\<sigma>.\n          (P[<\\<sigma>>], Q[<\\<sigma>>]) \\<in> Rel \\<Longrightarrow>\n       (P[<\\<sigma>>][<\\<sigma>'>], Q[<\\<sigma>>][<\\<sigma>'>]) \\<in> Rel", "thus \"((P[<\\<sigma>>])[<\\<sigma>'>], (Q[<\\<sigma>>])[<\\<sigma>'>]) \\<in> Rel\""], ["proof (prove)\nusing this:\n  (P[<(\\<sigma> @ \\<sigma>')>], Q[<(\\<sigma> @ \\<sigma>')>]) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (P[<\\<sigma>>][<\\<sigma>'>], Q[<\\<sigma>>][<\\<sigma>'>]) \\<in> Rel", "by simp"], ["proof (state)\nthis:\n  (P[<\\<sigma>>][<\\<sigma>'>], Q[<\\<sigma>>][<\\<sigma>'>]) \\<in> Rel\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive_set bangRel :: \"(pi \\<times> pi) set \\<Rightarrow> (pi \\<times> pi) set\"\nfor Rel :: \"(pi \\<times> pi) set\"\nwhere\n  BRBang: \"(P, Q) \\<in> Rel \\<Longrightarrow> (!P, !Q) \\<in> bangRel Rel\"\n| BRPar: \"(R, T) \\<in> Rel \\<Longrightarrow> (P, Q) \\<in> (bangRel Rel) \\<Longrightarrow> (R \\<parallel> P, T \\<parallel> Q) \\<in> (bangRel Rel)\"\n| BRRes: \"(P, Q) \\<in> bangRel Rel \\<Longrightarrow> (<\\<nu>a>P, <\\<nu>a>Q) \\<in> bangRel Rel\""], ["", "inductive_cases BRBangCases': \"(P, !Q) \\<in> bangRel Rel\""], ["", "inductive_cases BRParCases': \"(P, Q \\<parallel> !Q) \\<in> bangRel Rel\""], ["", "inductive_cases BRResCases': \"(P, <\\<nu>x>Q) \\<in> bangRel Rel\""], ["", "lemma eqvtBangRel:\n  fixes Rel :: \"(pi \\<times> pi) set\"\n\n  assumes eqvtRel: \"eqvt Rel\"\n\n  shows \"eqvt(bangRel Rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (bangRel Rel)", "proof(simp add: eqvt_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b perma.\n       (a, b) \\<in> bangRel Rel \\<Longrightarrow>\n       (perma \\<bullet> a, perma \\<bullet> b) \\<in> bangRel Rel", "fix P Q perm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b perma.\n       (a, b) \\<in> bangRel Rel \\<Longrightarrow>\n       (perma \\<bullet> a, perma \\<bullet> b) \\<in> bangRel Rel", "assume \"(P, Q) \\<in> bangRel Rel\""], ["proof (state)\nthis:\n  (P, Q) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. \\<And>a b perma.\n       (a, b) \\<in> bangRel Rel \\<Longrightarrow>\n       (perma \\<bullet> a, perma \\<bullet> b) \\<in> bangRel Rel", "thus \"((perm::name prm) \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\""], ["proof (prove)\nusing this:\n  (P, Q) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel", "proof(induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P Q.\n       (P, Q) \\<in> Rel \\<Longrightarrow>\n       (perm \\<bullet> !P, perm \\<bullet> !Q) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "fix P Q"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P Q.\n       (P, Q) \\<in> Rel \\<Longrightarrow>\n       (perm \\<bullet> !P, perm \\<bullet> !Q) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "assume \"(P, Q) \\<in> Rel\""], ["proof (state)\nthis:\n  (P, Q) \\<in> Rel\n\ngoal (3 subgoals):\n 1. \\<And>P Q.\n       (P, Q) \\<in> Rel \\<Longrightarrow>\n       (perm \\<bullet> !P, perm \\<bullet> !Q) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "with eqvtRel"], ["proof (chain)\npicking this:\n  eqvt Rel\n  (P, Q) \\<in> Rel", "have \"(perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\""], ["proof (prove)\nusing this:\n  eqvt Rel\n  (P, Q) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel", "by(rule eqvtRelI)"], ["proof (state)\nthis:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\n\ngoal (3 subgoals):\n 1. \\<And>P Q.\n       (P, Q) \\<in> Rel \\<Longrightarrow>\n       (perm \\<bullet> !P, perm \\<bullet> !Q) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "thus \"(perm \\<bullet> !P, perm \\<bullet> !Q) \\<in> bangRel Rel\""], ["proof (prove)\nusing this:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> !P, perm \\<bullet> !Q) \\<in> bangRel Rel", "by(force intro: BRBang)"], ["proof (state)\nthis:\n  (perm \\<bullet> !P, perm \\<bullet> !Q) \\<in> bangRel Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "fix P Q R T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "assume R: \"(R, T) \\<in> Rel\""], ["proof (state)\nthis:\n  (R, T) \\<in> Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "assume BR: \"(perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\""], ["proof (state)\nthis:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "from eqvtRel R"], ["proof (chain)\npicking this:\n  eqvt Rel\n  (R, T) \\<in> Rel", "have \"(perm \\<bullet> R, perm \\<bullet> T) \\<in> Rel\""], ["proof (prove)\nusing this:\n  eqvt Rel\n  (R, T) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> R, perm \\<bullet> T) \\<in> Rel", "by(rule eqvtRelI)"], ["proof (state)\nthis:\n  (perm \\<bullet> R, perm \\<bullet> T) \\<in> Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> R \\<parallel> P,\n                          perm \\<bullet> T \\<parallel> Q)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "with BR"], ["proof (chain)\npicking this:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\n  (perm \\<bullet> R, perm \\<bullet> T) \\<in> Rel", "show \"(perm \\<bullet> (R \\<parallel> P), perm \\<bullet> (T \\<parallel> Q)) \\<in> bangRel Rel\""], ["proof (prove)\nusing this:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\n  (perm \\<bullet> R, perm \\<bullet> T) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> R \\<parallel> P, perm \\<bullet> T \\<parallel> Q)\n    \\<in> bangRel Rel", "by(force intro: BRPar)"], ["proof (state)\nthis:\n  (perm \\<bullet> R \\<parallel> P, perm \\<bullet> T \\<parallel> Q)\n  \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "fix P Q a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "assume \"(perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\""], ["proof (state)\nthis:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel;\n        (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (perm \\<bullet> <\\<nu>a>P,\n                          perm \\<bullet> <\\<nu>a>Q)\n                         \\<in> bangRel Rel", "thus \"(perm \\<bullet> <\\<nu>a>P, perm \\<bullet> <\\<nu>a>Q) \\<in> bangRel Rel\""], ["proof (prove)\nusing this:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. (perm \\<bullet> <\\<nu>a>P, perm \\<bullet> <\\<nu>a>Q) \\<in> bangRel Rel", "by(force intro: BRRes)"], ["proof (state)\nthis:\n  (perm \\<bullet> <\\<nu>a>P, perm \\<bullet> <\\<nu>a>Q) \\<in> bangRel Rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (perm \\<bullet> P, perm \\<bullet> Q) \\<in> bangRel Rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma BRBangCases[consumes 1, case_names BRBang]:\n  fixes P   :: pi\n  and   Q   :: pi\n  and   Rel :: \"(pi \\<times> pi) set\"\n  and   F   :: \"pi \\<Rightarrow> bool\"\n\n  assumes \"(P, !Q) \\<in> bangRel Rel\"\n  and     \"\\<And>P. (P, Q) \\<in> Rel \\<Longrightarrow> F (!P)\"\n  \n  shows \"F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F P", "using assms"], ["proof (prove)\nusing this:\n  (P, !Q) \\<in> bangRel Rel\n  (?P, Q) \\<in> Rel \\<Longrightarrow> F (!?P)\n\ngoal (1 subgoal):\n 1. F P", "by(induct rule: BRBangCases', auto simp add: pi.inject)"], ["", "lemma BRParCases[consumes 1, case_names BRPar]:\n  fixes P   :: pi\n  and   Q   :: pi\n  and   Rel :: \"(pi \\<times> pi) set\"\n  and   F   :: \"pi \\<Rightarrow> bool\"\n\n  assumes \"(P, Q \\<parallel> !Q) \\<in> bangRel Rel\"\n  and     \"\\<And>P R. \\<lbrakk>(P, Q) \\<in> Rel; (R, !Q) \\<in> bangRel Rel\\<rbrakk> \\<Longrightarrow> F (P \\<parallel> R)\"\n\n  shows \"F P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F P", "using assms"], ["proof (prove)\nusing this:\n  (P, Q \\<parallel> !Q) \\<in> bangRel Rel\n  \\<lbrakk>(?P, Q) \\<in> Rel; (?R, !Q) \\<in> bangRel Rel\\<rbrakk>\n  \\<Longrightarrow> F (?P \\<parallel> ?R)\n\ngoal (1 subgoal):\n 1. F P", "by(induct rule: BRParCases', auto simp add: pi.inject)"], ["", "lemma bangRelSubset:\n  fixes Rel  :: \"(pi \\<times> pi) set\"\n  and   Rel' :: \"(pi \\<times> pi) set\"\n\n  assumes \"(P, Q) \\<in> bangRel Rel\"\n  and     \"\\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (P, Q) \\<in> Rel'\"\n\n  shows \"(P, Q) \\<in> bangRel Rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P, Q) \\<in> bangRel Rel'", "using assms"], ["proof (prove)\nusing this:\n  (P, Q) \\<in> bangRel Rel\n  (?P, ?Q) \\<in> Rel \\<Longrightarrow> (?P, ?Q) \\<in> Rel'\n\ngoal (1 subgoal):\n 1. (P, Q) \\<in> bangRel Rel'", "by(induct rule:  bangRel.induct) (auto intro: BRBang BRPar BRRes)"], ["", "lemma bangRelSymetric: \n  fixes P   :: pi\n  and   Q   :: pi\n  and   Rel :: \"(pi \\<times> pi) set\"\n\n  assumes A:   \"(P, Q) \\<in> bangRel Rel\"\n  and     Sym: \"\\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (Q, P) \\<in> Rel\"\n\n  shows \"(Q, P) \\<in> bangRel Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q, P) \\<in> bangRel Rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Q, P) \\<in> bangRel Rel", "from A"], ["proof (chain)\npicking this:\n  (P, Q) \\<in> bangRel Rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (P, Q) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. (Q, P) \\<in> bangRel Rel", "proof(induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (!Q, !P) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "fix P Q"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (!Q, !P) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "assume \"(P, Q) \\<in> Rel\""], ["proof (state)\nthis:\n  (P, Q) \\<in> Rel\n\ngoal (3 subgoals):\n 1. \\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (!Q, !P) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "hence \"(Q, P) \\<in> Rel\""], ["proof (prove)\nusing this:\n  (P, Q) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (Q, P) \\<in> Rel", "by(rule Sym)"], ["proof (state)\nthis:\n  (Q, P) \\<in> Rel\n\ngoal (3 subgoals):\n 1. \\<And>P Q. (P, Q) \\<in> Rel \\<Longrightarrow> (!Q, !P) \\<in> bangRel Rel\n 2. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 3. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "thus \"(!Q, !P) \\<in> bangRel Rel\""], ["proof (prove)\nusing this:\n  (Q, P) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (!Q, !P) \\<in> bangRel Rel", "by(rule BRBang)"], ["proof (state)\nthis:\n  (!Q, !P) \\<in> bangRel Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "fix P Q R T"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "assume RRelT: \"(R, T) \\<in> Rel\""], ["proof (state)\nthis:\n  (R, T) \\<in> Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "assume IH: \"(Q, P) \\<in> bangRel Rel\""], ["proof (state)\nthis:\n  (Q, P) \\<in> bangRel Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "from RRelT"], ["proof (chain)\npicking this:\n  (R, T) \\<in> Rel", "have \"(T, R) \\<in> Rel\""], ["proof (prove)\nusing this:\n  (R, T) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (T, R) \\<in> Rel", "by(rule Sym)"], ["proof (state)\nthis:\n  (T, R) \\<in> Rel\n\ngoal (2 subgoals):\n 1. \\<And>R T P Q.\n       \\<lbrakk>(R, T) \\<in> Rel; (P, Q) \\<in> bangRel Rel;\n        (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (T \\<parallel> Q, R \\<parallel> P)\n                         \\<in> bangRel Rel\n 2. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "thus \"(T \\<parallel> Q, R \\<parallel> P) \\<in> bangRel Rel\""], ["proof (prove)\nusing this:\n  (T, R) \\<in> Rel\n\ngoal (1 subgoal):\n 1. (T \\<parallel> Q, R \\<parallel> P) \\<in> bangRel Rel", "using IH"], ["proof (prove)\nusing this:\n  (T, R) \\<in> Rel\n  (Q, P) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. (T \\<parallel> Q, R \\<parallel> P) \\<in> bangRel Rel", "by(rule BRPar)"], ["proof (state)\nthis:\n  (T \\<parallel> Q, R \\<parallel> P) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "fix P Q a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "assume \"(Q, P) \\<in> bangRel Rel\""], ["proof (state)\nthis:\n  (Q, P) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. \\<And>P Q a.\n       \\<lbrakk>(P, Q) \\<in> bangRel Rel; (Q, P) \\<in> bangRel Rel\\<rbrakk>\n       \\<Longrightarrow> (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "thus \"(<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel\""], ["proof (prove)\nusing this:\n  (Q, P) \\<in> bangRel Rel\n\ngoal (1 subgoal):\n 1. (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel", "by(rule BRRes)"], ["proof (state)\nthis:\n  (<\\<nu>a>Q, <\\<nu>a>P) \\<in> bangRel Rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Q, P) \\<in> bangRel Rel\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec resChain :: \"name list \\<Rightarrow> pi \\<Rightarrow> pi\" where\n   base: \"resChain [] P = P\"\n | step: \"resChain (x#xs) P = <\\<nu>x>(resChain xs P)\""], ["", "lemma resChainPerm[simp]:\n  fixes perm :: \"name prm\"\n  and   lst  :: \"name list\"\n  and   P    :: pi\n  \n  shows \"perm \\<bullet> (resChain lst P) = resChain (perm \\<bullet> lst) (perm \\<bullet> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm \\<bullet> resChain lst P =\n    resChain (perm \\<bullet> lst) (perm \\<bullet> P)", "by(induct_tac lst, auto)"], ["", "lemma resChainFresh:\n  fixes a   :: name\n  and   lst :: \"name list\"\n  and   P   :: pi\n\n  assumes \"a \\<sharp> (lst, P)\"\n\n  shows \"a \\<sharp> (resChain lst P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> resChain lst P", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> (lst, P)\n\ngoal (1 subgoal):\n 1. a \\<sharp> resChain lst P", "apply(induct_tac lst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<sharp> (lst, P) \\<Longrightarrow> a \\<sharp> resChain [] P\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<sharp> (lst, P); a \\<sharp> resChain list P\\<rbrakk>\n       \\<Longrightarrow> a \\<sharp> resChain (aa # list) P", "apply(simp add: fresh_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>a \\<sharp> (lst, P); a \\<sharp> resChain list P\\<rbrakk>\n       \\<Longrightarrow> a \\<sharp> resChain (aa # list) P", "by(simp add: fresh_prod name_fresh_abs)"], ["", "end"]]}