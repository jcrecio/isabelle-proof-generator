{"file_name": "/home/qj213/afp-2021-10-22/thys/Regular-Sets/Equivalence_Checking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regular-Sets", "problem_names": ["lemma equal_if_bisimilar:\nassumes \"bisimilar K L\" shows \"K = L\"", "lemma language_coinduct:\nfixes R (infixl \"\\<sim>\" 50)\nassumes \"K \\<sim> L\"\nassumes \"\\<And>K L. K \\<sim> L \\<Longrightarrow> ([] \\<in> K \\<longleftrightarrow> [] \\<in> L)\"\nassumes \"\\<And>K L x. K \\<sim> L \\<Longrightarrow> Deriv x K \\<sim> Deriv x L\"\nshows \"K = L\"", "lemma bisim_lang_eq:\nassumes bisim: \"is_bisimulation as ps\"\nassumes \"(r, s) \\<in> ps\"\nshows \"lang r = lang s\"", "theorem closure_sound:\nassumes result: \"closure as (r,s) = Some([],R)\"\nand atoms: \"atoms r \\<union> atoms s \\<subseteq> set as\"\nshows \"lang r = lang s\"", "lemma rtrancl_nderiv_nderivs: defines \"nderivs == foldl (%r a. nderiv a r)\"\nshows \"{((r,s),(nderiv a r,nderiv a s))| r s a. a : A}^* =\n       {((r,s),(nderivs r w,nderivs s w))| r s w. w : lists A}\" (is \"?L = ?R\")", "lemma nullable_nderivs:\n  \"nullable (foldl (%r a. nderiv a r) r w) = (w : lang r)\"", "theorem closure_sound_complete:\nassumes result: \"closure as (r,s) = Some(ws,R)\"\nand atoms: \"set as = atoms r \\<union> atoms s\"\nshows \"ws = [] \\<longleftrightarrow> lang r = lang s\"", "lemma set_add_atoms: \"set (add_atoms r as) = atoms r \\<union> set as\"", "lemma soundness: \nassumes \"check_eqv r s\" shows \"lang r = lang s\"", "lemma \"check_eqv (Plus One (Times (Atom 0) (Star(Atom 0)))) (Star(Atom 0))\""], "translations": [["", "lemma equal_if_bisimilar:\nassumes \"bisimilar K L\" shows \"K = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K = L", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> K) = (x \\<in> L)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> K) = (x \\<in> L)", "from \\<open>bisimilar K L\\<close>"], ["proof (chain)\npicking this:\n  bisimilar K L", "show \"w \\<in> K \\<longleftrightarrow> w \\<in> L\""], ["proof (prove)\nusing this:\n  bisimilar K L\n\ngoal (1 subgoal):\n 1. (w \\<in> K) = (w \\<in> L)", "proof (induct w arbitrary: K L)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K L. bisimilar K L \\<Longrightarrow> ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   bisimilar K L \\<Longrightarrow>\n                   (w \\<in> K) = (w \\<in> L);\n        bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "case Nil"], ["proof (state)\nthis:\n  bisimilar K L\n\ngoal (2 subgoals):\n 1. \\<And>K L. bisimilar K L \\<Longrightarrow> ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   bisimilar K L \\<Longrightarrow>\n                   (w \\<in> K) = (w \\<in> L);\n        bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "thus ?case"], ["proof (prove)\nusing this:\n  bisimilar K L\n\ngoal (1 subgoal):\n 1. ([] \\<in> K) = ([] \\<in> L)", "by (auto elim: bisimilar.cases)"], ["proof (state)\nthis:\n  ([] \\<in> K) = ([] \\<in> L)\n\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   bisimilar K L \\<Longrightarrow>\n                   (w \\<in> K) = (w \\<in> L);\n        bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   bisimilar K L \\<Longrightarrow>\n                   (w \\<in> K) = (w \\<in> L);\n        bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "case (Cons a w K L)"], ["proof (state)\nthis:\n  bisimilar ?K ?L \\<Longrightarrow> (w \\<in> ?K) = (w \\<in> ?L)\n  bisimilar K L\n\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   bisimilar K L \\<Longrightarrow>\n                   (w \\<in> K) = (w \\<in> L);\n        bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "from \\<open>bisimilar K L\\<close>"], ["proof (chain)\npicking this:\n  bisimilar K L", "have \"bisimilar (Deriv a K) (Deriv a L)\""], ["proof (prove)\nusing this:\n  bisimilar K L\n\ngoal (1 subgoal):\n 1. bisimilar (Deriv a K) (Deriv a L)", "by (auto elim: bisimilar.cases)"], ["proof (state)\nthis:\n  bisimilar (Deriv a K) (Deriv a L)\n\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   bisimilar K L \\<Longrightarrow>\n                   (w \\<in> K) = (w \\<in> L);\n        bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "then"], ["proof (chain)\npicking this:\n  bisimilar (Deriv a K) (Deriv a L)", "have \"w \\<in> Deriv a K \\<longleftrightarrow> w \\<in> Deriv a L\""], ["proof (prove)\nusing this:\n  bisimilar (Deriv a K) (Deriv a L)\n\ngoal (1 subgoal):\n 1. (w \\<in> Deriv a K) = (w \\<in> Deriv a L)", "by (rule Cons(1))"], ["proof (state)\nthis:\n  (w \\<in> Deriv a K) = (w \\<in> Deriv a L)\n\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   bisimilar K L \\<Longrightarrow>\n                   (w \\<in> K) = (w \\<in> L);\n        bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "thus ?case"], ["proof (prove)\nusing this:\n  (w \\<in> Deriv a K) = (w \\<in> Deriv a L)\n\ngoal (1 subgoal):\n 1. (a # w \\<in> K) = (a # w \\<in> L)", "by (auto simp: Deriv_def)"], ["proof (state)\nthis:\n  (a # w \\<in> K) = (a # w \\<in> L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (w \\<in> K) = (w \\<in> L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_coinduct:\nfixes R (infixl \"\\<sim>\" 50)\nassumes \"K \\<sim> L\"\nassumes \"\\<And>K L. K \\<sim> L \\<Longrightarrow> ([] \\<in> K \\<longleftrightarrow> [] \\<in> L)\"\nassumes \"\\<And>K L x. K \\<sim> L \\<Longrightarrow> Deriv x K \\<sim> Deriv x L\"\nshows \"K = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K = L", "apply (rule equal_if_bisimilar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimilar K L", "apply (rule bisimilar.coinduct[of R, OF \\<open>K \\<sim> L\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 \\<sim> x2 \\<Longrightarrow>\n       \\<exists>K L.\n          x1 = K \\<and>\n          x2 = L \\<and>\n          ([] \\<in> K) = ([] \\<in> L) \\<and>\n          (\\<forall>x.\n              Deriv x K \\<sim> Deriv x L \\<or>\n              bisimilar (Deriv x K) (Deriv x L))", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "type_synonym 'a rexp_pair = \"'a rexp * 'a rexp\""], ["", "type_synonym 'a rexp_pairs = \"'a rexp_pair list\""], ["", "definition is_bisimulation ::  \"'a::order list \\<Rightarrow> 'a rexp_pair set \\<Rightarrow> bool\"\nwhere\n\"is_bisimulation as R =\n  (\\<forall>(r,s)\\<in> R. (atoms r \\<union> atoms s \\<subseteq> set as) \\<and> (nullable r \\<longleftrightarrow> nullable s) \\<and>\n    (\\<forall>a\\<in>set as. (nderiv a r, nderiv a s) \\<in> R))\""], ["", "lemma bisim_lang_eq:\nassumes bisim: \"is_bisimulation as ps\"\nassumes \"(r, s) \\<in> ps\"\nshows \"lang r = lang s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang r = lang s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "define ps' where \"ps' = insert (Zero, Zero) ps\""], ["proof (state)\nthis:\n  ps' = insert (Zero, Zero) ps\n\ngoal (1 subgoal):\n 1. lang r = lang s", "from bisim"], ["proof (chain)\npicking this:\n  is_bisimulation as ps", "have bisim': \"is_bisimulation as ps'\""], ["proof (prove)\nusing this:\n  is_bisimulation as ps\n\ngoal (1 subgoal):\n 1. is_bisimulation as ps'", "by (auto simp: ps'_def is_bisimulation_def)"], ["proof (state)\nthis:\n  is_bisimulation as ps'\n\ngoal (1 subgoal):\n 1. lang r = lang s", "let ?R = \"\\<lambda>K L. (\\<exists>(r,s)\\<in>ps'. K = lang r \\<and> L = lang s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang r = lang s", "proof (rule language_coinduct[where R=\"?R\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>(ra, sa)\\<in>ps'. lang r = lang ra \\<and> lang s = lang sa\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "from \\<open>(r, s) \\<in> ps\\<close>"], ["proof (chain)\npicking this:\n  (r, s) \\<in> ps", "have \"(r, s) \\<in> ps'\""], ["proof (prove)\nusing this:\n  (r, s) \\<in> ps\n\ngoal (1 subgoal):\n 1. (r, s) \\<in> ps'", "by (auto simp: ps'_def)"], ["proof (state)\nthis:\n  (r, s) \\<in> ps'\n\ngoal (3 subgoals):\n 1. \\<exists>(ra, sa)\\<in>ps'. lang r = lang ra \\<and> lang s = lang sa\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "thus \"?R (lang r) (lang s)\""], ["proof (prove)\nusing this:\n  (r, s) \\<in> ps'\n\ngoal (1 subgoal):\n 1. \\<exists>(ra, sa)\\<in>ps'. lang r = lang ra \\<and> lang s = lang sa", "by auto"], ["proof (state)\nthis:\n  \\<exists>(ra, sa)\\<in>ps'. lang r = lang ra \\<and> lang s = lang sa\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "fix K L"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "assume \"?R K L\""], ["proof (state)\nthis:\n  \\<exists>(r, s)\\<in>ps'. K = lang r \\<and> L = lang s\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "then"], ["proof (chain)\npicking this:\n  \\<exists>(r, s)\\<in>ps'. K = lang r \\<and> L = lang s", "obtain r s where rs: \"(r, s) \\<in> ps'\"\n      and KL: \"K = lang r\" \"L = lang s\""], ["proof (prove)\nusing this:\n  \\<exists>(r, s)\\<in>ps'. K = lang r \\<and> L = lang s\n\ngoal (1 subgoal):\n 1. (\\<And>r s.\n        \\<lbrakk>(r, s) \\<in> ps'; K = lang r; L = lang s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (r, s) \\<in> ps'\n  K = lang r\n  L = lang s\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "with bisim'"], ["proof (chain)\npicking this:\n  is_bisimulation as ps'\n  (r, s) \\<in> ps'\n  K = lang r\n  L = lang s", "have \"nullable r \\<longleftrightarrow> nullable s\""], ["proof (prove)\nusing this:\n  is_bisimulation as ps'\n  (r, s) \\<in> ps'\n  K = lang r\n  L = lang s\n\ngoal (1 subgoal):\n 1. nullable r = nullable s", "by (auto simp: is_bisimulation_def)"], ["proof (state)\nthis:\n  nullable r = nullable s\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "thus \"[] \\<in> K \\<longleftrightarrow> [] \\<in> L\""], ["proof (prove)\nusing this:\n  nullable r = nullable s\n\ngoal (1 subgoal):\n 1. ([] \\<in> K) = ([] \\<in> L)", "by (auto simp: nullable_iff KL)"], ["proof (state)\nthis:\n  ([] \\<in> K) = ([] \\<in> L)\n\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<exists>(r, s)\\<in>ps'.\n          K = lang r \\<and> L = lang s \\<Longrightarrow>\n       \\<exists>(r, s)\\<in>ps'. Deriv x K = lang r \\<and> Deriv x L = lang s", "show \"?R (Deriv a K) (Deriv a L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "assume \"a \\<in> set as\""], ["proof (state)\nthis:\n  a \\<in> set as\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "with rs bisim'"], ["proof (chain)\npicking this:\n  (r, s) \\<in> ps'\n  is_bisimulation as ps'\n  a \\<in> set as", "have \"(nderiv a r, nderiv a s) \\<in> ps'\""], ["proof (prove)\nusing this:\n  (r, s) \\<in> ps'\n  is_bisimulation as ps'\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. (nderiv a r, nderiv a s) \\<in> ps'", "by (auto simp: is_bisimulation_def)"], ["proof (state)\nthis:\n  (nderiv a r, nderiv a s) \\<in> ps'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "thus ?thesis"], ["proof (prove)\nusing this:\n  (nderiv a r, nderiv a s) \\<in> ps'\n\ngoal (1 subgoal):\n 1. \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "by (force simp: KL lang_nderiv)"], ["proof (state)\nthis:\n  \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "assume \"a \\<notin> set as\""], ["proof (state)\nthis:\n  a \\<notin> set as\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "with bisim' rs"], ["proof (chain)\npicking this:\n  is_bisimulation as ps'\n  (r, s) \\<in> ps'\n  a \\<notin> set as", "have \"a \\<notin> atoms r\" \"a \\<notin> atoms s\""], ["proof (prove)\nusing this:\n  is_bisimulation as ps'\n  (r, s) \\<in> ps'\n  a \\<notin> set as\n\ngoal (1 subgoal):\n 1. a \\<notin> atoms r &&& a \\<notin> atoms s", "by (auto simp: is_bisimulation_def)"], ["proof (state)\nthis:\n  a \\<notin> atoms r\n  a \\<notin> atoms s\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "then"], ["proof (chain)\npicking this:\n  a \\<notin> atoms r\n  a \\<notin> atoms s", "have \"nderiv a r = Zero\" \"nderiv a s = Zero\""], ["proof (prove)\nusing this:\n  a \\<notin> atoms r\n  a \\<notin> atoms s\n\ngoal (1 subgoal):\n 1. nderiv a r = Zero &&& nderiv a s = Zero", "by (auto intro: deriv_no_occurrence)"], ["proof (state)\nthis:\n  nderiv a r = Zero\n  nderiv a s = Zero\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "then"], ["proof (chain)\npicking this:\n  nderiv a r = Zero\n  nderiv a s = Zero", "have \"Deriv a K = lang Zero\" \n        \"Deriv a L = lang Zero\""], ["proof (prove)\nusing this:\n  nderiv a r = Zero\n  nderiv a s = Zero\n\ngoal (1 subgoal):\n 1. Deriv a K = lang Zero &&& Deriv a L = lang Zero", "unfolding KL lang_nderiv[symmetric]"], ["proof (prove)\nusing this:\n  nderiv a r = Zero\n  nderiv a s = Zero\n\ngoal (1 subgoal):\n 1. lang (nderiv a r) = lang Zero &&& lang (nderiv a s) = lang Zero", "by auto"], ["proof (state)\nthis:\n  Deriv a K = lang Zero\n  Deriv a L = lang Zero\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "thus ?thesis"], ["proof (prove)\nusing this:\n  Deriv a K = lang Zero\n  Deriv a L = lang Zero\n\ngoal (1 subgoal):\n 1. \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s", "by (auto simp: ps'_def)"], ["proof (state)\nthis:\n  \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(r, s)\\<in>ps'. Deriv a K = lang r \\<and> Deriv a L = lang s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lang r = lang s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure computation\\<close>"], ["", "definition closure ::\n  \"'a::order list \\<Rightarrow> 'a rexp_pair \\<Rightarrow> ('a rexp_pairs * 'a rexp_pair set) option\"\nwhere\n\"closure as = rtrancl_while (%(r,s). nullable r = nullable s)\n  (%(r,s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\""], ["", "definition pre_bisim :: \"'a::order list \\<Rightarrow> 'a rexp \\<Rightarrow> 'a rexp \\<Rightarrow>\n 'a rexp_pairs * 'a rexp_pair set \\<Rightarrow> bool\"\nwhere\n\"pre_bisim as r s = (\\<lambda>(ws,R).\n (r,s) \\<in> R \\<and> set ws \\<subseteq> R \\<and>\n (\\<forall>(r,s)\\<in> R. atoms r \\<union> atoms s \\<subseteq> set as) \\<and>\n (\\<forall>(r,s)\\<in> R - set ws. (nullable r \\<longleftrightarrow> nullable s) \\<and>\n   (\\<forall>a\\<in>set as. (nderiv a r, nderiv a s) \\<in> R)))\""], ["", "theorem closure_sound:\nassumes result: \"closure as (r,s) = Some([],R)\"\nand atoms: \"atoms r \\<union> atoms s \\<subseteq> set as\"\nshows \"lang r = lang s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang r = lang s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "let ?test = \"While_Combinator.rtrancl_while_test (%(r,s). nullable r = nullable s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "let ?step = \"While_Combinator.rtrancl_while_step (%(r,s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "fix st"], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "assume inv: \"pre_bisim as r s st\" and test: \"?test st\""], ["proof (state)\nthis:\n  pre_bisim as r s st\n  While_Combinator.rtrancl_while_test\n   (\\<lambda>(r, s). nullable r = nullable s) st\n\ngoal (1 subgoal):\n 1. lang r = lang s", "have \"pre_bisim as r s (?step st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_bisim as r s\n     (While_Combinator.rtrancl_while_step\n       (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as) st)", "proof (cases st)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       st = (a, b) \\<Longrightarrow>\n       pre_bisim as r s\n        (While_Combinator.rtrancl_while_step\n          (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n          st)", "fix ws R"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       st = (a, b) \\<Longrightarrow>\n       pre_bisim as r s\n        (While_Combinator.rtrancl_while_step\n          (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n          st)", "assume \"st = (ws, R)\""], ["proof (state)\nthis:\n  st = (ws, R)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       st = (a, b) \\<Longrightarrow>\n       pre_bisim as r s\n        (While_Combinator.rtrancl_while_step\n          (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n          st)", "with test"], ["proof (chain)\npicking this:\n  While_Combinator.rtrancl_while_test\n   (\\<lambda>(r, s). nullable r = nullable s) st\n  st = (ws, R)", "obtain r s t where st: \"st = ((r, s) # t, R)\" and \"nullable r = nullable s\""], ["proof (prove)\nusing this:\n  While_Combinator.rtrancl_while_test\n   (\\<lambda>(r, s). nullable r = nullable s) st\n  st = (ws, R)\n\ngoal (1 subgoal):\n 1. (\\<And>r s t.\n        \\<lbrakk>st = ((r, s) # t, R); nullable r = nullable s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ws) auto"], ["proof (state)\nthis:\n  st = ((r, s) # t, R)\n  nullable r = nullable s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       st = (a, b) \\<Longrightarrow>\n       pre_bisim as r s\n        (While_Combinator.rtrancl_while_step\n          (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n          st)", "with inv"], ["proof (chain)\npicking this:\n  pre_bisim as r s st\n  st = ((r, s) # t, R)\n  nullable r = nullable s", "show ?thesis"], ["proof (prove)\nusing this:\n  pre_bisim as r s st\n  st = ((r, s) # t, R)\n  nullable r = nullable s\n\ngoal (1 subgoal):\n 1. pre_bisim as r s\n     (While_Combinator.rtrancl_while_step\n       (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as) st)", "using atoms_nderiv[of _ r] atoms_nderiv[of _ s]"], ["proof (prove)\nusing this:\n  pre_bisim as r s st\n  st = ((r, s) # t, R)\n  nullable r = nullable s\n  atoms (nderiv ?a r) \\<subseteq> atoms r\n  atoms (nderiv ?a s) \\<subseteq> atoms s\n\ngoal (1 subgoal):\n 1. pre_bisim as r s\n     (While_Combinator.rtrancl_while_step\n       (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as) st)", "unfolding st rtrancl_while_test.simps rtrancl_while_step.simps pre_bisim_def Ball_def"], ["proof (prove)\nusing this:\n  case ((r, s) # t, R) of\n  (ws, R) \\<Rightarrow>\n    (r, s) \\<in> R \\<and>\n    set ws \\<subseteq> R \\<and>\n    (\\<forall>x.\n        x \\<in> R \\<longrightarrow>\n        (case x of\n         (r, s) \\<Rightarrow>\n           atoms r \\<union> atoms s \\<subseteq> set as)) \\<and>\n    (\\<forall>x.\n        x \\<in> R - set ws \\<longrightarrow>\n        (case x of\n         (r, s) \\<Rightarrow>\n           nullable r = nullable s \\<and>\n           (\\<forall>x.\n               x \\<in> set as \\<longrightarrow>\n               (nderiv x r, nderiv x s) \\<in> R)))\n  ((r, s) # t, R) = ((r, s) # t, R)\n  nullable r = nullable s\n  atoms (nderiv ?a r) \\<subseteq> atoms r\n  atoms (nderiv ?a s) \\<subseteq> atoms s\n\ngoal (1 subgoal):\n 1. case let x = hd ((r, s) # t);\n             new =\n               remdups\n                (filter (\\<lambda>y. y \\<notin> R)\n                  (case x of\n                   (r, s) \\<Rightarrow>\n                     map (\\<lambda>a. (nderiv a r, nderiv a s)) as))\n         in (new @ tl ((r, s) # t), set new \\<union> R) of\n    (ws, R) \\<Rightarrow>\n      (r, s) \\<in> R \\<and>\n      set ws \\<subseteq> R \\<and>\n      (\\<forall>x.\n          x \\<in> R \\<longrightarrow>\n          (case x of\n           (r, s) \\<Rightarrow>\n             atoms r \\<union> atoms s \\<subseteq> set as)) \\<and>\n      (\\<forall>x.\n          x \\<in> R - set ws \\<longrightarrow>\n          (case x of\n           (r, s) \\<Rightarrow>\n             nullable r = nullable s \\<and>\n             (\\<forall>x.\n                 x \\<in> set as \\<longrightarrow>\n                 (nderiv x r, nderiv x s) \\<in> R)))", "by simp_all blast+"], ["proof (state)\nthis:\n  pre_bisim as r s\n   (While_Combinator.rtrancl_while_step\n     (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as) st)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pre_bisim as r s\n   (While_Combinator.rtrancl_while_step\n     (\\<lambda>(r, s). map (\\<lambda>a. (nderiv a r, nderiv a s)) as) st)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>pre_bisim as r s ?st3;\n   While_Combinator.rtrancl_while_test\n    (\\<lambda>(r, s). nullable r = nullable s) ?st3\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s\n                     (While_Combinator.rtrancl_while_step\n                       (\\<lambda>(r, s).\n                           map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n                       ?st3)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>pre_bisim as r s ?st3;\n   While_Combinator.rtrancl_while_test\n    (\\<lambda>(r, s). nullable r = nullable s) ?st3\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s\n                     (While_Combinator.rtrancl_while_step\n                       (\\<lambda>(r, s).\n                           map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n                       ?st3)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "from atoms"], ["proof (chain)\npicking this:\n  atoms r \\<union> atoms s \\<subseteq> set as", "have \"pre_bisim as r s ([(r,s)],{(r,s)})\""], ["proof (prove)\nusing this:\n  atoms r \\<union> atoms s \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. pre_bisim as r s ([(r, s)], {(r, s)})", "by (simp add: pre_bisim_def)"], ["proof (state)\nthis:\n  pre_bisim as r s ([(r, s)], {(r, s)})\n\ngoal (1 subgoal):\n 1. lang r = lang s", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>pre_bisim as r s ?st3;\n   While_Combinator.rtrancl_while_test\n    (\\<lambda>(r, s). nullable r = nullable s) ?st3\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s\n                     (While_Combinator.rtrancl_while_step\n                       (\\<lambda>(r, s).\n                           map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n                       ?st3)\n  pre_bisim as r s ([(r, s)], {(r, s)})", "have pre_bisim_ps: \"pre_bisim as r s ([],R)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>pre_bisim as r s ?st3;\n   While_Combinator.rtrancl_while_test\n    (\\<lambda>(r, s). nullable r = nullable s) ?st3\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s\n                     (While_Combinator.rtrancl_while_step\n                       (\\<lambda>(r, s).\n                           map (\\<lambda>a. (nderiv a r, nderiv a s)) as)\n                       ?st3)\n  pre_bisim as r s ([(r, s)], {(r, s)})\n\ngoal (1 subgoal):\n 1. pre_bisim as r s ([], R)", "by (rule while_option_rule[OF _ result[unfolded closure_def rtrancl_while_def]])"], ["proof (state)\nthis:\n  pre_bisim as r s ([], R)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "then"], ["proof (chain)\npicking this:\n  pre_bisim as r s ([], R)", "have \"is_bisimulation as R\" \"(r, s) \\<in> R\""], ["proof (prove)\nusing this:\n  pre_bisim as r s ([], R)\n\ngoal (1 subgoal):\n 1. is_bisimulation as R &&& (r, s) \\<in> R", "by (auto simp: pre_bisim_def is_bisimulation_def)"], ["proof (state)\nthis:\n  is_bisimulation as R\n  (r, s) \\<in> R\n\ngoal (1 subgoal):\n 1. lang r = lang s", "thus \"lang r = lang s\""], ["proof (prove)\nusing this:\n  is_bisimulation as R\n  (r, s) \\<in> R\n\ngoal (1 subgoal):\n 1. lang r = lang s", "by (rule bisim_lang_eq)"], ["proof (state)\nthis:\n  lang r = lang s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Bisimulation-free proof of closure computation\\<close>"], ["", "text\\<open>The equivalence check can be viewed as the product construction\nof two automata. The state space is the reflexive transitive closure of\nthe pair of next-state functions, i.e. derivatives.\\<close>"], ["", "lemma rtrancl_nderiv_nderivs: defines \"nderivs == foldl (%r a. nderiv a r)\"\nshows \"{((r,s),(nderiv a r,nderiv a s))| r s a. a : A}^* =\n       {((r,s),(nderivs r w,nderivs s w))| r s w. w : lists A}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "note [simp] = nderivs_def"], ["proof (state)\nthis:\n  nderivs \\<equiv> foldl (\\<lambda>r a. nderiv a r)\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "{"], ["proof (state)\nthis:\n  nderivs \\<equiv> foldl (\\<lambda>r a. nderiv a r)\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "fix r s r' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "have \"((r,s),(r',s')) : ?L \\<Longrightarrow> ((r,s),(r',s')) : ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r, s), r', s')\n    \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n           a \\<in> A}\\<^sup>* \\<Longrightarrow>\n    ((r, s), r', s')\n    \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "proof(induction rule: converse_rtrancl_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n                                w \\<in> lists A}", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n                                w \\<in> lists A}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r', s'), r', s')\n    \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "by (force intro!: foldl.simps(1)[symmetric])"], ["proof (state)\nthis:\n  ((r', s'), r', s')\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n                                w \\<in> lists A}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n                                w \\<in> lists A}", "case step"], ["proof (state)\nthis:\n  ((a___, b___), a_, b_)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\n  ((a_, b_), r', s')\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n  ((a_, b_), r', s')\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A};\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*;\n        ((aa, ba), r', s')\n        \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n               w \\<in> lists A}\\<rbrakk>\n       \\<Longrightarrow> ((a, b), r', s')\n                         \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n                                w \\<in> lists A}", "thus ?case"], ["proof (prove)\nusing this:\n  ((a___, b___), a_, b_)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\n  ((a_, b_), r', s')\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n  ((a_, b_), r', s')\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. ((a___, b___), r', s')\n    \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "by(force intro!: foldl.simps(2)[symmetric])"], ["proof (state)\nthis:\n  ((a___, b___), r', s')\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((r, s), r', s')\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n         a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((r, s), r', s')\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "}"], ["proof (state)\nthis:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n         a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "moreover"], ["proof (state)\nthis:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n         a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "{"], ["proof (state)\nthis:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n         a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "fix r s r' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "have \"\\<forall>x\\<in>set w. x \\<in> A \\<Longrightarrow> ((r, s), nderivs r w, nderivs s w) :?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set w. x \\<in> A \\<Longrightarrow>\n    ((r, s), nderivs r w, nderivs s w)\n    \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*", "proof(induction w rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. x \\<in> A \\<Longrightarrow>\n    ((r, s), nderivs r [], nderivs s [])\n    \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n 2. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), nderivs r xs, nderivs s xs)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                       a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), nderivs r (xs @ [x]),\n                          nderivs s (xs @ [x]))\n                         \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. x \\<in> A\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. x \\<in> A \\<Longrightarrow>\n    ((r, s), nderivs r [], nderivs s [])\n    \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n 2. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), nderivs r xs, nderivs s xs)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                       a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), nderivs r (xs @ [x]),\n                          nderivs s (xs @ [x]))\n                         \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((r, s), nderivs r [], nderivs s [])\n    \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  ((r, s), nderivs r [], nderivs s [])\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), nderivs r xs, nderivs s xs)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                       a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), nderivs r (xs @ [x]),\n                          nderivs s (xs @ [x]))\n                         \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), nderivs r xs, nderivs s xs)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                       a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), nderivs r (xs @ [x]),\n                          nderivs s (xs @ [x]))\n                         \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "case snoc"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs_. x \\<in> A \\<Longrightarrow>\n  ((r, s), nderivs r xs_, nderivs s xs_)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n  \\<forall>x\\<in>set (xs_ @ [x_]). x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs. x \\<in> A \\<Longrightarrow>\n                ((r, s), nderivs r xs, nderivs s xs)\n                \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                       a \\<in> A}\\<^sup>*;\n        \\<forall>x\\<in>set (xs @ [x]). x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ((r, s), nderivs r (xs @ [x]),\n                          nderivs s (xs @ [x]))\n                         \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n                                a \\<in> A}\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs_. x \\<in> A \\<Longrightarrow>\n  ((r, s), nderivs r xs_, nderivs s xs_)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n  \\<forall>x\\<in>set (xs_ @ [x_]). x \\<in> A\n\ngoal (1 subgoal):\n 1. ((r, s), nderivs r (xs_ @ [x_]), nderivs s (xs_ @ [x_]))\n    \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*", "by (auto elim!: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  ((r, s), nderivs r (xs_ @ [x_]), nderivs s (xs_ @ [x_]))\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set w. x \\<in> A \\<Longrightarrow>\n  ((r, s), nderivs r w, nderivs s w)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "}"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ?w2. x \\<in> A \\<Longrightarrow>\n  ((r, s), nderivs r ?w2, nderivs s ?w2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "hence \"((r,s),(r',s')) : ?R \\<Longrightarrow> ((r,s),(r',s')) : ?L\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?w2. x \\<in> A \\<Longrightarrow>\n  ((r, s), nderivs r ?w2, nderivs s ?w2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((r, s), r', s')\n    \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n           w \\<in> lists A} \\<Longrightarrow>\n    ((r, s), r', s')\n    \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  ((r, s), r', s')\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ((r, s), r', s')\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "}"], ["proof (state)\nthis:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "ultimately"], ["proof (chain)\npicking this:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n         a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a.\n         a \\<in> A}\\<^sup>* \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderivs r w, nderivs s w) |r s w.\n         w \\<in> lists A} \\<Longrightarrow>\n  ((?r2, ?s2), ?r'2, ?s'2)\n  \\<in> {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>*\n\ngoal (1 subgoal):\n 1. {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n    {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}", "by (auto simp: in_lists_conv_set) blast"], ["proof (state)\nthis:\n  {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> A}\\<^sup>* =\n  {((r, s), nderivs r w, nderivs s w) |r s w. w \\<in> lists A}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nullable_nderivs:\n  \"nullable (foldl (%r a. nderiv a r) r w) = (w : lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nullable (foldl (\\<lambda>r a. nderiv a r) r w) = (w \\<in> lang r)", "by (induct w arbitrary: r) (simp_all add: nullable_iff lang_nderiv Deriv_def)"], ["", "theorem closure_sound_complete:\nassumes result: \"closure as (r,s) = Some(ws,R)\"\nand atoms: \"set as = atoms r \\<union> atoms s\"\nshows \"ws = [] \\<longleftrightarrow> lang r = lang s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ws = []) = (lang r = lang s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ws = []) = (lang r = lang s)", "have leq: \"(lang r = lang s) =\n  (\\<forall>(r',s') \\<in> {((r0,s0),(nderiv a r0,nderiv a s0))| r0 s0 a. a : set as}^* `` {(r,s)}.\n    nullable r' = nullable s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lang r = lang s) =\n    (\\<forall>(r', s')\n              \\<in>{((r0, s0), nderiv a r0, nderiv a s0) |r0 s0 a.\n                    a \\<in> set as}\\<^sup>* ``\n                   {(r, s)}.\n        nullable r' = nullable s')", "by(simp add: atoms rtrancl_nderiv_nderivs Ball_def lang_eq_ext imp_ex nullable_nderivs\n         del:Un_iff)"], ["proof (state)\nthis:\n  (lang r = lang s) =\n  (\\<forall>(r', s')\n            \\<in>{((r0, s0), nderiv a r0, nderiv a s0) |r0 s0 a.\n                  a \\<in> set as}\\<^sup>* ``\n                 {(r, s)}.\n      nullable r' = nullable s')\n\ngoal (1 subgoal):\n 1. (ws = []) = (lang r = lang s)", "have \"{(x,y). y \\<in> set ((\\<lambda>(p,q). map (\\<lambda>a. (nderiv a p, nderiv a q)) as) x)} =\n    {((r,s), nderiv a r, nderiv a s) |r s a. a \\<in> set as}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y).\n     y \\<in> set (case x of\n                  (p, q) \\<Rightarrow>\n                    map (\\<lambda>a. (nderiv a p, nderiv a q)) as)} =\n    {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> set as}", "by auto"], ["proof (state)\nthis:\n  {(x, y).\n   y \\<in> set (case x of\n                (p, q) \\<Rightarrow>\n                  map (\\<lambda>a. (nderiv a p, nderiv a q)) as)} =\n  {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> set as}\n\ngoal (1 subgoal):\n 1. (ws = []) = (lang r = lang s)", "with atoms rtrancl_while_Some[OF result[unfolded closure_def]]"], ["proof (chain)\npicking this:\n  set as = atoms r \\<union> atoms s\n  if ws = []\n  then R =\n       {(x, y).\n        y \\<in> set (case x of\n                     (r, s) \\<Rightarrow>\n                       map (\\<lambda>a. (nderiv a r, nderiv a s))\n                        as)}\\<^sup>* ``\n       {(r, s)} \\<and>\n       (\\<forall>z\\<in>R.\n           case z of (r, s) \\<Rightarrow> nullable r = nullable s)\n  else \\<not> (case hd ws of\n               (r, s) \\<Rightarrow> nullable r = nullable s) \\<and>\n       hd ws\n       \\<in> {(x, y).\n              y \\<in> set (case x of\n                           (r, s) \\<Rightarrow>\n                             map (\\<lambda>a. (nderiv a r, nderiv a s))\n                              as)}\\<^sup>* ``\n             {(r, s)}\n  {(x, y).\n   y \\<in> set (case x of\n                (p, q) \\<Rightarrow>\n                  map (\\<lambda>a. (nderiv a p, nderiv a q)) as)} =\n  {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> set as}", "show ?thesis"], ["proof (prove)\nusing this:\n  set as = atoms r \\<union> atoms s\n  if ws = []\n  then R =\n       {(x, y).\n        y \\<in> set (case x of\n                     (r, s) \\<Rightarrow>\n                       map (\\<lambda>a. (nderiv a r, nderiv a s))\n                        as)}\\<^sup>* ``\n       {(r, s)} \\<and>\n       (\\<forall>z\\<in>R.\n           case z of (r, s) \\<Rightarrow> nullable r = nullable s)\n  else \\<not> (case hd ws of\n               (r, s) \\<Rightarrow> nullable r = nullable s) \\<and>\n       hd ws\n       \\<in> {(x, y).\n              y \\<in> set (case x of\n                           (r, s) \\<Rightarrow>\n                             map (\\<lambda>a. (nderiv a r, nderiv a s))\n                              as)}\\<^sup>* ``\n             {(r, s)}\n  {(x, y).\n   y \\<in> set (case x of\n                (p, q) \\<Rightarrow>\n                  map (\\<lambda>a. (nderiv a p, nderiv a q)) as)} =\n  {((r, s), nderiv a r, nderiv a s) |r s a. a \\<in> set as}\n\ngoal (1 subgoal):\n 1. (ws = []) = (lang r = lang s)", "by (auto simp add: leq Ball_def split: if_splits)"], ["proof (state)\nthis:\n  (ws = []) = (lang r = lang s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The overall procedure\\<close>"], ["", "primrec add_atoms :: \"'a rexp \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"add_atoms Zero = id\"\n| \"add_atoms One = id\"\n| \"add_atoms (Atom a) = List.insert a\"\n| \"add_atoms (Plus r s) = add_atoms s o add_atoms r\"\n| \"add_atoms (Times r s) = add_atoms s o add_atoms r\"\n| \"add_atoms (Star r) = add_atoms r\""], ["", "lemma set_add_atoms: \"set (add_atoms r as) = atoms r \\<union> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_atoms r as) = atoms r \\<union> set as", "by (induct r arbitrary: as) auto"], ["", "definition check_eqv :: \"nat rexp \\<Rightarrow> nat rexp \\<Rightarrow> bool\" where\n\"check_eqv r s =\n  (let nr = norm r; ns = norm s; as = add_atoms nr (add_atoms ns [])\n   in case closure as (nr, ns) of\n     Some([],_) \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "lemma soundness: \nassumes \"check_eqv r s\" shows \"lang r = lang s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang r = lang s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "let ?nr = \"norm r\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "let ?ns = \"norm s\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "let ?as = \"add_atoms ?nr (add_atoms ?ns [])\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "obtain R where 1: \"closure ?as (?nr,?ns) = Some([],R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        closure (add_atoms (norm r) (add_atoms (norm s) []))\n         (norm r, norm s) =\n        Some ([], R) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  check_eqv r s\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        closure (add_atoms (norm r) (add_atoms (norm s) []))\n         (norm r, norm s) =\n        Some ([], R) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: check_eqv_def Let_def split:option.splits list.splits)"], ["proof (state)\nthis:\n  closure (add_atoms (norm r) (add_atoms (norm s) [])) (norm r, norm s) =\n  Some ([], R)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "then"], ["proof (chain)\npicking this:\n  closure (add_atoms (norm r) (add_atoms (norm s) [])) (norm r, norm s) =\n  Some ([], R)", "have \"lang (norm r) = lang (norm s)\""], ["proof (prove)\nusing this:\n  closure (add_atoms (norm r) (add_atoms (norm s) [])) (norm r, norm s) =\n  Some ([], R)\n\ngoal (1 subgoal):\n 1. lang (norm r) = lang (norm s)", "by (rule closure_sound) (auto simp: set_add_atoms dest!: subsetD[OF atoms_norm])"], ["proof (state)\nthis:\n  lang (norm r) = lang (norm s)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "thus \"lang r = lang s\""], ["proof (prove)\nusing this:\n  lang (norm r) = lang (norm s)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "by simp"], ["proof (state)\nthis:\n  lang r = lang s\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Test:\\<close>"], ["", "lemma \"check_eqv (Plus One (Times (Atom 0) (Star(Atom 0)))) (Star(Atom 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv (Plus One (Times (Atom 0) (Star (Atom 0)))) (Star (Atom 0))", "by eval"], ["", "end"]]}