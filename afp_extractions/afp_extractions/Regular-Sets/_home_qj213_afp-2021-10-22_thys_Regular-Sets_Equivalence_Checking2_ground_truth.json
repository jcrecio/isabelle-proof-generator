{"file_name": "/home/qj213/afp-2021-10-22/thys/Regular-Sets/Equivalence_Checking2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regular-Sets", "problem_names": ["lemma lang_nPlus[simp]: \"lang S (nPlus r s) = lang S (Plus r s)\"", "lemma lang_nTimes[simp]: \"lang S (nTimes r s) = lang S (Times r s)\"", "lemma lang_nInter[simp]: \"lang S (nInter r s) = lang S (Inter r s)\"", "lemma lang_norm[simp]: \"lang S (norm r) = lang S r\"", "lemma lang_nderiv: \"a:S \\<Longrightarrow> lang S (nderiv a r) = Deriv a (lang S r)\"", "lemma atoms_nPlus[simp]: \"atoms (nPlus r s) = atoms r \\<union> atoms s\"", "lemma atoms_nTimes: \"atoms (nTimes r s) \\<subseteq> atoms r \\<union> atoms s\"", "lemma atoms_nInter: \"atoms (nInter r s) \\<subseteq> atoms r \\<union> atoms s\"", "lemma atoms_norm: \"atoms (norm r) \\<subseteq> atoms r\"", "lemma atoms_nderiv: \"atoms (nderiv a r) \\<subseteq> atoms r\"", "lemma equal_if_bisimilar:\nassumes \"K \\<subseteq> lists S\" \"L \\<subseteq> lists S\" \"bisimilar K L\" shows \"K = L\"", "lemma language_coinduct:\nfixes R (infixl \"\\<sim>\" 50)\nassumes \"\\<And>K L. K \\<sim> L \\<Longrightarrow> K \\<subseteq> lists S \\<and> L \\<subseteq> lists S\"\nassumes \"K \\<sim> L\"\nassumes \"\\<And>K L. K \\<sim> L \\<Longrightarrow> ([] \\<in> K \\<longleftrightarrow> [] \\<in> L)\"\nassumes \"\\<And>K L x. K \\<sim> L \\<Longrightarrow> x : S \\<Longrightarrow> Deriv x K \\<sim> Deriv x L\"\nshows \"K = L\"", "lemma bisim_lang_eq:\nassumes bisim: \"is_bisimulation as ps\"\nassumes \"(r, s) \\<in> set ps\"\nshows \"lang (set as) r = lang (set as) s\"", "theorem closure_sound:\nassumes result: \"closure as ([(r,s)],[]) = Some([],ps)\"\nand atoms: \"atoms r \\<union> atoms s \\<subseteq> set as\"\nshows \"lang (set as) r = lang (set as) s\"", "lemma set_add_atoms: \"set (add_atoms r as) = atoms r \\<union> set as\"", "lemma soundness: \nassumes \"check_eqv as r s\" shows \"lang (set as) r = lang (set as) s\"", "lemma \"check_eqv [0] (Plus One (Times (Atom 0) (Star(Atom 0)))) (Star(Atom 0))\"", "lemma \"check_eqv [0,1] (Not(Atom 0))\n  (Plus One (Times (Plus (Atom 1) (Times (Atom 0) (Plus (Atom 0) (Atom 1))))\n                   (Star(Plus (Atom 0) (Atom 1)))))\"", "lemma \"check_eqv [0] (Atom 0) (Inter (Star (Atom 0)) (Atom 0))\""], "translations": [["", "lemma lang_nPlus[simp]: \"lang S (nPlus r s) = lang S (Plus r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang S (nPlus r s) = lang S (Plus r s)", "by (induct r s rule: nPlus.induct) auto"], ["", "text \\<open>associativity, zero, one\\<close>"], ["", "fun nTimes :: \"nat rexp \\<Rightarrow> nat rexp \\<Rightarrow> nat rexp\"\nwhere\n  \"nTimes Zero _ = Zero\"\n| \"nTimes _ Zero = Zero\"\n| \"nTimes One r = r\"\n| \"nTimes r One = r\"\n| \"nTimes (Times r s) t = Times r (nTimes s t)\"\n| \"nTimes r s = Times r s\""], ["", "lemma lang_nTimes[simp]: \"lang S (nTimes r s) = lang S (Times r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang S (nTimes r s) = lang S (Times r s)", "by (induct r s rule: nTimes.induct) (auto simp: conc_assoc)"], ["", "text \\<open>more optimisations:\\<close>"], ["", "fun nInter :: \"nat rexp \\<Rightarrow> nat rexp \\<Rightarrow> nat rexp\"\nwhere\n  \"nInter Zero _ = Zero\"\n| \"nInter _ Zero = Zero\"\n| \"nInter r s = Inter r s\""], ["", "lemma lang_nInter[simp]: \"lang S (nInter r s) = lang S (Inter r s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang S (nInter r s) = lang S (rexp.Inter r s)", "by (induct r s rule: nInter.induct) (auto)"], ["", "primrec norm :: \"nat rexp \\<Rightarrow> nat rexp\"\nwhere\n  \"norm Zero = Zero\"\n| \"norm One = One\"\n| \"norm (Atom a) = Atom a\"\n| \"norm (Plus r s) = nPlus (norm r) (norm s)\"\n| \"norm (Times r s) = nTimes (norm r) (norm s)\"\n| \"norm (Star r) = Star (norm r)\"\n| \"norm (Not r) = Not (norm r)\"\n| \"norm (Inter r1 r2) = nInter (norm r1) (norm r2)\""], ["", "lemma lang_norm[simp]: \"lang S (norm r) = lang S r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang S (norm r) = lang S r", "by (induct r) auto"], ["", "subsection \\<open>Derivative\\<close>"], ["", "primrec nderiv :: \"nat \\<Rightarrow> nat rexp \\<Rightarrow> nat rexp\"\nwhere\n  \"nderiv _ Zero = Zero\"\n| \"nderiv _ One = Zero\"\n| \"nderiv a (Atom b) = (if a = b then One else Zero)\"\n| \"nderiv a (Plus r s) = nPlus (nderiv a r) (nderiv a s)\"\n| \"nderiv a (Times r s) =\n    (let r's = nTimes (nderiv a r) s\n     in if nullable r then nPlus r's (nderiv a s) else r's)\"\n| \"nderiv a (Star r) = nTimes (nderiv a r) (Star r)\"\n| \"nderiv a (Not r) = Not (nderiv a r)\"\n| \"nderiv a (Inter r1 r2) = nInter (nderiv a r1) (nderiv a r2)\""], ["", "lemma lang_nderiv: \"a:S \\<Longrightarrow> lang S (nderiv a r) = Deriv a (lang S r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> S \\<Longrightarrow> lang S (nderiv a r) = Deriv a (lang S r)", "by (induct r) (auto simp: Let_def nullable_iff[where S=S])"], ["", "lemma atoms_nPlus[simp]: \"atoms (nPlus r s) = atoms r \\<union> atoms s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (nPlus r s) = atoms r \\<union> atoms s", "by (induct r s rule: nPlus.induct) auto"], ["", "lemma atoms_nTimes: \"atoms (nTimes r s) \\<subseteq> atoms r \\<union> atoms s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (nTimes r s) \\<subseteq> atoms r \\<union> atoms s", "by (induct r s rule: nTimes.induct) auto"], ["", "lemma atoms_nInter: \"atoms (nInter r s) \\<subseteq> atoms r \\<union> atoms s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (nInter r s) \\<subseteq> atoms r \\<union> atoms s", "by (induct r s rule: nInter.induct) auto"], ["", "lemma atoms_norm: \"atoms (norm r) \\<subseteq> atoms r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (norm r) \\<subseteq> atoms r", "by (induct r) (auto dest!:subsetD[OF atoms_nTimes]subsetD[OF atoms_nInter])"], ["", "lemma atoms_nderiv: \"atoms (nderiv a r) \\<subseteq> atoms r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (nderiv a r) \\<subseteq> atoms r", "by (induct r) (auto simp: Let_def dest!:subsetD[OF atoms_nTimes]subsetD[OF atoms_nInter])"], ["", "subsection \\<open>Bisimulation between languages and regular expressions\\<close>"], ["", "context\nfixes S :: \"'a set\"\nbegin"], ["", "coinductive bisimilar :: \"'a lang \\<Rightarrow> 'a lang \\<Rightarrow> bool\" where\n\"K \\<subseteq> lists S \\<Longrightarrow> L \\<subseteq> lists S\n \\<Longrightarrow> ([] \\<in> K \\<longleftrightarrow> [] \\<in> L) \n \\<Longrightarrow> (\\<And>x. x:S \\<Longrightarrow> bisimilar (Deriv x K) (Deriv x L))\n \\<Longrightarrow> bisimilar K L\""], ["", "lemma equal_if_bisimilar:\nassumes \"K \\<subseteq> lists S\" \"L \\<subseteq> lists S\" \"bisimilar K L\" shows \"K = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K = L", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> K) = (x \\<in> L)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> K) = (x \\<in> L)", "from assms"], ["proof (chain)\npicking this:\n  K \\<subseteq> lists S\n  L \\<subseteq> lists S\n  local.bisimilar K L", "show \"w \\<in> K \\<longleftrightarrow> w \\<in> L\""], ["proof (prove)\nusing this:\n  K \\<subseteq> lists S\n  L \\<subseteq> lists S\n  local.bisimilar K L\n\ngoal (1 subgoal):\n 1. (w \\<in> K) = (w \\<in> L)", "proof (induction w arbitrary: K L)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<lbrakk>K \\<subseteq> lists S; L \\<subseteq> lists S;\n        local.bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   \\<lbrakk>K \\<subseteq> lists S; L \\<subseteq> lists S;\n                    local.bisimilar K L\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> K) = (w \\<in> L);\n        K \\<subseteq> lists S; L \\<subseteq> lists S;\n        local.bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "case Nil"], ["proof (state)\nthis:\n  K \\<subseteq> lists S\n  L \\<subseteq> lists S\n  local.bisimilar K L\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<lbrakk>K \\<subseteq> lists S; L \\<subseteq> lists S;\n        local.bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   \\<lbrakk>K \\<subseteq> lists S; L \\<subseteq> lists S;\n                    local.bisimilar K L\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> K) = (w \\<in> L);\n        K \\<subseteq> lists S; L \\<subseteq> lists S;\n        local.bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "thus ?case"], ["proof (prove)\nusing this:\n  K \\<subseteq> lists S\n  L \\<subseteq> lists S\n  local.bisimilar K L\n\ngoal (1 subgoal):\n 1. ([] \\<in> K) = ([] \\<in> L)", "by (auto elim: bisimilar.cases)"], ["proof (state)\nthis:\n  ([] \\<in> K) = ([] \\<in> L)\n\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   \\<lbrakk>K \\<subseteq> lists S; L \\<subseteq> lists S;\n                    local.bisimilar K L\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> K) = (w \\<in> L);\n        K \\<subseteq> lists S; L \\<subseteq> lists S;\n        local.bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   \\<lbrakk>K \\<subseteq> lists S; L \\<subseteq> lists S;\n                    local.bisimilar K L\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> K) = (w \\<in> L);\n        K \\<subseteq> lists S; L \\<subseteq> lists S;\n        local.bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "case (Cons a w K L)"], ["proof (state)\nthis:\n  \\<lbrakk>?K \\<subseteq> lists S; ?L \\<subseteq> lists S;\n   local.bisimilar ?K ?L\\<rbrakk>\n  \\<Longrightarrow> (w \\<in> ?K) = (w \\<in> ?L)\n  K \\<subseteq> lists S\n  L \\<subseteq> lists S\n  local.bisimilar K L\n\ngoal (1 subgoal):\n 1. \\<And>a w K L.\n       \\<lbrakk>\\<And>K L.\n                   \\<lbrakk>K \\<subseteq> lists S; L \\<subseteq> lists S;\n                    local.bisimilar K L\\<rbrakk>\n                   \\<Longrightarrow> (w \\<in> K) = (w \\<in> L);\n        K \\<subseteq> lists S; L \\<subseteq> lists S;\n        local.bisimilar K L\\<rbrakk>\n       \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # w \\<in> K) = (a # w \\<in> L)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "assume \"a : S\""], ["proof (state)\nthis:\n  a \\<in> S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "with \\<open>bisimilar K L\\<close>"], ["proof (chain)\npicking this:\n  local.bisimilar K L\n  a \\<in> S", "have \"bisimilar (Deriv a K) (Deriv a L)\""], ["proof (prove)\nusing this:\n  local.bisimilar K L\n  a \\<in> S\n\ngoal (1 subgoal):\n 1. local.bisimilar (Deriv a K) (Deriv a L)", "by (auto elim: bisimilar.cases)"], ["proof (state)\nthis:\n  local.bisimilar (Deriv a K) (Deriv a L)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "then"], ["proof (chain)\npicking this:\n  local.bisimilar (Deriv a K) (Deriv a L)", "have \"w \\<in> Deriv a K \\<longleftrightarrow> w \\<in> Deriv a L\""], ["proof (prove)\nusing this:\n  local.bisimilar (Deriv a K) (Deriv a L)\n\ngoal (1 subgoal):\n 1. (w \\<in> Deriv a K) = (w \\<in> Deriv a L)", "by (metis Cons.IH bisimilar.cases)"], ["proof (state)\nthis:\n  (w \\<in> Deriv a K) = (w \\<in> Deriv a L)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)\n 2. \\<not> ?P \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "thus ?case"], ["proof (prove)\nusing this:\n  (w \\<in> Deriv a K) = (w \\<in> Deriv a L)\n\ngoal (1 subgoal):\n 1. (a # w \\<in> K) = (a # w \\<in> L)", "by (auto simp: Deriv_def)"], ["proof (state)\nthis:\n  (a # w \\<in> K) = (a # w \\<in> L)\n\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "assume \"a \\<notin> S\""], ["proof (state)\nthis:\n  a \\<notin> S\n\ngoal (1 subgoal):\n 1. a \\<notin> S \\<Longrightarrow> (a # w \\<in> K) = (a # w \\<in> L)", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<notin> S\n\ngoal (1 subgoal):\n 1. (a # w \\<in> K) = (a # w \\<in> L)", "using Cons.prems"], ["proof (prove)\nusing this:\n  a \\<notin> S\n  K \\<subseteq> lists S\n  L \\<subseteq> lists S\n  local.bisimilar K L\n\ngoal (1 subgoal):\n 1. (a # w \\<in> K) = (a # w \\<in> L)", "by auto"], ["proof (state)\nthis:\n  (a # w \\<in> K) = (a # w \\<in> L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a # w \\<in> K) = (a # w \\<in> L)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (w \\<in> K) = (w \\<in> L)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma language_coinduct:\nfixes R (infixl \"\\<sim>\" 50)\nassumes \"\\<And>K L. K \\<sim> L \\<Longrightarrow> K \\<subseteq> lists S \\<and> L \\<subseteq> lists S\"\nassumes \"K \\<sim> L\"\nassumes \"\\<And>K L. K \\<sim> L \\<Longrightarrow> ([] \\<in> K \\<longleftrightarrow> [] \\<in> L)\"\nassumes \"\\<And>K L x. K \\<sim> L \\<Longrightarrow> x : S \\<Longrightarrow> Deriv x K \\<sim> Deriv x L\"\nshows \"K = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K = L", "apply (rule equal_if_bisimilar)"], ["proof (prove)\ngoal (3 subgoals):\n 1. K \\<subseteq> lists S\n 2. L \\<subseteq> lists S\n 3. local.bisimilar K L", "apply (metis assms(1) assms(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. L \\<subseteq> lists S\n 2. local.bisimilar K L", "apply (metis assms(1) assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bisimilar K L", "apply (rule bisimilar.coinduct[of R, OF \\<open>K \\<sim> L\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x1 \\<sim> x2 \\<Longrightarrow>\n       \\<exists>K L.\n          x1 = K \\<and>\n          x2 = L \\<and>\n          K \\<subseteq> lists S \\<and>\n          L \\<subseteq> lists S \\<and>\n          ([] \\<in> K) = ([] \\<in> L) \\<and>\n          (\\<forall>x.\n              x \\<in> S \\<longrightarrow>\n              Deriv x K \\<sim> Deriv x L \\<or>\n              local.bisimilar (Deriv x K) (Deriv x L))", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "type_synonym rexp_pair = \"nat rexp * nat rexp\""], ["", "type_synonym rexp_pairs = \"rexp_pair list\""], ["", "definition is_bisimulation :: \"nat list \\<Rightarrow> rexp_pairs \\<Rightarrow> bool\"\nwhere\n\"is_bisimulation as ps =\n  (\\<forall>(r,s)\\<in> set ps. (atoms r \\<union> atoms s \\<subseteq> set as) \\<and> (nullable r \\<longleftrightarrow> nullable s) \\<and>\n    (\\<forall>a\\<in>set as. (nderiv a r, nderiv a s) \\<in> set ps))\""], ["", "lemma bisim_lang_eq:\nassumes bisim: \"is_bisimulation as ps\"\nassumes \"(r, s) \\<in> set ps\"\nshows \"lang (set as) r = lang (set as) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "let ?R = \"\\<lambda>K L. (\\<exists>(r,s)\\<in>set ps. K = lang (set as) r \\<and> L = lang (set as) s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "proof (rule language_coinduct[where R=\"?R\" and S = \"set as\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<exists>(ra, sa)\\<in>set ps.\n       lang (set as) r = lang (set as) ra \\<and>\n       lang (set as) s = lang (set as) sa\n 3. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 4. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "from \\<open>(r, s) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (r, s) \\<in> set ps", "show \"?R (lang (set as) r) (lang (set as) s)\""], ["proof (prove)\nusing this:\n  (r, s) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<exists>(ra, sa)\\<in>set ps.\n       lang (set as) r = lang (set as) ra \\<and>\n       lang (set as) s = lang (set as) sa", "by auto"], ["proof (state)\nthis:\n  \\<exists>(ra, sa)\\<in>set ps.\n     lang (set as) r = lang (set as) ra \\<and>\n     lang (set as) s = lang (set as) sa\n\ngoal (3 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "fix K L"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "assume \"?R K L\""], ["proof (state)\nthis:\n  \\<exists>(r, s)\\<in>set ps. K = lang (set as) r \\<and> L = lang (set as) s\n\ngoal (3 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "then"], ["proof (chain)\npicking this:\n  \\<exists>(r, s)\\<in>set ps. K = lang (set as) r \\<and> L = lang (set as) s", "obtain r s where rs: \"(r, s) \\<in> set ps\"\n      and KL: \"K = lang (set as) r\" \"L = lang (set as) s\""], ["proof (prove)\nusing this:\n  \\<exists>(r, s)\\<in>set ps. K = lang (set as) r \\<and> L = lang (set as) s\n\ngoal (1 subgoal):\n 1. (\\<And>r s.\n        \\<lbrakk>(r, s) \\<in> set ps; K = lang (set as) r;\n         L = lang (set as) s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (r, s) \\<in> set ps\n  K = lang (set as) r\n  L = lang (set as) s\n\ngoal (3 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "with bisim"], ["proof (chain)\npicking this:\n  is_bisimulation as ps\n  (r, s) \\<in> set ps\n  K = lang (set as) r\n  L = lang (set as) s", "have \"nullable r \\<longleftrightarrow> nullable s\""], ["proof (prove)\nusing this:\n  is_bisimulation as ps\n  (r, s) \\<in> set ps\n  K = lang (set as) r\n  L = lang (set as) s\n\ngoal (1 subgoal):\n 1. nullable r = nullable s", "by (auto simp: is_bisimulation_def)"], ["proof (state)\nthis:\n  nullable r = nullable s\n\ngoal (3 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "thus \"[] \\<in> K \\<longleftrightarrow> [] \\<in> L\""], ["proof (prove)\nusing this:\n  nullable r = nullable s\n\ngoal (1 subgoal):\n 1. ([] \\<in> K) = ([] \\<in> L)", "by (auto simp: nullable_iff[where S=\"set as\"] KL)"], ["proof (state)\nthis:\n  ([] \\<in> K) = ([] \\<in> L)\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "txt\\<open>next case, but shared context\\<close>"], ["proof (state)\nthis:\n  ([] \\<in> K) = ([] \\<in> L)\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(r, s)\\<in>set ps.\n          K = lang (set as) r \\<and> L = lang (set as) s \\<Longrightarrow>\n       K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n 2. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "from bisim rs KL lang_subset_lists[of _ \"set as\"]"], ["proof (chain)\npicking this:\n  is_bisimulation as ps\n  (r, s) \\<in> set ps\n  K = lang (set as) r\n  L = lang (set as) s\n  atoms ?r \\<subseteq> set as \\<Longrightarrow>\n  lang (set as) ?r \\<subseteq> lists (set as)", "show \"K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\""], ["proof (prove)\nusing this:\n  is_bisimulation as ps\n  (r, s) \\<in> set ps\n  K = lang (set as) r\n  L = lang (set as) s\n  atoms ?r \\<subseteq> set as \\<Longrightarrow>\n  lang (set as) ?r \\<subseteq> lists (set as)\n\ngoal (1 subgoal):\n 1. K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)", "unfolding is_bisimulation_def"], ["proof (prove)\nusing this:\n  \\<forall>(r, s)\\<in>set ps.\n     atoms r \\<union> atoms s \\<subseteq> set as \\<and>\n     nullable r = nullable s \\<and>\n     (\\<forall>a\\<in>set as. (nderiv a r, nderiv a s) \\<in> set ps)\n  (r, s) \\<in> set ps\n  K = lang (set as) r\n  L = lang (set as) s\n  atoms ?r \\<subseteq> set as \\<Longrightarrow>\n  lang (set as) ?r \\<subseteq> lists (set as)\n\ngoal (1 subgoal):\n 1. K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)", "by blast"], ["proof (state)\nthis:\n  K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "txt\\<open>next case, but shared context\\<close>"], ["proof (state)\nthis:\n  K \\<subseteq> lists (set as) \\<and> L \\<subseteq> lists (set as)\n\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "assume \"a \\<in> set as\""], ["proof (state)\nthis:\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "with rs bisim"], ["proof (chain)\npicking this:\n  (r, s) \\<in> set ps\n  is_bisimulation as ps\n  a \\<in> set as", "have \"(nderiv a r, nderiv a s) \\<in> set ps\""], ["proof (prove)\nusing this:\n  (r, s) \\<in> set ps\n  is_bisimulation as ps\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. (nderiv a r, nderiv a s) \\<in> set ps", "by (auto simp: is_bisimulation_def)"], ["proof (state)\nthis:\n  (nderiv a r, nderiv a s) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<lbrakk>\\<exists>(r, s)\\<in>set ps.\n                   K = lang (set as) r \\<and> L = lang (set as) s;\n        x \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(r, s)\\<in>set ps.\n                            Deriv x K = lang (set as) r \\<and>\n                            Deriv x L = lang (set as) s", "thus \"?R (Deriv a K) (Deriv a L)\""], ["proof (prove)\nusing this:\n  (nderiv a r, nderiv a s) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<exists>(r, s)\\<in>set ps.\n       Deriv a K = lang (set as) r \\<and> Deriv a L = lang (set as) s", "using \\<open>a \\<in> set as\\<close>"], ["proof (prove)\nusing this:\n  (nderiv a r, nderiv a s) \\<in> set ps\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<exists>(r, s)\\<in>set ps.\n       Deriv a K = lang (set as) r \\<and> Deriv a L = lang (set as) s", "by (force simp: KL lang_nderiv)"], ["proof (state)\nthis:\n  \\<exists>(r, s)\\<in>set ps.\n     Deriv a K = lang (set as) r \\<and> Deriv a L = lang (set as) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lang (set as) r = lang (set as) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure computation\\<close>"], ["", "fun test :: \"rexp_pairs * rexp_pairs \\<Rightarrow> bool\"\nwhere \"test (ws, ps) = (case ws of [] \\<Rightarrow>  False | (p,q)#_ \\<Rightarrow> nullable p = nullable q)\""], ["", "fun step :: \"nat list \\<Rightarrow> rexp_pairs * rexp_pairs \\<Rightarrow> rexp_pairs * rexp_pairs\"\nwhere \"step as (ws,ps) =\n    (let \n      (r, s) = hd ws;\n      ps' = (r, s) # ps;\n      succs = map (\\<lambda>a. (nderiv a r, nderiv a s)) as;\n      new = filter (\\<lambda>p. p \\<notin> set ps' \\<union> set ws) succs\n    in (new @ tl ws, ps'))\""], ["", "definition closure ::\n  \"nat list \\<Rightarrow> rexp_pairs * rexp_pairs\n   \\<Rightarrow> (rexp_pairs * rexp_pairs) option\" where\n\"closure as = while_option test (step as)\""], ["", "definition pre_bisim :: \"nat list \\<Rightarrow> nat rexp \\<Rightarrow> nat rexp \\<Rightarrow>\n rexp_pairs * rexp_pairs \\<Rightarrow> bool\"\nwhere\n\"pre_bisim as r s = (\\<lambda>(ws,ps).\n ((r, s) \\<in> set ws \\<union> set ps) \\<and>\n (\\<forall>(r,s)\\<in> set ws \\<union> set ps. atoms r \\<union> atoms s \\<subseteq> set as) \\<and>\n (\\<forall>(r,s)\\<in> set ps. (nullable r \\<longleftrightarrow> nullable s) \\<and>\n   (\\<forall>a\\<in>set as. (nderiv a r, nderiv a s) \\<in> set ps \\<union> set ws)))\""], ["", "theorem closure_sound:\nassumes result: \"closure as ([(r,s)],[]) = Some([],ps)\"\nand atoms: \"atoms r \\<union> atoms s \\<subseteq> set as\"\nshows \"lang (set as) r = lang (set as) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "fix st"], ["proof (state)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "have \"pre_bisim as r s st \\<Longrightarrow> test st \\<Longrightarrow> pre_bisim as r s (step as st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_bisim as r s st; test st\\<rbrakk>\n    \\<Longrightarrow> pre_bisim as r s (step as st)", "unfolding pre_bisim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case st of\n             (ws, ps) \\<Rightarrow>\n               (r, s) \\<in> set ws \\<union> set ps \\<and>\n               (\\<forall>(r, s)\\<in>set ws \\<union> set ps.\n                   atoms r \\<union> atoms s \\<subseteq> set as) \\<and>\n               (\\<forall>(r, s)\\<in>set ps.\n                   nullable r = nullable s \\<and>\n                   (\\<forall>a\\<in>set as.\n                       (nderiv a r, nderiv a s)\n                       \\<in> set ps \\<union> set ws));\n     test st\\<rbrakk>\n    \\<Longrightarrow> case step as st of\n                      (ws, ps) \\<Rightarrow>\n                        (r, s) \\<in> set ws \\<union> set ps \\<and>\n                        (\\<forall>(r, s)\\<in>set ws \\<union> set ps.\n                            atoms r \\<union> atoms s\n                            \\<subseteq> set as) \\<and>\n                        (\\<forall>(r, s)\\<in>set ps.\n                            nullable r = nullable s \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (nderiv a r, nderiv a s)\n                                \\<in> set ps \\<union> set ws))", "by (cases st) (auto simp: split_def split: list.splits prod.splits\n        dest!: subsetD[OF atoms_nderiv])"], ["proof (state)\nthis:\n  \\<lbrakk>pre_bisim as r s st; test st\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s (step as st)\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>pre_bisim as r s ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s (step as ?st2)\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>pre_bisim as r s ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s (step as ?st2)\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "from atoms"], ["proof (chain)\npicking this:\n  atoms r \\<union> atoms s \\<subseteq> set as", "have \"pre_bisim as r s ([(r,s)],[])\""], ["proof (prove)\nusing this:\n  atoms r \\<union> atoms s \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. pre_bisim as r s ([(r, s)], [])", "by (simp add: pre_bisim_def)"], ["proof (state)\nthis:\n  pre_bisim as r s ([(r, s)], [])\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>pre_bisim as r s ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s (step as ?st2)\n  pre_bisim as r s ([(r, s)], [])", "have pre_bisim_ps: \"pre_bisim as r s ([],ps)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>pre_bisim as r s ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_bisim as r s (step as ?st2)\n  pre_bisim as r s ([(r, s)], [])\n\ngoal (1 subgoal):\n 1. pre_bisim as r s ([], ps)", "by (rule while_option_rule[OF _ result[unfolded closure_def]])"], ["proof (state)\nthis:\n  pre_bisim as r s ([], ps)\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "then"], ["proof (chain)\npicking this:\n  pre_bisim as r s ([], ps)", "have \"is_bisimulation as ps\" \"(r, s) \\<in> set ps\""], ["proof (prove)\nusing this:\n  pre_bisim as r s ([], ps)\n\ngoal (1 subgoal):\n 1. is_bisimulation as ps &&& (r, s) \\<in> set ps", "by (auto simp: pre_bisim_def is_bisimulation_def)"], ["proof (state)\nthis:\n  is_bisimulation as ps\n  (r, s) \\<in> set ps\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "thus \"lang (set as) r = lang (set as) s\""], ["proof (prove)\nusing this:\n  is_bisimulation as ps\n  (r, s) \\<in> set ps\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "by (rule bisim_lang_eq)"], ["proof (state)\nthis:\n  lang (set as) r = lang (set as) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The overall procedure\\<close>"], ["", "primrec add_atoms :: \"nat rexp \\<Rightarrow> nat list \\<Rightarrow> nat list\"\nwhere\n  \"add_atoms Zero = id\"\n| \"add_atoms One = id\"\n| \"add_atoms (Atom a) = List.insert a\"\n| \"add_atoms (Plus r s) = add_atoms s o add_atoms r\"\n| \"add_atoms (Times r s) = add_atoms s o add_atoms r\"\n| \"add_atoms (Not r) = add_atoms r\"\n| \"add_atoms (Inter r s) = add_atoms s o add_atoms r\"\n| \"add_atoms (Star r) = add_atoms r\""], ["", "lemma set_add_atoms: \"set (add_atoms r as) = atoms r \\<union> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_atoms r as) = atoms r \\<union> set as", "by (induct r arbitrary: as) auto"], ["", "definition check_eqv :: \"nat list \\<Rightarrow> nat rexp \\<Rightarrow> nat rexp \\<Rightarrow> bool\"\nwhere\n\"check_eqv as r s \\<longleftrightarrow> set(add_atoms r (add_atoms s [])) \\<subseteq> set as \\<and>\n  (case closure as ([(norm r, norm s)], []) of\n     Some([],_) \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "lemma soundness: \nassumes \"check_eqv as r s\" shows \"lang (set as) r = lang (set as) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "obtain ps where cl: \"closure as ([(norm r,norm s)],[]) = Some([],ps)\"\n    and at: \"atoms r \\<union> atoms s \\<subseteq> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>closure as ([(norm r, norm s)], []) = Some ([], ps);\n         atoms r \\<union> atoms s \\<subseteq> set as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  check_eqv as r s\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>closure as ([(norm r, norm s)], []) = Some ([], ps);\n         atoms r \\<union> atoms s \\<subseteq> set as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: check_eqv_def set_add_atoms split:option.splits list.splits)"], ["proof (state)\nthis:\n  closure as ([(norm r, norm s)], []) = Some ([], ps)\n  atoms r \\<union> atoms s \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "hence \"atoms(norm r) \\<union> atoms(norm s) \\<subseteq> set as\""], ["proof (prove)\nusing this:\n  closure as ([(norm r, norm s)], []) = Some ([], ps)\n  atoms r \\<union> atoms s \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. atoms (norm r) \\<union> atoms (norm s) \\<subseteq> set as", "using atoms_norm"], ["proof (prove)\nusing this:\n  closure as ([(norm r, norm s)], []) = Some ([], ps)\n  atoms r \\<union> atoms s \\<subseteq> set as\n  atoms (norm ?r) \\<subseteq> atoms ?r\n\ngoal (1 subgoal):\n 1. atoms (norm r) \\<union> atoms (norm s) \\<subseteq> set as", "by blast"], ["proof (state)\nthis:\n  atoms (norm r) \\<union> atoms (norm s) \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "hence \"lang (set as) (norm r) = lang (set as) (norm s)\""], ["proof (prove)\nusing this:\n  atoms (norm r) \\<union> atoms (norm s) \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. lang (set as) (norm r) = lang (set as) (norm s)", "by (rule closure_sound[OF cl])"], ["proof (state)\nthis:\n  lang (set as) (norm r) = lang (set as) (norm s)\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "thus \"lang (set as) r = lang (set as) s\""], ["proof (prove)\nusing this:\n  lang (set as) (norm r) = lang (set as) (norm s)\n\ngoal (1 subgoal):\n 1. lang (set as) r = lang (set as) s", "by simp"], ["proof (state)\nthis:\n  lang (set as) r = lang (set as) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"check_eqv [0] (Plus One (Times (Atom 0) (Star(Atom 0)))) (Star(Atom 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv [0] (Plus One (Times (Atom 0) (Star (Atom 0))))\n     (Star (Atom 0))", "by eval"], ["", "lemma \"check_eqv [0,1] (Not(Atom 0))\n  (Plus One (Times (Plus (Atom 1) (Times (Atom 0) (Plus (Atom 0) (Atom 1))))\n                   (Star(Plus (Atom 0) (Atom 1)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv [0, 1] (rexp.Not (Atom 0))\n     (Plus One\n       (Times (Plus (Atom 1) (Times (Atom 0) (Plus (Atom 0) (Atom 1))))\n         (Star (Plus (Atom 0) (Atom 1)))))", "by eval"], ["", "lemma \"check_eqv [0] (Atom 0) (Inter (Star (Atom 0)) (Atom 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv [0] (Atom 0) (rexp.Inter (Star (Atom 0)) (Atom 0))", "by eval"], ["", "end"]]}