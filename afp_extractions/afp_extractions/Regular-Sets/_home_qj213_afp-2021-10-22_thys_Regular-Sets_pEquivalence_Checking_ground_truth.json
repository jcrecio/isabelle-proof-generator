{"file_name": "/home/qj213/afp-2021-10-22/thys/Regular-Sets/pEquivalence_Checking.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regular-Sets", "problem_names": ["lemma Atoms_pderiv: \"Atoms(pderiv a r) \\<subseteq> atoms r\"", "lemma Atoms_Pderiv: \"Atoms(Pderiv a R) \\<subseteq> Atoms R\"", "lemma pderiv_no_occurrence: \n  \"x \\<notin> atoms r \\<Longrightarrow> pderiv x r = {}\"", "lemma Pderiv_no_occurrence: \n  \"x \\<notin> Atoms R \\<Longrightarrow> Pderiv x R = {}\"", "lemma Deriv_Lang: \"Deriv c (Lang R) = Lang (Pderiv c R)\"", "lemma Nullable_pderiv[simp]: \"Nullable(pderivs w r) = (w : lang r)\"", "lemma Bisim_Lang_eq:\nassumes Bisim: \"is_Bisimulation as ps\"\nassumes \"(R, S) \\<in> set ps\"\nshows \"Lang R = Lang S\"", "lemma step_set_eq: \"\\<lbrakk> test (ws,ps); step as (ws,ps) = (ws',ps') \\<rbrakk>\n  \\<Longrightarrow> set ws' \\<union> set ps' =\n     set ws \\<union> set ps\n     \\<union> (\\<Union>a\\<in>set as. {(Pderiv a (fst(hd ws)), Pderiv a (snd(hd ws)))})\"", "theorem closure_sound:\nassumes result: \"closure as ([(R,S)],[]) = Some([],ps)\"\nand atoms: \"Atoms R \\<union> Atoms S \\<subseteq> set as\"\nshows \"Lang R = Lang S\"", "lemma soundness: assumes \"check_eqv r s\" shows \"lang r = lang s\"", "lemma \"check_eqv\n  (Plus One (Times (Atom 0) (Star(Atom 0))))\n  (Star(Atom(0::nat)))\"", "lemma PDERIVS_incr[simp]: \"R \\<subseteq> PDERIVS R\"", "lemma Pderiv_PDERIVS: assumes \"R' \\<subseteq> PDERIVS R\" shows \"Pderiv a R' \\<subseteq> PDERIVS R\"", "lemma finite_PDERIVS: \"finite R \\<Longrightarrow> finite(PDERIVS R)\"", "lemma closure_Some: assumes \"finite R0\" \"finite S0\" shows \"\\<exists>p. closure as ([(R0,S0)],[]) = Some p\"", "theorem closure_Some_Inv: assumes \"closure as ([({r},{s})],[]) = Some p\"\nshows \"\\<forall>(R,S)\\<in>set(fst p). \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\" (is \"?Inv p\")", "lemma closure_complete: assumes \"lang r = lang s\"\n shows \"EX bs. closure as ([({r},{s})],[]) = Some([],bs)\" (is ?C)"], "translations": [["", "lemma Atoms_pderiv: \"Atoms(pderiv a r) \\<subseteq> atoms r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Atoms (pderiv a r) \\<subseteq> atoms r", "apply (induct r)"], ["proof (prove)\ngoal (6 subgoals):\n 1. Atoms (pderiv a Zero) \\<subseteq> atoms Zero\n 2. Atoms (pderiv a One) \\<subseteq> atoms One\n 3. \\<And>x. Atoms (pderiv a (Atom x)) \\<subseteq> atoms (Atom x)\n 4. \\<And>r1 r2.\n       \\<lbrakk>Atoms (pderiv a r1) \\<subseteq> atoms r1;\n        Atoms (pderiv a r2) \\<subseteq> atoms r2\\<rbrakk>\n       \\<Longrightarrow> Atoms (pderiv a (Plus r1 r2))\n                         \\<subseteq> atoms (Plus r1 r2)\n 5. \\<And>r1 r2.\n       \\<lbrakk>Atoms (pderiv a r1) \\<subseteq> atoms r1;\n        Atoms (pderiv a r2) \\<subseteq> atoms r2\\<rbrakk>\n       \\<Longrightarrow> Atoms (pderiv a (Times r1 r2))\n                         \\<subseteq> atoms (Times r1 r2)\n 6. \\<And>r.\n       Atoms (pderiv a r) \\<subseteq> atoms r \\<Longrightarrow>\n       Atoms (pderiv a (Star r)) \\<subseteq> atoms (Star r)", "apply (auto simp: Atoms_def UN_subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r1 r2 x r'.\n       \\<lbrakk>\\<forall>i\\<in>pderiv a r1. atoms i \\<subseteq> atoms r1;\n        \\<forall>i\\<in>pderiv a r2. atoms i \\<subseteq> atoms r2;\n        nullable r1; x \\<in> atoms r'; x \\<notin> atoms r2;\n        r' \\<in> pderiv a r1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> atoms r1", "apply (fastforce)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Atoms_Pderiv: \"Atoms(Pderiv a R) \\<subseteq> Atoms R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Atoms (Pderiv a R) \\<subseteq> Atoms R", "using Atoms_pderiv"], ["proof (prove)\nusing this:\n  Atoms (pderiv ?a ?r) \\<subseteq> atoms ?r\n\ngoal (1 subgoal):\n 1. Atoms (Pderiv a R) \\<subseteq> Atoms R", "by (fastforce simp: Atoms_def Pderiv_def)"], ["", "lemma pderiv_no_occurrence: \n  \"x \\<notin> atoms r \\<Longrightarrow> pderiv x r = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> atoms r \\<Longrightarrow> pderiv x r = {}", "by (induct r) auto"], ["", "lemma Pderiv_no_occurrence: \n  \"x \\<notin> Atoms R \\<Longrightarrow> Pderiv x R = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Atoms R \\<Longrightarrow> Pderiv x R = {}", "by(auto simp:pderiv_no_occurrence Atoms_def Pderiv_def)"], ["", "lemma Deriv_Lang: \"Deriv c (Lang R) = Lang (Pderiv c R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Deriv c (Lang R) = Lang (Pderiv c R)", "by(auto simp: Deriv_pderiv Pderiv_def Lang_def)"], ["", "lemma Nullable_pderiv[simp]: \"Nullable(pderivs w r) = (w : lang r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nullable (pderivs w r) = (w \\<in> lang r)", "apply(induction w arbitrary: r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r. Nullable (pderivs [] r) = ([] \\<in> lang r)\n 2. \\<And>a w r.\n       (\\<And>r.\n           Nullable (pderivs w r) = (w \\<in> lang r)) \\<Longrightarrow>\n       Nullable (pderivs (a # w) r) = (a # w \\<in> lang r)", "apply (simp add: Nullable_def nullable_iff singleton_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a w r.\n       (\\<And>r.\n           Nullable (pderivs w r) = (w \\<in> lang r)) \\<Longrightarrow>\n       Nullable (pderivs (a # w) r) = (a # w \\<in> lang r)", "using eqset_imp_iff[OF Deriv_pderiv[where 'a = 'a]]"], ["proof (prove)\nusing this:\n  (?x \\<in> Deriv ?c1 (lang ?r1)) =\n  (?x \\<in> \\<Union> (lang ` pderiv ?c1 ?r1))\n\ngoal (1 subgoal):\n 1. \\<And>a w r.\n       (\\<And>r.\n           Nullable (pderivs w r) = (w \\<in> lang r)) \\<Longrightarrow>\n       Nullable (pderivs (a # w) r) = (a # w \\<in> lang r)", "apply (simp add: Nullable_def Deriv_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "type_synonym 'a Rexp_pair = \"'a rexp set * 'a rexp set\""], ["", "type_synonym 'a Rexp_pairs = \"'a Rexp_pair list\""], ["", "definition is_Bisimulation :: \"'a list \\<Rightarrow> 'a Rexp_pairs \\<Rightarrow> bool\"\nwhere\n\"is_Bisimulation as ps =\n  (\\<forall>(R,S)\\<in> set ps. Atoms R \\<union> Atoms S \\<subseteq> set as \\<and>\n    (Nullable R \\<longleftrightarrow> Nullable S) \\<and>\n    (\\<forall>a\\<in>set as. (Pderiv a R, Pderiv a S) \\<in> set ps))\""], ["", "lemma Bisim_Lang_eq:\nassumes Bisim: \"is_Bisimulation as ps\"\nassumes \"(R, S) \\<in> set ps\"\nshows \"Lang R = Lang S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "define ps' where \"ps' = ({}, {}) # ps\""], ["proof (state)\nthis:\n  ps' = ({}, {}) # ps\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "from Bisim"], ["proof (chain)\npicking this:\n  is_Bisimulation as ps", "have Bisim': \"is_Bisimulation as ps'\""], ["proof (prove)\nusing this:\n  is_Bisimulation as ps\n\ngoal (1 subgoal):\n 1. is_Bisimulation as ps'", "by (fastforce simp: ps'_def is_Bisimulation_def UN_subset_iff Pderiv_def Atoms_def)"], ["proof (state)\nthis:\n  is_Bisimulation as ps'\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "let ?R = \"\\<lambda>K L. (\\<exists>(R,S)\\<in>set ps'. K = Lang R \\<and> L = Lang S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "proof (rule language_coinduct[where R=\"?R\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>(Ra, Sa)\\<in>set ps'. Lang R = Lang Ra \\<and> Lang S = Lang Sa\n 2. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "from \\<open>(R,S) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (R, S) \\<in> set ps", "have \"(R,S) \\<in> set ps'\""], ["proof (prove)\nusing this:\n  (R, S) \\<in> set ps\n\ngoal (1 subgoal):\n 1. (R, S) \\<in> set ps'", "by (auto simp: ps'_def)"], ["proof (state)\nthis:\n  (R, S) \\<in> set ps'\n\ngoal (3 subgoals):\n 1. \\<exists>(Ra, Sa)\\<in>set ps'. Lang R = Lang Ra \\<and> Lang S = Lang Sa\n 2. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 3. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "thus \"?R (Lang R) (Lang S)\""], ["proof (prove)\nusing this:\n  (R, S) \\<in> set ps'\n\ngoal (1 subgoal):\n 1. \\<exists>(Ra, Sa)\\<in>set ps'. Lang R = Lang Ra \\<and> Lang S = Lang Sa", "by auto"], ["proof (state)\nthis:\n  \\<exists>(Ra, Sa)\\<in>set ps'. Lang R = Lang Ra \\<and> Lang S = Lang Sa\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "fix K L"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "assume \"?R K L\""], ["proof (state)\nthis:\n  \\<exists>(R, S)\\<in>set ps'. K = Lang R \\<and> L = Lang S\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "then"], ["proof (chain)\npicking this:\n  \\<exists>(R, S)\\<in>set ps'. K = Lang R \\<and> L = Lang S", "obtain R S where rs: \"(R, S) \\<in> set ps'\"\n      and KL: \"K = Lang R\" \"L = Lang S\""], ["proof (prove)\nusing this:\n  \\<exists>(R, S)\\<in>set ps'. K = Lang R \\<and> L = Lang S\n\ngoal (1 subgoal):\n 1. (\\<And>R S.\n        \\<lbrakk>(R, S) \\<in> set ps'; K = Lang R; L = Lang S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (R, S) \\<in> set ps'\n  K = Lang R\n  L = Lang S\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "with Bisim'"], ["proof (chain)\npicking this:\n  is_Bisimulation as ps'\n  (R, S) \\<in> set ps'\n  K = Lang R\n  L = Lang S", "have \"Nullable R \\<longleftrightarrow> Nullable S\""], ["proof (prove)\nusing this:\n  is_Bisimulation as ps'\n  (R, S) \\<in> set ps'\n  K = Lang R\n  L = Lang S\n\ngoal (1 subgoal):\n 1. Nullable R = Nullable S", "by (auto simp: is_Bisimulation_def)"], ["proof (state)\nthis:\n  Nullable R = Nullable S\n\ngoal (2 subgoals):\n 1. \\<And>K L.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       ([] \\<in> K) = ([] \\<in> L)\n 2. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "thus \"[] \\<in> K \\<longleftrightarrow> [] \\<in> L\""], ["proof (prove)\nusing this:\n  Nullable R = Nullable S\n\ngoal (1 subgoal):\n 1. ([] \\<in> K) = ([] \\<in> L)", "by (auto simp: nullable_iff KL Nullable_def Lang_def)"], ["proof (state)\nthis:\n  ([] \\<in> K) = ([] \\<in> L)\n\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K L x.\n       \\<exists>(R, S)\\<in>set ps'.\n          K = Lang R \\<and> L = Lang S \\<Longrightarrow>\n       \\<exists>(R, S)\\<in>set ps'.\n          Deriv x K = Lang R \\<and> Deriv x L = Lang S", "show \"?R (Deriv a K) (Deriv a L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "assume \"a \\<in> set as\""], ["proof (state)\nthis:\n  a \\<in> set as\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "with rs Bisim'"], ["proof (chain)\npicking this:\n  (R, S) \\<in> set ps'\n  is_Bisimulation as ps'\n  a \\<in> set as", "have \"(Pderiv a R, Pderiv a S) \\<in> set ps'\""], ["proof (prove)\nusing this:\n  (R, S) \\<in> set ps'\n  is_Bisimulation as ps'\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. (Pderiv a R, Pderiv a S) \\<in> set ps'", "by (auto simp: is_Bisimulation_def)"], ["proof (state)\nthis:\n  (Pderiv a R, Pderiv a S) \\<in> set ps'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "thus ?thesis"], ["proof (prove)\nusing this:\n  (Pderiv a R, Pderiv a S) \\<in> set ps'\n\ngoal (1 subgoal):\n 1. \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "by (fastforce simp: KL Deriv_Lang)"], ["proof (state)\nthis:\n  \\<exists>(R, S)\\<in>set ps'. Deriv a K = Lang R \\<and> Deriv a L = Lang S\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "assume \"a \\<notin> set as\""], ["proof (state)\nthis:\n  a \\<notin> set as\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "with Bisim' rs"], ["proof (chain)\npicking this:\n  is_Bisimulation as ps'\n  (R, S) \\<in> set ps'\n  a \\<notin> set as", "have \"a \\<notin> Atoms R \\<union> Atoms S\""], ["proof (prove)\nusing this:\n  is_Bisimulation as ps'\n  (R, S) \\<in> set ps'\n  a \\<notin> set as\n\ngoal (1 subgoal):\n 1. a \\<notin> Atoms R \\<union> Atoms S", "by (fastforce simp: is_Bisimulation_def UN_subset_iff)"], ["proof (state)\nthis:\n  a \\<notin> Atoms R \\<union> Atoms S\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "then"], ["proof (chain)\npicking this:\n  a \\<notin> Atoms R \\<union> Atoms S", "have \"Pderiv a R = {}\" \"Pderiv a S = {}\""], ["proof (prove)\nusing this:\n  a \\<notin> Atoms R \\<union> Atoms S\n\ngoal (1 subgoal):\n 1. Pderiv a R = {} &&& Pderiv a S = {}", "by (metis Pderiv_no_occurrence Un_iff)+"], ["proof (state)\nthis:\n  Pderiv a R = {}\n  Pderiv a S = {}\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "then"], ["proof (chain)\npicking this:\n  Pderiv a R = {}\n  Pderiv a S = {}", "have \"Deriv a K = Lang {}\" \"Deriv a L = Lang {}\""], ["proof (prove)\nusing this:\n  Pderiv a R = {}\n  Pderiv a S = {}\n\ngoal (1 subgoal):\n 1. Deriv a K = Lang {} &&& Deriv a L = Lang {}", "unfolding KL Deriv_Lang"], ["proof (prove)\nusing this:\n  Pderiv a R = {}\n  Pderiv a S = {}\n\ngoal (1 subgoal):\n 1. Lang (Pderiv a R) = Lang {} &&& Lang (Pderiv a S) = Lang {}", "by auto"], ["proof (state)\nthis:\n  Deriv a K = Lang {}\n  Deriv a L = Lang {}\n\ngoal (1 subgoal):\n 1. a \\<notin> set as \\<Longrightarrow>\n    \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "thus ?thesis"], ["proof (prove)\nusing this:\n  Deriv a K = Lang {}\n  Deriv a L = Lang {}\n\ngoal (1 subgoal):\n 1. \\<exists>(R, S)\\<in>set ps'.\n       Deriv a K = Lang R \\<and> Deriv a L = Lang S", "by (auto simp: ps'_def)"], ["proof (state)\nthis:\n  \\<exists>(R, S)\\<in>set ps'. Deriv a K = Lang R \\<and> Deriv a L = Lang S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(R, S)\\<in>set ps'. Deriv a K = Lang R \\<and> Deriv a L = Lang S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lang R = Lang S\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure computation\\<close>"], ["", "fun test :: \"'a Rexp_pairs * 'a Rexp_pairs \\<Rightarrow> bool\" where\n\"test (ws, ps) = (case ws of [] \\<Rightarrow>  False | (R,S)#_ \\<Rightarrow> Nullable R = Nullable S)\""], ["", "fun step :: \"'a list \\<Rightarrow>\n  'a Rexp_pairs * 'a Rexp_pairs \\<Rightarrow> 'a Rexp_pairs * 'a Rexp_pairs\"\nwhere \"step as (ws,ps) =\n    (let\n      (R,S) = hd ws;\n      ps' = (R,S) # ps;\n      succs = map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as;\n      new = filter (\\<lambda>p. p \\<notin> set ps \\<union> set ws) succs\n    in (remdups new @ tl ws, ps'))\""], ["", "definition closure ::\n  \"'a list \\<Rightarrow> 'a Rexp_pairs * 'a Rexp_pairs\n   \\<Rightarrow> ('a Rexp_pairs * 'a Rexp_pairs) option\" where\n\"closure as = while_option test (step as)\""], ["", "definition pre_Bisim :: \"'a list \\<Rightarrow> 'a rexp set \\<Rightarrow> 'a rexp set \\<Rightarrow>\n 'a Rexp_pairs * 'a Rexp_pairs \\<Rightarrow> bool\"\nwhere\n\"pre_Bisim as R S = (\\<lambda>(ws,ps).\n ((R,S) \\<in> set ws \\<union> set ps) \\<and>\n (\\<forall>(R,S)\\<in> set ws \\<union> set ps. Atoms R \\<union> Atoms S \\<subseteq> set as) \\<and>\n (\\<forall>(R,S)\\<in> set ps. (Nullable R \\<longleftrightarrow> Nullable S) \\<and>\n   (\\<forall>a\\<in>set as. (Pderiv a R, Pderiv a S) \\<in> set ps \\<union> set ws)))\""], ["", "lemma step_set_eq: \"\\<lbrakk> test (ws,ps); step as (ws,ps) = (ws',ps') \\<rbrakk>\n  \\<Longrightarrow> set ws' \\<union> set ps' =\n     set ws \\<union> set ps\n     \\<union> (\\<Union>a\\<in>set as. {(Pderiv a (fst(hd ws)), Pderiv a (snd(hd ws)))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>test (ws, ps); step as (ws, ps) = (ws', ps')\\<rbrakk>\n    \\<Longrightarrow> set ws' \\<union> set ps' =\n                      set ws \\<union> set ps \\<union>\n                      (\\<Union>a\\<in>set as.\n                          {(Pderiv a (fst (hd ws)),\n                            Pderiv a (snd (hd ws)))})", "by(auto split: list.splits)"], ["", "theorem closure_sound:\nassumes result: \"closure as ([(R,S)],[]) = Some([],ps)\"\nand atoms: \"Atoms R \\<union> Atoms S \\<subseteq> set as\"\nshows \"Lang R = Lang S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "fix st"], ["proof (state)\ngoal (1 subgoal):\n 1. Lang R = Lang S", "have \"pre_Bisim as R S st \\<Longrightarrow> test st \\<Longrightarrow> pre_Bisim as R S (step as st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pre_Bisim as R S st; test st\\<rbrakk>\n    \\<Longrightarrow> pre_Bisim as R S (step as st)", "unfolding pre_Bisim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case st of\n             (ws, ps) \\<Rightarrow>\n               (R, S) \\<in> set ws \\<union> set ps \\<and>\n               (\\<forall>(R, S)\\<in>set ws \\<union> set ps.\n                   Atoms R \\<union> Atoms S \\<subseteq> set as) \\<and>\n               (\\<forall>(R, S)\\<in>set ps.\n                   Nullable R = Nullable S \\<and>\n                   (\\<forall>a\\<in>set as.\n                       (Pderiv a R, Pderiv a S)\n                       \\<in> set ps \\<union> set ws));\n     test st\\<rbrakk>\n    \\<Longrightarrow> case step as st of\n                      (ws, ps) \\<Rightarrow>\n                        (R, S) \\<in> set ws \\<union> set ps \\<and>\n                        (\\<forall>(R, S)\\<in>set ws \\<union> set ps.\n                            Atoms R \\<union> Atoms S\n                            \\<subseteq> set as) \\<and>\n                        (\\<forall>(R, S)\\<in>set ps.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set ps \\<union> set ws))", "proof(split prod.splits, elim case_prodE conjE, intro allI impI conjI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (R, S) \\<in> set x1 \\<union> set x2\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 3. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "case 1"], ["proof (state)\nthis:\n  test st\n  st = (x_, y_)\n  (R, S) \\<in> set x_ \\<union> set y_\n  \\<forall>(R, S)\\<in>set x_ \\<union> set y_.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n  \\<forall>(R, S)\\<in>set y_.\n     Nullable R = Nullable S \\<and>\n     (\\<forall>a\\<in>set as.\n         (Pderiv a R, Pderiv a S) \\<in> set y_ \\<union> set x_)\n  step as st = (x1_, x2_)\n\ngoal (3 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (R, S) \\<in> set x1 \\<union> set x2\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 3. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "thus ?case"], ["proof (prove)\nusing this:\n  test st\n  st = (x_, y_)\n  (R, S) \\<in> set x_ \\<union> set y_\n  \\<forall>(R, S)\\<in>set x_ \\<union> set y_.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n  \\<forall>(R, S)\\<in>set y_.\n     Nullable R = Nullable S \\<and>\n     (\\<forall>a\\<in>set as.\n         (Pderiv a R, Pderiv a S) \\<in> set y_ \\<union> set x_)\n  step as st = (x1_, x2_)\n\ngoal (1 subgoal):\n 1. (R, S) \\<in> set x1_ \\<union> set x2_", "by(auto split: list.splits)"], ["proof (state)\nthis:\n  (R, S) \\<in> set x1_ \\<union> set x2_\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "case prems: (2 ws ps ws' ps')"], ["proof (state)\nthis:\n  test st\n  st = (ws, ps)\n  (R, S) \\<in> set ws \\<union> set ps\n  \\<forall>(R, S)\\<in>set ws \\<union> set ps.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n  \\<forall>(R, S)\\<in>set ps.\n     Nullable R = Nullable S \\<and>\n     (\\<forall>a\\<in>set as.\n         (Pderiv a R, Pderiv a S) \\<in> set ps \\<union> set ws)\n  step as st = (ws', ps')\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "note prems(2)[simp]"], ["proof (state)\nthis:\n  st = (ws, ps)\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "from \\<open>test st\\<close>"], ["proof (chain)\npicking this:\n  test st", "obtain wstl R S where [simp]: \"ws = (R,S)#wstl\""], ["proof (prove)\nusing this:\n  test st\n\ngoal (1 subgoal):\n 1. (\\<And>R S wstl.\n        ws = (R, S) # wstl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: list.splits)"], ["proof (state)\nthis:\n  ws = (R, S) # wstl\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "from \\<open>step as st = (ws',ps')\\<close>"], ["proof (chain)\npicking this:\n  step as st = (ws', ps')", "obtain P where [simp]: \"ps' = (R,S) # ps\"\n        and [simp]: \"ws' = remdups(filter P (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @ wstl\""], ["proof (prove)\nusing this:\n  step as st = (ws', ps')\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>ps' = (R, S) # ps;\n         ws' =\n         remdups\n          (filter P (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n         wstl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ps' = (R, S) # ps\n  ws' =\n  remdups (filter P (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @ wstl\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "have \"\\<forall>(R',S')\\<in>set wstl \\<union> set ps'. Atoms R' \\<union> Atoms S' \\<subseteq> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(R', S')\\<in>set wstl \\<union> set ps'.\n       Atoms R' \\<union> Atoms S' \\<subseteq> set as", "using prems(4)"], ["proof (prove)\nusing this:\n  \\<forall>(R, S)\\<in>set ws \\<union> set ps.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. \\<forall>(R', S')\\<in>set wstl \\<union> set ps'.\n       Atoms R' \\<union> Atoms S' \\<subseteq> set as", "by auto"], ["proof (state)\nthis:\n  \\<forall>(R', S')\\<in>set wstl \\<union> set ps'.\n     Atoms R' \\<union> Atoms S' \\<subseteq> set as\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "moreover"], ["proof (state)\nthis:\n  \\<forall>(R', S')\\<in>set wstl \\<union> set ps'.\n     Atoms R' \\<union> Atoms S' \\<subseteq> set as\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "have \"\\<forall>a\\<in>set as. Atoms(Pderiv a R) \\<union> Atoms(Pderiv a S) \\<subseteq> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as.\n       Atoms (Pderiv a R) \\<union> Atoms (Pderiv a S) \\<subseteq> set as", "using prems(4)"], ["proof (prove)\nusing this:\n  \\<forall>(R, S)\\<in>set ws \\<union> set ps.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as.\n       Atoms (Pderiv a R) \\<union> Atoms (Pderiv a S) \\<subseteq> set as", "by simp (metis (lifting) Atoms_Pderiv order_trans)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as.\n     Atoms (Pderiv a R) \\<union> Atoms (Pderiv a S) \\<subseteq> set as\n\ngoal (2 subgoals):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x1 \\<union> set x2.\n                            Atoms R \\<union> Atoms S \\<subseteq> set as\n 2. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(R', S')\\<in>set wstl \\<union> set ps'.\n     Atoms R' \\<union> Atoms S' \\<subseteq> set as\n  \\<forall>a\\<in>set as.\n     Atoms (Pderiv a R) \\<union> Atoms (Pderiv a S) \\<subseteq> set as", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>(R', S')\\<in>set wstl \\<union> set ps'.\n     Atoms R' \\<union> Atoms S' \\<subseteq> set as\n  \\<forall>a\\<in>set as.\n     Atoms (Pderiv a R) \\<union> Atoms (Pderiv a S) \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set ws' \\<union> set ps'.\n       Atoms R \\<union> Atoms S \\<subseteq> set as", "by simp blast"], ["proof (state)\nthis:\n  \\<forall>(R, S)\\<in>set ws' \\<union> set ps'.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "case 3"], ["proof (state)\nthis:\n  test st\n  st = (x_, y_)\n  (R, S) \\<in> set x_ \\<union> set y_\n  \\<forall>(R, S)\\<in>set x_ \\<union> set y_.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n  \\<forall>(R, S)\\<in>set y_.\n     Nullable R = Nullable S \\<and>\n     (\\<forall>a\\<in>set as.\n         (Pderiv a R, Pderiv a S) \\<in> set y_ \\<union> set x_)\n  step as st = (x1_, x2_)\n\ngoal (1 subgoal):\n 1. \\<And>x y x1 x2.\n       \\<lbrakk>test st; st = (x, y); (R, S) \\<in> set x \\<union> set y;\n        \\<forall>(R, S)\\<in>set x \\<union> set y.\n           Atoms R \\<union> Atoms S \\<subseteq> set as;\n        \\<forall>(R, S)\\<in>set y.\n           Nullable R = Nullable S \\<and>\n           (\\<forall>a\\<in>set as.\n               (Pderiv a R, Pderiv a S) \\<in> set y \\<union> set x);\n        step as st = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(R, S)\\<in>set x2.\n                            Nullable R = Nullable S \\<and>\n                            (\\<forall>a\\<in>set as.\n                                (Pderiv a R, Pderiv a S)\n                                \\<in> set x2 \\<union> set x1)", "thus ?case"], ["proof (prove)\nusing this:\n  test st\n  st = (x_, y_)\n  (R, S) \\<in> set x_ \\<union> set y_\n  \\<forall>(R, S)\\<in>set x_ \\<union> set y_.\n     Atoms R \\<union> Atoms S \\<subseteq> set as\n  \\<forall>(R, S)\\<in>set y_.\n     Nullable R = Nullable S \\<and>\n     (\\<forall>a\\<in>set as.\n         (Pderiv a R, Pderiv a S) \\<in> set y_ \\<union> set x_)\n  step as st = (x1_, x2_)\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set x2_.\n       Nullable R = Nullable S \\<and>\n       (\\<forall>a\\<in>set as.\n           (Pderiv a R, Pderiv a S) \\<in> set x2_ \\<union> set x1_)", "apply (clarsimp simp: image_iff split: prod.splits list.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a x22 x1aa x2aa.\n       \\<lbrakk>st = ((x1a, x2a) # x22, y_);\n        R = x1a \\<and> S = x2a \\<or>\n        (R, S) \\<in> set x22 \\<or> (R, S) \\<in> set y_;\n        \\<forall>x\\<in>set y_.\n           \\<forall>x1 x2.\n              x = (x1, x2) \\<longrightarrow>\n              Nullable x1 = Nullable x2 \\<and>\n              (\\<forall>a\\<in>set as.\n                  (Pderiv a x1, Pderiv a x2) \\<in> set y_ \\<or>\n                  Pderiv a x1 = x1a \\<and> Pderiv a x2 = x2a \\<or>\n                  (Pderiv a x1, Pderiv a x2) \\<in> set x22);\n        x_ = (x1a, x2a) # x22; Nullable x1a = Nullable x2a;\n        x1_ =\n        remdups\n         (filter\n           (\\<lambda>p.\n               p \\<notin> set y_ \\<and>\n               p \\<noteq> (x1a, x2a) \\<and> p \\<notin> set x22)\n           (map (\\<lambda>a. (Pderiv a x1a, Pderiv a x2a)) as)) @\n        x22;\n        x2_ = (x1a, x2a) # y_;\n        x1aa = x1a \\<and> x2aa = x2a \\<or> (x1aa, x2aa) \\<in> set y_;\n        Atoms x1a \\<subseteq> set as; Atoms x2a \\<subseteq> set as;\n        \\<forall>x\\<in>set x22 \\<union> set y_.\n           \\<forall>x1 x2.\n              x = (x1, x2) \\<longrightarrow>\n              Atoms x1 \\<subseteq> set as \\<and>\n              Atoms x2 \\<subseteq> set as\\<rbrakk>\n       \\<Longrightarrow> Nullable x1aa = Nullable x2aa \\<and>\n                         (\\<forall>a\\<in>set as.\n                             Pderiv a x1aa = x1a \\<and>\n                             Pderiv a x2aa = x2a \\<or>\n                             (Pderiv a x1aa, Pderiv a x2aa)\n                             \\<in> set y_ \\<or>\n                             (\\<exists>x\\<in>set as.\n                                 Pderiv a x1aa = Pderiv x x1a \\<and>\n                                 Pderiv a x2aa = Pderiv x x2a) \\<and>\n                             (Pderiv a x1aa, Pderiv a x2aa)\n                             \\<notin> set y_ \\<and>\n                             (Pderiv a x1aa = x1a \\<longrightarrow>\n                              Pderiv a x2aa \\<noteq> x2a) \\<and>\n                             (Pderiv a x1aa, Pderiv a x2aa)\n                             \\<notin> set x22 \\<or>\n                             (Pderiv a x1aa, Pderiv a x2aa) \\<in> set x22)", "by hypsubst_thin metis"], ["proof (state)\nthis:\n  \\<forall>(R, S)\\<in>set x2_.\n     Nullable R = Nullable S \\<and>\n     (\\<forall>a\\<in>set as.\n         (Pderiv a R, Pderiv a S) \\<in> set x2_ \\<union> set x1_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>pre_Bisim as R S st; test st\\<rbrakk>\n  \\<Longrightarrow> pre_Bisim as R S (step as st)\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "}"], ["proof (state)\nthis:\n  \\<lbrakk>pre_Bisim as R S ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_Bisim as R S (step as ?st2)\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>pre_Bisim as R S ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_Bisim as R S (step as ?st2)\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "from atoms"], ["proof (chain)\npicking this:\n  Atoms R \\<union> Atoms S \\<subseteq> set as", "have \"pre_Bisim as R S ([(R,S)],[])\""], ["proof (prove)\nusing this:\n  Atoms R \\<union> Atoms S \\<subseteq> set as\n\ngoal (1 subgoal):\n 1. pre_Bisim as R S ([(R, S)], [])", "by (simp add: pre_Bisim_def)"], ["proof (state)\nthis:\n  pre_Bisim as R S ([(R, S)], [])\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>pre_Bisim as R S ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_Bisim as R S (step as ?st2)\n  pre_Bisim as R S ([(R, S)], [])", "have pre_Bisim_ps: \"pre_Bisim as R S ([],ps)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>pre_Bisim as R S ?st2; test ?st2\\<rbrakk>\n  \\<Longrightarrow> pre_Bisim as R S (step as ?st2)\n  pre_Bisim as R S ([(R, S)], [])\n\ngoal (1 subgoal):\n 1. pre_Bisim as R S ([], ps)", "by (rule while_option_rule[OF _ result[unfolded closure_def]])"], ["proof (state)\nthis:\n  pre_Bisim as R S ([], ps)\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "then"], ["proof (chain)\npicking this:\n  pre_Bisim as R S ([], ps)", "have \"is_Bisimulation as ps\" \"(R,S) \\<in> set ps\""], ["proof (prove)\nusing this:\n  pre_Bisim as R S ([], ps)\n\ngoal (1 subgoal):\n 1. is_Bisimulation as ps &&& (R, S) \\<in> set ps", "by (auto simp: pre_Bisim_def is_Bisimulation_def)"], ["proof (state)\nthis:\n  is_Bisimulation as ps\n  (R, S) \\<in> set ps\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "thus \"Lang R = Lang S\""], ["proof (prove)\nusing this:\n  is_Bisimulation as ps\n  (R, S) \\<in> set ps\n\ngoal (1 subgoal):\n 1. Lang R = Lang S", "by (rule Bisim_Lang_eq)"], ["proof (state)\nthis:\n  Lang R = Lang S\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The overall procedure\\<close>"], ["", "definition check_eqv :: \"'a rexp \\<Rightarrow> 'a rexp \\<Rightarrow> bool\"\nwhere\n\"check_eqv r s =\n  (case closure (add_atoms r (add_atoms s [])) ([({r}, {s})], []) of\n     Some([],_) \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "lemma soundness: assumes \"check_eqv r s\" shows \"lang r = lang s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang r = lang s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "let ?as = \"add_atoms r (add_atoms s [])\""], ["proof (state)\ngoal (1 subgoal):\n 1. lang r = lang s", "obtain ps where 1: \"closure ?as ([({r},{s})],[]) = Some([],ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        pEquivalence_Checking.closure (add_atoms r (add_atoms s []))\n         ([({r}, {s})], []) =\n        Some ([], ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  pEquivalence_Checking.check_eqv r s\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        pEquivalence_Checking.closure (add_atoms r (add_atoms s []))\n         ([({r}, {s})], []) =\n        Some ([], ps) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: check_eqv_def split:option.splits list.splits)"], ["proof (state)\nthis:\n  pEquivalence_Checking.closure (add_atoms r (add_atoms s []))\n   ([({r}, {s})], []) =\n  Some ([], ps)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "then"], ["proof (chain)\npicking this:\n  pEquivalence_Checking.closure (add_atoms r (add_atoms s []))\n   ([({r}, {s})], []) =\n  Some ([], ps)", "have \"lang r = lang s\""], ["proof (prove)\nusing this:\n  pEquivalence_Checking.closure (add_atoms r (add_atoms s []))\n   ([({r}, {s})], []) =\n  Some ([], ps)\n\ngoal (1 subgoal):\n 1. lang r = lang s", "by(rule closure_sound[of _ \"{r}\" \"{s}\", simplified Lang_def, simplified])\n      (auto simp: set_add_atoms Atoms_def)"], ["proof (state)\nthis:\n  lang r = lang s\n\ngoal (1 subgoal):\n 1. lang r = lang s", "thus \"lang r = lang s\""], ["proof (prove)\nusing this:\n  lang r = lang s\n\ngoal (1 subgoal):\n 1. lang r = lang s", "by simp"], ["proof (state)\nthis:\n  lang r = lang s\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Test:\\<close>"], ["", "lemma \"check_eqv\n  (Plus One (Times (Atom 0) (Star(Atom 0))))\n  (Star(Atom(0::nat)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pEquivalence_Checking.check_eqv\n     (Plus One (Times (Atom 0) (Star (Atom 0)))) (Star (Atom 0))", "by eval"], ["", "subsection \"Termination and Completeness\""], ["", "definition PDERIVS :: \"'a rexp set => 'a rexp set\" where\n\"PDERIVS R = (UN r:R. pderivs_lang UNIV r)\""], ["", "lemma PDERIVS_incr[simp]: \"R \\<subseteq> PDERIVS R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> PDERIVS R", "apply(auto simp add: PDERIVS_def pderivs_lang_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       \\<exists>xa\\<in>R. \\<exists>xb. x \\<in> pderivs xb xa", "by (metis pderivs.simps(1) insertI1)"], ["", "lemma Pderiv_PDERIVS: assumes \"R' \\<subseteq> PDERIVS R\" shows \"Pderiv a R' \\<subseteq> PDERIVS R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pderiv a R' \\<subseteq> PDERIVS R", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pderiv a R' \\<Longrightarrow> x \\<in> PDERIVS R", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pderiv a R' \\<Longrightarrow> x \\<in> PDERIVS R", "assume \"r : Pderiv a R'\""], ["proof (state)\nthis:\n  r \\<in> Pderiv a R'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pderiv a R' \\<Longrightarrow> x \\<in> PDERIVS R", "then"], ["proof (chain)\npicking this:\n  r \\<in> Pderiv a R'", "obtain r' where \"r' : R'\" \"r : pderiv a r'\""], ["proof (prove)\nusing this:\n  r \\<in> Pderiv a R'\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>r' \\<in> R'; r \\<in> pderiv a r'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: Pderiv_def)"], ["proof (state)\nthis:\n  r' \\<in> R'\n  r \\<in> pderiv a r'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pderiv a R' \\<Longrightarrow> x \\<in> PDERIVS R", "from \\<open>r' : R'\\<close> \\<open>R' \\<subseteq> PDERIVS R\\<close>"], ["proof (chain)\npicking this:\n  r' \\<in> R'\n  R' \\<subseteq> PDERIVS R", "obtain s w where \"s : R\" \"r' : pderivs w s\""], ["proof (prove)\nusing this:\n  r' \\<in> R'\n  R' \\<subseteq> PDERIVS R\n\ngoal (1 subgoal):\n 1. (\\<And>s w.\n        \\<lbrakk>s \\<in> R; r' \\<in> pderivs w s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: PDERIVS_def pderivs_lang_def)"], ["proof (state)\nthis:\n  s \\<in> R\n  r' \\<in> pderivs w s\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pderiv a R' \\<Longrightarrow> x \\<in> PDERIVS R", "hence \"r \\<in> pderivs (w @ [a]) s\""], ["proof (prove)\nusing this:\n  s \\<in> R\n  r' \\<in> pderivs w s\n\ngoal (1 subgoal):\n 1. r \\<in> pderivs (w @ [a]) s", "using \\<open>r : pderiv a r'\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> R\n  r' \\<in> pderivs w s\n  r \\<in> pderiv a r'\n\ngoal (1 subgoal):\n 1. r \\<in> pderivs (w @ [a]) s", "by(auto simp add:pderivs_snoc)"], ["proof (state)\nthis:\n  r \\<in> pderivs (w @ [a]) s\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Pderiv a R' \\<Longrightarrow> x \\<in> PDERIVS R", "thus \"r : PDERIVS R\""], ["proof (prove)\nusing this:\n  r \\<in> pderivs (w @ [a]) s\n\ngoal (1 subgoal):\n 1. r \\<in> PDERIVS R", "using \\<open>s : R\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> pderivs (w @ [a]) s\n  s \\<in> R\n\ngoal (1 subgoal):\n 1. r \\<in> PDERIVS R", "by(auto simp: PDERIVS_def pderivs_lang_def)"], ["proof (state)\nthis:\n  r \\<in> PDERIVS R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_PDERIVS: \"finite R \\<Longrightarrow> finite(PDERIVS R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow> finite (PDERIVS R)", "by(simp add: PDERIVS_def finite_pderivs_lang_UNIV)"], ["", "lemma closure_Some: assumes \"finite R0\" \"finite S0\" shows \"\\<exists>p. closure as ([(R0,S0)],[]) = Some p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. pEquivalence_Checking.closure as ([(R0, S0)], []) = Some p", "proof(unfold closure_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "let ?Inv = \"%(ws,bs).  distinct ws \\<and> (ALL (R,S) : set ws. R \\<subseteq> PDERIVS R0 \\<and> S \\<subseteq> PDERIVS S0 \\<and> (R,S) \\<notin> set bs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "let ?m1 = \"%bs. Pow(PDERIVS R0) \\<times> Pow(PDERIVS S0) - set bs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "let ?m2 = \"%(ws,bs). card(?m1 bs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "have Inv0: \"?Inv ([(R0, S0)], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case ([(R0, S0)], []) of\n    (ws, bs) \\<Rightarrow>\n      distinct ws \\<and>\n      (\\<forall>(R, S)\\<in>set ws.\n          R \\<subseteq> PDERIVS R0 \\<and>\n          S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)", "by simp"], ["proof (state)\nthis:\n  case ([(R0, S0)], []) of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "{"], ["proof (state)\nthis:\n  case ([(R0, S0)], []) of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "assume \"test s\" \"?Inv s\""], ["proof (state)\nthis:\n  test s\n  case s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "obtain ws bs where [simp]: \"s = (ws,bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ws bs. s = (ws, bs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  s = (ws, bs)\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "from \\<open>test s\\<close>"], ["proof (chain)\npicking this:\n  test s", "obtain R S ws' where [simp]: \"ws = (R,S)#ws'\""], ["proof (prove)\nusing this:\n  test s\n\ngoal (1 subgoal):\n 1. (\\<And>R S ws'.\n        ws = (R, S) # ws' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto split: prod.splits list.splits)"], ["proof (state)\nthis:\n  ws = (R, S) # ws'\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "let ?bs' = \"(R,S) # bs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "let ?succs = \"map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "let ?new = \"filter (\\<lambda>p. p \\<notin> set bs \\<union> set ws) ?succs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "let ?ws' = \"remdups ?new @ ws'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "have *: \"?Inv (step as s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case step as s of\n    (ws, bs) \\<Rightarrow>\n      distinct ws \\<and>\n      (\\<forall>(R, S)\\<in>set ws.\n          R \\<subseteq> PDERIVS R0 \\<and>\n          S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. case step as s of\n    (ws, bs) \\<Rightarrow>\n      distinct ws \\<and>\n      (\\<forall>(R, S)\\<in>set ws.\n          R \\<subseteq> PDERIVS R0 \\<and>\n          S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)", "from \\<open>?Inv s\\<close>"], ["proof (chain)\npicking this:\n  case s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)", "have \"distinct ?ws'\""], ["proof (prove)\nusing this:\n  case s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. distinct\n     (remdups\n       (filter (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n         (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n      ws')", "by auto"], ["proof (state)\nthis:\n  distinct\n   (remdups\n     (filter (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n       (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n    ws')\n\ngoal (1 subgoal):\n 1. case step as s of\n    (ws, bs) \\<Rightarrow>\n      distinct ws \\<and>\n      (\\<forall>(R, S)\\<in>set ws.\n          R \\<subseteq> PDERIVS R0 \\<and>\n          S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)", "have \"ALL (R,S) : set ?ws'. R \\<subseteq> PDERIVS R0 \\<and> S \\<subseteq> PDERIVS S0 \\<and> (R,S) \\<notin> set ?bs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(Ra, Sa)\n             \\<in>set (remdups\n                        (filter\n                          (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n                          (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n                       ws').\n       Ra \\<subseteq> PDERIVS R0 \\<and>\n       Sa \\<subseteq> PDERIVS S0 \\<and> (Ra, Sa) \\<notin> set ((R, S) # bs)", "using \\<open>?Inv s\\<close>"], ["proof (prove)\nusing this:\n  case s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. \\<forall>(Ra, Sa)\n             \\<in>set (remdups\n                        (filter\n                          (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n                          (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n                       ws').\n       Ra \\<subseteq> PDERIVS R0 \\<and>\n       Sa \\<subseteq> PDERIVS S0 \\<and> (Ra, Sa) \\<notin> set ((R, S) # bs)", "by(simp add: Ball_def image_iff) (metis Pderiv_PDERIVS)"], ["proof (state)\nthis:\n  \\<forall>(Ra, Sa)\n           \\<in>set (remdups\n                      (filter\n                        (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n                        (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n                     ws').\n     Ra \\<subseteq> PDERIVS R0 \\<and>\n     Sa \\<subseteq> PDERIVS S0 \\<and> (Ra, Sa) \\<notin> set ((R, S) # bs)\n\ngoal (1 subgoal):\n 1. case step as s of\n    (ws, bs) \\<Rightarrow>\n      distinct ws \\<and>\n      (\\<forall>(R, S)\\<in>set ws.\n          R \\<subseteq> PDERIVS R0 \\<and>\n          S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)", "with \\<open>distinct ?ws'\\<close>"], ["proof (chain)\npicking this:\n  distinct\n   (remdups\n     (filter (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n       (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n    ws')\n  \\<forall>(Ra, Sa)\n           \\<in>set (remdups\n                      (filter\n                        (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n                        (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n                     ws').\n     Ra \\<subseteq> PDERIVS R0 \\<and>\n     Sa \\<subseteq> PDERIVS S0 \\<and> (Ra, Sa) \\<notin> set ((R, S) # bs)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct\n   (remdups\n     (filter (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n       (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n    ws')\n  \\<forall>(Ra, Sa)\n           \\<in>set (remdups\n                      (filter\n                        (\\<lambda>p. p \\<notin> set bs \\<union> set ws)\n                        (map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as)) @\n                     ws').\n     Ra \\<subseteq> PDERIVS R0 \\<and>\n     Sa \\<subseteq> PDERIVS S0 \\<and> (Ra, Sa) \\<notin> set ((R, S) # bs)\n\ngoal (1 subgoal):\n 1. case step as s of\n    (ws, bs) \\<Rightarrow>\n      distinct ws \\<and>\n      (\\<forall>(R, S)\\<in>set ws.\n          R \\<subseteq> PDERIVS R0 \\<and>\n          S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)", "by(simp)"], ["proof (state)\nthis:\n  case step as s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case step as s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "have \"?m2(step as s) < ?m2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "have \"finite(?m1 bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs)", "by(metis assms finite_Diff finite_PDERIVS finite_cartesian_product finite_Pow_iff)"], ["proof (state)\nthis:\n  finite (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs)\n\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "moreover"], ["proof (state)\nthis:\n  finite (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs)\n\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "have \"?m2(step as s) < ?m2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "using \\<open>?Inv s\\<close>"], ["proof (prove)\nusing this:\n  case s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "by(auto intro: psubset_card_mono[OF \\<open>finite(?m1 bs)\\<close>])"], ["proof (state)\nthis:\n  (case step as s of\n   (ws, bs) \\<Rightarrow>\n     card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  < (case s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "then"], ["proof (chain)\npicking this:\n  (case step as s of\n   (ws, bs) \\<Rightarrow>\n     card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  < (case s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "show ?thesis"], ["proof (prove)\nusing this:\n  (case step as s of\n   (ws, bs) \\<Rightarrow>\n     card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  < (case s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "using \\<open>?Inv s\\<close>"], ["proof (prove)\nusing this:\n  (case step as s of\n   (ws, bs) \\<Rightarrow>\n     card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  < (case s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  case s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n\ngoal (1 subgoal):\n 1. (case step as s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n    < (case s of\n       (ws, bs) \\<Rightarrow>\n         card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))", "by simp"], ["proof (state)\nthis:\n  (case step as s of\n   (ws, bs) \\<Rightarrow>\n     card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  < (case s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case step as s of\n   (ws, bs) \\<Rightarrow>\n     card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  < (case s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "note * and this"], ["proof (state)\nthis:\n  case step as s of\n  (ws, bs) \\<Rightarrow>\n    distinct ws \\<and>\n    (\\<forall>(R, S)\\<in>set ws.\n        R \\<subseteq> PDERIVS R0 \\<and>\n        S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\n  (case step as s of\n   (ws, bs) \\<Rightarrow>\n     card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n  < (case s of\n     (ws, bs) \\<Rightarrow>\n       card (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) - set bs))\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "}"], ["proof (state)\nthis:\n  \\<lbrakk>test ?s3;\n   case ?s3 of\n   (ws, bs) \\<Rightarrow>\n     distinct ws \\<and>\n     (\\<forall>(R, S)\\<in>set ws.\n         R \\<subseteq> PDERIVS R0 \\<and>\n         S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\\<rbrakk>\n  \\<Longrightarrow> case step as ?s3 of\n                    (ws, bs) \\<Rightarrow>\n                      distinct ws \\<and>\n                      (\\<forall>(R, S)\\<in>set ws.\n                          R \\<subseteq> PDERIVS R0 \\<and>\n                          S \\<subseteq> PDERIVS S0 \\<and>\n                          (R, S) \\<notin> set bs)\n  \\<lbrakk>test ?s3;\n   case ?s3 of\n   (ws, bs) \\<Rightarrow>\n     distinct ws \\<and>\n     (\\<forall>(R, S)\\<in>set ws.\n         R \\<subseteq> PDERIVS R0 \\<and>\n         S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\\<rbrakk>\n  \\<Longrightarrow> (case step as ?s3 of\n                     (ws, bs) \\<Rightarrow>\n                       card\n                        (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) -\n                         set bs))\n                    < (case ?s3 of\n                       (ws, bs) \\<Rightarrow>\n                         card\n                          (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) -\n                           set bs))\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "note step = this"], ["proof (state)\nthis:\n  \\<lbrakk>test ?s3;\n   case ?s3 of\n   (ws, bs) \\<Rightarrow>\n     distinct ws \\<and>\n     (\\<forall>(R, S)\\<in>set ws.\n         R \\<subseteq> PDERIVS R0 \\<and>\n         S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\\<rbrakk>\n  \\<Longrightarrow> case step as ?s3 of\n                    (ws, bs) \\<Rightarrow>\n                      distinct ws \\<and>\n                      (\\<forall>(R, S)\\<in>set ws.\n                          R \\<subseteq> PDERIVS R0 \\<and>\n                          S \\<subseteq> PDERIVS S0 \\<and>\n                          (R, S) \\<notin> set bs)\n  \\<lbrakk>test ?s3;\n   case ?s3 of\n   (ws, bs) \\<Rightarrow>\n     distinct ws \\<and>\n     (\\<forall>(R, S)\\<in>set ws.\n         R \\<subseteq> PDERIVS R0 \\<and>\n         S \\<subseteq> PDERIVS S0 \\<and> (R, S) \\<notin> set bs)\\<rbrakk>\n  \\<Longrightarrow> (case step as ?s3 of\n                     (ws, bs) \\<Rightarrow>\n                       card\n                        (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) -\n                         set bs))\n                    < (case ?s3 of\n                       (ws, bs) \\<Rightarrow>\n                         card\n                          (Pow (PDERIVS R0) \\<times> Pow (PDERIVS S0) -\n                           set bs))\n\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "show \"\\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p", "by(rule measure_while_option_Some [where P = ?Inv and f = ?m2, OF _ Inv0])(simp add: step)"], ["proof (state)\nthis:\n  \\<exists>p. while_option test (step as) ([(R0, S0)], []) = Some p\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem closure_Some_Inv: assumes \"closure as ([({r},{s})],[]) = Some p\"\nshows \"\\<forall>(R,S)\\<in>set(fst p). \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\" (is \"?Inv p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "from assms"], ["proof (chain)\npicking this:\n  pEquivalence_Checking.closure as ([({r}, {s})], []) = Some p", "have 1: \"while_option test (step as) ([({r},{s})],[]) = Some p\""], ["proof (prove)\nusing this:\n  pEquivalence_Checking.closure as ([({r}, {s})], []) = Some p\n\ngoal (1 subgoal):\n 1. while_option test (step as) ([({r}, {s})], []) = Some p", "by(simp add: closure_def)"], ["proof (state)\nthis:\n  while_option test (step as) ([({r}, {s})], []) = Some p\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "have Inv0: \"?Inv ([({r},{s})],[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (fst ([({r}, {s})], [])).\n       case a of\n       (R, S) \\<Rightarrow>\n         \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "by simp (metis pderivs.simps(1))"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (fst ([({r}, {s})], [])).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "{"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (fst ([({r}, {s})], [])).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "assume \"?Inv p\" \"test p\""], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (fst p).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n  test p\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "obtain ws bs where [simp]: \"p = (ws,bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ws bs. p = (ws, bs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  p = (ws, bs)\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "from \\<open>test p\\<close>"], ["proof (chain)\npicking this:\n  test p", "obtain R S ws' where [simp]: \"ws = (R,S)#ws'\""], ["proof (prove)\nusing this:\n  test p\n\ngoal (1 subgoal):\n 1. (\\<And>R S ws'.\n        ws = (R, S) # ws' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto split: prod.splits list.splits)"], ["proof (state)\nthis:\n  ws = (R, S) # ws'\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "let ?succs = \"map (\\<lambda>a. (Pderiv a R, Pderiv a S)) as\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "let ?new = \"filter (\\<lambda>p. p \\<notin> set bs \\<union> set ws) ?succs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "let ?ws' = \"remdups ?new @ ws'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "from \\<open>?Inv p\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (fst p).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "obtain w where [simp]: \"R = pderivs w r\" \"S = pderivs w s\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (fst p).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>R = pderivs w r; S = pderivs w s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  R = pderivs w r\n  S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "{"], ["proof (state)\nthis:\n  R = pderivs w r\n  S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "assume \"x : set as\""], ["proof (state)\nthis:\n  x \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "have \"EX w. Pderiv x R = pderivs w r \\<and> Pderiv x S = pderivs w s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. Pderiv x R = pderivs w r \\<and> Pderiv x S = pderivs w s", "by(rule_tac x=\"w@[x]\" in exI)(simp add: pderivs_append Pderiv_def)"], ["proof (state)\nthis:\n  \\<exists>w. Pderiv x R = pderivs w r \\<and> Pderiv x S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> set as \\<Longrightarrow>\n  \\<exists>w. Pderiv ?x2 R = pderivs w r \\<and> Pderiv ?x2 S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "with \\<open>?Inv p\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (fst p).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n  ?x2 \\<in> set as \\<Longrightarrow>\n  \\<exists>w. Pderiv ?x2 R = pderivs w r \\<and> Pderiv ?x2 S = pderivs w s", "have \"?Inv (step as p)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (fst p).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n  ?x2 \\<in> set as \\<Longrightarrow>\n  \\<exists>w. Pderiv ?x2 R = pderivs w r \\<and> Pderiv ?x2 S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (fst (step as p)).\n       case a of\n       (R, S) \\<Rightarrow>\n         \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (fst (step as p)).\n     case a of\n     (R, S) \\<Rightarrow> \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>set (fst ?pa2).\n              case a of\n              (R, S) \\<Rightarrow>\n                \\<exists>w. R = pderivs w r \\<and> S = pderivs w s;\n   test ?pa2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (fst (step as ?pa2)).\n                       case a of\n                       (R, S) \\<Rightarrow>\n                         \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "note Inv_step = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>set (fst ?pa2).\n              case a of\n              (R, S) \\<Rightarrow>\n                \\<exists>w. R = pderivs w r \\<and> S = pderivs w s;\n   test ?pa2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (fst (step as ?pa2)).\n                       case a of\n                       (R, S) \\<Rightarrow>\n                         \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(R, S)\\<in>set (fst p).\n       \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "apply(rule while_option_rule[OF _ 1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa.\n       \\<lbrakk>\\<forall>a\\<in>set (fst sa).\n                   case a of\n                   (R, S) \\<Rightarrow>\n                     \\<exists>w. R = pderivs w r \\<and> S = pderivs w s;\n        test sa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a\\<in>set (fst (step as sa)).\n                            case a of\n                            (R, S) \\<Rightarrow>\n                              \\<exists>w.\n                                 R = pderivs w r \\<and> S = pderivs w s\n 2. \\<forall>a\\<in>set (fst ([({r}, {s})], [])).\n       case a of\n       (R, S) \\<Rightarrow>\n         \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "apply(erule (1) Inv_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (fst ([({r}, {s})], [])).\n       case a of\n       (R, S) \\<Rightarrow>\n         \\<exists>w. R = pderivs w r \\<and> S = pderivs w s", "apply(rule Inv0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>(R, S)\\<in>set (fst p).\n     \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_complete: assumes \"lang r = lang s\"\n shows \"EX bs. closure as ([({r},{s})],[]) = Some([],bs)\" (is ?C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>bs.\n       pEquivalence_Checking.closure as ([({r}, {s})], []) = Some ([], bs)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>bs.\n       pEquivalence_Checking.closure as ([({r}, {s})], []) =\n       Some ([], bs) \\<Longrightarrow>\n    False", "assume \"\\<not> ?C\""], ["proof (state)\nthis:\n  \\<nexists>bs.\n     pEquivalence_Checking.closure as ([({r}, {s})], []) = Some ([], bs)\n\ngoal (1 subgoal):\n 1. \\<nexists>bs.\n       pEquivalence_Checking.closure as ([({r}, {s})], []) =\n       Some ([], bs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>bs.\n     pEquivalence_Checking.closure as ([({r}, {s})], []) = Some ([], bs)", "obtain R S ws bs\n    where cl: \"closure as ([({r},{s})],[]) = Some((R,S)#ws,bs)\""], ["proof (prove)\nusing this:\n  \\<nexists>bs.\n     pEquivalence_Checking.closure as ([({r}, {s})], []) = Some ([], bs)\n\ngoal (1 subgoal):\n 1. (\\<And>R S ws bs.\n        pEquivalence_Checking.closure as ([({r}, {s})], []) =\n        Some ((R, S) # ws, bs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using closure_Some[of \"{r}\" \"{s}\", simplified]"], ["proof (prove)\nusing this:\n  \\<nexists>bs.\n     pEquivalence_Checking.closure as ([({r}, {s})], []) = Some ([], bs)\n  \\<exists>a b.\n     pEquivalence_Checking.closure ?as ([({r}, {s})], []) = Some (a, b)\n\ngoal (1 subgoal):\n 1. (\\<And>R S ws bs.\n        pEquivalence_Checking.closure as ([({r}, {s})], []) =\n        Some ((R, S) # ws, bs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (hide_lams, no_types) list.exhaust prod.exhaust)"], ["proof (state)\nthis:\n  pEquivalence_Checking.closure as ([({r}, {s})], []) =\n  Some ((R, S) # ws, bs)\n\ngoal (1 subgoal):\n 1. \\<nexists>bs.\n       pEquivalence_Checking.closure as ([({r}, {s})], []) =\n       Some ([], bs) \\<Longrightarrow>\n    False", "from assms closure_Some_Inv[OF this]\n    while_option_stop[OF cl[unfolded closure_def]]"], ["proof (chain)\npicking this:\n  lang r = lang s\n  \\<forall>(R, S)\\<in>set (fst ((R, S) # ws, bs)).\n     \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n  \\<not> test ((R, S) # ws, bs)", "show \"False\""], ["proof (prove)\nusing this:\n  lang r = lang s\n  \\<forall>(R, S)\\<in>set (fst ((R, S) # ws, bs)).\n     \\<exists>w. R = pderivs w r \\<and> S = pderivs w s\n  \\<not> test ((R, S) # ws, bs)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary completeness: \"lang r = lang s \\<Longrightarrow> check_eqv r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lang r = lang s \\<Longrightarrow> pEquivalence_Checking.check_eqv r s", "by(auto simp add: check_eqv_def dest!: closure_complete\n      split: option.split list.split)"], ["", "end"]]}