{"file_name": "/home/qj213/afp-2021-10-22/thys/Regular-Sets/Regexp_Method.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Regular-Sets", "problem_names": ["lemma rel_of_regexp_rel: \"rel_of_regexp vs r = rel (\\<lambda>i. vs ! i) r\"", "lemma rel_eqI: \"check_eqv r s \\<Longrightarrow> rel_eq (r, s) vs\"", "lemmas regexp_reify = rel_of_regexp.simps rel_eq.simps", "lemmas regexp_unfold = trancl_unfold_left subset_Un_eq", "lemma \"(r \\<union> s^+)^* = (r \\<union> s)^*\""], "translations": [["", "lemma rel_of_regexp_rel: \"rel_of_regexp vs r = rel (\\<lambda>i. vs ! i) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_of_regexp vs r = rel ((!) vs) r", "by (induct r) auto"], ["", "primrec rel_eq where\n\"rel_eq (r, s) vs = (rel_of_regexp vs r = rel_of_regexp vs s)\""], ["", "lemma rel_eqI: \"check_eqv r s \\<Longrightarrow> rel_eq (r, s) vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv r s \\<Longrightarrow> rel_eq (r, s) vs", "unfolding rel_eq.simps rel_of_regexp_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. check_eqv r s \\<Longrightarrow> rel ((!) vs) r = rel ((!) vs) s", "by (rule Relation_Interpretation.soundness)\n (rule Equivalence_Checking.soundness)"], ["", "lemmas regexp_reify = rel_of_regexp.simps rel_eq.simps"], ["", "lemmas regexp_unfold = trancl_unfold_left subset_Un_eq"], ["", "ML \\<open>\nlocal\n\nfun check_eqv (ct, b) = Thm.mk_binop @{cterm \"Pure.eq :: bool \\<Rightarrow> bool \\<Rightarrow> prop\"}\n  ct (if b then @{cterm True} else @{cterm False});\n\nval (_, check_eqv_oracle) = Context.>>> (Context.map_theory_result\n  (Thm.add_oracle (@{binding check_eqv}, check_eqv)));\n\nin\n\nval regexp_conv =\n  @{computation_conv bool terms: check_eqv datatypes: \"nat rexp\"}\n  (fn _ => fn b => fn ct => check_eqv_oracle (ct, b))\n\nend\n\\<close>"], ["", "method_setup regexp = \\<open>\n  Scan.succeed (fn ctxt =>\n    SIMPLE_METHOD' (\n      (TRY o eresolve_tac ctxt @{thms rev_subsetD})\n      THEN' (Subgoal.FOCUS_PARAMS (fn {context = ctxt', ...} =>\n        TRY (Local_Defs.unfold_tac ctxt' @{thms regexp_unfold})\n        THEN Reification.tac ctxt' @{thms regexp_reify} NONE 1\n        THEN resolve_tac ctxt' @{thms rel_eqI} 1\n        THEN CONVERSION (HOLogic.Trueprop_conv (regexp_conv ctxt')) 1\n        THEN resolve_tac ctxt' [TrueI] 1) ctxt)))\n\\<close> \\<open>decide relation equalities via regular expressions\\<close>"], ["", "hide_const (open) le_rexp nPlus nTimes norm nullable bisimilar is_bisimulation closure\n  pre_bisim add_atoms check_eqv rel word_rel rel_eq"], ["", "text \\<open>Example:\\<close>"], ["", "lemma \"(r \\<union> s^+)^* = (r \\<union> s)^*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<union> s\\<^sup>+)\\<^sup>* = (r \\<union> s)\\<^sup>*", "by regexp"], ["", "end"]]}