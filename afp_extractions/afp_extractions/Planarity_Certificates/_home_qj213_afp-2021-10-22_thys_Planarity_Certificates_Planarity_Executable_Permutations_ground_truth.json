{"file_name": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates/Planarity/Executable_Permutations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates", "problem_names": ["lemma list_succ_altdef:\n  \"list_succ xs x = (let n = index xs x in if n + 1 = length xs then xs ! 0 else if n + 1 < length xs then xs ! (n + 1) else x)\"", "lemma list_succ_Nil:\n  \"list_succ [] = id\"", "lemma list_succ_singleton:\n  \"list_succ [x] = list_succ []\"", "lemma list_succ_short:\n  assumes \"length xs < 2\" shows \"list_succ xs = id\"", "lemma list_succ_simps:\n  \"index xs x + 1 = length xs \\<Longrightarrow> list_succ xs x = xs ! 0\"\n  \"index xs x + 1 < length xs \\<Longrightarrow> list_succ xs x = xs ! (index xs x + 1)\"\n  \"length xs \\<le> index xs x \\<Longrightarrow> list_succ xs x = x\"", "lemma list_succ_not_in:\n  assumes \"x \\<notin> set xs\" shows \"list_succ xs x = x\"", "lemma list_succ_list_succ_rev:\n  assumes \"distinct xs\" shows \"list_succ (rev xs) (list_succ xs x) = x\"", "lemma inj_list_succ: \"distinct xs \\<Longrightarrow> inj (list_succ xs)\"", "lemma inv_list_succ_eq: \"distinct xs \\<Longrightarrow> inv (list_succ xs) = list_succ (rev xs)\"", "lemma bij_list_succ: \"distinct xs \\<Longrightarrow> bij (list_succ xs)\"", "lemma list_succ_permutes:\n  assumes \"distinct xs\" shows \"list_succ xs permutes set xs\"", "lemma permutation_list_succ:\n  assumes \"distinct xs\" shows \"permutation (list_succ xs)\"", "lemma list_succ_nth:\n  assumes \"distinct xs\" \"n < length xs\" shows \"list_succ xs (xs ! n) = xs ! (Suc n mod length xs)\"", "lemma list_succ_last[simp]:\n  assumes \"distinct xs\" \"xs \\<noteq> []\" shows \"list_succ xs (last xs) = hd xs\"", "lemma list_succ_rotate1[simp]:\n  assumes \"distinct xs\" shows \"list_succ (rotate1 xs) = list_succ xs\"", "lemma list_succ_rotate[simp]:\n  assumes \"distinct xs\" shows \"list_succ (rotate n xs) = list_succ xs\"", "lemma list_succ_in_conv:\n  \"list_succ xs x \\<in> set xs \\<longleftrightarrow> x \\<in> set xs\"", "lemma list_succ_in_conv1:\n  assumes \"A \\<inter> set xs = {}\"\n  shows \"list_succ xs x \\<in> A \\<longleftrightarrow> x \\<in> A\"", "lemma list_succ_commute:\n  assumes \"set xs \\<inter> set ys = {}\"\n  shows \"list_succ xs (list_succ ys x) = list_succ ys (list_succ xs x)\"", "lemma distincts_distinct: \"distincts xss \\<Longrightarrow> distinct xss\"", "lemma distincts_Nil[simp]: \"distincts []\"", "lemma distincts_single: \"distincts [xs] \\<longleftrightarrow> distinct xs \\<and> xs \\<noteq> []\"", "lemma distincts_Cons: \"distincts (xs # xss)\n   \\<longleftrightarrow> xs \\<noteq> [] \\<and> distinct xs \\<and> distincts xss \\<and> (set xs \\<inter> (\\<Union>ys \\<in> set xss. set ys)) = {}\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma distincts_Cons': \"distincts (xs # xss)\n   \\<longleftrightarrow> xs \\<noteq> [] \\<and> distinct xs \\<and> distincts xss \\<and> (\\<forall>ys \\<in> set xss. set xs \\<inter> set ys = {})\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma distincts_rev:\n  \"distincts (map rev xss) \\<longleftrightarrow> distincts xss\"", "lemma length_distincts:\n  assumes \"distincts xss\"\n  shows \"length xss = card (set ` set xss)\"", "lemma distincts_remove1: \"distincts xss \\<Longrightarrow> distincts (remove1 xs xss)\"", "lemma distinct_Cons_remove1:\n  \"x \\<in> set xs \\<Longrightarrow> distinct (x # remove1 x xs) = distinct xs\"", "lemma set_Cons_remove1:\n  \"x \\<in> set xs \\<Longrightarrow> set (x # remove1 x xs) = set xs\"", "lemma distincts_Cons_remove1:\n  \"xs \\<in> set xss \\<Longrightarrow> distincts (xs # remove1 xs xss) = distincts xss\"", "lemma distincts_inj_on_set:\n  assumes \"distincts xss\" shows \"inj_on set (set xss)\"", "lemma distincts_distinct_set:\n  assumes \"distincts xss\" shows \"distinct (map set xss)\"", "lemma distincts_distinct_nth:\n  assumes \"distincts xss\" \"n < length xss\" shows \"distinct (xss ! n)\"", "lemma lists_succ_not_in:\n  assumes \"x \\<notin> (\\<Union>xs\\<in>set xss. set xs)\" shows \"lists_succ xss x = x\"", "lemma lists_succ_in_conv:\n  \"lists_succ xss x \\<in> (\\<Union>xs\\<in>set xss. set xs) \\<longleftrightarrow> x \\<in> (\\<Union>xs\\<in>set xss. set xs)\"", "lemma lists_succ_in_conv1:\n  assumes \"A \\<inter> (\\<Union>xs\\<in>set xss. set xs) = {}\"\n  shows \"lists_succ xss x \\<in> A \\<longleftrightarrow> x \\<in> A\"", "lemma lists_succ_Cons_pf: \"lists_succ (xs # xss) = list_succ xs o lists_succ xss\"", "lemma lists_succ_Nil_pf: \"lists_succ [] = id\"", "lemmas lists_succ_simps_pf = lists_succ_Cons_pf lists_succ_Nil_pf", "lemma lists_succ_permutes:\n  assumes \"distincts xss\"\n  shows \"lists_succ xss permutes (\\<Union>xs \\<in> set xss. set xs)\"", "lemma bij_lists_succ: \"distincts xss \\<Longrightarrow> bij (lists_succ xss)\"", "lemma lists_succ_snoc: \"lists_succ (xss @ [xs]) = lists_succ xss o list_succ xs\"", "lemma inv_lists_succ_eq:\n  assumes \"distincts xss\"\n  shows \"inv (lists_succ xss) = lists_succ (rev (map rev xss))\"", "lemma lists_succ_remove1:\n  assumes \"distincts xss\" \"xs \\<in> set xss\"\n  shows \"lists_succ (xs # remove1 xs xss) = lists_succ xss\"", "lemma lists_succ_no_order:\n  assumes \"distincts xss\" \"distincts yss\" \"set xss = set yss\"\n  shows \"lists_succ xss = lists_succ yss\"", "lemma iterate_funpow_step:\n  assumes \"f x \\<noteq> y\" \"y \\<in> orbit f x\"\n  shows \"iterate 0 (funpow_dist1 f x y) f x = x # iterate 0 (funpow_dist1 f (f x) y) f (f x)\"", "lemma orbit_list_impl_conv:\n  assumes \"y \\<in> orbit f x\"\n  shows \"orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\"", "lemma orbit_list_conv_impl:\n  assumes \"x \\<in> orbit f x\"\n  shows \"orbit_list f x = orbit_list_impl f x [] x\"", "lemma set_orbit_list:\n  assumes \"x \\<in> orbit f x\"\n  shows \"set (orbit_list f x) = orbit f x\"", "lemma set_orbit_list':\n  assumes \"permutation f\" shows \"set (orbit_list f x) = orbit f x\"", "lemma distinct_orbit_list:\n  assumes \"x \\<in> orbit f x\"\n  shows \"distinct (orbit_list f x)\"", "lemma distinct_orbit_list':\n  assumes \"permutation f\" shows \"distinct (orbit_list f x)\"", "lemma orbits_list_conv_impl:\n  assumes \"permutation f\"\n  shows \"orbits_list f xs = orbits_list_impl f xs\"", "lemma orbit_list_not_nil[simp]: \"orbit_list f x \\<noteq> []\"", "lemma sset_orbits_list:\n  assumes \"permutation f\" shows \"sset (orbits_list f xs) = (orbit f) ` set xs\"", "lemma list_succ_orbit_list:\n  assumes \"s \\<in> orbit f s\" \"\\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x\"\n  shows \"list_succ (orbit_list f s) = f\"", "lemma list_succ_funpow_conv:\n  assumes A: \"distinct xs\" \"x \\<in> set xs\"\n  shows \"(list_succ xs ^^ n) x = xs ! ((index xs x + n) mod length xs)\"", "lemma orbit_list_succ:\n  assumes \"distinct xs\" \"x \\<in> set xs\"\n  shows \"orbit (list_succ xs) x = set xs\"", "lemma cyclic_on_list_succ:\n  assumes \"distinct xs\" \"xs \\<noteq> []\" shows \"cyclic_on (list_succ xs) (set xs)\"", "lemma obtain_orbit_list_func:\n  assumes \"s \\<in> orbit f s\" \"\\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x\"\n  obtains xs where \"f = list_succ xs\" \"set xs = orbit f s\" \"distinct xs\" \"hd xs = s\"", "lemma cyclic_on_obtain_list_succ:\n  assumes \"cyclic_on f S\" \"\\<And>x. x \\<notin> S \\<Longrightarrow> f x = x\"\n  obtains xs where \"f = list_succ xs\" \"set xs = S\" \"distinct xs\"", "lemma cyclic_on_obtain_list_succ':\n  assumes \"cyclic_on f S\" \"f permutes S\"\n  obtains xs where \"f = list_succ xs\" \"set xs = S\" \"distinct xs\"", "lemma list_succ_unique:\n  assumes \"s \\<in> orbit f s\" \"\\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x\"\n  shows \"\\<exists>!xs. f = list_succ xs \\<and> distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s\"", "lemma distincts_orbits_list:\n  assumes \"distinct as\" \"permutation f\"\n  shows \"distincts (orbits_list f as)\"", "lemma cyclic_on_lists_succ':\n  assumes \"distincts xss\"\n  shows \"A \\<in> sset xss \\<Longrightarrow> cyclic_on (lists_succ xss) A\"", "lemma cyclic_on_lists_succ:\n  assumes \"distincts xss\"\n  shows \"\\<And>xs. xs \\<in> set xss \\<Longrightarrow> cyclic_on (lists_succ xss) (set xs)\"", "lemma permutes_as_lists_succ:\n  assumes \"distincts xss\"\n  assumes ls_eq: \"\\<And>xs. xs \\<in> set xss \\<Longrightarrow> list_succ xs = perm_restrict f (set xs)\"\n  assumes \"f permutes (\\<Union>(sset xss))\"\n  shows \"f = lists_succ xss\"", "lemma cyclic_on_obtain_lists_succ:\n  assumes\n    permutes: \"f permutes S\" and\n    S: \"S = \\<Union>(sset css)\" and\n    dists: \"distincts css\" and\n    cyclic: \"\\<And>cs. cs \\<in> set css \\<Longrightarrow> cyclic_on f (set cs)\"\n  obtains xss where \"f = lists_succ xss\" \"distincts xss\" \"map set xss = map set css\" \"map hd xss = map hd css\"", "lemma length_remove1_less:\n  assumes \"x \\<in> set xs\" shows \"length (remove1 x xs) < length xs\"", "lemma nil_in_permutations[simp]: \"[] \\<in> set (permutations xs) \\<longleftrightarrow> xs = []\"", "lemma permutations_not_nil:\n  assumes \"xs \\<noteq> []\"\n  shows \"permutations xs = concat (map (\\<lambda>x. map ((#) x) (permutations (remove1 x xs))) xs)\"", "lemma set_permutations_step:\n  assumes \"xs \\<noteq> []\"\n  shows \"set (permutations xs) = (\\<Union>x \\<in> set xs. Cons x ` set (permutations (remove1 x xs)))\"", "lemma in_set_permutations:\n  assumes \"distinct xs\"\n  shows \"ys \\<in> set (permutations xs) \\<longleftrightarrow> distinct ys \\<and> set xs = set ys\" (is \"?L xs ys \\<longleftrightarrow> ?R xs ys\")", "lemma in_set_cyc_permutations:\n  assumes \"distinct xs\"\n  shows \"ys \\<in> set (cyc_permutations xs) \\<longleftrightarrow> distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs\" (is \"?L xs ys \\<longleftrightarrow> ?R xs ys\")", "lemma in_set_cyc_permutations_obtain:\n  assumes \"distinct xs\" \"distinct ys\" \"set xs = set ys\"\n  obtains n where \"rotate n ys \\<in> set (cyc_permutations xs)\"", "lemma list_succ_set_cyc_permutations:\n  assumes \"distinct xs\" \"xs \\<noteq> []\"\n  shows \"list_succ ` set (cyc_permutations xs) = {f. f permutes set xs \\<and> cyclic_on f (set xs)}\" (is \"?L = ?R\")", "lemma cyc_permutationss_Nil[simp]: \"cyc_permutationss [] = [[]]\"", "lemma in_set_cyc_permutationss:\n  assumes \"distincts xss\"\n  shows \"yss \\<in> set (cyc_permutationss xss) \\<longleftrightarrow> distincts yss \\<and> map set xss = map set yss \\<and> map hd xss = map hd yss\"", "lemma lists_succ_set_cyc_permutationss:\n  assumes \"distincts xss\"\n  shows \"lists_succ ` set (cyc_permutationss xss) = {f. f permutes \\<Union>(sset xss) \\<and> (\\<forall>c \\<in> sset xss. cyclic_on f c)}\" (is \"?L = ?R\")", "lemma permutationss_Nil[simp]: \"permutationss [] = [[]]\"", "lemma permutationss_Cons:\n  \"permutationss (xs # xss) = concat (map (\\<lambda>ys. map (Cons ys) (permutationss xss)) (permutations xs))\"", "lemma in_set_permutationss:\n  assumes \"distincts xss\"\n  shows \"yss \\<in> set (permutationss xss) \\<longleftrightarrow> distincts yss \\<and> map set xss = map set yss\"", "lemma set_permutationss:\n  assumes \"distincts xss\"\n  shows \"set (permutationss xss) = {yss. distincts yss \\<and> map set xss = map set yss}\"", "lemma permutationss_complete:\n  assumes \"distincts xss\" \"distincts yss\" \"xss \\<noteq> []\"\n    and \"set ` set xss = set ` set yss\"\n  shows \"set yss \\<in> set ` set (permutationss xss)\"", "lemma permutations_complete: (* could generalize with multi-sets *)\n  assumes \"distinct xs\" \"distinct ys\" \"set xs = set ys\"\n  shows \"ys \\<in> set (permutations xs)\""], "translations": [["", "lemma list_succ_altdef:\n  \"list_succ xs x = (let n = index xs x in if n + 1 = length xs then xs ! 0 else if n + 1 < length xs then xs ! (n + 1) else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs x =\n    (let n = index xs x\n     in if n + 1 = length xs then xs ! 0\n        else if n + 1 < length xs then xs ! (n + 1) else x)", "using index_le_size[of xs x]"], ["proof (prove)\nusing this:\n  index xs x \\<le> length xs\n\ngoal (1 subgoal):\n 1. list_succ xs x =\n    (let n = index xs x\n     in if n + 1 = length xs then xs ! 0\n        else if n + 1 < length xs then xs ! (n + 1) else x)", "unfolding list_succ_def index_less_size_conv[symmetric]"], ["proof (prove)\nusing this:\n  index xs x \\<le> length xs\n\ngoal (1 subgoal):\n 1. (if index xs x < length xs then xs ! ((index xs x + 1) mod length xs)\n     else x) =\n    (let n = index xs x\n     in if n + 1 = length xs then xs ! 0\n        else if n + 1 < length xs then xs ! (n + 1) else x)", "by (auto simp: Let_def)"], ["", "lemma list_succ_Nil:\n  \"list_succ [] = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ [] = id", "by (simp add: list_succ_def fun_eq_iff)"], ["", "lemma list_succ_singleton:\n  \"list_succ [x] = list_succ []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ [x] = list_succ []", "by (simp add: fun_eq_iff list_succ_def)"], ["", "lemma list_succ_short:\n  assumes \"length xs < 2\" shows \"list_succ xs = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs = id", "using assms"], ["proof (prove)\nusing this:\n  length xs < 2\n\ngoal (1 subgoal):\n 1. list_succ xs = id", "by (cases xs) (rename_tac [2] y ys, case_tac [2] ys, auto simp: list_succ_Nil list_succ_singleton)"], ["", "lemma list_succ_simps:\n  \"index xs x + 1 = length xs \\<Longrightarrow> list_succ xs x = xs ! 0\"\n  \"index xs x + 1 < length xs \\<Longrightarrow> list_succ xs x = xs ! (index xs x + 1)\"\n  \"length xs \\<le> index xs x \\<Longrightarrow> list_succ xs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index xs x + 1 = length xs \\<Longrightarrow>\n     list_succ xs x = xs ! 0) &&&\n    (index xs x + 1 < length xs \\<Longrightarrow>\n     list_succ xs x = xs ! (index xs x + 1)) &&&\n    (length xs \\<le> index xs x \\<Longrightarrow> list_succ xs x = x)", "by (auto simp: list_succ_altdef)"], ["", "lemma list_succ_not_in:\n  assumes \"x \\<notin> set xs\" shows \"list_succ xs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs x = x", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. list_succ xs x = x", "by (auto simp: list_succ_def)"], ["", "lemma list_succ_list_succ_rev:\n  assumes \"distinct xs\" shows \"list_succ (rev xs) (list_succ xs x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "assume \"index xs x + 1 < length xs\""], ["proof (state)\nthis:\n  index xs x + 1 < length xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "moreover"], ["proof (state)\nthis:\n  index xs x + 1 < length xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "then"], ["proof (chain)\npicking this:\n  index xs x + 1 < length xs", "have \"length xs - Suc (Suc (length xs - Suc (Suc (index xs x)))) = index xs x\""], ["proof (prove)\nusing this:\n  index xs x + 1 < length xs\n\ngoal (1 subgoal):\n 1. length xs - Suc (Suc (length xs - Suc (Suc (index xs x)))) = index xs x", "by linarith"], ["proof (state)\nthis:\n  length xs - Suc (Suc (length xs - Suc (Suc (index xs x)))) = index xs x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "ultimately"], ["proof (chain)\npicking this:\n  index xs x + 1 < length xs\n  length xs - Suc (Suc (length xs - Suc (Suc (index xs x)))) = index xs x", "have ?thesis"], ["proof (prove)\nusing this:\n  index xs x + 1 < length xs\n  length xs - Suc (Suc (length xs - Suc (Suc (index xs x)))) = index xs x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "using assms"], ["proof (prove)\nusing this:\n  index xs x + 1 < length xs\n  length xs - Suc (Suc (length xs - Suc (Suc (index xs x)))) = index xs x\n  distinct xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "by (simp add: list_succ_def index_rev index_nth_id rev_nth)"], ["proof (state)\nthis:\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "}"], ["proof (state)\nthis:\n  index xs x + 1 < length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "moreover"], ["proof (state)\nthis:\n  index xs x + 1 < length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "{"], ["proof (state)\nthis:\n  index xs x + 1 < length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "assume A: \"index xs x + 1 = length xs\""], ["proof (state)\nthis:\n  index xs x + 1 = length xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "moreover"], ["proof (state)\nthis:\n  index xs x + 1 = length xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "from A"], ["proof (chain)\npicking this:\n  index xs x + 1 = length xs", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  index xs x + 1 = length xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "moreover"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "with A"], ["proof (chain)\npicking this:\n  index xs x + 1 = length xs\n  xs \\<noteq> []", "have \"last xs = xs ! index xs x\""], ["proof (prove)\nusing this:\n  index xs x + 1 = length xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. last xs = xs ! index xs x", "by (cases \"length xs\") (auto simp: last_conv_nth)"], ["proof (state)\nthis:\n  last xs = xs ! index xs x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "ultimately"], ["proof (chain)\npicking this:\n  index xs x + 1 = length xs\n  xs \\<noteq> []\n  last xs = xs ! index xs x", "have ?thesis"], ["proof (prove)\nusing this:\n  index xs x + 1 = length xs\n  xs \\<noteq> []\n  last xs = xs ! index xs x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "using assms"], ["proof (prove)\nusing this:\n  index xs x + 1 = length xs\n  xs \\<noteq> []\n  last xs = xs ! index xs x\n  distinct xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "by (auto simp add: list_succ_def rev_nth index_rev index_nth_id last_conv_nth)"], ["proof (state)\nthis:\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "}"], ["proof (state)\nthis:\n  index xs x + 1 = length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "moreover"], ["proof (state)\nthis:\n  index xs x + 1 = length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "{"], ["proof (state)\nthis:\n  index xs x + 1 = length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "assume A: \"index xs x \\<ge> length xs\""], ["proof (state)\nthis:\n  length xs \\<le> index xs x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "then"], ["proof (chain)\npicking this:\n  length xs \\<le> index xs x", "have \"x \\<notin> set xs\""], ["proof (prove)\nusing this:\n  length xs \\<le> index xs x\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "by (metis index_less less_irrefl)"], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> set xs", "have ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "by (auto simp: list_succ_def)"], ["proof (state)\nthis:\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "}"], ["proof (state)\nthis:\n  length xs \\<le> index xs x \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "ultimately"], ["proof (chain)\npicking this:\n  index xs x + 1 < length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n  index xs x + 1 = length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n  length xs \\<le> index xs x \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  index xs x + 1 < length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n  index xs x + 1 = length xs \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n  length xs \\<le> index xs x \\<Longrightarrow>\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal (1 subgoal):\n 1. list_succ (rev xs) (list_succ xs x) = x", "by (metis discrete le_less not_less)"], ["proof (state)\nthis:\n  list_succ (rev xs) (list_succ xs x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_list_succ: \"distinct xs \\<Longrightarrow> inj (list_succ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> inj (list_succ xs)", "by (metis injI list_succ_list_succ_rev)"], ["", "lemma inv_list_succ_eq: \"distinct xs \\<Longrightarrow> inv (list_succ xs) = list_succ (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> inv (list_succ xs) = list_succ (rev xs)", "by (metis distinct_rev inj_imp_inv_eq inj_list_succ list_succ_list_succ_rev)"], ["", "lemma bij_list_succ: \"distinct xs \\<Longrightarrow> bij (list_succ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> bij (list_succ xs)", "by (metis bij_def inj_list_succ distinct_rev list_succ_list_succ_rev surj_def)"], ["", "lemma list_succ_permutes:\n  assumes \"distinct xs\" shows \"list_succ xs permutes set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs permutes set xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. list_succ xs permutes set xs", "by (auto simp: permutes_conv_has_dom bij_list_succ has_dom_def list_succ_def)"], ["", "lemma permutation_list_succ:\n  assumes \"distinct xs\" shows \"permutation (list_succ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation (list_succ xs)", "using list_succ_permutes[OF assms]"], ["proof (prove)\nusing this:\n  list_succ xs permutes set xs\n\ngoal (1 subgoal):\n 1. permutation (list_succ xs)", "by (auto simp: permutation_permutes)"], ["", "lemma list_succ_nth:\n  assumes \"distinct xs\" \"n < length xs\" shows \"list_succ xs (xs ! n) = xs ! (Suc n mod length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs (xs ! n) = xs ! (Suc n mod length xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  n < length xs\n\ngoal (1 subgoal):\n 1. list_succ xs (xs ! n) = xs ! (Suc n mod length xs)", "by (auto simp: list_succ_def index_nth_id)"], ["", "lemma list_succ_last[simp]:\n  assumes \"distinct xs\" \"xs \\<noteq> []\" shows \"list_succ xs (last xs) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs (last xs) = hd xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_succ xs (last xs) = hd xs", "by (auto simp: list_succ_def hd_conv_nth)"], ["", "lemma list_succ_rotate1[simp]:\n  assumes \"distinct xs\" shows \"list_succ (rotate1 xs) = list_succ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ (rotate1 xs) = list_succ xs", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. list_succ (rotate1 xs) x = list_succ xs x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. list_succ (rotate1 xs) x = list_succ xs x", "show \"list_succ (rotate1 xs) y = list_succ xs y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ (rotate1 xs) y = list_succ xs y", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. list_succ (rotate1 xs) y = list_succ xs y", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> list_succ (rotate1 []) y = list_succ [] y\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                list_succ (rotate1 xs) y = list_succ xs y;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_succ (rotate1 (a # xs)) y =\n                         list_succ (a # xs) y", "case Nil"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> list_succ (rotate1 []) y = list_succ [] y\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                list_succ (rotate1 xs) y = list_succ xs y;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_succ (rotate1 (a # xs)) y =\n                         list_succ (a # xs) y", "then"], ["proof (chain)\npicking this:\n  distinct []", "show ?case"], ["proof (prove)\nusing this:\n  distinct []\n\ngoal (1 subgoal):\n 1. list_succ (rotate1 []) y = list_succ [] y", "by simp"], ["proof (state)\nthis:\n  list_succ (rotate1 []) y = list_succ [] y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                list_succ (rotate1 xs) y = list_succ xs y;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_succ (rotate1 (a # xs)) y =\n                         list_succ (a # xs) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                list_succ (rotate1 xs) y = list_succ xs y;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_succ (rotate1 (a # xs)) y =\n                         list_succ (a # xs) y", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct xs \\<Longrightarrow> list_succ (rotate1 xs) y = list_succ xs y\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                list_succ (rotate1 xs) y = list_succ xs y;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> list_succ (rotate1 (a # xs)) y =\n                         list_succ (a # xs) y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y\n 2. x \\<noteq> y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y\n 2. x \\<noteq> y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "then"], ["proof (chain)\npicking this:\n  x = y", "have \"index (xs @ [y]) y = length xs\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. index (xs @ [y]) y = length xs", "using \\<open>distinct (x # xs)\\<close>"], ["proof (prove)\nusing this:\n  x = y\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. index (xs @ [y]) y = length xs", "by (simp add: index_append)"], ["proof (state)\nthis:\n  index (xs @ [y]) y = length xs\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y\n 2. x \\<noteq> y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "with True"], ["proof (chain)\npicking this:\n  x = y\n  index (xs @ [y]) y = length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n  index (xs @ [y]) y = length xs\n\ngoal (1 subgoal):\n 1. list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "by (cases \"xs=[]\") (auto simp: list_succ_def nth_append)"], ["proof (state)\nthis:\n  list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "apply (cases \"index xs y + 1 < length xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> y; index xs y + 1 < length xs\\<rbrakk>\n    \\<Longrightarrow> list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y\n 2. \\<lbrakk>x \\<noteq> y; \\<not> index xs y + 1 < length xs\\<rbrakk>\n    \\<Longrightarrow> list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y", "apply (auto simp:list_succ_def index_append nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> y; \\<not> Suc (index xs y) < length xs;\n     y \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> [x] ! (Suc (index xs y) - length xs) =\n                      (x # xs) !\n                      (Suc (Suc (index xs y)) mod Suc (length xs))", "by (metis Suc_lessI index_less_size_conv mod_self nth_Cons_0 nth_append nth_append_length)"], ["proof (state)\nthis:\n  list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_succ (rotate1 (x # xs)) y = list_succ (x # xs) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_succ (rotate1 xs) y = list_succ xs y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_succ_rotate[simp]:\n  assumes \"distinct xs\" shows \"list_succ (rotate n xs) = list_succ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ (rotate n xs) = list_succ xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. list_succ (rotate n xs) = list_succ xs", "by (induct n) auto"], ["", "lemma list_succ_in_conv:\n  \"list_succ xs x \\<in> set xs \\<longleftrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_succ xs x \\<in> set xs) = (x \\<in> set xs)", "by (auto simp: list_succ_def not_nil_if_in_set )"], ["", "lemma list_succ_in_conv1:\n  assumes \"A \\<inter> set xs = {}\"\n  shows \"list_succ xs x \\<in> A \\<longleftrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_succ xs x \\<in> A) = (x \\<in> A)", "by (metis assms disjoint_iff_not_equal list_succ_in_conv list_succ_not_in)"], ["", "lemma list_succ_commute:\n  assumes \"set xs \\<inter> set ys = {}\"\n  shows \"list_succ xs (list_succ ys x) = list_succ ys (list_succ xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs (list_succ ys x) = list_succ ys (list_succ xs x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_succ xs (list_succ ys x) = list_succ ys (list_succ xs x)", "have \"\\<And>x. x \\<in> set xs \\<Longrightarrow> list_succ ys x = x\"\n     \"\\<And>x. x \\<in> set ys \\<Longrightarrow> list_succ xs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> list_succ ys x = x) &&&\n    (\\<And>x. x \\<in> set ys \\<Longrightarrow> list_succ xs x = x)", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> list_succ ys x = x) &&&\n    (\\<And>x. x \\<in> set ys \\<Longrightarrow> list_succ xs x = x)", "by (blast intro: list_succ_not_in)+"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> list_succ ys ?x = ?x\n  ?x \\<in> set ys \\<Longrightarrow> list_succ xs ?x = ?x\n\ngoal (1 subgoal):\n 1. list_succ xs (list_succ ys x) = list_succ ys (list_succ xs x)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> set xs \\<Longrightarrow> list_succ ys ?x = ?x\n  ?x \\<in> set ys \\<Longrightarrow> list_succ xs ?x = ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> list_succ ys ?x = ?x\n  ?x \\<in> set ys \\<Longrightarrow> list_succ xs ?x = ?x\n\ngoal (1 subgoal):\n 1. list_succ xs (list_succ ys x) = list_succ ys (list_succ xs x)", "by (cases \"x \\<in> set xs \\<union> set ys\") (auto simp: list_succ_in_conv list_succ_not_in)"], ["proof (state)\nthis:\n  list_succ xs (list_succ ys x) = list_succ ys (list_succ xs x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Arbitrary Permutations\\<close>"], ["", "fun lists_succ :: \"'a list list \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n  \"lists_succ [] x = x\"\n| \"lists_succ (xs # xss) x = list_succ xs (lists_succ xss x)\""], ["", "definition distincts ::  \"'a list list \\<Rightarrow> bool\" where\n  \"distincts xss \\<equiv> distinct xss \\<and> (\\<forall>xs \\<in> set xss. distinct xs \\<and> xs \\<noteq> []) \\<and> (\\<forall>xs \\<in> set xss. \\<forall>ys \\<in> set xss. xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {})\""], ["", "lemma distincts_distinct: \"distincts xss \\<Longrightarrow> distinct xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts xss \\<Longrightarrow> distinct xss", "by (auto simp: distincts_def)"], ["", "lemma distincts_Nil[simp]: \"distincts []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts []", "by (simp add: distincts_def)"], ["", "lemma distincts_single: \"distincts [xs] \\<longleftrightarrow> distinct xs \\<and> xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts [xs] = (distinct xs \\<and> xs \\<noteq> [])", "by (auto simp add: distincts_def)"], ["", "lemma distincts_Cons: \"distincts (xs # xss)\n   \\<longleftrightarrow> xs \\<noteq> [] \\<and> distinct xs \\<and> distincts xss \\<and> (set xs \\<inter> (\\<Union>ys \\<in> set xss. set ys)) = {}\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (xs # xss) =\n    (xs \\<noteq> [] \\<and>\n     distinct xs \\<and>\n     distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. distincts (xs # xss) \\<Longrightarrow>\n    xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}\n 2. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "assume ?L"], ["proof (state)\nthis:\n  distincts (xs # xss)\n\ngoal (2 subgoals):\n 1. distincts (xs # xss) \\<Longrightarrow>\n    xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}\n 2. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "then"], ["proof (chain)\npicking this:\n  distincts (xs # xss)", "show ?R"], ["proof (prove)\nusing this:\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}", "by (auto simp: distincts_def)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "assume ?R"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}", "have \"distinct (xs # xss)\""], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}\n\ngoal (1 subgoal):\n 1. distinct (xs # xss)", "apply (auto simp: disjoint_iff_not_equal distincts_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; distinct xs; distincts xss;\n     \\<forall>x\\<in>set xs.\n        \\<forall>y\\<in>set xss. \\<forall>y\\<in>set y. x \\<noteq> y;\n     xs \\<in> set xss\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis length_greater_0_conv nth_mem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (xs # xss)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "moreover"], ["proof (state)\nthis:\n  distinct (xs # xss)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "from \\<open>?R\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}", "have \"\\<forall>xs \\<in> set (xs # xss). distinct xs \\<and> xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>set (xs # xss). distinct xs \\<and> xs \\<noteq> []", "by (auto simp: distincts_def)"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>set (xs # xss). distinct xs \\<and> xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "moreover"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>set (xs # xss). distinct xs \\<and> xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "from \\<open>?R\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}", "have \"\\<forall>xs' \\<in> set (xs # xss). \\<forall>ys \\<in> set (xs # xss). xs' \\<noteq> ys \\<longrightarrow> set xs' \\<inter> set ys = {}\""], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and>\n  distinct xs \\<and>\n  distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}\n\ngoal (1 subgoal):\n 1. \\<forall>xs'\\<in>set (xs # xss).\n       \\<forall>ys\\<in>set (xs # xss).\n          xs' \\<noteq> ys \\<longrightarrow> set xs' \\<inter> set ys = {}", "by (simp add: distincts_def) blast"], ["proof (state)\nthis:\n  \\<forall>xs'\\<in>set (xs # xss).\n     \\<forall>ys\\<in>set (xs # xss).\n        xs' \\<noteq> ys \\<longrightarrow> set xs' \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and>\n    distinct xs \\<and>\n    distincts xss \\<and>\n    set xs \\<inter> \\<Union> (set ` set xss) = {} \\<Longrightarrow>\n    distincts (xs # xss)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (xs # xss)\n  \\<forall>xs\\<in>set (xs # xss). distinct xs \\<and> xs \\<noteq> []\n  \\<forall>xs'\\<in>set (xs # xss).\n     \\<forall>ys\\<in>set (xs # xss).\n        xs' \\<noteq> ys \\<longrightarrow> set xs' \\<inter> set ys = {}", "show ?L"], ["proof (prove)\nusing this:\n  distinct (xs # xss)\n  \\<forall>xs\\<in>set (xs # xss). distinct xs \\<and> xs \\<noteq> []\n  \\<forall>xs'\\<in>set (xs # xss).\n     \\<forall>ys\\<in>set (xs # xss).\n        xs' \\<noteq> ys \\<longrightarrow> set xs' \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. distincts (xs # xss)", "unfolding distincts_def"], ["proof (prove)\nusing this:\n  distinct (xs # xss)\n  \\<forall>xs\\<in>set (xs # xss). distinct xs \\<and> xs \\<noteq> []\n  \\<forall>xs'\\<in>set (xs # xss).\n     \\<forall>ys\\<in>set (xs # xss).\n        xs' \\<noteq> ys \\<longrightarrow> set xs' \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. distinct (xs # xss) \\<and>\n    (\\<forall>xs\\<in>set (xs # xss).\n        distinct xs \\<and> xs \\<noteq> []) \\<and>\n    (\\<forall>xsa\\<in>set (xs # xss).\n        \\<forall>ys\\<in>set (xs # xss).\n           xsa \\<noteq> ys \\<longrightarrow> set xsa \\<inter> set ys = {})", "by (intro conjI)"], ["proof (state)\nthis:\n  distincts (xs # xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distincts_Cons': \"distincts (xs # xss)\n   \\<longleftrightarrow> xs \\<noteq> [] \\<and> distinct xs \\<and> distincts xss \\<and> (\\<forall>ys \\<in> set xss. set xs \\<inter> set ys = {})\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (xs # xss) =\n    (xs \\<noteq> [] \\<and>\n     distinct xs \\<and>\n     distincts xss \\<and>\n     (\\<forall>ys\\<in>set xss. set xs \\<inter> set ys = {}))", "unfolding distincts_Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> [] \\<and>\n     distinct xs \\<and>\n     distincts xss \\<and> set xs \\<inter> \\<Union> (set ` set xss) = {}) =\n    (xs \\<noteq> [] \\<and>\n     distinct xs \\<and>\n     distincts xss \\<and>\n     (\\<forall>ys\\<in>set xss. set xs \\<inter> set ys = {}))", "by blast"], ["", "lemma distincts_rev:\n  \"distincts (map rev xss) \\<longleftrightarrow> distincts xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (map rev xss) = distincts xss", "by (simp add: distincts_def distinct_map)"], ["", "lemma length_distincts:\n  assumes \"distincts xss\"\n  shows \"length xss = card (set ` set xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xss = card (set ` set xss)", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n\ngoal (1 subgoal):\n 1. length xss = card (set ` set xss)", "proof (induct xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. distincts [] \\<Longrightarrow> length [] = card (set ` set [])\n 2. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                length xss = card (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> length (a # xss) = card (set ` set (a # xss))", "case Nil"], ["proof (state)\nthis:\n  distincts []\n\ngoal (2 subgoals):\n 1. distincts [] \\<Longrightarrow> length [] = card (set ` set [])\n 2. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                length xss = card (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> length (a # xss) = card (set ` set (a # xss))", "then"], ["proof (chain)\npicking this:\n  distincts []", "show ?case"], ["proof (prove)\nusing this:\n  distincts []\n\ngoal (1 subgoal):\n 1. length [] = card (set ` set [])", "by simp"], ["proof (state)\nthis:\n  length [] = card (set ` set [])\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                length xss = card (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> length (a # xss) = card (set ` set (a # xss))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                length xss = card (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> length (a # xss) = card (set ` set (a # xss))", "case (Cons xs xss)"], ["proof (state)\nthis:\n  distincts xss \\<Longrightarrow> length xss = card (set ` set xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                length xss = card (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> length (a # xss) = card (set ` set (a # xss))", "then"], ["proof (chain)\npicking this:\n  distincts xss \\<Longrightarrow> length xss = card (set ` set xss)\n  distincts (xs # xss)", "have \"set xs \\<notin> set ` set xss\""], ["proof (prove)\nusing this:\n  distincts xss \\<Longrightarrow> length xss = card (set ` set xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. set xs \\<notin> set ` set xss", "using equals0I[of \"set xs\"]"], ["proof (prove)\nusing this:\n  distincts xss \\<Longrightarrow> length xss = card (set ` set xss)\n  distincts (xs # xss)\n  (\\<And>y. y \\<in> set xs \\<Longrightarrow> False) \\<Longrightarrow>\n  set xs = {}\n\ngoal (1 subgoal):\n 1. set xs \\<notin> set ` set xss", "by (auto simp: distincts_Cons disjoint_iff_not_equal )"], ["proof (state)\nthis:\n  set xs \\<notin> set ` set xss\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                length xss = card (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> length (a # xss) = card (set ` set (a # xss))", "with Cons"], ["proof (chain)\npicking this:\n  distincts xss \\<Longrightarrow> length xss = card (set ` set xss)\n  distincts (xs # xss)\n  set xs \\<notin> set ` set xss", "show ?case"], ["proof (prove)\nusing this:\n  distincts xss \\<Longrightarrow> length xss = card (set ` set xss)\n  distincts (xs # xss)\n  set xs \\<notin> set ` set xss\n\ngoal (1 subgoal):\n 1. length (xs # xss) = card (set ` set (xs # xss))", "by (auto simp add: distincts_Cons)"], ["proof (state)\nthis:\n  length (xs # xss) = card (set ` set (xs # xss))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distincts_remove1: \"distincts xss \\<Longrightarrow> distincts (remove1 xs xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts xss \\<Longrightarrow> distincts (remove1 xs xss)", "by (auto simp: distincts_def)"], ["", "lemma distinct_Cons_remove1:\n  \"x \\<in> set xs \\<Longrightarrow> distinct (x # remove1 x xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow>\n    distinct (x # remove1 x xs) = distinct xs", "by (induct xs) auto"], ["", "lemma set_Cons_remove1:\n  \"x \\<in> set xs \\<Longrightarrow> set (x # remove1 x xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> set (x # remove1 x xs) = set xs", "by (induct xs) auto"], ["", "lemma distincts_Cons_remove1:\n  \"xs \\<in> set xss \\<Longrightarrow> distincts (xs # remove1 xs xss) = distincts xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> set xss \\<Longrightarrow>\n    distincts (xs # remove1 xs xss) = distincts xss", "by (simp only: distinct_Cons_remove1 set_Cons_remove1 distincts_def)"], ["", "lemma distincts_inj_on_set:\n  assumes \"distincts xss\" shows \"inj_on set (set xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on set (set xss)", "by (rule inj_onI) (metis assms distincts_def inf.idem set_empty)"], ["", "lemma distincts_distinct_set:\n  assumes \"distincts xss\" shows \"distinct (map set xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map set xss)", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n\ngoal (1 subgoal):\n 1. distinct (map set xss)", "by (auto simp: distinct_map distincts_distinct distincts_inj_on_set)"], ["", "lemma distincts_distinct_nth:\n  assumes \"distincts xss\" \"n < length xss\" shows \"distinct (xss ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xss ! n)", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n  n < length xss\n\ngoal (1 subgoal):\n 1. distinct (xss ! n)", "by (auto simp: distincts_def)"], ["", "lemma lists_succ_not_in:\n  assumes \"x \\<notin> (\\<Union>xs\\<in>set xss. set xs)\" shows \"lists_succ xss x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ xss x = x", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> \\<Union> (set ` set xss)\n\ngoal (1 subgoal):\n 1. lists_succ xss x = x", "by (induct xss) (auto simp: list_succ_not_in)"], ["", "lemma lists_succ_in_conv:\n  \"lists_succ xss x \\<in> (\\<Union>xs\\<in>set xss. set xs) \\<longleftrightarrow> x \\<in> (\\<Union>xs\\<in>set xss. set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lists_succ xss x \\<in> \\<Union> (set ` set xss)) =\n    (x \\<in> \\<Union> (set ` set xss))", "by (induct xss) (auto simp: list_succ_in_conv lists_succ_not_in list_succ_not_in)"], ["", "lemma lists_succ_in_conv1:\n  assumes \"A \\<inter> (\\<Union>xs\\<in>set xss. set xs) = {}\"\n  shows \"lists_succ xss x \\<in> A \\<longleftrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lists_succ xss x \\<in> A) = (x \\<in> A)", "by (metis Int_iff assms emptyE lists_succ_in_conv lists_succ_not_in)"], ["", "lemma lists_succ_Cons_pf: \"lists_succ (xs # xss) = list_succ xs o lists_succ xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ (xs # xss) = list_succ xs \\<circ> lists_succ xss", "by auto"], ["", "lemma lists_succ_Nil_pf: \"lists_succ [] = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ [] = id", "by (simp add: fun_eq_iff)"], ["", "lemmas lists_succ_simps_pf = lists_succ_Cons_pf lists_succ_Nil_pf"], ["", "lemma lists_succ_permutes:\n  assumes \"distincts xss\"\n  shows \"lists_succ xss permutes (\\<Union>xs \\<in> set xss. set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ xss permutes \\<Union> (set ` set xss)", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n\ngoal (1 subgoal):\n 1. lists_succ xss permutes \\<Union> (set ` set xss)", "proof (induction xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. distincts [] \\<Longrightarrow>\n    lists_succ [] permutes \\<Union> (set ` set [])\n 2. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "case Nil"], ["proof (state)\nthis:\n  distincts []\n\ngoal (2 subgoals):\n 1. distincts [] \\<Longrightarrow>\n    lists_succ [] permutes \\<Union> (set ` set [])\n 2. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "then"], ["proof (chain)\npicking this:\n  distincts []", "show ?case"], ["proof (prove)\nusing this:\n  distincts []\n\ngoal (1 subgoal):\n 1. lists_succ [] permutes \\<Union> (set ` set [])", "by auto"], ["proof (state)\nthis:\n  lists_succ [] permutes \\<Union> (set ` set [])\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "case (Cons xs xss)"], ["proof (state)\nthis:\n  distincts xss \\<Longrightarrow>\n  lists_succ xss permutes \\<Union> (set ` set xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "have \"list_succ xs permutes (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs permutes set xs", "using Cons"], ["proof (prove)\nusing this:\n  distincts xss \\<Longrightarrow>\n  lists_succ xss permutes \\<Union> (set ` set xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. list_succ xs permutes set xs", "by (intro list_succ_permutes) (simp add: distincts_def in_set_member)"], ["proof (state)\nthis:\n  list_succ xs permutes set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "moreover"], ["proof (state)\nthis:\n  list_succ xs permutes set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "have \"lists_succ xss permutes (\\<Union>ys \\<in> set xss. set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ xss permutes \\<Union> (set ` set xss)", "using Cons"], ["proof (prove)\nusing this:\n  distincts xss \\<Longrightarrow>\n  lists_succ xss permutes \\<Union> (set ` set xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. lists_succ xss permutes \\<Union> (set ` set xss)", "by (auto simp: Cons distincts_def)"], ["proof (state)\nthis:\n  lists_succ xss permutes \\<Union> (set ` set xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>distincts xss \\<Longrightarrow>\n                lists_succ xss permutes \\<Union> (set ` set xss);\n        distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) permutes\n                         \\<Union> (set ` set (a # xss))", "ultimately"], ["proof (chain)\npicking this:\n  list_succ xs permutes set xs\n  lists_succ xss permutes \\<Union> (set ` set xss)", "show \"lists_succ (xs # xss) permutes (\\<Union>ys \\<in> set (xs # xss). set ys)\""], ["proof (prove)\nusing this:\n  list_succ xs permutes set xs\n  lists_succ xss permutes \\<Union> (set ` set xss)\n\ngoal (1 subgoal):\n 1. lists_succ (xs # xss) permutes \\<Union> (set ` set (xs # xss))", "using Cons"], ["proof (prove)\nusing this:\n  list_succ xs permutes set xs\n  lists_succ xss permutes \\<Union> (set ` set xss)\n  distincts xss \\<Longrightarrow>\n  lists_succ xss permutes \\<Union> (set ` set xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. lists_succ (xs # xss) permutes \\<Union> (set ` set (xs # xss))", "by (auto simp: lists_succ_Cons_pf intro: permutes_compose permutes_subset)"], ["proof (state)\nthis:\n  lists_succ (xs # xss) permutes \\<Union> (set ` set (xs # xss))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_lists_succ: \"distincts xss \\<Longrightarrow> bij (lists_succ xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts xss \\<Longrightarrow> bij (lists_succ xss)", "by (induct xss) (auto simp: lists_succ_simps_pf bij_comp bij_list_succ distincts_Cons)"], ["", "lemma lists_succ_snoc: \"lists_succ (xss @ [xs]) = lists_succ xss o list_succ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ (xss @ [xs]) = lists_succ xss \\<circ> list_succ xs", "by (induct xss) auto"], ["", "lemma inv_lists_succ_eq:\n  assumes \"distincts xss\"\n  shows \"inv (lists_succ xss) = lists_succ (rev (map rev xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (lists_succ xss) = lists_succ (rev (map rev xss))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv (lists_succ xss) = lists_succ (rev (map rev xss))", "have *: \"\\<And>f g. inv (\\<lambda>b. f (g b)) = inv (f o g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g. inv (\\<lambda>b. f (g b)) = inv (f \\<circ> g)", "by (simp add: o_def)"], ["proof (state)\nthis:\n  inv (\\<lambda>b. ?f (?g b)) = inv (?f \\<circ> ?g)\n\ngoal (1 subgoal):\n 1. inv (lists_succ xss) = lists_succ (rev (map rev xss))", "have **: \"lists_succ [] = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ [] = id", "by auto"], ["proof (state)\nthis:\n  lists_succ [] = id\n\ngoal (1 subgoal):\n 1. inv (lists_succ xss) = lists_succ (rev (map rev xss))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (lists_succ xss) = lists_succ (rev (map rev xss))", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n\ngoal (1 subgoal):\n 1. inv (lists_succ xss) = lists_succ (rev (map rev xss))", "by (induct xss) (auto simp: * ** lists_succ_snoc lists_succ_Cons_pf o_inv_distrib\n      inv_list_succ_eq distincts_Cons bij_list_succ bij_lists_succ)"], ["proof (state)\nthis:\n  inv (lists_succ xss) = lists_succ (rev (map rev xss))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lists_succ_remove1:\n  assumes \"distincts xss\" \"xs \\<in> set xss\"\n  shows \"lists_succ (xs # remove1 xs xss) = lists_succ xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ (xs # remove1 xs xss) = lists_succ xss", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n  xs \\<in> set xss\n\ngoal (1 subgoal):\n 1. lists_succ (xs # remove1 xs xss) = lists_succ xss", "proof (induct xss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distincts []; xs \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> lists_succ (xs # remove1 xs []) = lists_succ []\n 2. \\<And>a xss.\n       \\<lbrakk>\\<lbrakk>distincts xss; xs \\<in> set xss\\<rbrakk>\n                \\<Longrightarrow> lists_succ (xs # remove1 xs xss) =\n                                  lists_succ xss;\n        distincts (a # xss); xs \\<in> set (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (xs # remove1 xs (a # xss)) =\n                         lists_succ (a # xss)", "case Nil"], ["proof (state)\nthis:\n  distincts []\n  xs \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distincts []; xs \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> lists_succ (xs # remove1 xs []) = lists_succ []\n 2. \\<And>a xss.\n       \\<lbrakk>\\<lbrakk>distincts xss; xs \\<in> set xss\\<rbrakk>\n                \\<Longrightarrow> lists_succ (xs # remove1 xs xss) =\n                                  lists_succ xss;\n        distincts (a # xss); xs \\<in> set (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (xs # remove1 xs (a # xss)) =\n                         lists_succ (a # xss)", "then"], ["proof (chain)\npicking this:\n  distincts []\n  xs \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  distincts []\n  xs \\<in> set []\n\ngoal (1 subgoal):\n 1. lists_succ (xs # remove1 xs []) = lists_succ []", "by simp"], ["proof (state)\nthis:\n  lists_succ (xs # remove1 xs []) = lists_succ []\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>\\<lbrakk>distincts xss; xs \\<in> set xss\\<rbrakk>\n                \\<Longrightarrow> lists_succ (xs # remove1 xs xss) =\n                                  lists_succ xss;\n        distincts (a # xss); xs \\<in> set (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (xs # remove1 xs (a # xss)) =\n                         lists_succ (a # xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>\\<lbrakk>distincts xss; xs \\<in> set xss\\<rbrakk>\n                \\<Longrightarrow> lists_succ (xs # remove1 xs xss) =\n                                  lists_succ xss;\n        distincts (a # xss); xs \\<in> set (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (xs # remove1 xs (a # xss)) =\n                         lists_succ (a # xss)", "case (Cons ys xss)"], ["proof (state)\nthis:\n  \\<lbrakk>distincts xss; xs \\<in> set xss\\<rbrakk>\n  \\<Longrightarrow> lists_succ (xs # remove1 xs xss) = lists_succ xss\n  distincts (ys # xss)\n  xs \\<in> set (ys # xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>\\<lbrakk>distincts xss; xs \\<in> set xss\\<rbrakk>\n                \\<Longrightarrow> lists_succ (xs # remove1 xs xss) =\n                                  lists_succ xss;\n        distincts (a # xss); xs \\<in> set (a # xss)\\<rbrakk>\n       \\<Longrightarrow> lists_succ (xs # remove1 xs (a # xss)) =\n                         lists_succ (a # xss)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)\n 2. \\<not> ?P \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "assume \"xs = ys\""], ["proof (state)\nthis:\n  xs = ys\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)\n 2. \\<not> ?P \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "then"], ["proof (chain)\npicking this:\n  xs = ys", "show ?case"], ["proof (prove)\nusing this:\n  xs = ys\n\ngoal (1 subgoal):\n 1. lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "by simp"], ["proof (state)\nthis:\n  lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "assume \"xs \\<noteq> ys\""], ["proof (state)\nthis:\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "with Cons.prems"], ["proof (chain)\npicking this:\n  distincts (ys # xss)\n  xs \\<in> set (ys # xss)\n  xs \\<noteq> ys", "have inter: \"set xs \\<inter> set ys = {}\" and \"xs \\<in> set xss\""], ["proof (prove)\nusing this:\n  distincts (ys # xss)\n  xs \\<in> set (ys # xss)\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys = {} &&& xs \\<in> set xss", "by (auto simp: distincts_Cons)"], ["proof (state)\nthis:\n  set xs \\<inter> set ys = {}\n  xs \\<in> set xss\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "have dists:\n        \"distincts (xs # remove1 xs xss)\"\n        \"distincts (xs # ys # remove1 xs xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (xs # remove1 xs xss) &&& distincts (xs # ys # remove1 xs xss)", "using \\<open>distincts (ys # xss)\\<close> \\<open>xs \\<in> set xss\\<close>"], ["proof (prove)\nusing this:\n  distincts (ys # xss)\n  xs \\<in> set xss\n\ngoal (1 subgoal):\n 1. distincts (xs # remove1 xs xss) &&& distincts (xs # ys # remove1 xs xss)", "by (auto simp: distincts_def)"], ["proof (state)\nthis:\n  distincts (xs # remove1 xs xss)\n  distincts (xs # ys # remove1 xs xss)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "have \"list_succ xs \\<circ> (list_succ ys \\<circ> lists_succ (remove1 xs xss))\n        = list_succ ys \\<circ> (list_succ xs \\<circ> lists_succ (remove1 xs xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs \\<circ>\n    (list_succ ys \\<circ> lists_succ (remove1 xs xss)) =\n    list_succ ys \\<circ> (list_succ xs \\<circ> lists_succ (remove1 xs xss))", "using inter"], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. list_succ xs \\<circ>\n    (list_succ ys \\<circ> lists_succ (remove1 xs xss)) =\n    list_succ ys \\<circ> (list_succ xs \\<circ> lists_succ (remove1 xs xss))", "unfolding fun_eq_iff comp_def"], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       list_succ xs (list_succ ys (lists_succ (remove1 xs xss) x)) =\n       list_succ ys (list_succ xs (lists_succ (remove1 xs xss) x))", "by (subst list_succ_commute) auto"], ["proof (state)\nthis:\n  list_succ xs \\<circ> (list_succ ys \\<circ> lists_succ (remove1 xs xss)) =\n  list_succ ys \\<circ> (list_succ xs \\<circ> lists_succ (remove1 xs xss))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "also"], ["proof (state)\nthis:\n  list_succ xs \\<circ> (list_succ ys \\<circ> lists_succ (remove1 xs xss)) =\n  list_succ ys \\<circ> (list_succ xs \\<circ> lists_succ (remove1 xs xss))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "have \"\\<dots> = list_succ ys o (lists_succ (xs # remove1 xs xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ ys \\<circ>\n    (list_succ xs \\<circ> lists_succ (remove1 xs xss)) =\n    list_succ ys \\<circ> lists_succ (xs # remove1 xs xss)", "using dists"], ["proof (prove)\nusing this:\n  distincts (xs # remove1 xs xss)\n  distincts (xs # ys # remove1 xs xss)\n\ngoal (1 subgoal):\n 1. list_succ ys \\<circ>\n    (list_succ xs \\<circ> lists_succ (remove1 xs xss)) =\n    list_succ ys \\<circ> lists_succ (xs # remove1 xs xss)", "by (simp add: lists_succ_Cons_pf distincts_Cons)"], ["proof (state)\nthis:\n  list_succ ys \\<circ> (list_succ xs \\<circ> lists_succ (remove1 xs xss)) =\n  list_succ ys \\<circ> lists_succ (xs # remove1 xs xss)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "also"], ["proof (state)\nthis:\n  list_succ ys \\<circ> (list_succ xs \\<circ> lists_succ (remove1 xs xss)) =\n  list_succ ys \\<circ> lists_succ (xs # remove1 xs xss)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "have \"\\<dots> = list_succ ys o lists_succ xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ ys \\<circ> lists_succ (xs # remove1 xs xss) =\n    list_succ ys \\<circ> lists_succ xss", "using \\<open>xs \\<in> set xss\\<close> \\<open>distincts (ys # xss)\\<close>"], ["proof (prove)\nusing this:\n  xs \\<in> set xss\n  distincts (ys # xss)\n\ngoal (1 subgoal):\n 1. list_succ ys \\<circ> lists_succ (xs # remove1 xs xss) =\n    list_succ ys \\<circ> lists_succ xss", "by (simp add: distincts_Cons Cons.hyps)"], ["proof (state)\nthis:\n  list_succ ys \\<circ> lists_succ (xs # remove1 xs xss) =\n  list_succ ys \\<circ> lists_succ xss\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow>\n    lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "finally"], ["proof (chain)\npicking this:\n  list_succ xs \\<circ> (list_succ ys \\<circ> lists_succ (remove1 xs xss)) =\n  list_succ ys \\<circ> lists_succ xss", "show \"lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)\""], ["proof (prove)\nusing this:\n  list_succ xs \\<circ> (list_succ ys \\<circ> lists_succ (remove1 xs xss)) =\n  list_succ ys \\<circ> lists_succ xss\n\ngoal (1 subgoal):\n 1. lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "using Cons dists"], ["proof (prove)\nusing this:\n  list_succ xs \\<circ> (list_succ ys \\<circ> lists_succ (remove1 xs xss)) =\n  list_succ ys \\<circ> lists_succ xss\n  \\<lbrakk>distincts xss; xs \\<in> set xss\\<rbrakk>\n  \\<Longrightarrow> lists_succ (xs # remove1 xs xss) = lists_succ xss\n  distincts (ys # xss)\n  xs \\<in> set (ys # xss)\n  distincts (xs # remove1 xs xss)\n  distincts (xs # ys # remove1 xs xss)\n\ngoal (1 subgoal):\n 1. lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)", "by (auto simp: lists_succ_Cons_pf distincts_Cons)"], ["proof (state)\nthis:\n  lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lists_succ (xs # remove1 xs (ys # xss)) = lists_succ (ys # xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lists_succ_no_order:\n  assumes \"distincts xss\" \"distincts yss\" \"set xss = set yss\"\n  shows \"lists_succ xss = lists_succ yss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ xss = lists_succ yss", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n  distincts yss\n  set xss = set yss\n\ngoal (1 subgoal):\n 1. lists_succ xss = lists_succ yss", "proof (induct xss arbitrary: yss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>yss.\n       \\<lbrakk>distincts []; distincts yss; set [] = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ [] = lists_succ yss\n 2. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "case Nil"], ["proof (state)\nthis:\n  distincts []\n  distincts yss\n  set [] = set yss\n\ngoal (2 subgoals):\n 1. \\<And>yss.\n       \\<lbrakk>distincts []; distincts yss; set [] = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ [] = lists_succ yss\n 2. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "then"], ["proof (chain)\npicking this:\n  distincts []\n  distincts yss\n  set [] = set yss", "show ?case"], ["proof (prove)\nusing this:\n  distincts []\n  distincts yss\n  set [] = set yss\n\ngoal (1 subgoal):\n 1. lists_succ [] = lists_succ yss", "by simp"], ["proof (state)\nthis:\n  lists_succ [] = lists_succ yss\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "case (Cons xs xss)"], ["proof (state)\nthis:\n  \\<lbrakk>distincts xss; distincts ?yss; set xss = set ?yss\\<rbrakk>\n  \\<Longrightarrow> lists_succ xss = lists_succ ?yss\n  distincts (xs # xss)\n  distincts yss\n  set (xs # xss) = set yss\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "have \"xs \\<notin> set xss\" \"xs \\<in> set yss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<notin> set xss &&& xs \\<in> set yss", "using Cons.prems"], ["proof (prove)\nusing this:\n  distincts (xs # xss)\n  distincts yss\n  set (xs # xss) = set yss\n\ngoal (1 subgoal):\n 1. xs \\<notin> set xss &&& xs \\<in> set yss", "by (auto dest: distincts_distinct)"], ["proof (state)\nthis:\n  xs \\<notin> set xss\n  xs \\<in> set yss\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "have \"lists_succ xss = lists_succ (remove1 xs yss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ xss = lists_succ (remove1 xs yss)", "using Cons.prems \\<open>xs \\<notin> _\\<close>"], ["proof (prove)\nusing this:\n  distincts (xs # xss)\n  distincts yss\n  set (xs # xss) = set yss\n  xs \\<notin> set xss\n\ngoal (1 subgoal):\n 1. lists_succ xss = lists_succ (remove1 xs yss)", "by (intro Cons.hyps) (auto simp add: distincts_Cons distincts_remove1 distincts_distinct)"], ["proof (state)\nthis:\n  lists_succ xss = lists_succ (remove1 xs yss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "then"], ["proof (chain)\npicking this:\n  lists_succ xss = lists_succ (remove1 xs yss)", "have \"lists_succ (xs # xss) = lists_succ (xs # remove1 xs yss)\""], ["proof (prove)\nusing this:\n  lists_succ xss = lists_succ (remove1 xs yss)\n\ngoal (1 subgoal):\n 1. lists_succ (xs # xss) = lists_succ (xs # remove1 xs yss)", "using Cons.prems \\<open>xs \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  lists_succ xss = lists_succ (remove1 xs yss)\n  distincts (xs # xss)\n  distincts yss\n  set (xs # xss) = set yss\n  xs \\<in> set yss\n\ngoal (1 subgoal):\n 1. lists_succ (xs # xss) = lists_succ (xs # remove1 xs yss)", "by (simp add: lists_succ_Cons_pf distincts_Cons_remove1)"], ["proof (state)\nthis:\n  lists_succ (xs # xss) = lists_succ (xs # remove1 xs yss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>distincts xss; distincts yss;\n                    set xss = set yss\\<rbrakk>\n                   \\<Longrightarrow> lists_succ xss = lists_succ yss;\n        distincts (a # xss); distincts yss; set (a # xss) = set yss\\<rbrakk>\n       \\<Longrightarrow> lists_succ (a # xss) = lists_succ yss", "then"], ["proof (chain)\npicking this:\n  lists_succ (xs # xss) = lists_succ (xs # remove1 xs yss)", "show ?case"], ["proof (prove)\nusing this:\n  lists_succ (xs # xss) = lists_succ (xs # remove1 xs yss)\n\ngoal (1 subgoal):\n 1. lists_succ (xs # xss) = lists_succ yss", "using Cons.prems \\<open>xs \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  lists_succ (xs # xss) = lists_succ (xs # remove1 xs yss)\n  distincts (xs # xss)\n  distincts yss\n  set (xs # xss) = set yss\n  xs \\<in> set yss\n\ngoal (1 subgoal):\n 1. lists_succ (xs # xss) = lists_succ yss", "by (simp add: lists_succ_remove1)"], ["proof (state)\nthis:\n  lists_succ (xs # xss) = lists_succ yss\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>List Orbits\\<close>"], ["", "text \\<open>Computes the orbit of @{term x} under @{term f}\\<close>"], ["", "definition orbit_list :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a list\" where\n  \"orbit_list f x \\<equiv> iterate 0 (funpow_dist1 f x x) f x\""], ["", "partial_function (tailrec)\n  orbit_list_impl :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a \\<Rightarrow> 'a list\"\nwhere\n  \"orbit_list_impl f s acc x = (let x' = f x in if x' = s then rev (x # acc) else orbit_list_impl f s (x # acc) x')\""], ["", "context notes [simp] = length_fold_remove1_le begin"], ["", "text \\<open>Computes the list of orbits\\<close>"], ["", "fun orbits_list :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\" where\n  \"orbits_list f [] = []\"\n| \"orbits_list f (x # xs) =\n     orbit_list f x # orbits_list f (fold remove1 (orbit_list f x) xs)\""], ["", "fun orbits_list_impl :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\" where\n  \"orbits_list_impl f [] = []\"\n| \"orbits_list_impl f (x # xs) =\n     (let fc = orbit_list_impl f x [] x in fc # orbits_list_impl f (fold remove1 fc xs))\""], ["", "declare orbit_list_impl.simps[code]"], ["", "end"], ["", "abbreviation sset :: \"'a list list \\<Rightarrow> 'a set set\" where\n  \"sset xss \\<equiv> set ` set xss\""], ["", "lemma iterate_funpow_step:\n  assumes \"f x \\<noteq> y\" \"y \\<in> orbit f x\"\n  shows \"iterate 0 (funpow_dist1 f x y) f x = x # iterate 0 (funpow_dist1 f (f x) y) f (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "from assms"], ["proof (chain)\npicking this:\n  f x \\<noteq> y\n  y \\<in> orbit f x", "have A: \"y \\<in> orbit f (f x)\""], ["proof (prove)\nusing this:\n  f x \\<noteq> y\n  y \\<in> orbit f x\n\ngoal (1 subgoal):\n 1. y \\<in> orbit f (f x)", "by (simp add: orbit_step)"], ["proof (state)\nthis:\n  y \\<in> orbit f (f x)\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "have \"iterate 0 (funpow_dist1 f x y) f x = x # iterate 1 (funpow_dist1 f x y) f x\" (is \"_ = _ # ?it\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 1 (funpow_dist1 f x y) f x", "unfolding iterate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n. (f ^^ n) x) [0..<funpow_dist1 f x y] =\n    x # map (\\<lambda>n. (f ^^ n) x) [1..<funpow_dist1 f x y]", "by (rewrite in \"\\<hole> = _\" upt_conv_Cons) auto"], ["proof (state)\nthis:\n  iterate 0 (funpow_dist1 f x y) f x =\n  x # iterate 1 (funpow_dist1 f x y) f x\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "also"], ["proof (state)\nthis:\n  iterate 0 (funpow_dist1 f x y) f x =\n  x # iterate 1 (funpow_dist1 f x y) f x\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "have \"?it = map (\\<lambda>n. (f ^^ n) x) (map Suc [0..<funpow_dist f (f x) y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate 1 (funpow_dist1 f x y) f x =\n    map (\\<lambda>n. (f ^^ n) x) (map Suc [0..<funpow_dist f (f x) y])", "unfolding iterate_def map_Suc_upt"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n. (f ^^ n) x) [1..<funpow_dist1 f x y] =\n    map (\\<lambda>n. (f ^^ n) x) [Suc 0..<funpow_dist1 f x y]", "by simp"], ["proof (state)\nthis:\n  iterate 1 (funpow_dist1 f x y) f x =\n  map (\\<lambda>n. (f ^^ n) x) (map Suc [0..<funpow_dist f (f x) y])\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "also"], ["proof (state)\nthis:\n  iterate 1 (funpow_dist1 f x y) f x =\n  map (\\<lambda>n. (f ^^ n) x) (map Suc [0..<funpow_dist f (f x) y])\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "have \"\\<dots> = map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n. (f ^^ n) x) (map Suc [0..<funpow_dist f (f x) y]) =\n    map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y]", "by (simp add: funpow_swap1)"], ["proof (state)\nthis:\n  map (\\<lambda>n. (f ^^ n) x) (map Suc [0..<funpow_dist f (f x) y]) =\n  map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y]\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "also"], ["proof (state)\nthis:\n  map (\\<lambda>n. (f ^^ n) x) (map Suc [0..<funpow_dist f (f x) y]) =\n  map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y]\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "have \"\\<dots> = iterate 0 (funpow_dist1 f (f x) y) f (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y] =\n    iterate 0 (funpow_dist1 f (f x) y) f (f x)", "unfolding iterate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y] =\n    map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist1 f (f x) y]", "unfolding iterate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y] =\n    map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist1 f (f x) y]", "by (simp add: funpow_dist_step[OF assms(1) A])"], ["proof (state)\nthis:\n  map (\\<lambda>n. (f ^^ n) (f x)) [0..<funpow_dist f (f x) y] =\n  iterate 0 (funpow_dist1 f (f x) y) f (f x)\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "finally"], ["proof (chain)\npicking this:\n  iterate 0 (funpow_dist1 f x y) f x =\n  x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  iterate 0 (funpow_dist1 f x y) f x =\n  x # iterate 0 (funpow_dist1 f (f x) y) f (f x)\n\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x y) f x =\n    x # iterate 0 (funpow_dist1 f (f x) y) f (f x)", "."], ["proof (state)\nthis:\n  iterate 0 (funpow_dist1 f x y) f x =\n  x # iterate 0 (funpow_dist1 f (f x) y) f (f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orbit_list_impl_conv:\n  assumes \"y \\<in> orbit f x\"\n  shows \"orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> orbit f x\n\ngoal (1 subgoal):\n 1. orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "proof (induct n\\<equiv>\"funpow_dist1 f x y\" arbitrary: x acc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x acc.\n       \\<lbrakk>\\<And>xa acc.\n                   \\<lbrakk>funpow_dist f (f x) y = funpow_dist1 f xa y;\n                    y \\<in> orbit f xa\\<rbrakk>\n                   \\<Longrightarrow> orbit_list_impl f y acc xa =\n                                     rev acc @\n                                     iterate 0 (funpow_dist1 f xa y) f xa;\n        y \\<in> orbit f x\\<rbrakk>\n       \\<Longrightarrow> orbit_list_impl f y acc x =\n                         rev acc @ iterate 0 (funpow_dist1 f x y) f x", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>funpow_dist f (f x) y = funpow_dist1 f ?x y;\n   y \\<in> orbit f ?x\\<rbrakk>\n  \\<Longrightarrow> orbit_list_impl f y ?acc ?x =\n                    rev ?acc @ iterate 0 (funpow_dist1 f ?x y) f ?x\n  y \\<in> orbit f x\n\ngoal (1 subgoal):\n 1. \\<And>x acc.\n       \\<lbrakk>\\<And>xa acc.\n                   \\<lbrakk>funpow_dist f (f x) y = funpow_dist1 f xa y;\n                    y \\<in> orbit f xa\\<rbrakk>\n                   \\<Longrightarrow> orbit_list_impl f y acc xa =\n                                     rev acc @\n                                     iterate 0 (funpow_dist1 f xa y) f xa;\n        y \\<in> orbit f x\\<rbrakk>\n       \\<Longrightarrow> orbit_list_impl f y acc x =\n                         rev acc @ iterate 0 (funpow_dist1 f x y) f x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\n 2. \\<not> ?P \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "assume \"f x = y\""], ["proof (state)\nthis:\n  f x = y\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\n 2. \\<not> ?P \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "then"], ["proof (chain)\npicking this:\n  f x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  f x = y\n\ngoal (1 subgoal):\n 1. orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "by (subst orbit_list_impl.simps) (simp add: Let_def iterate_def funpow_dist_0)"], ["proof (state)\nthis:\n  orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "assume not_y :\"f x \\<noteq> y\""], ["proof (state)\nthis:\n  f x \\<noteq> y\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "have y_in_succ: \"y \\<in> orbit f (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> orbit f (f x)", "by (intro orbit_step Suc.prems not_y)"], ["proof (state)\nthis:\n  y \\<in> orbit f (f x)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "have \"orbit_list_impl f y acc x = orbit_list_impl f y (x # acc) (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit_list_impl f y acc x = orbit_list_impl f y (x # acc) (f x)", "using not_y"], ["proof (prove)\nusing this:\n  f x \\<noteq> y\n\ngoal (1 subgoal):\n 1. orbit_list_impl f y acc x = orbit_list_impl f y (x # acc) (f x)", "by (subst orbit_list_impl.simps) simp"], ["proof (state)\nthis:\n  orbit_list_impl f y acc x = orbit_list_impl f y (x # acc) (f x)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "also"], ["proof (state)\nthis:\n  orbit_list_impl f y acc x = orbit_list_impl f y (x # acc) (f x)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "have \"\\<dots> = rev (x # acc) @ iterate 0 (funpow_dist1 f (f x) y) f (f x)\" (is \"_ = ?rev @ ?it\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit_list_impl f y (x # acc) (f x) =\n    rev (x # acc) @ iterate 0 (funpow_dist1 f (f x) y) f (f x)", "by (intro Suc funpow_dist_step not_y y_in_succ)"], ["proof (state)\nthis:\n  orbit_list_impl f y (x # acc) (f x) =\n  rev (x # acc) @ iterate 0 (funpow_dist1 f (f x) y) f (f x)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "also"], ["proof (state)\nthis:\n  orbit_list_impl f y (x # acc) (f x) =\n  rev (x # acc) @ iterate 0 (funpow_dist1 f (f x) y) f (f x)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "have \"\\<dots> = rev acc @ iterate 0 (funpow_dist1 f x y) f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (x # acc) @ iterate 0 (funpow_dist1 f (f x) y) f (f x) =\n    rev acc @ iterate 0 (funpow_dist1 f x y) f x", "using not_y Suc.prems"], ["proof (prove)\nusing this:\n  f x \\<noteq> y\n  y \\<in> orbit f x\n\ngoal (1 subgoal):\n 1. rev (x # acc) @ iterate 0 (funpow_dist1 f (f x) y) f (f x) =\n    rev acc @ iterate 0 (funpow_dist1 f x y) f x", "by (simp add: iterate_funpow_step)"], ["proof (state)\nthis:\n  rev (x # acc) @ iterate 0 (funpow_dist1 f (f x) y) f (f x) =\n  rev acc @ iterate 0 (funpow_dist1 f x y) f x\n\ngoal (1 subgoal):\n 1. f x \\<noteq> y \\<Longrightarrow>\n    orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "finally"], ["proof (chain)\npicking this:\n  orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "show ?thesis"], ["proof (prove)\nusing this:\n  orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\n\ngoal (1 subgoal):\n 1. orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x", "."], ["proof (state)\nthis:\n  orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orbit_list_impl f y acc x = rev acc @ iterate 0 (funpow_dist1 f x y) f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orbit_list_conv_impl:\n  assumes \"x \\<in> orbit f x\"\n  shows \"orbit_list f x = orbit_list_impl f x [] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit_list f x = orbit_list_impl f x [] x", "unfolding orbit_list_impl_conv[OF assms] orbit_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate 0 (funpow_dist1 f x x) f x =\n    rev [] @ iterate 0 (funpow_dist1 f x x) f x", "by simp"], ["", "lemma set_orbit_list:\n  assumes \"x \\<in> orbit f x\"\n  shows \"set (orbit_list f x) = orbit f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (orbit_list f x) = orbit f x", "by (simp add: orbit_list_def orbit_conv_funpow_dist1[OF assms] set_iterate)"], ["", "lemma set_orbit_list':\n  assumes \"permutation f\" shows \"set (orbit_list f x) = orbit f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (orbit_list f x) = orbit f x", "using assms"], ["proof (prove)\nusing this:\n  permutation f\n\ngoal (1 subgoal):\n 1. set (orbit_list f x) = orbit f x", "by (simp add: permutation_self_in_orbit set_orbit_list)"], ["", "lemma distinct_orbit_list:\n  assumes \"x \\<in> orbit f x\"\n  shows \"distinct (orbit_list f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (orbit_list f x)", "by (simp del: upt_Suc add: orbit_list_def iterate_def distinct_map inj_on_funpow_dist1[OF assms])"], ["", "lemma distinct_orbit_list':\n  assumes \"permutation f\" shows \"distinct (orbit_list f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (orbit_list f x)", "using assms"], ["proof (prove)\nusing this:\n  permutation f\n\ngoal (1 subgoal):\n 1. distinct (orbit_list f x)", "by (simp add: permutation_self_in_orbit distinct_orbit_list)"], ["", "lemma orbits_list_conv_impl:\n  assumes \"permutation f\"\n  shows \"orbits_list f xs = orbits_list_impl f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbits_list f xs = orbits_list_impl f xs", "proof (induct \"length xs\" arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>xsa.\n           length xsa < length xs \\<Longrightarrow>\n           orbits_list f xsa = orbits_list_impl f xsa) \\<Longrightarrow>\n       orbits_list f xs = orbits_list_impl f xs", "case less"], ["proof (state)\nthis:\n  length ?xs < length xs \\<Longrightarrow>\n  orbits_list f ?xs = orbits_list_impl f ?xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>xsa.\n           length xsa < length xs \\<Longrightarrow>\n           orbits_list f xsa = orbits_list_impl f xsa) \\<Longrightarrow>\n       orbits_list f xs = orbits_list_impl f xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. orbits_list f xs = orbits_list_impl f xs", "using assms"], ["proof (prove)\nusing this:\n  permutation f\n\ngoal (1 subgoal):\n 1. orbits_list f xs = orbits_list_impl f xs", "by (cases xs) (auto simp: assms less less_Suc_eq_le length_fold_remove1_le\n      orbit_list_conv_impl permutation_self_in_orbit Let_def)"], ["proof (state)\nthis:\n  orbits_list f xs = orbits_list_impl f xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orbit_list_not_nil[simp]: \"orbit_list f x \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit_list f x \\<noteq> []", "by (simp add: orbit_list_def)"], ["", "lemma sset_orbits_list:\n  assumes \"permutation f\" shows \"sset (orbits_list f xs) = (orbit f) ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (orbits_list f xs) = orbit f ` set xs", "proof (induct \"length xs\" arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>xsa.\n           length xsa < length xs \\<Longrightarrow>\n           sset (orbits_list f xsa) = orbit f ` set xsa) \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "case less"], ["proof (state)\nthis:\n  length ?xs < length xs \\<Longrightarrow>\n  sset (orbits_list f ?xs) = orbit f ` set ?xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       (\\<And>xsa.\n           length xsa < length xs \\<Longrightarrow>\n           sset (orbits_list f xsa) = orbit f ` set xsa) \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (orbits_list f xs) = orbit f ` set xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sset (orbits_list f xs) = orbit f ` set xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> sset (orbits_list f xs) = orbit f ` set xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "then"], ["proof (chain)\npicking this:\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. sset (orbits_list f xs) = orbit f ` set xs", "by simp"], ["proof (state)\nthis:\n  sset (orbits_list f xs) = orbit f ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "case (Cons x' xs')"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "let ?xs'' = \"fold remove1 (orbit_list f x') xs'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "have A: \"sset (orbits_list f ?xs'') = orbit f ` set ?xs''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (orbits_list f (fold remove1 (orbit_list f x') xs')) =\n    orbit f ` set (fold remove1 (orbit_list f x') xs')", "using Cons"], ["proof (prove)\nusing this:\n  xs = x' # xs'\n\ngoal (1 subgoal):\n 1. sset (orbits_list f (fold remove1 (orbit_list f x') xs')) =\n    orbit f ` set (fold remove1 (orbit_list f x') xs')", "by (simp add: less_Suc_eq_le length_fold_remove1_le less.hyps)"], ["proof (state)\nthis:\n  sset (orbits_list f (fold remove1 (orbit_list f x') xs')) =\n  orbit f ` set (fold remove1 (orbit_list f x') xs')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "have B: \"set (orbit_list f x') = orbit f x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (orbit_list f x') = orbit f x'", "by (rule set_orbit_list) (simp add: permutation_self_in_orbit assms)"], ["proof (state)\nthis:\n  set (orbit_list f x') = orbit f x'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "have \"orbit f ` set (fold remove1 (orbit_list f x') xs') \\<subseteq> orbit f ` set xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit f ` set (fold remove1 (orbit_list f x') xs')\n    \\<subseteq> orbit f ` set xs'", "using set_fold_remove1[of _ xs']"], ["proof (prove)\nusing this:\n  set (fold remove1 ?xs xs') \\<subseteq> set xs'\n\ngoal (1 subgoal):\n 1. orbit f ` set (fold remove1 (orbit_list f x') xs')\n    \\<subseteq> orbit f ` set xs'", "by auto"], ["proof (state)\nthis:\n  orbit f ` set (fold remove1 (orbit_list f x') xs')\n  \\<subseteq> orbit f ` set xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "moreover"], ["proof (state)\nthis:\n  orbit f ` set (fold remove1 (orbit_list f x') xs')\n  \\<subseteq> orbit f ` set xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "have \"orbit f ` set xs' - {orbit f x'} \\<subseteq> (orbit f ` set (fold remove1 (orbit_list f x') xs'))\" (is \"?L \\<subseteq> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit f ` set xs' - {orbit f x'}\n    \\<subseteq> orbit f ` set (fold remove1 (orbit_list f x') xs')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> orbit f ` set xs' - {orbit f x'} \\<Longrightarrow>\n       x \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> orbit f ` set xs' - {orbit f x'} \\<Longrightarrow>\n       x \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "assume \"A \\<in> ?L\""], ["proof (state)\nthis:\n  A \\<in> orbit f ` set xs' - {orbit f x'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> orbit f ` set xs' - {orbit f x'} \\<Longrightarrow>\n       x \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "then"], ["proof (chain)\npicking this:\n  A \\<in> orbit f ` set xs' - {orbit f x'}", "obtain y where \"A = orbit f y\" \"y \\<in> set xs'\""], ["proof (prove)\nusing this:\n  A \\<in> orbit f ` set xs' - {orbit f x'}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>A = orbit f y; y \\<in> set xs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A = orbit f y\n  y \\<in> set xs'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> orbit f ` set xs' - {orbit f x'} \\<Longrightarrow>\n       x \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "have \"A \\<noteq> orbit f x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> orbit f x'", "using \\<open>A \\<in> ?L\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> orbit f ` set xs' - {orbit f x'}\n\ngoal (1 subgoal):\n 1. A \\<noteq> orbit f x'", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> orbit f x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> orbit f ` set xs' - {orbit f x'} \\<Longrightarrow>\n       x \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "from \\<open>A = _\\<close> \\<open>A \\<noteq> _\\<close>"], ["proof (chain)\npicking this:\n  A = orbit f y\n  A \\<noteq> orbit f x'", "have \"y \\<notin> orbit f x'\""], ["proof (prove)\nusing this:\n  A = orbit f y\n  A \\<noteq> orbit f x'\n\ngoal (1 subgoal):\n 1. y \\<notin> orbit f x'", "by (meson assms cyclic_on_orbit orbit_cyclic_eq3 permutation_permutes)"], ["proof (state)\nthis:\n  y \\<notin> orbit f x'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> orbit f ` set xs' - {orbit f x'} \\<Longrightarrow>\n       x \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "with \\<open>y \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> set xs'\n  y \\<notin> orbit f x'", "have \"y \\<in> set (fold remove1 (orbit_list f x') xs')\""], ["proof (prove)\nusing this:\n  y \\<in> set xs'\n  y \\<notin> orbit f x'\n\ngoal (1 subgoal):\n 1. y \\<in> set (fold remove1 (orbit_list f x') xs')", "by (auto simp: set_fold_remove1' set_orbit_list permutation_self_in_orbit assms)"], ["proof (state)\nthis:\n  y \\<in> set (fold remove1 (orbit_list f x') xs')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> orbit f ` set xs' - {orbit f x'} \\<Longrightarrow>\n       x \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "then"], ["proof (chain)\npicking this:\n  y \\<in> set (fold remove1 (orbit_list f x') xs')", "show \"A \\<in> ?R\""], ["proof (prove)\nusing this:\n  y \\<in> set (fold remove1 (orbit_list f x') xs')\n\ngoal (1 subgoal):\n 1. A \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "using \\<open>A = _\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> set (fold remove1 (orbit_list f x') xs')\n  A = orbit f y\n\ngoal (1 subgoal):\n 1. A \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')", "by auto"], ["proof (state)\nthis:\n  A \\<in> orbit f ` set (fold remove1 (orbit_list f x') xs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orbit f ` set xs' - {orbit f x'}\n  \\<subseteq> orbit f ` set (fold remove1 (orbit_list f x') xs')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       sset (orbits_list f xs) = orbit f ` set xs", "ultimately"], ["proof (chain)\npicking this:\n  orbit f ` set (fold remove1 (orbit_list f x') xs')\n  \\<subseteq> orbit f ` set xs'\n  orbit f ` set xs' - {orbit f x'}\n  \\<subseteq> orbit f ` set (fold remove1 (orbit_list f x') xs')", "show ?thesis"], ["proof (prove)\nusing this:\n  orbit f ` set (fold remove1 (orbit_list f x') xs')\n  \\<subseteq> orbit f ` set xs'\n  orbit f ` set xs' - {orbit f x'}\n  \\<subseteq> orbit f ` set (fold remove1 (orbit_list f x') xs')\n\ngoal (1 subgoal):\n 1. sset (orbits_list f xs) = orbit f ` set xs", "by (auto simp: A B Cons)"], ["proof (state)\nthis:\n  sset (orbits_list f xs) = orbit f ` set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sset (orbits_list f xs) = orbit f ` set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Relation to @{term cyclic_on}\\<close>"], ["", "lemma list_succ_orbit_list:\n  assumes \"s \\<in> orbit f s\" \"\\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x\"\n  shows \"list_succ (orbit_list f s) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ (orbit_list f s) = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_succ (orbit_list f s) = f", "have \"distinct (orbit_list f s)\" \"\\<And>x. x \\<notin> set (orbit_list f s) \\<Longrightarrow> x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (orbit_list f s) &&&\n    (\\<And>x. x \\<notin> set (orbit_list f s) \\<Longrightarrow> x = f x)", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x\n\ngoal (1 subgoal):\n 1. distinct (orbit_list f s) &&&\n    (\\<And>x. x \\<notin> set (orbit_list f s) \\<Longrightarrow> x = f x)", "by (simp_all add: distinct_orbit_list set_orbit_list)"], ["proof (state)\nthis:\n  distinct (orbit_list f s)\n  ?x \\<notin> set (orbit_list f s) \\<Longrightarrow> ?x = f ?x\n\ngoal (1 subgoal):\n 1. list_succ (orbit_list f s) = f", "moreover"], ["proof (state)\nthis:\n  distinct (orbit_list f s)\n  ?x \\<notin> set (orbit_list f s) \\<Longrightarrow> ?x = f ?x\n\ngoal (1 subgoal):\n 1. list_succ (orbit_list f s) = f", "have \"\\<And>i. i < length (orbit_list f s) \\<Longrightarrow> orbit_list f s ! (Suc i mod length (orbit_list f s)) = f (orbit_list f s ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (orbit_list f s) \\<Longrightarrow>\n       orbit_list f s ! (Suc i mod length (orbit_list f s)) =\n       f (orbit_list f s ! i)", "using funpow_dist1_prop[OF \\<open>s \\<in> orbit f s\\<close>]"], ["proof (prove)\nusing this:\n  (f ^^ funpow_dist1 f s s) s = s\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (orbit_list f s) \\<Longrightarrow>\n       orbit_list f s ! (Suc i mod length (orbit_list f s)) =\n       f (orbit_list f s ! i)", "by (auto simp: orbit_list_def funpow_mod_eq)"], ["proof (state)\nthis:\n  ?i < length (orbit_list f s) \\<Longrightarrow>\n  orbit_list f s ! (Suc ?i mod length (orbit_list f s)) =\n  f (orbit_list f s ! ?i)\n\ngoal (1 subgoal):\n 1. list_succ (orbit_list f s) = f", "ultimately"], ["proof (chain)\npicking this:\n  distinct (orbit_list f s)\n  ?x \\<notin> set (orbit_list f s) \\<Longrightarrow> ?x = f ?x\n  ?i < length (orbit_list f s) \\<Longrightarrow>\n  orbit_list f s ! (Suc ?i mod length (orbit_list f s)) =\n  f (orbit_list f s ! ?i)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (orbit_list f s)\n  ?x \\<notin> set (orbit_list f s) \\<Longrightarrow> ?x = f ?x\n  ?i < length (orbit_list f s) \\<Longrightarrow>\n  orbit_list f s ! (Suc ?i mod length (orbit_list f s)) =\n  f (orbit_list f s ! ?i)\n\ngoal (1 subgoal):\n 1. list_succ (orbit_list f s) = f", "by (auto simp: list_succ_def fun_eq_iff)"], ["proof (state)\nthis:\n  list_succ (orbit_list f s) = f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_succ_funpow_conv:\n  assumes A: \"distinct xs\" \"x \\<in> set xs\"\n  shows \"(list_succ xs ^^ n) x = xs ! ((index xs x + n) mod length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_succ xs ^^ n) x = xs ! ((index xs x + n) mod length xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (list_succ xs ^^ n) x = xs ! ((index xs x + n) mod length xs)", "have \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (list_succ xs ^^ n) x = xs ! ((index xs x + n) mod length xs)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (list_succ xs ^^ n) x = xs ! ((index xs x + n) mod length xs)", "by (induct n) (auto simp: hd_conv_nth A index_nth_id list_succ_def mod_simps)"], ["proof (state)\nthis:\n  (list_succ xs ^^ n) x = xs ! ((index xs x + n) mod length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orbit_list_succ:\n  assumes \"distinct xs\" \"x \\<in> set xs\"\n  shows \"orbit (list_succ xs) x = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit (list_succ xs) x = set xs", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> orbit (list_succ xs) x \\<Longrightarrow> xa \\<in> set xs\n 2. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> orbit (list_succ xs) x \\<Longrightarrow> xa \\<in> set xs\n 2. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "assume \"y \\<in> orbit (list_succ xs) x\""], ["proof (state)\nthis:\n  y \\<in> orbit (list_succ xs) x\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> orbit (list_succ xs) x \\<Longrightarrow> xa \\<in> set xs\n 2. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "then"], ["proof (chain)\npicking this:\n  y \\<in> orbit (list_succ xs) x", "show \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  y \\<in> orbit (list_succ xs) x\n\ngoal (1 subgoal):\n 1. y \\<in> set xs", "by induct (auto simp: list_succ_in_conv \\<open>x \\<in> set xs\\<close>)"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "moreover"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "{"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "have \"i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> \\<exists>n. xs ! j = xs ! ((i + n) mod length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. xs ! j = xs ! ((i + n) mod length xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. xs ! j = xs ! ((i + n) mod length xs)", "by (auto simp: exI[where x=\"j + (length xs - i)\"])"], ["proof (state)\nthis:\n  \\<lbrakk>i < length xs; j < length xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. xs ! j = xs ! ((i + n) mod length xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length xs; ?j2 < length xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. xs ! ?j2 = xs ! ((?i2 + n) mod length xs)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set xs \\<Longrightarrow> xa \\<in> orbit (list_succ xs) x", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> set xs\n  \\<lbrakk>?i2 < length xs; ?j2 < length xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. xs ! ?j2 = xs ! ((?i2 + n) mod length xs)", "show \"y \\<in> orbit (list_succ xs) x\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  \\<lbrakk>?i2 < length xs; ?j2 < length xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. xs ! ?j2 = xs ! ((?i2 + n) mod length xs)\n\ngoal (1 subgoal):\n 1. y \\<in> orbit (list_succ xs) x", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  \\<lbrakk>?i2 < length xs; ?j2 < length xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. xs ! ?j2 = xs ! ((?i2 + n) mod length xs)\n  distinct xs\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. y \\<in> orbit (list_succ xs) x", "by (auto simp: orbit_altdef_permutation permutation_list_succ list_succ_funpow_conv index_nth_id in_set_conv_nth)"], ["proof (state)\nthis:\n  y \\<in> orbit (list_succ xs) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_on_list_succ:\n  assumes \"distinct xs\" \"xs \\<noteq> []\" shows \"cyclic_on (list_succ xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_on (list_succ xs) (set xs)", "using assms last_in_set"], ["proof (prove)\nusing this:\n  distinct xs\n  xs \\<noteq> []\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. cyclic_on (list_succ xs) (set xs)", "by (auto simp: cyclic_on_def orbit_list_succ)"], ["", "lemma obtain_orbit_list_func:\n  assumes \"s \\<in> orbit f s\" \"\\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x\"\n  obtains xs where \"f = list_succ xs\" \"set xs = orbit f s\" \"distinct xs\" \"hd xs = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x", "have \"f = list_succ (orbit_list f s)\""], ["proof (prove)\nusing this:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x\n\ngoal (1 subgoal):\n 1. f = list_succ (orbit_list f s)", "by (simp add: list_succ_orbit_list)"], ["proof (state)\nthis:\n  f = list_succ (orbit_list f s)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  f = list_succ (orbit_list f s)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"set (orbit_list f s) = orbit f s\" \"distinct (orbit_list f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (orbit_list f s) = orbit f s &&& distinct (orbit_list f s)", "by (auto simp: set_orbit_list distinct_orbit_list assms)"], ["proof (state)\nthis:\n  set (orbit_list f s) = orbit f s\n  distinct (orbit_list f s)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  set (orbit_list f s) = orbit f s\n  distinct (orbit_list f s)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"hd (orbit_list f s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (orbit_list f s) = s", "by (simp add: orbit_list_def iterate_def hd_map del: upt_Suc)"], ["proof (state)\nthis:\n  hd (orbit_list f s) = s\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  f = list_succ (orbit_list f s)\n  set (orbit_list f s) = orbit f s\n  distinct (orbit_list f s)\n  hd (orbit_list f s) = s", "have \"\\<exists>xs. f = list_succ xs \\<and> set xs = orbit f s \\<and> distinct xs \\<and> hd xs = s\""], ["proof (prove)\nusing this:\n  f = list_succ (orbit_list f s)\n  set (orbit_list f s) = orbit f s\n  distinct (orbit_list f s)\n  hd (orbit_list f s) = s\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       f = list_succ xs \\<and>\n       set xs = orbit f s \\<and> distinct xs \\<and> hd xs = s", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs.\n     f = list_succ xs \\<and>\n     set xs = orbit f s \\<and> distinct xs \\<and> hd xs = s\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<exists>xs.\n     f = list_succ xs \\<and>\n     set xs = orbit f s \\<and> distinct xs \\<and> hd xs = s\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = orbit f s; distinct xs;\n         hd xs = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs.\n     f = list_succ xs \\<and>\n     set xs = orbit f s \\<and> distinct xs \\<and> hd xs = s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     f = list_succ xs \\<and>\n     set xs = orbit f s \\<and> distinct xs \\<and> hd xs = s\n\ngoal (1 subgoal):\n 1. thesis", "by (metis that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_on_obtain_list_succ:\n  assumes \"cyclic_on f S\" \"\\<And>x. x \\<notin> S \\<Longrightarrow> f x = x\"\n  obtains xs where \"f = list_succ xs\" \"set xs = S\" \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  cyclic_on f S\n  ?x \\<notin> S \\<Longrightarrow> f ?x = ?x", "obtain s where s: \"s \\<in> orbit f s\" \"\\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x\"  \"S = orbit f s\""], ["proof (prove)\nusing this:\n  cyclic_on f S\n  ?x \\<notin> S \\<Longrightarrow> f ?x = ?x\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> orbit f s;\n         \\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x;\n         S = orbit f s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: cyclic_on_def)"], ["proof (state)\nthis:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x\n  S = orbit f s\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x\n  S = orbit f s", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x\n  S = orbit f s\n\ngoal (1 subgoal):\n 1. thesis", "by (metis that obtain_orbit_list_func)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_on_obtain_list_succ':\n  assumes \"cyclic_on f S\" \"f permutes S\"\n  obtains xs where \"f = list_succ xs\" \"set xs = S\" \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  cyclic_on f S\n  f permutes S\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding permutes_def"], ["proof (prove)\nusing this:\n  cyclic_on f S\n  (\\<forall>x. x \\<notin> S \\<longrightarrow> f x = x) \\<and>\n  (\\<forall>y. \\<exists>!x. f x = y)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; set xs = S; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis cyclic_on_obtain_list_succ)"], ["", "lemma list_succ_unique:\n  assumes \"s \\<in> orbit f s\" \"\\<And>x. x \\<notin> orbit f s \\<Longrightarrow> f x = x\"\n  shows \"\\<exists>!xs. f = list_succ xs \\<and> distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x", "obtain xs where xs: \"f = list_succ xs\" \"distinct xs\" \"hd xs = s\" \"set xs = orbit f s\""], ["proof (prove)\nusing this:\n  s \\<in> orbit f s\n  ?x \\<notin> orbit f s \\<Longrightarrow> f ?x = ?x\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>f = list_succ xs; distinct xs; hd xs = s;\n         set xs = orbit f s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_orbit_list_func)"], ["proof (state)\nthis:\n  f = list_succ xs\n  distinct xs\n  hd xs = s\n  set xs = orbit f s\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "moreover"], ["proof (state)\nthis:\n  f = list_succ xs\n  distinct xs\n  hd xs = s\n  set xs = orbit f s\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "{"], ["proof (state)\nthis:\n  f = list_succ xs\n  distinct xs\n  hd xs = s\n  set xs = orbit f s\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "fix zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "assume A: \"f = list_succ zs\" \"distinct zs\" \"hd zs = s\" \"set zs = orbit f s\""], ["proof (state)\nthis:\n  f = list_succ zs\n  distinct zs\n  hd zs = s\n  set zs = orbit f s\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "then"], ["proof (chain)\npicking this:\n  f = list_succ zs\n  distinct zs\n  hd zs = s\n  set zs = orbit f s", "have \"zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  f = list_succ zs\n  distinct zs\n  hd zs = s\n  set zs = orbit f s\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "using \\<open>s \\<in> orbit f s\\<close>"], ["proof (prove)\nusing this:\n  f = list_succ zs\n  distinct zs\n  hd zs = s\n  set zs = orbit f s\n  s \\<in> orbit f s\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "from \\<open>distinct xs\\<close> \\<open>distinct zs\\<close> \\<open>set xs = orbit f s\\<close> \\<open>set zs = orbit f s\\<close>"], ["proof (chain)\npicking this:\n  distinct xs\n  distinct zs\n  set xs = orbit f s\n  set zs = orbit f s", "have len: \"length xs = length zs\""], ["proof (prove)\nusing this:\n  distinct xs\n  distinct zs\n  set xs = orbit f s\n  set zs = orbit f s\n\ngoal (1 subgoal):\n 1. length xs = length zs", "by (metis distinct_card)"], ["proof (state)\nthis:\n  length xs = length zs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "{"], ["proof (state)\nthis:\n  length xs = length zs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "assume \"n < length xs\""], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "then"], ["proof (chain)\npicking this:\n  n < length xs", "have \"zs ! n = xs ! n\""], ["proof (prove)\nusing this:\n  n < length xs\n\ngoal (1 subgoal):\n 1. zs ! n = xs ! n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length xs \\<Longrightarrow> zs ! 0 = xs ! 0\n 2. \\<And>n.\n       \\<lbrakk>n < length xs \\<Longrightarrow> zs ! n = xs ! n;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> zs ! Suc n = xs ! Suc n", "case 0"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (2 subgoals):\n 1. 0 < length xs \\<Longrightarrow> zs ! 0 = xs ! 0\n 2. \\<And>n.\n       \\<lbrakk>n < length xs \\<Longrightarrow> zs ! n = xs ! n;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> zs ! Suc n = xs ! Suc n", "with A xs \\<open>zs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  f = list_succ zs\n  distinct zs\n  hd zs = s\n  set zs = orbit f s\n  f = list_succ xs\n  distinct xs\n  hd xs = s\n  set xs = orbit f s\n  zs \\<noteq> []\n  0 < length xs", "show ?case"], ["proof (prove)\nusing this:\n  f = list_succ zs\n  distinct zs\n  hd zs = s\n  set zs = orbit f s\n  f = list_succ xs\n  distinct xs\n  hd xs = s\n  set xs = orbit f s\n  zs \\<noteq> []\n  0 < length xs\n\ngoal (1 subgoal):\n 1. zs ! 0 = xs ! 0", "by (simp add: hd_conv_nth nth_rotate_conv_nth)"], ["proof (state)\nthis:\n  zs ! 0 = xs ! 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length xs \\<Longrightarrow> zs ! n = xs ! n;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> zs ! Suc n = xs ! Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length xs \\<Longrightarrow> zs ! n = xs ! n;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> zs ! Suc n = xs ! Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  n < length xs \\<Longrightarrow> zs ! n = xs ! n\n  Suc n < length xs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length xs \\<Longrightarrow> zs ! n = xs ! n;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> zs ! Suc n = xs ! Suc n", "then"], ["proof (chain)\npicking this:\n  n < length xs \\<Longrightarrow> zs ! n = xs ! n\n  Suc n < length xs", "have \"list_succ zs (zs ! n) = list_succ xs (xs! n)\""], ["proof (prove)\nusing this:\n  n < length xs \\<Longrightarrow> zs ! n = xs ! n\n  Suc n < length xs\n\ngoal (1 subgoal):\n 1. list_succ zs (zs ! n) = list_succ xs (xs ! n)", "using \\<open>f = list_succ xs\\<close> \\<open>f = list_succ zs\\<close>"], ["proof (prove)\nusing this:\n  n < length xs \\<Longrightarrow> zs ! n = xs ! n\n  Suc n < length xs\n  f = list_succ xs\n  f = list_succ zs\n\ngoal (1 subgoal):\n 1. list_succ zs (zs ! n) = list_succ xs (xs ! n)", "by simp"], ["proof (state)\nthis:\n  list_succ zs (zs ! n) = list_succ xs (xs ! n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < length xs \\<Longrightarrow> zs ! n = xs ! n;\n        Suc n < length xs\\<rbrakk>\n       \\<Longrightarrow> zs ! Suc n = xs ! Suc n", "with \\<open>Suc n < _\\<close>"], ["proof (chain)\npicking this:\n  Suc n < length xs\n  list_succ zs (zs ! n) = list_succ xs (xs ! n)", "show ?case"], ["proof (prove)\nusing this:\n  Suc n < length xs\n  list_succ zs (zs ! n) = list_succ xs (xs ! n)\n\ngoal (1 subgoal):\n 1. zs ! Suc n = xs ! Suc n", "by (simp add:list_succ_nth len \\<open>distinct xs\\<close> \\<open>distinct zs\\<close>)"], ["proof (state)\nthis:\n  zs ! Suc n = xs ! Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zs ! n = xs ! n\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "}"], ["proof (state)\nthis:\n  ?n2 < length xs \\<Longrightarrow> zs ! ?n2 = xs ! ?n2\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "then"], ["proof (chain)\npicking this:\n  ?n2 < length xs \\<Longrightarrow> zs ! ?n2 = xs ! ?n2", "have \"zs = xs\""], ["proof (prove)\nusing this:\n  ?n2 < length xs \\<Longrightarrow> zs ! ?n2 = xs ! ?n2\n\ngoal (1 subgoal):\n 1. zs = xs", "by (metis len nth_equalityI)"], ["proof (state)\nthis:\n  zs = xs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>f = list_succ ?zs2; distinct ?zs2; hd ?zs2 = s;\n   set ?zs2 = orbit f s\\<rbrakk>\n  \\<Longrightarrow> ?zs2 = xs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "ultimately"], ["proof (chain)\npicking this:\n  f = list_succ xs\n  distinct xs\n  hd xs = s\n  set xs = orbit f s\n  \\<lbrakk>f = list_succ ?zs2; distinct ?zs2; hd ?zs2 = s;\n   set ?zs2 = orbit f s\\<rbrakk>\n  \\<Longrightarrow> ?zs2 = xs", "show ?thesis"], ["proof (prove)\nusing this:\n  f = list_succ xs\n  distinct xs\n  hd xs = s\n  set xs = orbit f s\n  \\<lbrakk>f = list_succ ?zs2; distinct ?zs2; hd ?zs2 = s;\n   set ?zs2 = orbit f s\\<rbrakk>\n  \\<Longrightarrow> ?zs2 = xs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       f = list_succ xs \\<and>\n       distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s", "by metis"], ["proof (state)\nthis:\n  \\<exists>!xs.\n     f = list_succ xs \\<and>\n     distinct xs \\<and> hd xs = s \\<and> set xs = orbit f s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distincts_orbits_list:\n  assumes \"distinct as\" \"permutation f\"\n  shows \"distincts (orbits_list f as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (orbits_list f as)", "using assms(1)"], ["proof (prove)\nusing this:\n  distinct as\n\ngoal (1 subgoal):\n 1. distincts (orbits_list f as)", "proof (induct \"length as\" arbitrary: as rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>\\<And>asa.\n                   \\<lbrakk>length asa < length as; distinct asa\\<rbrakk>\n                   \\<Longrightarrow> distincts (orbits_list f asa);\n        distinct as\\<rbrakk>\n       \\<Longrightarrow> distincts (orbits_list f as)", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>length ?as < length as; distinct ?as\\<rbrakk>\n  \\<Longrightarrow> distincts (orbits_list f ?as)\n  distinct as\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>\\<And>asa.\n                   \\<lbrakk>length asa < length as; distinct asa\\<rbrakk>\n                   \\<Longrightarrow> distincts (orbits_list f asa);\n        distinct as\\<rbrakk>\n       \\<Longrightarrow> distincts (orbits_list f as)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (orbits_list f as)", "proof (cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> distincts (orbits_list f as)\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> distincts (orbits_list f as)\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. distincts (orbits_list f as)", "by simp"], ["proof (state)\nthis:\n  distincts (orbits_list f as)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "case (Cons a as')"], ["proof (state)\nthis:\n  as = a # as'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "let ?as' = \"fold remove1 (orbit_list f a) as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "from Cons less.prems"], ["proof (chain)\npicking this:\n  as = a # as'\n  distinct as", "have A: \"distincts (orbits_list f (fold remove1 (orbit_list f a) as'))\""], ["proof (prove)\nusing this:\n  as = a # as'\n  distinct as\n\ngoal (1 subgoal):\n 1. distincts (orbits_list f (fold remove1 (orbit_list f a) as'))", "by (intro less) (auto simp: distinct_fold_remove1 length_fold_remove1_le less_Suc_eq_le)"], ["proof (state)\nthis:\n  distincts (orbits_list f (fold remove1 (orbit_list f a) as'))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "have B: \"set (orbit_list f a) \\<inter> \\<Union>(sset (orbits_list f (fold remove1 (orbit_list f a) as'))) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (orbit_list f a) \\<inter>\n    \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (orbit_list f a) \\<inter>\n    \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n    {}", "have \"orbit f a \\<inter> set (fold remove1 (orbit_list f a) as') = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit f a \\<inter> set (fold remove1 (orbit_list f a) as') = {}", "using assms less.prems Cons"], ["proof (prove)\nusing this:\n  distinct as\n  permutation f\n  distinct as\n  as = a # as'\n\ngoal (1 subgoal):\n 1. orbit f a \\<inter> set (fold remove1 (orbit_list f a) as') = {}", "by (simp add: set_fold_remove1_distinct set_orbit_list')"], ["proof (state)\nthis:\n  orbit f a \\<inter> set (fold remove1 (orbit_list f a) as') = {}\n\ngoal (1 subgoal):\n 1. set (orbit_list f a) \\<inter>\n    \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n    {}", "then"], ["proof (chain)\npicking this:\n  orbit f a \\<inter> set (fold remove1 (orbit_list f a) as') = {}", "have \"orbit f a \\<inter> \\<Union> (orbit f ` set (fold remove1 (orbit_list f a) as')) = {}\""], ["proof (prove)\nusing this:\n  orbit f a \\<inter> set (fold remove1 (orbit_list f a) as') = {}\n\ngoal (1 subgoal):\n 1. orbit f a \\<inter>\n    \\<Union> (orbit f ` set (fold remove1 (orbit_list f a) as')) =\n    {}", "by auto (metis assms(2) cyclic_on_orbit disjoint_iff_not_equal permutation_self_in_orbit[OF assms(2)] orbit_cyclic_eq3 permutation_permutes)"], ["proof (state)\nthis:\n  orbit f a \\<inter>\n  \\<Union> (orbit f ` set (fold remove1 (orbit_list f a) as')) =\n  {}\n\ngoal (1 subgoal):\n 1. set (orbit_list f a) \\<inter>\n    \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n    {}", "then"], ["proof (chain)\npicking this:\n  orbit f a \\<inter>\n  \\<Union> (orbit f ` set (fold remove1 (orbit_list f a) as')) =\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  orbit f a \\<inter>\n  \\<Union> (orbit f ` set (fold remove1 (orbit_list f a) as')) =\n  {}\n\ngoal (1 subgoal):\n 1. set (orbit_list f a) \\<inter>\n    \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n    {}", "using assms"], ["proof (prove)\nusing this:\n  orbit f a \\<inter>\n  \\<Union> (orbit f ` set (fold remove1 (orbit_list f a) as')) =\n  {}\n  distinct as\n  permutation f\n\ngoal (1 subgoal):\n 1. set (orbit_list f a) \\<inter>\n    \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n    {}", "by (auto simp: set_orbit_list' sset_orbits_list disjoint_iff_not_equal)"], ["proof (state)\nthis:\n  set (orbit_list f a) \\<inter>\n  \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (orbit_list f a) \\<inter>\n  \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow> distincts (orbits_list f as)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (orbits_list f as)", "using A B assms"], ["proof (prove)\nusing this:\n  distincts (orbits_list f (fold remove1 (orbit_list f a) as'))\n  set (orbit_list f a) \\<inter>\n  \\<Union> (sset (orbits_list f (fold remove1 (orbit_list f a) as'))) =\n  {}\n  distinct as\n  permutation f\n\ngoal (1 subgoal):\n 1. distincts (orbits_list f as)", "by (auto simp: distincts_Cons Cons distinct_orbit_list')"], ["proof (state)\nthis:\n  distincts (orbits_list f as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distincts (orbits_list f as)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_on_lists_succ':\n  assumes \"distincts xss\"\n  shows \"A \\<in> sset xss \\<Longrightarrow> cyclic_on (lists_succ xss) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> sset xss \\<Longrightarrow> cyclic_on (lists_succ xss) A", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n\ngoal (1 subgoal):\n 1. A \\<in> sset xss \\<Longrightarrow> cyclic_on (lists_succ xss) A", "proof (induction xss arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> sset []; distincts []\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ []) A\n 2. \\<And>a xss A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> sset xss; distincts xss\\<rbrakk>\n                   \\<Longrightarrow> cyclic_on (lists_succ xss) A;\n        A \\<in> sset (a # xss); distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ (a # xss)) A", "case Nil"], ["proof (state)\nthis:\n  A \\<in> sset []\n  distincts []\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<in> sset []; distincts []\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ []) A\n 2. \\<And>a xss A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> sset xss; distincts xss\\<rbrakk>\n                   \\<Longrightarrow> cyclic_on (lists_succ xss) A;\n        A \\<in> sset (a # xss); distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ (a # xss)) A", "then"], ["proof (chain)\npicking this:\n  A \\<in> sset []\n  distincts []", "show ?case"], ["proof (prove)\nusing this:\n  A \\<in> sset []\n  distincts []\n\ngoal (1 subgoal):\n 1. cyclic_on (lists_succ []) A", "by auto"], ["proof (state)\nthis:\n  cyclic_on (lists_succ []) A\n\ngoal (1 subgoal):\n 1. \\<And>a xss A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> sset xss; distincts xss\\<rbrakk>\n                   \\<Longrightarrow> cyclic_on (lists_succ xss) A;\n        A \\<in> sset (a # xss); distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ (a # xss)) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> sset xss; distincts xss\\<rbrakk>\n                   \\<Longrightarrow> cyclic_on (lists_succ xss) A;\n        A \\<in> sset (a # xss); distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ (a # xss)) A", "case (Cons xs xss A)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> sset xss; distincts xss\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (lists_succ xss) ?A\n  A \\<in> sset (xs # xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> sset xss; distincts xss\\<rbrakk>\n                   \\<Longrightarrow> cyclic_on (lists_succ xss) A;\n        A \\<in> sset (a # xss); distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ (a # xss)) A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?A \\<in> sset xss; distincts xss\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (lists_succ xss) ?A\n  A \\<in> sset (xs # xss)\n  distincts (xs # xss)", "have inter: \"set xs \\<inter> (\\<Union>ys\\<in>set xss. set ys) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> sset xss; distincts xss\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (lists_succ xss) ?A\n  A \\<in> sset (xs # xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. set xs \\<inter> \\<Union> (sset xss) = {}", "by (auto simp: distincts_Cons)"], ["proof (state)\nthis:\n  set xs \\<inter> \\<Union> (sset xss) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a xss A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> sset xss; distincts xss\\<rbrakk>\n                   \\<Longrightarrow> cyclic_on (lists_succ xss) A;\n        A \\<in> sset (a # xss); distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ (a # xss)) A", "note pcp[OF _ _ inter] = permutes_comp_preserves_cyclic1 permutes_comp_preserves_cyclic2"], ["proof (state)\nthis:\n  \\<lbrakk>?g permutes \\<Union> (sset xss); cyclic_on ?f ?C;\n   ?C \\<subseteq> set xs\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (?f \\<circ> ?g) ?C\n  \\<lbrakk>?f permutes set xs; cyclic_on ?g ?C;\n   ?C \\<subseteq> \\<Union> (sset xss)\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (?f \\<circ> ?g) ?C\n\ngoal (1 subgoal):\n 1. \\<And>a xss A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> sset xss; distincts xss\\<rbrakk>\n                   \\<Longrightarrow> cyclic_on (lists_succ xss) A;\n        A \\<in> sset (a # xss); distincts (a # xss)\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (lists_succ (a # xss)) A", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>?A \\<in> sset xss; distincts xss\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (lists_succ xss) ?A\n  A \\<in> sset (xs # xss)\n  distincts (xs # xss)", "show \"cyclic_on (lists_succ (xs # xss)) A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> sset xss; distincts xss\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (lists_succ xss) ?A\n  A \\<in> sset (xs # xss)\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. cyclic_on (lists_succ (xs # xss)) A", "by (cases \"A = set xs\")\n      (auto intro: pcp simp: cyclic_on_list_succ list_succ_permutes\n        lists_succ_permutes lists_succ_Cons_pf distincts_Cons)"], ["proof (state)\nthis:\n  cyclic_on (lists_succ (xs # xss)) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_on_lists_succ:\n  assumes \"distincts xss\"\n  shows \"\\<And>xs. xs \\<in> set xss \\<Longrightarrow> cyclic_on (lists_succ xss) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> set xss \\<Longrightarrow>\n       cyclic_on (lists_succ xss) (set xs)", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> set xss \\<Longrightarrow>\n       cyclic_on (lists_succ xss) (set xs)", "by (auto intro: cyclic_on_lists_succ')"], ["", "lemma permutes_as_lists_succ:\n  assumes \"distincts xss\"\n  assumes ls_eq: \"\\<And>xs. xs \\<in> set xss \\<Longrightarrow> list_succ xs = perm_restrict f (set xs)\"\n  assumes \"f permutes (\\<Union>(sset xss))\"\n  shows \"f = lists_succ xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = lists_succ xss", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n  ?xs \\<in> set xss \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. f = lists_succ xss", "proof (induct xss arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>distincts [];\n        \\<And>xs.\n           xs \\<in> set [] \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset [])\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ []\n 2. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "case Nil"], ["proof (state)\nthis:\n  distincts []\n  ?xs \\<in> set [] \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset [])\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>distincts [];\n        \\<And>xs.\n           xs \\<in> set [] \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset [])\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ []\n 2. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "then"], ["proof (chain)\npicking this:\n  distincts []\n  ?xs \\<in> set [] \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset [])", "show ?case"], ["proof (prove)\nusing this:\n  distincts []\n  ?xs \\<in> set [] \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset [])\n\ngoal (1 subgoal):\n 1. f = lists_succ []", "by simp"], ["proof (state)\nthis:\n  f = lists_succ []\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "case (Cons xs xss)"], ["proof (state)\nthis:\n  \\<lbrakk>distincts xss;\n   \\<And>xs.\n      xs \\<in> set xss \\<Longrightarrow>\n      list_succ xs = perm_restrict ?f (set xs);\n   ?f permutes \\<Union> (sset xss)\\<rbrakk>\n  \\<Longrightarrow> ?f = lists_succ xss\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "let ?sets = \"\\<lambda>xss. \\<Union>ys \\<in> set xss. set ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "have xs: \"distinct xs\" \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs &&& xs \\<noteq> []", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>distincts xss;\n   \\<And>xs.\n      xs \\<in> set xss \\<Longrightarrow>\n      list_succ xs = perm_restrict ?f (set xs);\n   ?f permutes \\<Union> (sset xss)\\<rbrakk>\n  \\<Longrightarrow> ?f = lists_succ xss\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n\ngoal (1 subgoal):\n 1. distinct xs &&& xs \\<noteq> []", "by (auto simp: distincts_Cons)"], ["proof (state)\nthis:\n  distinct xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "have f_xs: \"perm_restrict f (set xs) = list_succ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_restrict f (set xs) = list_succ xs", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>distincts xss;\n   \\<And>xs.\n      xs \\<in> set xss \\<Longrightarrow>\n      list_succ xs = perm_restrict ?f (set xs);\n   ?f permutes \\<Union> (sset xss)\\<rbrakk>\n  \\<Longrightarrow> ?f = lists_succ xss\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n\ngoal (1 subgoal):\n 1. perm_restrict f (set xs) = list_succ xs", "by simp"], ["proof (state)\nthis:\n  perm_restrict f (set xs) = list_succ xs\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "have co_xs: \"cyclic_on (perm_restrict f (set xs)) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_on (perm_restrict f (set xs)) (set xs)", "unfolding f_xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_on (list_succ xs) (set xs)", "using xs"], ["proof (prove)\nusing this:\n  distinct xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. cyclic_on (list_succ xs) (set xs)", "by (rule cyclic_on_list_succ)"], ["proof (state)\nthis:\n  cyclic_on (perm_restrict f (set xs)) (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "have perm_xs: \"perm_restrict f (set xs) permutes set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_restrict f (set xs) permutes set xs", "unfolding f_xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ xs permutes set xs", "using \\<open>distinct xs\\<close>"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. list_succ xs permutes set xs", "by (rule list_succ_permutes)"], ["proof (state)\nthis:\n  perm_restrict f (set xs) permutes set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "have perm_xss: \"perm_restrict f (?sets xss) permutes (?sets xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "have \"perm_restrict f (?sets (xs # xss) - set xs) permutes (?sets (xs # xss) - set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset (xs # xss)) - set xs) permutes\n    \\<Union> (sset (xs # xss)) - set xs", "using Cons co_xs"], ["proof (prove)\nusing this:\n  \\<lbrakk>distincts xss;\n   \\<And>xs.\n      xs \\<in> set xss \\<Longrightarrow>\n      list_succ xs = perm_restrict ?f (set xs);\n   ?f permutes \\<Union> (sset xss)\\<rbrakk>\n  \\<Longrightarrow> ?f = lists_succ xss\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n  cyclic_on (perm_restrict f (set xs)) (set xs)\n\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset (xs # xss)) - set xs) permutes\n    \\<Union> (sset (xs # xss)) - set xs", "by (intro perm_restrict_diff_cyclic) (auto simp: cyclic_on_perm_restrict)"], ["proof (state)\nthis:\n  perm_restrict f (\\<Union> (sset (xs # xss)) - set xs) permutes\n  \\<Union> (sset (xs # xss)) - set xs\n\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "also"], ["proof (state)\nthis:\n  perm_restrict f (\\<Union> (sset (xs # xss)) - set xs) permutes\n  \\<Union> (sset (xs # xss)) - set xs\n\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "have \"?sets (xs # xss) - set xs = ?sets xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (sset (xs # xss)) - set xs = \\<Union> (sset xss)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>distincts xss;\n   \\<And>xs.\n      xs \\<in> set xss \\<Longrightarrow>\n      list_succ xs = perm_restrict ?f (set xs);\n   ?f permutes \\<Union> (sset xss)\\<rbrakk>\n  \\<Longrightarrow> ?f = lists_succ xss\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n\ngoal (1 subgoal):\n 1. \\<Union> (sset (xs # xss)) - set xs = \\<Union> (sset xss)", "by (auto simp: distincts_Cons)"], ["proof (state)\nthis:\n  \\<Union> (sset (xs # xss)) - set xs = \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "finally"], ["proof (chain)\npicking this:\n  perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "show ?thesis"], ["proof (prove)\nusing this:\n  perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "."], ["proof (state)\nthis:\n  perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "have f_xss: \"perm_restrict f (?sets xss) = lists_succ xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) = lists_succ xss", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) = lists_succ xss", "have *: \"\\<And>xs. xs \\<in> set xss \\<Longrightarrow> ((\\<Union>x\\<in>set xss. set x) \\<inter> set xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> set xss \\<Longrightarrow>\n       \\<Union> (sset xss) \\<inter> set xs = set xs", "by blast"], ["proof (state)\nthis:\n  ?xs1 \\<in> set xss \\<Longrightarrow>\n  \\<Union> (sset xss) \\<inter> set ?xs1 = set ?xs1\n\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) = lists_succ xss", "with perm_xss Cons.prems"], ["proof (chain)\npicking this:\n  perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n  ?xs1 \\<in> set xss \\<Longrightarrow>\n  \\<Union> (sset xss) \\<inter> set ?xs1 = set ?xs1", "show ?thesis"], ["proof (prove)\nusing this:\n  perm_restrict f (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n  ?xs1 \\<in> set xss \\<Longrightarrow>\n  \\<Union> (sset xss) \\<inter> set ?xs1 = set ?xs1\n\ngoal (1 subgoal):\n 1. perm_restrict f (\\<Union> (sset xss)) = lists_succ xss", "by (intro Cons.hyps) (auto simp: distincts_Cons perm_restrict_perm_restrict *)"], ["proof (state)\nthis:\n  perm_restrict f (\\<Union> (sset xss)) = lists_succ xss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  perm_restrict f (\\<Union> (sset xss)) = lists_succ xss\n\ngoal (1 subgoal):\n 1. \\<And>a xss f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>distincts xss;\n                    \\<And>xs.\n                       xs \\<in> set xss \\<Longrightarrow>\n                       list_succ xs = perm_restrict f (set xs);\n                    f permutes \\<Union> (sset xss)\\<rbrakk>\n                   \\<Longrightarrow> f = lists_succ xss;\n        distincts (a # xss);\n        \\<And>xs.\n           xs \\<in> set (a # xss) \\<Longrightarrow>\n           list_succ xs = perm_restrict f (set xs);\n        f permutes \\<Union> (sset (a # xss))\\<rbrakk>\n       \\<Longrightarrow> f = lists_succ (a # xss)", "from Cons.prems"], ["proof (chain)\npicking this:\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))", "show \"f = lists_succ (xs # xss)\""], ["proof (prove)\nusing this:\n  distincts (xs # xss)\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow>\n  list_succ ?xs = perm_restrict f (set ?xs)\n  f permutes \\<Union> (sset (xs # xss))\n\ngoal (1 subgoal):\n 1. f = lists_succ (xs # xss)", "by (simp add: lists_succ_Cons_pf distincts_Cons f_xss[symmetric]\n      perm_restrict_union perm_xs perm_xss)"], ["proof (state)\nthis:\n  f = lists_succ (xs # xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_on_obtain_lists_succ:\n  assumes\n    permutes: \"f permutes S\" and\n    S: \"S = \\<Union>(sset css)\" and\n    dists: \"distincts css\" and\n    cyclic: \"\\<And>cs. cs \\<in> set css \\<Longrightarrow> cyclic_on f (set cs)\"\n  obtains xss where \"f = lists_succ xss\" \"distincts xss\" \"map set xss = map set css\" \"map hd xss = map hd css\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?fc = \"\\<lambda>cs. perm_restrict f (set cs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define some_list where \"some_list cs = (SOME xs. ?fc cs = list_succ xs \\<and> set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs)\" for cs"], ["proof (state)\nthis:\n  some_list ?cs =\n  (SOME xs.\n      perm_restrict f (set ?cs) = list_succ xs \\<and>\n      set xs = set ?cs \\<and> distinct xs \\<and> hd xs = hd ?cs)\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  some_list ?cs =\n  (SOME xs.\n      perm_restrict f (set ?cs) = list_succ xs \\<and>\n      set xs = set ?cs \\<and> distinct xs \\<and> hd xs = hd ?cs)\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix cs"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"cs \\<in> set css\""], ["proof (state)\nthis:\n  cs \\<in> set css\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  cs \\<in> set css", "have \"cyclic_on (?fc cs) (set cs)\" \"\\<And>x. x \\<notin> set cs \\<Longrightarrow> ?fc cs x = x\" \"hd cs \\<in> set cs\""], ["proof (prove)\nusing this:\n  cs \\<in> set css\n\ngoal (1 subgoal):\n 1. cyclic_on (perm_restrict f (set cs)) (set cs) &&&\n    (\\<And>x.\n        x \\<notin> set cs \\<Longrightarrow>\n        perm_restrict f (set cs) x = x) &&&\n    hd cs \\<in> set cs", "using cyclic dists"], ["proof (prove)\nusing this:\n  cs \\<in> set css\n  ?cs \\<in> set css \\<Longrightarrow> cyclic_on f (set ?cs)\n  distincts css\n\ngoal (1 subgoal):\n 1. cyclic_on (perm_restrict f (set cs)) (set cs) &&&\n    (\\<And>x.\n        x \\<notin> set cs \\<Longrightarrow>\n        perm_restrict f (set cs) x = x) &&&\n    hd cs \\<in> set cs", "by (auto simp add: cyclic_on_perm_restrict perm_restrict_def distincts_def)"], ["proof (state)\nthis:\n  cyclic_on (perm_restrict f (set cs)) (set cs)\n  ?x \\<notin> set cs \\<Longrightarrow> perm_restrict f (set cs) ?x = ?x\n  hd cs \\<in> set cs\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  cyclic_on (perm_restrict f (set cs)) (set cs)\n  ?x \\<notin> set cs \\<Longrightarrow> perm_restrict f (set cs) ?x = ?x\n  hd cs \\<in> set cs", "have \"hd cs \\<in> orbit (?fc cs) (hd cs)\"  \"\\<And>x. x \\<notin> orbit (?fc cs) (hd cs) \\<Longrightarrow> ?fc cs x = x\" \"hd cs \\<in> set cs\" \"set cs = orbit (?fc cs) (hd cs)\""], ["proof (prove)\nusing this:\n  cyclic_on (perm_restrict f (set cs)) (set cs)\n  ?x \\<notin> set cs \\<Longrightarrow> perm_restrict f (set cs) ?x = ?x\n  hd cs \\<in> set cs\n\ngoal (1 subgoal):\n 1. (hd cs \\<in> orbit (perm_restrict f (set cs)) (hd cs) &&&\n     (\\<And>x.\n         x \\<notin> orbit (perm_restrict f (set cs))\n                     (hd cs) \\<Longrightarrow>\n         perm_restrict f (set cs) x = x)) &&&\n    hd cs \\<in> set cs &&& set cs = orbit (perm_restrict f (set cs)) (hd cs)", "by (auto simp: cyclic_on_alldef)"], ["proof (state)\nthis:\n  hd cs \\<in> orbit (perm_restrict f (set cs)) (hd cs)\n  ?x \\<notin> orbit (perm_restrict f (set cs)) (hd cs) \\<Longrightarrow>\n  perm_restrict f (set cs) ?x = ?x\n  hd cs \\<in> set cs\n  set cs = orbit (perm_restrict f (set cs)) (hd cs)\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  hd cs \\<in> orbit (perm_restrict f (set cs)) (hd cs)\n  ?x \\<notin> orbit (perm_restrict f (set cs)) (hd cs) \\<Longrightarrow>\n  perm_restrict f (set cs) ?x = ?x\n  hd cs \\<in> set cs\n  set cs = orbit (perm_restrict f (set cs)) (hd cs)", "have \"\\<exists>xs. ?fc cs = list_succ xs \\<and> set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs\""], ["proof (prove)\nusing this:\n  hd cs \\<in> orbit (perm_restrict f (set cs)) (hd cs)\n  ?x \\<notin> orbit (perm_restrict f (set cs)) (hd cs) \\<Longrightarrow>\n  perm_restrict f (set cs) ?x = ?x\n  hd cs \\<in> set cs\n  set cs = orbit (perm_restrict f (set cs)) (hd cs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       perm_restrict f (set cs) = list_succ xs \\<and>\n       set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs", "by (metis obtain_orbit_list_func)"], ["proof (state)\nthis:\n  \\<exists>xs.\n     perm_restrict f (set cs) = list_succ xs \\<and>\n     set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs.\n     perm_restrict f (set cs) = list_succ xs \\<and>\n     set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs", "have \"?fc cs = list_succ (some_list cs) \\<and> set (some_list cs) = set cs \\<and> distinct (some_list cs) \\<and> hd (some_list cs) = hd cs\""], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     perm_restrict f (set cs) = list_succ xs \\<and>\n     set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs\n\ngoal (1 subgoal):\n 1. perm_restrict f (set cs) = list_succ (some_list cs) \\<and>\n    set (some_list cs) = set cs \\<and>\n    distinct (some_list cs) \\<and> hd (some_list cs) = hd cs", "unfolding some_list_def"], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     perm_restrict f (set cs) = list_succ xs \\<and>\n     set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs\n\ngoal (1 subgoal):\n 1. perm_restrict f (set cs) =\n    list_succ\n     (SOME xs.\n         perm_restrict f (set cs) = list_succ xs \\<and>\n         set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs) \\<and>\n    set (SOME xs.\n            perm_restrict f (set cs) = list_succ xs \\<and>\n            set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs) =\n    set cs \\<and>\n    distinct\n     (SOME xs.\n         perm_restrict f (set cs) = list_succ xs \\<and>\n         set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs) \\<and>\n    hd (SOME xs.\n           perm_restrict f (set cs) = list_succ xs \\<and>\n           set xs = set cs \\<and> distinct xs \\<and> hd xs = hd cs) =\n    hd cs", "by (rule someI_ex)"], ["proof (state)\nthis:\n  perm_restrict f (set cs) = list_succ (some_list cs) \\<and>\n  set (some_list cs) = set cs \\<and>\n  distinct (some_list cs) \\<and> hd (some_list cs) = hd cs\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  perm_restrict f (set cs) = list_succ (some_list cs) \\<and>\n  set (some_list cs) = set cs \\<and>\n  distinct (some_list cs) \\<and> hd (some_list cs) = hd cs", "have \"?fc cs = list_succ (some_list cs)\" \"set (some_list cs) = set cs\" \"distinct (some_list cs)\" \"hd (some_list cs) = hd cs\""], ["proof (prove)\nusing this:\n  perm_restrict f (set cs) = list_succ (some_list cs) \\<and>\n  set (some_list cs) = set cs \\<and>\n  distinct (some_list cs) \\<and> hd (some_list cs) = hd cs\n\ngoal (1 subgoal):\n 1. (perm_restrict f (set cs) = list_succ (some_list cs) &&&\n     set (some_list cs) = set cs) &&&\n    distinct (some_list cs) &&& hd (some_list cs) = hd cs", "by auto"], ["proof (state)\nthis:\n  perm_restrict f (set cs) = list_succ (some_list cs)\n  set (some_list cs) = set cs\n  distinct (some_list cs)\n  hd (some_list cs) = hd cs\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  ?cs2 \\<in> set css \\<Longrightarrow>\n  perm_restrict f (set ?cs2) = list_succ (some_list ?cs2)\n  ?cs2 \\<in> set css \\<Longrightarrow> set (some_list ?cs2) = set ?cs2\n  ?cs2 \\<in> set css \\<Longrightarrow> distinct (some_list ?cs2)\n  ?cs2 \\<in> set css \\<Longrightarrow> hd (some_list ?cs2) = hd ?cs2\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note sl_cs  = this"], ["proof (state)\nthis:\n  ?cs2 \\<in> set css \\<Longrightarrow>\n  perm_restrict f (set ?cs2) = list_succ (some_list ?cs2)\n  ?cs2 \\<in> set css \\<Longrightarrow> set (some_list ?cs2) = set ?cs2\n  ?cs2 \\<in> set css \\<Longrightarrow> distinct (some_list ?cs2)\n  ?cs2 \\<in> set css \\<Longrightarrow> hd (some_list ?cs2) = hd ?cs2\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<And>cs. cs \\<in> set css \\<Longrightarrow> cs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs. cs \\<in> set css \\<Longrightarrow> cs \\<noteq> []", "using dists"], ["proof (prove)\nusing this:\n  distincts css\n\ngoal (1 subgoal):\n 1. \\<And>cs. cs \\<in> set css \\<Longrightarrow> cs \\<noteq> []", "by (auto simp: distincts_def)"], ["proof (state)\nthis:\n  ?cs \\<in> set css \\<Longrightarrow> ?cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?cs \\<in> set css \\<Longrightarrow> ?cs \\<noteq> []", "have some_list_ne: \"\\<And>cs. cs \\<in> set css \\<Longrightarrow> some_list cs \\<noteq> []\""], ["proof (prove)\nusing this:\n  ?cs \\<in> set css \\<Longrightarrow> ?cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>cs. cs \\<in> set css \\<Longrightarrow> some_list cs \\<noteq> []", "by (metis set_empty sl_cs(2))"], ["proof (state)\nthis:\n  ?cs \\<in> set css \\<Longrightarrow> some_list ?cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have set: \"map set (map some_list css) = map set css\" \"map hd (map some_list css) = map hd css\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map set (map some_list css) = map set css &&&\n    map hd (map some_list css) = map hd css", "using sl_cs(2,4)"], ["proof (prove)\nusing this:\n  ?cs2 \\<in> set css \\<Longrightarrow> set (some_list ?cs2) = set ?cs2\n  ?cs2 \\<in> set css \\<Longrightarrow> hd (some_list ?cs2) = hd ?cs2\n\ngoal (1 subgoal):\n 1. map set (map some_list css) = map set css &&&\n    map hd (map some_list css) = map hd css", "by (auto simp add: map_idI)"], ["proof (state)\nthis:\n  map set (map some_list css) = map set css\n  map hd (map some_list css) = map hd css\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have distincts: \"distincts (map some_list css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "have c_dist: \"\\<And>xs ys. \\<lbrakk>xs\\<in>set css; ys\\<in>set css; xs \\<noteq> ys\\<rbrakk> \\<Longrightarrow> set xs \\<inter> set ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<in> set css; ys \\<in> set css; xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> set xs \\<inter> set ys = {}", "using dists"], ["proof (prove)\nusing this:\n  distincts css\n\ngoal (1 subgoal):\n 1. \\<And>xs ys.\n       \\<lbrakk>xs \\<in> set css; ys \\<in> set css; xs \\<noteq> ys\\<rbrakk>\n       \\<Longrightarrow> set xs \\<inter> set ys = {}", "by (auto simp: distincts_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?xs \\<in> set css; ?ys \\<in> set css; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "have \"distinct (map some_list css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map some_list css)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map some_list css)", "have \"inj_on some_list (set css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on some_list (set css)", "using sl_cs(2) c_dist"], ["proof (prove)\nusing this:\n  ?cs2 \\<in> set css \\<Longrightarrow> set (some_list ?cs2) = set ?cs2\n  \\<lbrakk>?xs \\<in> set css; ?ys \\<in> set css; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. inj_on some_list (set css)", "by (intro inj_onI) (metis inf.idem set_empty)"], ["proof (state)\nthis:\n  inj_on some_list (set css)\n\ngoal (1 subgoal):\n 1. distinct (map some_list css)", "with \\<open>distincts css\\<close>"], ["proof (chain)\npicking this:\n  distincts css\n  inj_on some_list (set css)", "show ?thesis"], ["proof (prove)\nusing this:\n  distincts css\n  inj_on some_list (set css)\n\ngoal (1 subgoal):\n 1. distinct (map some_list css)", "by (auto simp: distincts_distinct distinct_map)"], ["proof (state)\nthis:\n  distinct (map some_list css)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map some_list css)\n\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "moreover"], ["proof (state)\nthis:\n  distinct (map some_list css)\n\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "have \"\\<forall>xs\\<in>set (map some_list css). distinct xs \\<and> xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>set (map some_list css).\n       distinct xs \\<and> xs \\<noteq> []", "using sl_cs(3) some_list_ne"], ["proof (prove)\nusing this:\n  ?cs2 \\<in> set css \\<Longrightarrow> distinct (some_list ?cs2)\n  ?cs \\<in> set css \\<Longrightarrow> some_list ?cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>set (map some_list css).\n       distinct xs \\<and> xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>set (map some_list css). distinct xs \\<and> xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "moreover"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>set (map some_list css). distinct xs \\<and> xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "from c_dist"], ["proof (chain)\npicking this:\n  \\<lbrakk>?xs \\<in> set css; ?ys \\<in> set css; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}", "have \"(\\<forall>xs\\<in>set (map some_list css). \\<forall>ys\\<in>set (map some_list css). xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs \\<in> set css; ?ys \\<in> set css; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>set (map some_list css).\n       \\<forall>ys\\<in>set (map some_list css).\n          xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {}", "using sl_cs(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs \\<in> set css; ?ys \\<in> set css; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> set ?xs \\<inter> set ?ys = {}\n  ?cs2 \\<in> set css \\<Longrightarrow> set (some_list ?cs2) = set ?cs2\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>set (map some_list css).\n       \\<forall>ys\\<in>set (map some_list css).\n          xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>set (map some_list css).\n     \\<forall>ys\\<in>set (map some_list css).\n        xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map some_list css)\n  \\<forall>xs\\<in>set (map some_list css). distinct xs \\<and> xs \\<noteq> []\n  \\<forall>xs\\<in>set (map some_list css).\n     \\<forall>ys\\<in>set (map some_list css).\n        xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map some_list css)\n  \\<forall>xs\\<in>set (map some_list css). distinct xs \\<and> xs \\<noteq> []\n  \\<forall>xs\\<in>set (map some_list css).\n     \\<forall>ys\\<in>set (map some_list css).\n        xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. distincts (map some_list css)", "by (simp add: distincts_def)"], ["proof (state)\nthis:\n  distincts (map some_list css)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distincts (map some_list css)\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have f: \"f = lists_succ (map some_list css)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = lists_succ (map some_list css)", "using distincts"], ["proof (prove)\nusing this:\n  distincts (map some_list css)\n\ngoal (1 subgoal):\n 1. f = lists_succ (map some_list css)", "proof (rule permutes_as_lists_succ)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs \\<in> set (map some_list css) \\<Longrightarrow>\n       list_succ xs = perm_restrict f (set xs)\n 2. f permutes \\<Union> (sset (map some_list css))", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs \\<in> set (map some_list css) \\<Longrightarrow>\n       list_succ xs = perm_restrict f (set xs)\n 2. f permutes \\<Union> (sset (map some_list css))", "assume \"xs \\<in> set (map some_list css)\""], ["proof (state)\nthis:\n  xs \\<in> set (map some_list css)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       xs \\<in> set (map some_list css) \\<Longrightarrow>\n       list_succ xs = perm_restrict f (set xs)\n 2. f permutes \\<Union> (sset (map some_list css))", "then"], ["proof (chain)\npicking this:\n  xs \\<in> set (map some_list css)", "show \"list_succ xs = perm_restrict f (set xs)\""], ["proof (prove)\nusing this:\n  xs \\<in> set (map some_list css)\n\ngoal (1 subgoal):\n 1. list_succ xs = perm_restrict f (set xs)", "using sl_cs(1) sl_cs(2)"], ["proof (prove)\nusing this:\n  xs \\<in> set (map some_list css)\n  ?cs2 \\<in> set css \\<Longrightarrow>\n  perm_restrict f (set ?cs2) = list_succ (some_list ?cs2)\n  ?cs2 \\<in> set css \\<Longrightarrow> set (some_list ?cs2) = set ?cs2\n\ngoal (1 subgoal):\n 1. list_succ xs = perm_restrict f (set xs)", "by auto"], ["proof (state)\nthis:\n  list_succ xs = perm_restrict f (set xs)\n\ngoal (1 subgoal):\n 1. f permutes \\<Union> (sset (map some_list css))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f permutes \\<Union> (sset (map some_list css))", "have \"S = (\\<Union>xs\\<in>set (map some_list css). set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = \\<Union> (sset (map some_list css))", "using S sl_cs(2)"], ["proof (prove)\nusing this:\n  S = \\<Union> (sset css)\n  ?cs2 \\<in> set css \\<Longrightarrow> set (some_list ?cs2) = set ?cs2\n\ngoal (1 subgoal):\n 1. S = \\<Union> (sset (map some_list css))", "by auto"], ["proof (state)\nthis:\n  S = \\<Union> (sset (map some_list css))\n\ngoal (1 subgoal):\n 1. f permutes \\<Union> (sset (map some_list css))", "with permutes"], ["proof (chain)\npicking this:\n  f permutes S\n  S = \\<Union> (sset (map some_list css))", "show \"f permutes \\<Union>(sset (map some_list css))\""], ["proof (prove)\nusing this:\n  f permutes S\n  S = \\<Union> (sset (map some_list css))\n\ngoal (1 subgoal):\n 1. f permutes \\<Union> (sset (map some_list css))", "by simp"], ["proof (state)\nthis:\n  f permutes \\<Union> (sset (map some_list css))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = lists_succ (map some_list css)\n\ngoal (1 subgoal):\n 1. (\\<And>xss.\n        \\<lbrakk>f = lists_succ xss; distincts xss;\n         map set xss = map set css; map hd xss = map hd css\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from f distincts set"], ["proof (chain)\npicking this:\n  f = lists_succ (map some_list css)\n  distincts (map some_list css)\n  map set (map some_list css) = map set css\n  map hd (map some_list css) = map hd css", "show ?thesis"], ["proof (prove)\nusing this:\n  f = lists_succ (map some_list css)\n  distincts (map some_list css)\n  map set (map some_list css) = map set css\n  map hd (map some_list css) = map hd css\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Permutations of a List\\<close>"], ["", "lemma length_remove1_less:\n  assumes \"x \\<in> set xs\" shows \"length (remove1 x xs) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remove1 x xs) < length xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (remove1 x xs) < length xs", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "have \"0 < length xs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. length (remove1 x xs) < length xs", "with assms"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  0 < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  0 < length xs\n\ngoal (1 subgoal):\n 1. length (remove1 x xs) < length xs", "by (auto simp: length_remove1)"], ["proof (state)\nthis:\n  length (remove1 x xs) < length xs\n\ngoal:\nNo subgoals!", "qed"], ["", "context notes [simp] = length_remove1_less begin"], ["", "fun permutations :: \"'a list \\<Rightarrow> 'a list list\" where\n  permutations_Nil: \"permutations [] = [[]]\"\n| permutations_Cons:\n    \"permutations xs = [y # ys. y <- xs, ys <- permutations (remove1 y xs)]\""], ["", "end"], ["", "declare permutations_Cons[simp del]"], ["", "text \\<open>\n  The function above returns all permutations of a list. The function below computes\n  only those which yield distinct cyclic permutation functions (cf. @{term list_succ}).\n\\<close>"], ["", "fun cyc_permutations :: \"'a list \\<Rightarrow> 'a list list\" where\n  \"cyc_permutations [] = [[]]\"\n| \"cyc_permutations (x # xs) = map (Cons x) (permutations xs)\""], ["", "lemma nil_in_permutations[simp]: \"[] \\<in> set (permutations xs) \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<in> set (permutations xs)) = (xs = [])", "by (induct xs) (auto simp: permutations_Cons)"], ["", "lemma permutations_not_nil:\n  assumes \"xs \\<noteq> []\"\n  shows \"permutations xs = concat (map (\\<lambda>x. map ((#) x) (permutations (remove1 x xs))) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutations xs =\n    concat (map (\\<lambda>x. map ((#) x) (permutations (remove1 x xs))) xs)", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. permutations xs =\n    concat (map (\\<lambda>x. map ((#) x) (permutations (remove1 x xs))) xs)", "by (cases xs) (auto simp: permutations_Cons)"], ["", "lemma set_permutations_step:\n  assumes \"xs \\<noteq> []\"\n  shows \"set (permutations xs) = (\\<Union>x \\<in> set xs. Cons x ` set (permutations (remove1 x xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (permutations xs) =\n    (\\<Union>x\\<in>set xs. (#) x ` set (permutations (remove1 x xs)))", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (permutations xs) =\n    (\\<Union>x\\<in>set xs. (#) x ` set (permutations (remove1 x xs)))", "by (cases xs) (auto simp: permutations_Cons)"], ["", "lemma in_set_permutations:\n  assumes \"distinct xs\"\n  shows \"ys \\<in> set (permutations xs) \\<longleftrightarrow> distinct ys \\<and> set xs = set ys\" (is \"?L xs ys \\<longleftrightarrow> ?R xs ys\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<in> set (permutations xs)) = (distinct ys \\<and> set xs = set ys)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. (ys \\<in> set (permutations xs)) = (distinct ys \\<and> set xs = set ys)", "proof (induct \"length xs\" arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>0 = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)\n 2. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                                     (distinct ys \\<and> set xs = set ys);\n        Suc x = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)", "case 0"], ["proof (state)\nthis:\n  0 = length xs\n  distinct xs\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>0 = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)\n 2. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                                     (distinct ys \\<and> set xs = set ys);\n        Suc x = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)", "then"], ["proof (chain)\npicking this:\n  0 = length xs\n  distinct xs", "show ?case"], ["proof (prove)\nusing this:\n  0 = length xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. (ys \\<in> set (permutations xs)) = (distinct ys \\<and> set xs = set ys)", "by auto"], ["proof (state)\nthis:\n  (ys \\<in> set (permutations xs)) = (distinct ys \\<and> set xs = set ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                                     (distinct ys \\<and> set xs = set ys);\n        Suc x = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                                     (distinct ys \\<and> set xs = set ys);\n        Suc x = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = length ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> (?ys \\<in> set (permutations ?xs)) =\n                    (distinct ?ys \\<and> set ?xs = set ?ys)\n  Suc n = length xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                                     (distinct ys \\<and> set xs = set ys);\n        Suc x = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = length ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> (?ys \\<in> set (permutations ?xs)) =\n                    (distinct ?ys \\<and> set ?xs = set ?ys)\n  Suc n = length xs\n  distinct xs", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = length ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> (?ys \\<in> set (permutations ?xs)) =\n                    (distinct ?ys \\<and> set ?xs = set ?ys)\n  Suc n = length xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                                     (distinct ys \\<and> set xs = set ys);\n        Suc x = length xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> (ys \\<in> set (permutations xs)) =\n                         (distinct ys \\<and> set xs = set ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<in> set (permutations xs)) = (distinct ys \\<and> set xs = set ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ys \\<in> set (permutations xs) \\<Longrightarrow>\n    distinct ys \\<and> set xs = set ys\n 2. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "assume \"?L xs ys\""], ["proof (state)\nthis:\n  ys \\<in> set (permutations xs)\n\ngoal (2 subgoals):\n 1. ys \\<in> set (permutations xs) \\<Longrightarrow>\n    distinct ys \\<and> set xs = set ys\n 2. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (permutations xs)", "obtain y ys' where \"ys = y # ys'\" \"y \\<in> set xs\" \"ys' \\<in> set (permutations (remove1 (hd ys) xs))\""], ["proof (prove)\nusing this:\n  ys \\<in> set (permutations xs)\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; y \\<in> set xs;\n         ys' \\<in> set (permutations (remove1 (hd ys) xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>xs \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  ys \\<in> set (permutations xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; y \\<in> set xs;\n         ys' \\<in> set (permutations (remove1 (hd ys) xs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: permutations_not_nil)"], ["proof (state)\nthis:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))\n\ngoal (2 subgoals):\n 1. ys \\<in> set (permutations xs) \\<Longrightarrow>\n    distinct ys \\<and> set xs = set ys\n 2. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "moreover"], ["proof (state)\nthis:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))\n\ngoal (2 subgoals):\n 1. ys \\<in> set (permutations xs) \\<Longrightarrow>\n    distinct ys \\<and> set xs = set ys\n 2. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "then"], ["proof (chain)\npicking this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))", "have \"?R (remove1 y xs) ys'\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))\n\ngoal (1 subgoal):\n 1. distinct ys' \\<and> set (remove1 y xs) = set ys'", "using Suc.prems Suc.hyps(2)"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))\n  distinct xs\n  Suc n = length xs\n\ngoal (1 subgoal):\n 1. distinct ys' \\<and> set (remove1 y xs) = set ys'", "by (intro Suc.hyps(1)[THEN iffD1]) (auto simp: length_remove1)"], ["proof (state)\nthis:\n  distinct ys' \\<and> set (remove1 y xs) = set ys'\n\ngoal (2 subgoals):\n 1. ys \\<in> set (permutations xs) \\<Longrightarrow>\n    distinct ys \\<and> set xs = set ys\n 2. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "ultimately"], ["proof (chain)\npicking this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))\n  distinct ys' \\<and> set (remove1 y xs) = set ys'", "show \"?R xs ys\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))\n  distinct ys' \\<and> set (remove1 y xs) = set ys'\n\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys", "using Suc"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 (hd ys) xs))\n  distinct ys' \\<and> set (remove1 y xs) = set ys'\n  \\<lbrakk>n = length ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> (?ys \\<in> set (permutations ?xs)) =\n                    (distinct ?ys \\<and> set ?xs = set ?ys)\n  Suc n = length xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys", "by auto"], ["proof (state)\nthis:\n  distinct ys \\<and> set xs = set ys\n\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "assume \"?R xs ys\""], ["proof (state)\nthis:\n  distinct ys \\<and> set xs = set ys\n\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "with \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  distinct ys \\<and> set xs = set ys", "obtain y ys' where \"ys = y # ys'\" \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  distinct ys \\<and> set xs = set ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; y \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ys) auto"], ["proof (state)\nthis:\n  ys = y # ys'\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "moreover"], ["proof (state)\nthis:\n  ys = y # ys'\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "then"], ["proof (chain)\npicking this:\n  ys = y # ys'\n  y \\<in> set xs", "have \"ys' \\<in> set (permutations (remove1 y xs))\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. ys' \\<in> set (permutations (remove1 y xs))", "using Suc \\<open>?R xs ys\\<close>"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n  \\<lbrakk>n = length ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> (?ys \\<in> set (permutations ?xs)) =\n                    (distinct ?ys \\<and> set ?xs = set ?ys)\n  Suc n = length xs\n  distinct xs\n  distinct ys \\<and> set xs = set ys\n\ngoal (1 subgoal):\n 1. ys' \\<in> set (permutations (remove1 y xs))", "by (intro Suc.hyps(1)[THEN iffD2]) (auto simp: length_remove1)"], ["proof (state)\nthis:\n  ys' \\<in> set (permutations (remove1 y xs))\n\ngoal (1 subgoal):\n 1. distinct ys \\<and> set xs = set ys \\<Longrightarrow>\n    ys \\<in> set (permutations xs)", "ultimately"], ["proof (chain)\npicking this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 y xs))", "show \"?L xs ys\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 y xs))\n\ngoal (1 subgoal):\n 1. ys \\<in> set (permutations xs)", "using \\<open>xs \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  y \\<in> set xs\n  ys' \\<in> set (permutations (remove1 y xs))\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. ys \\<in> set (permutations xs)", "by (auto simp: permutations_not_nil)"], ["proof (state)\nthis:\n  ys \\<in> set (permutations xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ys \\<in> set (permutations xs)) = (distinct ys \\<and> set xs = set ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_set_cyc_permutations:\n  assumes \"distinct xs\"\n  shows \"ys \\<in> set (cyc_permutations xs) \\<longleftrightarrow> distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs\" (is \"?L xs ys \\<longleftrightarrow> ?R xs ys\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<in> set (cyc_permutations xs)) =\n    (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    (ys \\<in> set (cyc_permutations xs)) =\n    (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (ys \\<in> set (cyc_permutations xs)) =\n       (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs = x # xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    (ys \\<in> set (cyc_permutations xs)) =\n    (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (ys \\<in> set (cyc_permutations xs)) =\n       (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)", "with assms"], ["proof (chain)\npicking this:\n  distinct xs\n  xs = x # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n  xs = x # xs\n\ngoal (1 subgoal):\n 1. (ys \\<in> set (cyc_permutations xs)) =\n    (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)", "by (cases ys) (auto simp: in_set_permutations intro!: imageI)"], ["proof (state)\nthis:\n  (ys \\<in> set (cyc_permutations xs)) =\n  (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    (ys \\<in> set (cyc_permutations xs)) =\n    (distinct ys \\<and> set xs = set ys \\<and> hd ys = hd xs)", "qed auto"], ["", "lemma in_set_cyc_permutations_obtain:\n  assumes \"distinct xs\" \"distinct ys\" \"set xs = set ys\"\n  obtains n where \"rotate n ys \\<in> set (cyc_permutations xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        rotate n ys \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                rotate n ys\n                \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                rotate n ys\n                \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "with assms"], ["proof (chain)\npicking this:\n  distinct xs\n  distinct ys\n  set xs = set ys\n  xs = []", "have \"rotate 0 ys \\<in> set (cyc_permutations xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  distinct ys\n  set xs = set ys\n  xs = []\n\ngoal (1 subgoal):\n 1. rotate 0 ys \\<in> set (cyc_permutations xs)", "by auto"], ["proof (state)\nthis:\n  rotate 0 ys \\<in> set (cyc_permutations xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                rotate n ys\n                \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  rotate 0 ys \\<in> set (cyc_permutations xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate 0 ys \\<in> set (cyc_permutations xs)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons x xs')"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "let ?ys' = \"rotate (index ys x) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"ys \\<noteq> []\" \"x \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> [] &&& x \\<in> set ys", "using Cons assms"], ["proof (prove)\nusing this:\n  xs = x # xs'\n  distinct xs\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] &&& x \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> []\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ys \\<noteq> []\n  x \\<in> set ys", "have \"distinct ?ys' \\<and> set xs = set ?ys' \\<and> hd ?ys' = hd xs\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. distinct (rotate (index ys x) ys) \\<and>\n    set xs = set (rotate (index ys x) ys) \\<and>\n    hd (rotate (index ys x) ys) = hd xs", "using assms Cons"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  x \\<in> set ys\n  distinct xs\n  distinct ys\n  set xs = set ys\n  xs = x # xs'\n\ngoal (1 subgoal):\n 1. distinct (rotate (index ys x) ys) \\<and>\n    set xs = set (rotate (index ys x) ys) \\<and>\n    hd (rotate (index ys x) ys) = hd xs", "by (auto simp add: hd_rotate_conv_nth)"], ["proof (state)\nthis:\n  distinct (rotate (index ys x) ys) \\<and>\n  set xs = set (rotate (index ys x) ys) \\<and>\n  hd (rotate (index ys x) ys) = hd xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>distinct xs\\<close>"], ["proof (chain)\npicking this:\n  distinct xs\n  distinct (rotate (index ys x) ys) \\<and>\n  set xs = set (rotate (index ys x) ys) \\<and>\n  hd (rotate (index ys x) ys) = hd xs", "have \"?ys' \\<in> set (cyc_permutations xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  distinct (rotate (index ys x) ys) \\<and>\n  set xs = set (rotate (index ys x) ys) \\<and>\n  hd (rotate (index ys x) ys) = hd xs\n\ngoal (1 subgoal):\n 1. rotate (index ys x) ys \\<in> set (cyc_permutations xs)", "by (rule in_set_cyc_permutations[THEN iffD2])"], ["proof (state)\nthis:\n  rotate (index ys x) ys \\<in> set (cyc_permutations xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   rotate n ys\n                   \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n                   thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  rotate (index ys x) ys \\<in> set (cyc_permutations xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate (index ys x) ys \\<in> set (cyc_permutations xs)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_succ_set_cyc_permutations:\n  assumes \"distinct xs\" \"xs \\<noteq> []\"\n  shows \"list_succ ` set (cyc_permutations xs) = {f. f permutes set xs \\<and> cyclic_on f (set xs)}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_succ ` set (cyc_permutations xs) =\n    {f. f permutes set xs \\<and> cyclic_on f (set xs)}", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> list_succ ` set (cyc_permutations xs) \\<Longrightarrow>\n       x \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n 2. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> list_succ ` set (cyc_permutations xs) \\<Longrightarrow>\n       x \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n 2. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "assume \"f \\<in> ?L\""], ["proof (state)\nthis:\n  f \\<in> list_succ ` set (cyc_permutations xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> list_succ ` set (cyc_permutations xs) \\<Longrightarrow>\n       x \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n 2. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "moreover"], ["proof (state)\nthis:\n  f \\<in> list_succ ` set (cyc_permutations xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> list_succ ` set (cyc_permutations xs) \\<Longrightarrow>\n       x \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n 2. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "have \"\\<And>ys. set xs = set ys \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>set xs = set ys; xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>set xs = set ?ys; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> list_succ ` set (cyc_permutations xs) \\<Longrightarrow>\n       x \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n 2. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "ultimately"], ["proof (chain)\npicking this:\n  f \\<in> list_succ ` set (cyc_permutations xs)\n  \\<lbrakk>set xs = set ?ys; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<noteq> []", "show \"f \\<in> ?R\""], ["proof (prove)\nusing this:\n  f \\<in> list_succ ` set (cyc_permutations xs)\n  \\<lbrakk>set xs = set ?ys; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. f \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> list_succ ` set (cyc_permutations xs)\n  \\<lbrakk>set xs = set ?ys; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<noteq> []\n  distinct xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. f \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}", "by (auto simp: in_set_cyc_permutations list_succ_permutes cyclic_on_list_succ)"], ["proof (state)\nthis:\n  f \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "assume \"f \\<in> ?R\""], ["proof (state)\nthis:\n  f \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "then"], ["proof (chain)\npicking this:\n  f \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}", "obtain ys where ys: \"list_succ ys = f\" \"distinct ys\" \"set ys = set xs\""], ["proof (prove)\nusing this:\n  f \\<in> {f. f permutes set xs \\<and> cyclic_on f (set xs)}\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>list_succ ys = f; distinct ys; set ys = set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: cyclic_on_obtain_list_succ')"], ["proof (state)\nthis:\n  list_succ ys = f\n  distinct ys\n  set ys = set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "moreover"], ["proof (state)\nthis:\n  list_succ ys = f\n  distinct ys\n  set ys = set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "with \\<open>distinct xs\\<close>"], ["proof (chain)\npicking this:\n  distinct xs\n  list_succ ys = f\n  distinct ys\n  set ys = set xs", "obtain n where \"rotate n ys \\<in> set (cyc_permutations xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  list_succ ys = f\n  distinct ys\n  set ys = set xs\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        rotate n ys \\<in> set (cyc_permutations xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: in_set_cyc_permutations_obtain)"], ["proof (state)\nthis:\n  rotate n ys \\<in> set (cyc_permutations xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "then"], ["proof (chain)\npicking this:\n  rotate n ys \\<in> set (cyc_permutations xs)", "have \"list_succ (rotate n ys) \\<in> ?L\""], ["proof (prove)\nusing this:\n  rotate n ys \\<in> set (cyc_permutations xs)\n\ngoal (1 subgoal):\n 1. list_succ (rotate n ys) \\<in> list_succ ` set (cyc_permutations xs)", "by simp"], ["proof (state)\nthis:\n  list_succ (rotate n ys) \\<in> list_succ ` set (cyc_permutations xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {f. f permutes set xs \\<and>\n                   cyclic_on f (set xs)} \\<Longrightarrow>\n       x \\<in> list_succ ` set (cyc_permutations xs)", "ultimately"], ["proof (chain)\npicking this:\n  list_succ ys = f\n  distinct ys\n  set ys = set xs\n  list_succ (rotate n ys) \\<in> list_succ ` set (cyc_permutations xs)", "show \"f \\<in> ?L\""], ["proof (prove)\nusing this:\n  list_succ ys = f\n  distinct ys\n  set ys = set xs\n  list_succ (rotate n ys) \\<in> list_succ ` set (cyc_permutations xs)\n\ngoal (1 subgoal):\n 1. f \\<in> list_succ ` set (cyc_permutations xs)", "by simp"], ["proof (state)\nthis:\n  f \\<in> list_succ ` set (cyc_permutations xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Enumerating Permutations from List Orbits\\<close>"], ["", "definition cyc_permutationss :: \"'a list list \\<Rightarrow> 'a list list list\" where\n  \"cyc_permutationss = product_lists o map cyc_permutations\""], ["", "lemma cyc_permutationss_Nil[simp]: \"cyc_permutationss [] = [[]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyc_permutationss [] = [[]]", "by (auto simp: cyc_permutationss_def)"], ["", "lemma in_set_cyc_permutationss:\n  assumes \"distincts xss\"\n  shows \"yss \\<in> set (cyc_permutationss xss) \\<longleftrightarrow> distincts yss \\<and> map set xss = map set yss \\<and> map hd xss = map hd yss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "assume A: \"list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)\""], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "then"], ["proof (chain)\npicking this:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)", "have \"length yss = length xss\""], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)\n\ngoal (1 subgoal):\n 1. length yss = length xss", "by (auto simp: list_all2_lengthD)"], ["proof (state)\nthis:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "then"], ["proof (chain)\npicking this:\n  length yss = length xss", "have \"\\<Union>(sset xss) = \\<Union>(sset yss)\" \"distincts yss\" \"map set xss = map set yss\" \"map hd xss = map hd yss\""], ["proof (prove)\nusing this:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. (\\<Union> (sset xss) = \\<Union> (sset yss) &&& distincts yss) &&&\n    map set xss = map set yss &&& map hd xss = map hd yss", "using A assms"], ["proof (prove)\nusing this:\n  length yss = length xss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)\n  distincts xss\n\ngoal (1 subgoal):\n 1. (\\<Union> (sset xss) = \\<Union> (sset yss) &&& distincts yss) &&&\n    map set xss = map set yss &&& map hd xss = map hd yss", "by (induct yss xss rule: list_induct2) (auto simp: distincts_Cons in_set_cyc_permutations)"], ["proof (state)\nthis:\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  distincts yss\n  map set xss = map set yss\n  map hd xss = map hd yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "}"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  distincts yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  map set xss = map set yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  map hd xss = map hd yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "note X = this"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  distincts yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  map set xss = map set yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  map hd xss = map hd yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "{"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  distincts yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  map set xss = map set yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map cyc_permutations xss) \\<Longrightarrow>\n  map hd xss = map hd yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "assume A: \"distincts yss\" \"map set xss = map set yss\" \"map hd xss = map hd yss\""], ["proof (state)\nthis:\n  distincts yss\n  map set xss = map set yss\n  map hd xss = map hd yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "then"], ["proof (chain)\npicking this:\n  distincts yss\n  map set xss = map set yss\n  map hd xss = map hd yss", "have \"length yss = length xss\""], ["proof (prove)\nusing this:\n  distincts yss\n  map set xss = map set yss\n  map hd xss = map hd yss\n\ngoal (1 subgoal):\n 1. length yss = length xss", "by (auto dest: map_eq_imp_length_eq)"], ["proof (state)\nthis:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "then"], ["proof (chain)\npicking this:\n  length yss = length xss", "have \"list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)\""], ["proof (prove)\nusing this:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)", "using A assms"], ["proof (prove)\nusing this:\n  length yss = length xss\n  distincts yss\n  map set xss = map set yss\n  map hd xss = map hd yss\n  distincts xss\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)", "by (induct yss xss rule: list_induct2) (auto simp: distincts_Cons in_set_cyc_permutations)"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map cyc_permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>distincts yss; map set xss = map set yss;\n   map hd xss = map hd yss\\<rbrakk>\n  \\<Longrightarrow> list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n                     (map cyc_permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "note Y = this"], ["proof (state)\nthis:\n  \\<lbrakk>distincts yss; map set xss = map set yss;\n   map hd xss = map hd yss\\<rbrakk>\n  \\<Longrightarrow> list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n                     (map cyc_permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "show \"?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yss \\<in> set (cyc_permutationss xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "unfolding cyc_permutationss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (yss \\<in> set ((product_lists \\<circ> map cyc_permutations) xss)) =\n    (distincts yss \\<and>\n     map set xss = map set yss \\<and> map hd xss = map hd yss)", "by (auto simp: product_lists_set intro: X Y)"], ["proof (state)\nthis:\n  (yss \\<in> set (cyc_permutationss xss)) =\n  (distincts yss \\<and>\n   map set xss = map set yss \\<and> map hd xss = map hd yss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lists_succ_set_cyc_permutationss:\n  assumes \"distincts xss\"\n  shows \"lists_succ ` set (cyc_permutationss xss) = {f. f permutes \\<Union>(sset xss) \\<and> (\\<forall>c \\<in> sset xss. cyclic_on f c)}\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ ` set (cyc_permutationss xss) =\n    {f. f permutes \\<Union> (sset xss) \\<and>\n        (\\<forall>c\\<in>sset xss. cyclic_on f c)}", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n\ngoal (1 subgoal):\n 1. lists_succ ` set (cyc_permutationss xss) =\n    {f. f permutes \\<Union> (sset xss) \\<and>\n        (\\<forall>c\\<in>sset xss. cyclic_on f c)}", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> lists_succ ` set (cyc_permutationss xss)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                                     (\\<forall>c\\<in>sset xss.\n   cyclic_on f c)}\n 2. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> lists_succ ` set (cyc_permutationss xss)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                                     (\\<forall>c\\<in>sset xss.\n   cyclic_on f c)}\n 2. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "assume \"f \\<in> ?L\""], ["proof (state)\nthis:\n  f \\<in> lists_succ ` set (cyc_permutationss xss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> lists_succ ` set (cyc_permutationss xss)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                                     (\\<forall>c\\<in>sset xss.\n   cyclic_on f c)}\n 2. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "then"], ["proof (chain)\npicking this:\n  f \\<in> lists_succ ` set (cyc_permutationss xss)", "obtain yss where \"yss \\<in> set (cyc_permutationss xss)\" \"f = lists_succ yss\""], ["proof (prove)\nusing this:\n  f \\<in> lists_succ ` set (cyc_permutationss xss)\n\ngoal (1 subgoal):\n 1. (\\<And>yss.\n        \\<lbrakk>yss \\<in> set (cyc_permutationss xss);\n         f = lists_succ yss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule imageE)"], ["proof (state)\nthis:\n  yss \\<in> set (cyc_permutationss xss)\n  f = lists_succ yss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> lists_succ ` set (cyc_permutationss xss)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                                     (\\<forall>c\\<in>sset xss.\n   cyclic_on f c)}\n 2. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "moreover"], ["proof (state)\nthis:\n  yss \\<in> set (cyc_permutationss xss)\n  f = lists_succ yss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> lists_succ ` set (cyc_permutationss xss)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                                     (\\<forall>c\\<in>sset xss.\n   cyclic_on f c)}\n 2. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "from \\<open>yss \\<in> _\\<close> assms"], ["proof (chain)\npicking this:\n  yss \\<in> set (cyc_permutationss xss)\n  distincts xss", "have \"set (map set xss) = set (map set yss)\""], ["proof (prove)\nusing this:\n  yss \\<in> set (cyc_permutationss xss)\n  distincts xss\n\ngoal (1 subgoal):\n 1. set (map set xss) = set (map set yss)", "by (auto simp: in_set_cyc_permutationss)"], ["proof (state)\nthis:\n  set (map set xss) = set (map set yss)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> lists_succ ` set (cyc_permutationss xss)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                                     (\\<forall>c\\<in>sset xss.\n   cyclic_on f c)}\n 2. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "then"], ["proof (chain)\npicking this:\n  set (map set xss) = set (map set yss)", "have \"sset xss = sset yss\""], ["proof (prove)\nusing this:\n  set (map set xss) = set (map set yss)\n\ngoal (1 subgoal):\n 1. sset xss = sset yss", "by simp"], ["proof (state)\nthis:\n  sset xss = sset yss\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> lists_succ ` set (cyc_permutationss xss)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                                     (\\<forall>c\\<in>sset xss.\n   cyclic_on f c)}\n 2. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "ultimately"], ["proof (chain)\npicking this:\n  yss \\<in> set (cyc_permutationss xss)\n  f = lists_succ yss\n  sset xss = sset yss", "show \"f \\<in> ?R\""], ["proof (prove)\nusing this:\n  yss \\<in> set (cyc_permutationss xss)\n  f = lists_succ yss\n  sset xss = sset yss\n\ngoal (1 subgoal):\n 1. f \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                (\\<forall>c\\<in>sset xss. cyclic_on f c)}", "using assms"], ["proof (prove)\nusing this:\n  yss \\<in> set (cyc_permutationss xss)\n  f = lists_succ yss\n  sset xss = sset yss\n  distincts xss\n\ngoal (1 subgoal):\n 1. f \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                (\\<forall>c\\<in>sset xss. cyclic_on f c)}", "by (auto simp: in_set_cyc_permutationss cyclic_on_lists_succ') (metis lists_succ_permutes)"], ["proof (state)\nthis:\n  f \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n              (\\<forall>c\\<in>sset xss. cyclic_on f c)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "assume \"f \\<in> ?R\""], ["proof (state)\nthis:\n  f \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n              (\\<forall>c\\<in>sset xss. cyclic_on f c)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "then"], ["proof (chain)\npicking this:\n  f \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n              (\\<forall>c\\<in>sset xss. cyclic_on f c)}", "have \"f permutes \\<Union>(sset xss)\" \"\\<And>cs. cs \\<in> set xss \\<Longrightarrow> cyclic_on f (set cs)\""], ["proof (prove)\nusing this:\n  f \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n              (\\<forall>c\\<in>sset xss. cyclic_on f c)}\n\ngoal (1 subgoal):\n 1. f permutes \\<Union> (sset xss) &&&\n    (\\<And>cs. cs \\<in> set xss \\<Longrightarrow> cyclic_on f (set cs))", "by auto"], ["proof (state)\nthis:\n  f permutes \\<Union> (sset xss)\n  ?cs \\<in> set xss \\<Longrightarrow> cyclic_on f (set ?cs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "from this(1) refl assms this(2)"], ["proof (chain)\npicking this:\n  f permutes \\<Union> (sset xss)\n  ?t = ?t\n  distincts xss\n  ?cs \\<in> set xss \\<Longrightarrow> cyclic_on f (set ?cs)", "obtain yss where \"f = lists_succ yss\" \"distincts yss\" \"map set yss = map set xss\" \"map hd yss = map hd xss\""], ["proof (prove)\nusing this:\n  f permutes \\<Union> (sset xss)\n  ?t = ?t\n  distincts xss\n  ?cs \\<in> set xss \\<Longrightarrow> cyclic_on f (set ?cs)\n\ngoal (1 subgoal):\n 1. (\\<And>yss.\n        \\<lbrakk>f = lists_succ yss; distincts yss;\n         map set yss = map set xss; map hd yss = map hd xss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule cyclic_on_obtain_lists_succ)"], ["proof (state)\nthis:\n  f = lists_succ yss\n  distincts yss\n  map set yss = map set xss\n  map hd yss = map hd xss\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distincts xss;\n        x \\<in> {f. f permutes \\<Union> (sset xss) \\<and>\n                    (\\<forall>c\\<in>sset xss. cyclic_on f c)}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> lists_succ ` set (cyc_permutationss xss)", "with assms"], ["proof (chain)\npicking this:\n  distincts xss\n  f = lists_succ yss\n  distincts yss\n  map set yss = map set xss\n  map hd yss = map hd xss", "show \"f \\<in> ?L\""], ["proof (prove)\nusing this:\n  distincts xss\n  f = lists_succ yss\n  distincts yss\n  map set yss = map set xss\n  map hd yss = map hd xss\n\ngoal (1 subgoal):\n 1. f \\<in> lists_succ ` set (cyc_permutationss xss)", "by (auto intro!: imageI simp: in_set_cyc_permutationss)"], ["proof (state)\nthis:\n  f \\<in> lists_succ ` set (cyc_permutationss xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lists of Permutations\\<close>"], ["", "definition permutationss :: \"'a list list \\<Rightarrow> 'a list list list\" where\n  \"permutationss = product_lists o map permutations\""], ["", "lemma permutationss_Nil[simp]: \"permutationss [] = [[]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutationss [] = [[]]", "by (auto simp: permutationss_def)"], ["", "lemma permutationss_Cons:\n  \"permutationss (xs # xss) = concat (map (\\<lambda>ys. map (Cons ys) (permutationss xss)) (permutations xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutationss (xs # xss) =\n    concat\n     (map (\\<lambda>ys. map ((#) ys) (permutationss xss)) (permutations xs))", "by (auto simp: permutationss_def)"], ["", "lemma in_set_permutationss:\n  assumes \"distincts xss\"\n  shows \"yss \\<in> set (permutationss xss) \\<longleftrightarrow> distincts yss \\<and> map set xss = map set yss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "assume A: \"list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)\""], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "then"], ["proof (chain)\npicking this:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)", "have \"length yss = length xss\""], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)\n\ngoal (1 subgoal):\n 1. length yss = length xss", "by (auto simp: list_all2_lengthD)"], ["proof (state)\nthis:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "then"], ["proof (chain)\npicking this:\n  length yss = length xss", "have \"\\<Union>(sset xss) = \\<Union>(sset yss)\" \"distincts yss\" \"map set xss = map set yss\""], ["proof (prove)\nusing this:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. \\<Union> (sset xss) = \\<Union> (sset yss) &&&\n    distincts yss &&& map set xss = map set yss", "using A assms"], ["proof (prove)\nusing this:\n  length yss = length xss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)\n  distincts xss\n\ngoal (1 subgoal):\n 1. \\<Union> (sset xss) = \\<Union> (sset yss) &&&\n    distincts yss &&& map set xss = map set yss", "by (induct yss xss rule: list_induct2) (auto simp: distincts_Cons in_set_permutations)"], ["proof (state)\nthis:\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  distincts yss\n  map set xss = map set yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "}"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  distincts yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  map set xss = map set yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "note X = this"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  distincts yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  map set xss = map set yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "{"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  \\<Union> (sset xss) = \\<Union> (sset yss)\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  distincts yss\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n   (map permutations xss) \\<Longrightarrow>\n  map set xss = map set yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "assume A: \"distincts yss\" \"map set xss = map set yss\""], ["proof (state)\nthis:\n  distincts yss\n  map set xss = map set yss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "then"], ["proof (chain)\npicking this:\n  distincts yss\n  map set xss = map set yss", "have \"length yss = length xss\""], ["proof (prove)\nusing this:\n  distincts yss\n  map set xss = map set yss\n\ngoal (1 subgoal):\n 1. length yss = length xss", "by (auto dest: map_eq_imp_length_eq)"], ["proof (state)\nthis:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "then"], ["proof (chain)\npicking this:\n  length yss = length xss", "have \"list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)\""], ["proof (prove)\nusing this:\n  length yss = length xss\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)", "using A assms"], ["proof (prove)\nusing this:\n  length yss = length xss\n  distincts yss\n  map set xss = map set yss\n  distincts xss\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)", "by (induct yss xss rule: list_induct2) (auto simp: in_set_permutations distincts_Cons)"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x ys. x \\<in> set ys) yss (map permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>distincts yss; map set xss = map set yss\\<rbrakk>\n  \\<Longrightarrow> list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n                     (map permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "note Y = this"], ["proof (state)\nthis:\n  \\<lbrakk>distincts yss; map set xss = map set yss\\<rbrakk>\n  \\<Longrightarrow> list_all2 (\\<lambda>x ys. x \\<in> set ys) yss\n                     (map permutations xss)\n\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "show \"?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yss \\<in> set (permutationss xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "unfolding permutationss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (yss \\<in> set ((product_lists \\<circ> map permutations) xss)) =\n    (distincts yss \\<and> map set xss = map set yss)", "by (auto simp: product_lists_set intro: X Y)"], ["proof (state)\nthis:\n  (yss \\<in> set (permutationss xss)) =\n  (distincts yss \\<and> map set xss = map set yss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_permutationss:\n  assumes \"distincts xss\"\n  shows \"set (permutationss xss) = {yss. distincts yss \\<and> map set xss = map set yss}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (permutationss xss) =\n    {yss. distincts yss \\<and> map set xss = map set yss}", "using in_set_permutationss[OF assms]"], ["proof (prove)\nusing this:\n  (?yss \\<in> set (permutationss xss)) =\n  (distincts ?yss \\<and> map set xss = map set ?yss)\n\ngoal (1 subgoal):\n 1. set (permutationss xss) =\n    {yss. distincts yss \\<and> map set xss = map set yss}", "by blast"], ["", "lemma permutationss_complete:\n  assumes \"distincts xss\" \"distincts yss\" \"xss \\<noteq> []\"\n    and \"set ` set xss = set ` set yss\"\n  shows \"set yss \\<in> set ` set (permutationss xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "have \"length xss = length yss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xss = length yss", "using assms"], ["proof (prove)\nusing this:\n  distincts xss\n  distincts yss\n  xss \\<noteq> []\n  sset xss = sset yss\n\ngoal (1 subgoal):\n 1. length xss = length yss", "by (simp add: length_distincts)"], ["proof (state)\nthis:\n  length xss = length yss\n\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "from \\<open>sset xss = _\\<close>"], ["proof (chain)\npicking this:\n  sset xss = sset yss", "have \"\\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set xss\""], ["proof (prove)\nusing this:\n  sset xss = sset yss\n\ngoal (1 subgoal):\n 1. \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set xss", "using assms(1-2)"], ["proof (prove)\nusing this:\n  sset xss = sset yss\n  distincts xss\n  distincts yss\n\ngoal (1 subgoal):\n 1. \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set xss", "proof (induct xss arbitrary: yss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>yss.\n       \\<lbrakk>sset [] = sset yss; distincts []; distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set []\n 2. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "case Nil"], ["proof (state)\nthis:\n  sset [] = sset yss\n  distincts []\n  distincts yss\n\ngoal (2 subgoals):\n 1. \\<And>yss.\n       \\<lbrakk>sset [] = sset yss; distincts []; distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set []\n 2. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "then"], ["proof (chain)\npicking this:\n  sset [] = sset yss\n  distincts []\n  distincts yss", "show ?case"], ["proof (prove)\nusing this:\n  sset [] = sset yss\n  distincts []\n  distincts yss\n\ngoal (1 subgoal):\n 1. \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set []", "by simp"], ["proof (state)\nthis:\n  \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set []\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "case (Cons xs xss)"], ["proof (state)\nthis:\n  \\<lbrakk>sset xss = sset ?yss; distincts xss; distincts ?yss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>yss'.\n                       set yss' = set ?yss \\<and> map set yss' = map set xss\n  sset (xs # xss) = sset yss\n  distincts (xs # xss)\n  distincts yss\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "from \\<open>sset (xs # xss) = sset yss\\<close>"], ["proof (chain)\npicking this:\n  sset (xs # xss) = sset yss", "obtain ys where ys: \"ys \\<in> set yss\" \"set ys = set xs\""], ["proof (prove)\nusing this:\n  sset (xs # xss) = sset yss\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> set yss; set ys = set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto (metis imageE insertI1)"], ["proof (state)\nthis:\n  ys \\<in> set yss\n  set ys = set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "with \\<open>distincts yss\\<close>"], ["proof (chain)\npicking this:\n  distincts yss\n  ys \\<in> set yss\n  set ys = set xs", "have \"set ys \\<notin> sset (remove1 ys yss)\""], ["proof (prove)\nusing this:\n  distincts yss\n  ys \\<in> set yss\n  set ys = set xs\n\ngoal (1 subgoal):\n 1. set ys \\<notin> sset (remove1 ys yss)", "by (fastforce simp: distincts_def)"], ["proof (state)\nthis:\n  set ys \\<notin> sset (remove1 ys yss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "moreover"], ["proof (state)\nthis:\n  set ys \\<notin> sset (remove1 ys yss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "from \\<open>distincts (xs # xss)\\<close>"], ["proof (chain)\npicking this:\n  distincts (xs # xss)", "have \"set xs \\<notin> sset xss\""], ["proof (prove)\nusing this:\n  distincts (xs # xss)\n\ngoal (1 subgoal):\n 1. set xs \\<notin> sset xss", "by (fastforce simp: distincts_def)"], ["proof (state)\nthis:\n  set xs \\<notin> sset xss\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "ultimately"], ["proof (chain)\npicking this:\n  set ys \\<notin> sset (remove1 ys yss)\n  set xs \\<notin> sset xss", "have \"sset xss = sset (remove1 ys yss)\""], ["proof (prove)\nusing this:\n  set ys \\<notin> sset (remove1 ys yss)\n  set xs \\<notin> sset xss\n\ngoal (1 subgoal):\n 1. sset xss = sset (remove1 ys yss)", "using \\<open>distincts yss\\<close> \\<open>sset (xs # xss) = sset yss\\<close>"], ["proof (prove)\nusing this:\n  set ys \\<notin> sset (remove1 ys yss)\n  set xs \\<notin> sset xss\n  distincts yss\n  sset (xs # xss) = sset yss\n\ngoal (1 subgoal):\n 1. sset xss = sset (remove1 ys yss)", "apply (auto simp: distincts_distinct \\<open>set ys = set xs\\<close>[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>set ys \\<notin> set ` (set yss - {ys});\n        set ys \\<notin> sset xss; distincts yss;\n        insert (set ys) (sset xss) = sset yss; xa \\<in> set xss\\<rbrakk>\n       \\<Longrightarrow> set xa \\<in> set ` (set yss - {ys})\n 2. \\<And>xa.\n       \\<lbrakk>set ys \\<notin> set ` (set yss - {ys});\n        set ys \\<notin> sset xss; distincts yss;\n        insert (set ys) (sset xss) = sset yss; xa \\<in> set yss;\n        set xa \\<notin> sset xss\\<rbrakk>\n       \\<Longrightarrow> xa = ys", "apply (smt Diff_insert_absorb \\<open>ys \\<in> set yss\\<close> image_insert insert_Diff rev_image_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>set ys \\<notin> set ` (set yss - {ys});\n        set ys \\<notin> sset xss; distincts yss;\n        insert (set ys) (sset xss) = sset yss; xa \\<in> set yss;\n        set xa \\<notin> sset xss\\<rbrakk>\n       \\<Longrightarrow> xa = ys", "by (metis \\<open>ys \\<in> set yss\\<close> image_eqI insert_Diff insert_iff)"], ["proof (state)\nthis:\n  sset xss = sset (remove1 ys yss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "then"], ["proof (chain)\npicking this:\n  sset xss = sset (remove1 ys yss)", "obtain yss' where \"set yss' = set (remove1 ys yss) \\<and> map set yss' = map set xss\""], ["proof (prove)\nusing this:\n  sset xss = sset (remove1 ys yss)\n\ngoal (1 subgoal):\n 1. (\\<And>yss'.\n        set yss' = set (remove1 ys yss) \\<and>\n        map set yss' = map set xss \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  sset xss = sset (remove1 ys yss)\n  \\<lbrakk>sset xss = sset ?yss; distincts xss; distincts ?yss\\<rbrakk>\n  \\<Longrightarrow> \\<exists>yss'.\n                       set yss' = set ?yss \\<and> map set yss' = map set xss\n  sset (xs # xss) = sset yss\n  distincts (xs # xss)\n  distincts yss\n\ngoal (1 subgoal):\n 1. (\\<And>yss'.\n        set yss' = set (remove1 ys yss) \\<and>\n        map set yss' = map set xss \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto simp: distincts_Cons distincts_remove1)"], ["proof (state)\nthis:\n  set yss' = set (remove1 ys yss) \\<and> map set yss' = map set xss\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "then"], ["proof (chain)\npicking this:\n  set yss' = set (remove1 ys yss) \\<and> map set yss' = map set xss", "have \"set (ys # yss') = set yss \\<and> map set (ys # yss') = map set (xs # xss)\""], ["proof (prove)\nusing this:\n  set yss' = set (remove1 ys yss) \\<and> map set yss' = map set xss\n\ngoal (1 subgoal):\n 1. set (ys # yss') = set yss \\<and>\n    map set (ys # yss') = map set (xs # xss)", "using ys set_remove1_eq \\<open>distincts yss\\<close>"], ["proof (prove)\nusing this:\n  set yss' = set (remove1 ys yss) \\<and> map set yss' = map set xss\n  ys \\<in> set yss\n  set ys = set xs\n  distinct ?xs \\<Longrightarrow> set (remove1 ?x ?xs) = set ?xs - {?x}\n  distincts yss\n\ngoal (1 subgoal):\n 1. set (ys # yss') = set yss \\<and>\n    map set (ys # yss') = map set (xs # xss)", "by (auto simp: distincts_distinct)"], ["proof (state)\nthis:\n  set (ys # yss') = set yss \\<and> map set (ys # yss') = map set (xs # xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss yss.\n       \\<lbrakk>\\<And>yss.\n                   \\<lbrakk>sset xss = sset yss; distincts xss;\n                    distincts yss\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>yss'.\n  set yss' = set yss \\<and> map set yss' = map set xss;\n        sset (a # xss) = sset yss; distincts (a # xss);\n        distincts yss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yss'.\n                            set yss' = set yss \\<and>\n                            map set yss' = map set (a # xss)", "then"], ["proof (chain)\npicking this:\n  set (ys # yss') = set yss \\<and> map set (ys # yss') = map set (xs # xss)", "show ?case"], ["proof (prove)\nusing this:\n  set (ys # yss') = set yss \\<and> map set (ys # yss') = map set (xs # xss)\n\ngoal (1 subgoal):\n 1. \\<exists>yss'.\n       set yss' = set yss \\<and> map set yss' = map set (xs # xss)", ".."], ["proof (state)\nthis:\n  \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set (xs # xss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set xss\n\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "then"], ["proof (chain)\npicking this:\n  \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set xss", "obtain yss' where \"set yss' = set yss\" \"map set yss' = map set xss\""], ["proof (prove)\nusing this:\n  \\<exists>yss'. set yss' = set yss \\<and> map set yss' = map set xss\n\ngoal (1 subgoal):\n 1. (\\<And>yss'.\n        \\<lbrakk>set yss' = set yss; map set yss' = map set xss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set yss' = set yss\n  map set yss' = map set xss\n\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "then"], ["proof (chain)\npicking this:\n  set yss' = set yss\n  map set yss' = map set xss", "have \"distincts yss'\""], ["proof (prove)\nusing this:\n  set yss' = set yss\n  map set yss' = map set xss\n\ngoal (1 subgoal):\n 1. distincts yss'", "using \\<open>distincts xss\\<close> \\<open>distincts yss\\<close>"], ["proof (prove)\nusing this:\n  set yss' = set yss\n  map set yss' = map set xss\n  distincts xss\n  distincts yss\n\ngoal (1 subgoal):\n 1. distincts yss'", "unfolding distincts_def"], ["proof (prove)\nusing this:\n  set yss' = set yss\n  map set yss' = map set xss\n  distinct xss \\<and>\n  (\\<forall>xs\\<in>set xss. distinct xs \\<and> xs \\<noteq> []) \\<and>\n  (\\<forall>xs\\<in>set xss.\n      \\<forall>ys\\<in>set xss.\n         xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {})\n  distinct yss \\<and>\n  (\\<forall>xs\\<in>set yss. distinct xs \\<and> xs \\<noteq> []) \\<and>\n  (\\<forall>xs\\<in>set yss.\n      \\<forall>ys\\<in>set yss.\n         xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {})\n\ngoal (1 subgoal):\n 1. distinct yss' \\<and>\n    (\\<forall>xs\\<in>set yss'. distinct xs \\<and> xs \\<noteq> []) \\<and>\n    (\\<forall>xs\\<in>set yss'.\n        \\<forall>ys\\<in>set yss'.\n           xs \\<noteq> ys \\<longrightarrow> set xs \\<inter> set ys = {})", "by simp_all (metis \\<open>length xss = length yss\\<close> card_distinct distinct_card length_map)"], ["proof (state)\nthis:\n  distincts yss'\n\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "then"], ["proof (chain)\npicking this:\n  distincts yss'", "have \"set yss' \\<in> set ` set (permutationss xss)\""], ["proof (prove)\nusing this:\n  distincts yss'\n\ngoal (1 subgoal):\n 1. set yss' \\<in> sset (permutationss xss)", "using \\<open>distincts xss\\<close> \\<open>map set yss' = _\\<close>"], ["proof (prove)\nusing this:\n  distincts yss'\n  distincts xss\n  map set yss' = map set xss\n\ngoal (1 subgoal):\n 1. set yss' \\<in> sset (permutationss xss)", "by (auto simp: set_permutationss)"], ["proof (state)\nthis:\n  set yss' \\<in> sset (permutationss xss)\n\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "then"], ["proof (chain)\npicking this:\n  set yss' \\<in> sset (permutationss xss)", "show ?thesis"], ["proof (prove)\nusing this:\n  set yss' \\<in> sset (permutationss xss)\n\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "using \\<open>set yss' = _\\<close>"], ["proof (prove)\nusing this:\n  set yss' \\<in> sset (permutationss xss)\n  set yss' = set yss\n\ngoal (1 subgoal):\n 1. set yss \\<in> sset (permutationss xss)", "by auto"], ["proof (state)\nthis:\n  set yss \\<in> sset (permutationss xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutations_complete: (* could generalize with multi-sets *)\n  assumes \"distinct xs\" \"distinct ys\" \"set xs = set ys\"\n  shows \"ys \\<in> set (permutations xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (permutations xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. ys \\<in> set (permutations xs)", "proof (induct \"length xs\" arbitrary: xs ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>0 = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)\n 2. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "case 0"], ["proof (state)\nthis:\n  0 = length xs\n  distinct xs\n  distinct ys\n  set xs = set ys\n\ngoal (2 subgoals):\n 1. \\<And>xs ys.\n       \\<lbrakk>0 = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)\n 2. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "then"], ["proof (chain)\npicking this:\n  0 = length xs\n  distinct xs\n  distinct ys\n  set xs = set ys", "show ?case"], ["proof (prove)\nusing this:\n  0 = length xs\n  distinct xs\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. ys \\<in> set (permutations xs)", "by simp"], ["proof (state)\nthis:\n  ys \\<in> set (permutations xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = length ?xs; distinct ?xs; distinct ?ys;\n   set ?xs = set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<in> set (permutations ?xs)\n  Suc n = length xs\n  distinct xs\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "from Suc.hyps"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = length ?xs; distinct ?xs; distinct ?ys;\n   set ?xs = set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<in> set (permutations ?xs)\n  Suc n = length xs", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = length ?xs; distinct ?xs; distinct ?ys;\n   set ?xs = set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?ys \\<in> set (permutations ?xs)\n  Suc n = length xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain y ys' where [simp]: \"ys = y # ys'\" \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; y \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc.prems"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  distinct xs\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; y \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ys) auto"], ["proof (state)\nthis:\n  ys = y # ys'\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "have \"ys' \\<in> set (permutations (remove1 y xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys' \\<in> set (permutations (remove1 y xs))", "using Suc.prems \\<open>Suc n = _\\<close>"], ["proof (prove)\nusing this:\n  distinct xs\n  distinct ys\n  set xs = set ys\n  Suc n = length xs\n\ngoal (1 subgoal):\n 1. ys' \\<in> set (permutations (remove1 y xs))", "by (intro Suc.hyps) (simp_all add: length_remove1 )"], ["proof (state)\nthis:\n  ys' \\<in> set (permutations (remove1 y xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   \\<lbrakk>x = length xs; distinct xs; distinct ys;\n                    set xs = set ys\\<rbrakk>\n                   \\<Longrightarrow> ys \\<in> set (permutations xs);\n        Suc x = length xs; distinct xs; distinct ys;\n        set xs = set ys\\<rbrakk>\n       \\<Longrightarrow> ys \\<in> set (permutations xs)", "then"], ["proof (chain)\npicking this:\n  ys' \\<in> set (permutations (remove1 y xs))", "show ?case"], ["proof (prove)\nusing this:\n  ys' \\<in> set (permutations (remove1 y xs))\n\ngoal (1 subgoal):\n 1. ys \\<in> set (permutations xs)", "using \\<open>xs \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  ys' \\<in> set (permutations (remove1 y xs))\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. ys \\<in> set (permutations xs)", "by (auto simp: set_permutations_step)"], ["proof (state)\nthis:\n  ys \\<in> set (permutations xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}