{"file_name": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates/l4v/lib/wp/NonDetMonadLemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates", "problem_names": ["lemma bind_cong[fundef_cong]:\n  \"\\<lbrakk> f = f'; \\<And>v s s'. (v, s') \\<in> fst (f' s) \\<Longrightarrow> g v s' = g' v s' \\<rbrakk> \\<Longrightarrow> f >>= g = f' >>= g'\"", "lemma bind_apply_cong [fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (rv, st) \\<in> fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk>\n       \\<Longrightarrow> (f >>= g) s = (f' >>= g') s'\"", "lemma bindE_cong[fundef_cong]:\n  \"\\<lbrakk> M = M' ; \\<And>v s s'. (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow> N v s' = N' v s' \\<rbrakk> \\<Longrightarrow> bindE M N = bindE M' N'\"", "lemma bindE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (Inr rv, st) \\<in> fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk> \n  \\<Longrightarrow> (f >>=E g) s = (f' >>=E g') s'\"", "lemma K_bind_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f st = f' st' \\<rbrakk> \\<Longrightarrow> K_bind f arg st = K_bind f' arg' st'\"", "lemma when_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\"", "lemma unless_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\"", "lemma whenE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\"", "lemma unlessE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\"", "lemma nested_bind [simp]:\n  \"do x <- do y <- f; return (g y) od; h x od =\n   do y <- f; h (g y) od\"", "lemma fail_bind [simp]:\n  \"fail >>= f = fail\"", "lemma fail_bindE [simp]:\n  \"fail >>=E f = fail\"", "lemma assert_False [simp]:\n  \"assert False >>= f = fail\"", "lemma assert_True [simp]:\n  \"assert True >>= f = f ()\"", "lemma assertE_False [simp]:\n  \"assertE False >>=E f = fail\"", "lemma assertE_True [simp]:\n  \"assertE True >>=E f = f ()\"", "lemma when_False_bind [simp]:\n  \"when False g >>= f = f ()\"", "lemma when_True_bind [simp]:\n  \"when True g >>= f = g >>= f\"", "lemma whenE_False_bind [simp]:\n  \"whenE False g >>=E f = f ()\"", "lemma whenE_True_bind [simp]:\n  \"whenE True g >>=E f = g >>=E f\"", "lemma when_True [simp]: \"when True X = X\"", "lemma when_False [simp]: \"when False X = return ()\"", "lemma unless_False [simp]: \"unless False X = X\"", "lemma unless_True [simp]: \"unless True X = return ()\"", "lemma unlessE_whenE:\n  \"unlessE P = whenE (~P)\"", "lemma unless_when:\n  \"unless P = when (~P)\"", "lemma gets_to_return [simp]: \"gets (\\<lambda>s. v) = return v\"", "lemma assert_opt_Some:\n  \"assert_opt (Some x) = return x\"", "lemma assertE_liftE:\n  \"assertE P = liftE (assert P)\"", "lemma liftE_handleE' [simp]: \"((liftE a) <handle2> b) = liftE a\"", "lemma liftE_handleE [simp]: \"((liftE a) <handle> b) = liftE a\"", "lemma condition_split:\n  \"P (condition C a b s) = ((((C s) \\<longrightarrow> P (a s)) \\<and> (\\<not> (C s) \\<longrightarrow> P (b s))))\"", "lemma condition_split_asm:\n  \"P (condition C a b s) = (\\<not> (C s \\<and> \\<not> P (a s) \\<or> \\<not> C s \\<and> \\<not> P (b s)))\"", "lemmas condition_splits = condition_split condition_split_asm", "lemma condition_true_triv [simp]:\n  \"condition (\\<lambda>_. True) A B = A\"", "lemma condition_false_triv [simp]:\n  \"condition (\\<lambda>_. False) A B = B\"", "lemma condition_true: \"\\<lbrakk> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = A s\"", "lemma condition_false: \"\\<lbrakk> \\<not> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = B s\"", "lemma monad_eqI [intro]:\n  \"\\<lbrakk> \\<And>r t s. (r, t) \\<in> fst (A s) \\<Longrightarrow> (r, t) \\<in> fst (B s);\n     \\<And>r t s. (r, t) \\<in> fst (B s) \\<Longrightarrow> (r, t) \\<in> fst (A s);\n     \\<And>x. snd (A x) = snd (B x) \\<rbrakk>\n  \\<Longrightarrow> (A :: ('s, 'a) nondet_monad) = B\"", "lemma monad_state_eqI [intro]:\n  \"\\<lbrakk> \\<And>r t. (r, t) \\<in> fst (A s) \\<Longrightarrow> (r, t) \\<in> fst (B s');\n     \\<And>r t. (r, t) \\<in> fst (B s') \\<Longrightarrow> (r, t) \\<in> fst (A s);\n     snd (A s) = snd (B s') \\<rbrakk>\n  \\<Longrightarrow> (A :: ('s, 'a) nondet_monad) s = B s'\"", "lemma whileLoop_cond_fail:\n    \"\\<lbrakk> \\<not> C x s \\<rbrakk> \\<Longrightarrow> (whileLoop C B x s) = (return x s)\"", "lemma whileLoopE_cond_fail:\n    \"\\<lbrakk> \\<not> C x s \\<rbrakk> \\<Longrightarrow> (whileLoopE C B x s) = (returnOk x s)\"", "lemma whileLoop_results_simps_no_move [simp]:\n  shows \"((Some x, Some x) \\<in> whileLoop_results C B) = (\\<not> C (fst x) (snd x))\"\n    (is \"?LHS x = ?RHS x\")", "lemma whileLoop_unroll:\n  \"(whileLoop C B r) =  ((condition (C r) (B r >>= (whileLoop C B)) (return r)))\"\n  (is \"?LHS r = ?RHS r\")", "lemma whileLoop_unroll':\n    \"(whileLoop C B r) = ((condition (C r) (B r) (return r)) >>= (whileLoop C B))\"", "lemma whileLoopE_unroll:\n  \"(whileLoopE C B r) =  ((condition (C r) (B r >>=E (whileLoopE C B)) (returnOk r)))\"", "lemma whileLoopE_unroll':\n  \"(whileLoopE C B r) =  ((condition (C r) (B r) (returnOk r)) >>=E (whileLoopE C B))\"", "lemma valid_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>\"", "lemma validNF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\"", "lemma validE_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>\"", "lemma validE_NF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>!\"", "lemma validNF_conjD1: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q \\<rbrace>!\"", "lemma validNF_conjD2: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\""], "translations": [["", "lemma bind_cong[fundef_cong]:\n  \"\\<lbrakk> f = f'; \\<And>v s s'. (v, s') \\<in> fst (f' s) \\<Longrightarrow> g v s' = g' v s' \\<rbrakk> \\<Longrightarrow> f >>= g = f' >>= g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = f';\n     \\<And>v s s'.\n        (v, s') \\<in> fst (f' s) \\<Longrightarrow> g v s' = g' v s'\\<rbrakk>\n    \\<Longrightarrow> f >>= g = f' >>= g'", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f = f';\n        \\<And>v s s'.\n           (v, s') \\<in> fst (f' s) \\<Longrightarrow>\n           g v s' = g' v s'\\<rbrakk>\n       \\<Longrightarrow> (f >>= g) x = (f' >>= g') x", "apply (auto simp: bind_def Let_def split_def intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_apply_cong [fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (rv, st) \\<in> fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk>\n       \\<Longrightarrow> (f >>= g) s = (f' >>= g') s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (rv, st) \\<in> fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (f >>= g) s = (f' >>= g') s'", "apply (simp add: bind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (rv, st) \\<in> fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>x\\<in>fst (f' s').\n                          fst (case x of (x, xa) \\<Rightarrow> g x xa)) =\n                      (\\<Union>a\\<in>fst (f' s').\n                          fst (case a of\n                               (x, xa) \\<Rightarrow> g' x xa)) \\<and>\n                      ((\\<exists>x\\<in>fst (f' s').\n                           snd (case x of\n                                (x, xa) \\<Rightarrow> g x xa)) \\<or>\n                       snd (f' s')) =\n                      ((\\<exists>x\\<in>fst (f' s').\n                           snd (case x of\n                                (x, xa) \\<Rightarrow> g' x xa)) \\<or>\n                       snd (f' s'))", "apply (auto simp: split_def intro: SUP_cong [OF refl] intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bindE_cong[fundef_cong]:\n  \"\\<lbrakk> M = M' ; \\<And>v s s'. (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow> N v s' = N' v s' \\<rbrakk> \\<Longrightarrow> bindE M N = bindE M' N'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = M';\n     \\<And>v s s'.\n        (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow>\n        N v s' = N' v s'\\<rbrakk>\n    \\<Longrightarrow> M >>=E N = M' >>=E N'", "apply (simp add: bindE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = M';\n     \\<And>v s s'.\n        (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow>\n        N v s' = N' v s'\\<rbrakk>\n    \\<Longrightarrow> M' >>= lift N = M' >>= lift N'", "apply (rule bind_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>M = M';\n     \\<And>v s s'.\n        (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow>\n        N v s' = N' v s'\\<rbrakk>\n    \\<Longrightarrow> M' = M'\n 2. \\<And>v s s'.\n       \\<lbrakk>M = M';\n        \\<And>v s s'.\n           (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow> N v s' = N' v s';\n        (v, s') \\<in> fst (M' s)\\<rbrakk>\n       \\<Longrightarrow> lift N v s' = lift N' v s'", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v s s'.\n       \\<lbrakk>M = M';\n        \\<And>v s s'.\n           (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow> N v s' = N' v s';\n        (v, s') \\<in> fst (M' s)\\<rbrakk>\n       \\<Longrightarrow> lift N v s' = lift N' v s'", "apply (unfold lift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v s s'.\n       \\<lbrakk>M = M';\n        \\<And>v s s'.\n           (Inr v, s') \\<in> fst (M' s) \\<Longrightarrow> N v s' = N' v s';\n        (v, s') \\<in> fst (M' s)\\<rbrakk>\n       \\<Longrightarrow> (case v of Inl e \\<Rightarrow> throwError e\n                          | Inr v' \\<Rightarrow> N v')\n                          s' =\n                         (case v of Inl e \\<Rightarrow> throwError e\n                          | Inr v' \\<Rightarrow> N' v')\n                          s'", "apply (case_tac v, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bindE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f s = f' s'; \\<And>rv st. (Inr rv, st) \\<in> fst (f' s') \\<Longrightarrow> g rv st = g' rv st \\<rbrakk> \n  \\<Longrightarrow> (f >>=E g) s = (f' >>=E g') s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (Inr rv, st) \\<in> fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (f >>=E g) s = (f' >>=E g') s'", "apply (simp add: bindE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (Inr rv, st) \\<in> fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> (f >>= lift g) s = (f' >>= lift g') s'", "apply (rule bind_apply_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>f s = f' s';\n     \\<And>rv st.\n        (Inr rv, st) \\<in> fst (f' s') \\<Longrightarrow>\n        g rv st = g' rv st\\<rbrakk>\n    \\<Longrightarrow> f s = f' s'\n 2. \\<And>rv st.\n       \\<lbrakk>f s = f' s';\n        \\<And>rv st.\n           (Inr rv, st) \\<in> fst (f' s') \\<Longrightarrow>\n           g rv st = g' rv st;\n        (rv, st) \\<in> fst (f' s')\\<rbrakk>\n       \\<Longrightarrow> lift g rv st = lift g' rv st", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rv st.\n       \\<lbrakk>f s = f' s';\n        \\<And>rv st.\n           (Inr rv, st) \\<in> fst (f' s') \\<Longrightarrow>\n           g rv st = g' rv st;\n        (rv, st) \\<in> fst (f' s')\\<rbrakk>\n       \\<Longrightarrow> lift g rv st = lift g' rv st", "apply (case_tac rv, simp_all add: lift_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma K_bind_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f st = f' st' \\<rbrakk> \\<Longrightarrow> K_bind f arg st = K_bind f' arg' st'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f st = f' st' \\<Longrightarrow> K_bind f arg st = K_bind f' arg' st'", "by simp"], ["", "lemma when_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> whenE C m s = whenE C' m' s'", "by (simp add: whenE_def)"], ["", "lemma unless_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s';\n     \\<not> C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> unlessE C m s = unlessE C' m' s'", "by (simp add: unlessE_def)"], ["", "lemma whenE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> whenE C m s = whenE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s'; C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> whenE C m s = whenE C' m' s'", "by (simp add: whenE_def)"], ["", "lemma unlessE_apply_cong[fundef_cong]:\n  \"\\<lbrakk> C = C'; s = s'; \\<not> C' \\<Longrightarrow> m s' = m' s' \\<rbrakk> \\<Longrightarrow> unlessE C m s = unlessE C' m' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C = C'; s = s';\n     \\<not> C' \\<Longrightarrow> m s' = m' s'\\<rbrakk>\n    \\<Longrightarrow> unlessE C m s = unlessE C' m' s'", "by (simp add: unlessE_def)"], ["", "subsection \"Simplifying Monads\""], ["", "lemma nested_bind [simp]:\n  \"do x <- do y <- f; return (g y) od; h x od =\n   do y <- f; h (g y) od\""], ["proof (prove)\ngoal (1 subgoal):\n 1. do y \\<leftarrow> f;\n       return (g y)\n    od >>=\n    h =\n    do y \\<leftarrow> f;\n       h (g y)\n    od", "apply (clarsimp simp add: bind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        (\\<Union>x\\<in>fst (f s).\n            \\<Union>a\\<in>fst (case x of\n                               (y, x) \\<Rightarrow> return (g y) x).\n               fst (case a of (x, xa) \\<Rightarrow> h x xa),\n         (\\<exists>y\\<in>fst (f s).\n             \\<exists>x\\<in>fst (case y of\n                                 (y, x) \\<Rightarrow> return (g y) x).\n                snd (case x of (x, xa) \\<Rightarrow> h x xa)) \\<or>\n         (\\<exists>x\\<in>fst (f s).\n             snd (case x of (y, x) \\<Rightarrow> return (g y) x)) \\<or>\n         snd (f s))) =\n    (\\<lambda>s.\n        (\\<Union>a\\<in>fst (f s).\n            fst (case a of (y, x) \\<Rightarrow> h (g y) x),\n         (\\<exists>x\\<in>fst (f s).\n             snd (case x of (y, x) \\<Rightarrow> h (g y) x)) \\<or>\n         snd (f s)))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<Union>x\\<in>fst (f s).\n           \\<Union>a\\<in>fst (case x of\n                              (y, x) \\<Rightarrow> return (g y) x).\n              fst (case a of (x, xa) \\<Rightarrow> h x xa),\n        (\\<exists>y\\<in>fst (f s).\n            \\<exists>x\\<in>fst (case y of\n                                (y, x) \\<Rightarrow> return (g y) x).\n               snd (case x of (x, xa) \\<Rightarrow> h x xa)) \\<or>\n        (\\<exists>x\\<in>fst (f s).\n            snd (case x of (y, x) \\<Rightarrow> return (g y) x)) \\<or>\n        snd (f s)) =\n       (\\<Union>a\\<in>fst (f s).\n           fst (case a of (y, x) \\<Rightarrow> h (g y) x),\n        (\\<exists>x\\<in>fst (f s).\n            snd (case x of (y, x) \\<Rightarrow> h (g y) x)) \\<or>\n        snd (f s))", "apply (clarsimp simp add: Let_def split_def return_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fail_bind [simp]:\n  \"fail >>= f = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fail >>= f = fail", "by (simp add: bind_def fail_def)"], ["", "lemma fail_bindE [simp]:\n  \"fail >>=E f = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fail >>=E f = fail", "by (simp add: bindE_def bind_def fail_def)"], ["", "lemma assert_False [simp]:\n  \"assert False >>= f = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert False >>= f = fail", "by (simp add: assert_def)"], ["", "lemma assert_True [simp]:\n  \"assert True >>= f = f ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert True >>= f = f ()", "by (simp add: assert_def)"], ["", "lemma assertE_False [simp]:\n  \"assertE False >>=E f = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assertE False >>=E f = fail", "by (simp add: assertE_def)"], ["", "lemma assertE_True [simp]:\n  \"assertE True >>=E f = f ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assertE True >>=E f = f ()", "by (simp add: assertE_def)"], ["", "lemma when_False_bind [simp]:\n  \"when False g >>= f = f ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. when False g >>= f = f ()", "by (rule ext) (simp add: when_def bind_def return_def)"], ["", "lemma when_True_bind [simp]:\n  \"when True g >>= f = g >>= f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. when True g >>= f = g >>= f", "by (simp add: when_def bind_def return_def)"], ["", "lemma whenE_False_bind [simp]:\n  \"whenE False g >>=E f = f ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. whenE False g >>=E f = f ()", "by (simp add: whenE_def bindE_def returnOk_def lift_def)"], ["", "lemma whenE_True_bind [simp]:\n  \"whenE True g >>=E f = g >>=E f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. whenE True g >>=E f = g >>=E f", "by (simp add: whenE_def bindE_def returnOk_def lift_def)"], ["", "lemma when_True [simp]: \"when True X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. when True X = X", "by (clarsimp simp: when_def)"], ["", "lemma when_False [simp]: \"when False X = return ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. when False X = return ()", "by (clarsimp simp: when_def)"], ["", "lemma unless_False [simp]: \"unless False X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unless False X = X", "by (clarsimp simp: unless_def)"], ["", "lemma unless_True [simp]: \"unless True X = return ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unless True X = return ()", "by (clarsimp simp: unless_def)"], ["", "lemma unlessE_whenE:\n  \"unlessE P = whenE (~P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlessE P = whenE (\\<not> P)", "by (rule ext)+ (simp add: unlessE_def whenE_def)"], ["", "lemma unless_when:\n  \"unless P = when (~P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unless P = when (\\<not> P)", "by (rule ext)+ (simp add: unless_def when_def)"], ["", "lemma gets_to_return [simp]: \"gets (\\<lambda>s. v) = return v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gets (\\<lambda>s. v) = return v", "by (clarsimp simp: gets_def put_def get_def bind_def return_def)"], ["", "lemma assert_opt_Some:\n  \"assert_opt (Some x) = return x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert_opt (Some x) = return x", "by (simp add: assert_opt_def)"], ["", "lemma assertE_liftE:\n  \"assertE P = liftE (assert P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assertE P = liftE (assert P)", "by (simp add: assertE_def assert_def liftE_def returnOk_def)"], ["", "lemma liftE_handleE' [simp]: \"((liftE a) <handle2> b) = liftE a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (liftE a <handle2> b) = liftE a", "apply (clarsimp simp: liftE_def handleE'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma liftE_handleE [simp]: \"((liftE a) <handle> b) = liftE a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (liftE a <handle> b) = liftE a", "apply (unfold handleE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (liftE a <handle2> b) = liftE a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_split:\n  \"P (condition C a b s) = ((((C s) \\<longrightarrow> P (a s)) \\<and> (\\<not> (C s) \\<longrightarrow> P (b s))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (condition C\n         a\n         b\n        s) =\n    ((C s \\<longrightarrow> P (a s)) \\<and>\n     (\\<not> C s \\<longrightarrow> P (b s)))", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_split_asm:\n  \"P (condition C a b s) = (\\<not> (C s \\<and> \\<not> P (a s) \\<or> \\<not> C s \\<and> \\<not> P (b s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (condition C\n         a\n         b\n        s) =\n    (\\<not> (C s \\<and> \\<not> P (a s) \\<or>\n             \\<not> C s \\<and> \\<not> P (b s)))", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas condition_splits = condition_split condition_split_asm"], ["", "lemma condition_true_triv [simp]:\n  \"condition (\\<lambda>_. True) A B = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. condition (\\<lambda>_. True)\n      A\n      B =\n    A", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. condition (\\<lambda>_. True)\n               A\n               B\n              x =\n             A x", "apply (clarsimp split: condition_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_false_triv [simp]:\n  \"condition (\\<lambda>_. False) A B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. condition (\\<lambda>_. False)\n      A\n      B =\n    B", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. condition (\\<lambda>_. False)\n               A\n               B\n              x =\n             B x", "apply (clarsimp split: condition_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_true: \"\\<lbrakk> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = A s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P s \\<Longrightarrow> condition P\n                            A\n                            B\n                           s =\n                          A s", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma condition_false: \"\\<lbrakk> \\<not> P s \\<rbrakk> \\<Longrightarrow> condition P A B s = B s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P s \\<Longrightarrow> condition P\n                                   A\n                                   B\n                                  s =\n                                 B s", "apply (clarsimp simp: condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \"Low-level monadic reasoning\""], ["", "lemma monad_eqI [intro]:\n  \"\\<lbrakk> \\<And>r t s. (r, t) \\<in> fst (A s) \\<Longrightarrow> (r, t) \\<in> fst (B s);\n     \\<And>r t s. (r, t) \\<in> fst (B s) \\<Longrightarrow> (r, t) \\<in> fst (A s);\n     \\<And>x. snd (A x) = snd (B x) \\<rbrakk>\n  \\<Longrightarrow> (A :: ('s, 'a) nondet_monad) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r t s.\n                (r, t) \\<in> fst (A s) \\<Longrightarrow>\n                (r, t) \\<in> fst (B s);\n     \\<And>r t s.\n        (r, t) \\<in> fst (B s) \\<Longrightarrow> (r, t) \\<in> fst (A s);\n     \\<And>x. snd (A x) = snd (B x)\\<rbrakk>\n    \\<Longrightarrow> A = B", "apply (fastforce intro!: set_eqI prod_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monad_state_eqI [intro]:\n  \"\\<lbrakk> \\<And>r t. (r, t) \\<in> fst (A s) \\<Longrightarrow> (r, t) \\<in> fst (B s');\n     \\<And>r t. (r, t) \\<in> fst (B s') \\<Longrightarrow> (r, t) \\<in> fst (A s);\n     snd (A s) = snd (B s') \\<rbrakk>\n  \\<Longrightarrow> (A :: ('s, 'a) nondet_monad) s = B s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r t.\n                (r, t) \\<in> fst (A s) \\<Longrightarrow>\n                (r, t) \\<in> fst (B s');\n     \\<And>r t.\n        (r, t) \\<in> fst (B s') \\<Longrightarrow> (r, t) \\<in> fst (A s);\n     snd (A s) = snd (B s')\\<rbrakk>\n    \\<Longrightarrow> A s = B s'", "apply (fastforce intro!: set_eqI prod_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"General whileLoop reasoning\""], ["", "definition\n  \"whileLoop_terminatesE C B \\<equiv> (\\<lambda>r.\n     whileLoop_terminates (\\<lambda>r s. case r of Inr v \\<Rightarrow> C v s | _ \\<Rightarrow> False) (lift B) (Inr r))\""], ["", "lemma whileLoop_cond_fail:\n    \"\\<lbrakk> \\<not> C x s \\<rbrakk> \\<Longrightarrow> (whileLoop C B x s) = (return x s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> C x s \\<Longrightarrow> whileLoop C\n                                     B\n                                    x s =\n                                   return x s", "apply (auto simp: return_def whileLoop_def\n       intro: whileLoop_results.intros\n              whileLoop_terminates.intros\n       elim!: whileLoop_results.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma whileLoopE_cond_fail:\n    \"\\<lbrakk> \\<not> C x s \\<rbrakk> \\<Longrightarrow> (whileLoopE C B x s) = (returnOk x s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> C x s \\<Longrightarrow> whileLoopE C\n                                     B\n                                    x s =\n                                   returnOk x s", "apply (clarsimp simp: whileLoopE_def returnOk_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> C x s \\<Longrightarrow>\n    whileLoop (\\<lambda>r s.\n                  case r of Inl a \\<Rightarrow> False\n                  | Inr v \\<Rightarrow> C v s)\n      (lift B)\n     (Inr x) s =\n    return (Inr x) s", "apply (auto intro: whileLoop_cond_fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma whileLoop_results_simps_no_move [simp]:\n  shows \"((Some x, Some x) \\<in> whileLoop_results C B) = (\\<not> C (fst x) (snd x))\"\n    (is \"?LHS x = ?RHS x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Some x, Some x) \\<in> whileLoop_results C B) =\n    (\\<not> C (fst x) (snd x))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (Some x, Some x) \\<in> whileLoop_results C B \\<Longrightarrow>\n    \\<not> C (fst x) (snd x)\n 2. \\<not> C (fst x) (snd x) \\<Longrightarrow>\n    (Some x, Some x) \\<in> whileLoop_results C B", "assume \"?LHS x\""], ["proof (state)\nthis:\n  (Some x, Some x) \\<in> whileLoop_results C B\n\ngoal (2 subgoals):\n 1. (Some x, Some x) \\<in> whileLoop_results C B \\<Longrightarrow>\n    \\<not> C (fst x) (snd x)\n 2. \\<not> C (fst x) (snd x) \\<Longrightarrow>\n    (Some x, Some x) \\<in> whileLoop_results C B", "then"], ["proof (chain)\npicking this:\n  (Some x, Some x) \\<in> whileLoop_results C B", "have \"(\\<exists>a. Some x = Some a) \\<longrightarrow> ?RHS (the (Some x))\""], ["proof (prove)\nusing this:\n  (Some x, Some x) \\<in> whileLoop_results C B\n\ngoal (1 subgoal):\n 1. (\\<exists>a. Some x = Some a) \\<longrightarrow>\n    \\<not> C (fst (the (Some x))) (snd (the (Some x)))", "by (induct rule: whileLoop_results.induct, auto)"], ["proof (state)\nthis:\n  (\\<exists>a. Some x = Some a) \\<longrightarrow>\n  \\<not> C (fst (the (Some x))) (snd (the (Some x)))\n\ngoal (2 subgoals):\n 1. (Some x, Some x) \\<in> whileLoop_results C B \\<Longrightarrow>\n    \\<not> C (fst x) (snd x)\n 2. \\<not> C (fst x) (snd x) \\<Longrightarrow>\n    (Some x, Some x) \\<in> whileLoop_results C B", "thus \"?RHS x\""], ["proof (prove)\nusing this:\n  (\\<exists>a. Some x = Some a) \\<longrightarrow>\n  \\<not> C (fst (the (Some x))) (snd (the (Some x)))\n\ngoal (1 subgoal):\n 1. \\<not> C (fst x) (snd x)", "by clarsimp"], ["proof (state)\nthis:\n  \\<not> C (fst x) (snd x)\n\ngoal (1 subgoal):\n 1. \\<not> C (fst x) (snd x) \\<Longrightarrow>\n    (Some x, Some x) \\<in> whileLoop_results C B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> C (fst x) (snd x) \\<Longrightarrow>\n    (Some x, Some x) \\<in> whileLoop_results C B", "assume \"?RHS x\""], ["proof (state)\nthis:\n  \\<not> C (fst x) (snd x)\n\ngoal (1 subgoal):\n 1. \\<not> C (fst x) (snd x) \\<Longrightarrow>\n    (Some x, Some x) \\<in> whileLoop_results C B", "thus \"?LHS x\""], ["proof (prove)\nusing this:\n  \\<not> C (fst x) (snd x)\n\ngoal (1 subgoal):\n 1. (Some x, Some x) \\<in> whileLoop_results C B", "by (metis surjective_pairing whileLoop_results.intros(1))"], ["proof (state)\nthis:\n  (Some x, Some x) \\<in> whileLoop_results C B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma whileLoop_unroll:\n  \"(whileLoop C B r) =  ((condition (C r) (B r >>= (whileLoop C B)) (return r)))\"\n  (is \"?LHS r = ?RHS r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. whileLoop C\n      B\n     r =\n    condition (C r)\n      (B r >>= whileLoop C\n                 B)\n      (return r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. whileLoop C\n      B\n     r =\n    condition (C r)\n      (B r >>= whileLoop C\n                 B)\n      (return r)", "have cond_fail: \"\\<And>r s. \\<not> C r s \\<Longrightarrow> ?LHS r s = ?RHS r s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<not> C r s \\<Longrightarrow>\n       whileLoop C\n         B\n        r s =\n       condition (C r)\n         (B r >>= whileLoop C\n                    B)\n         (return r)\n        s", "apply (subst whileLoop_cond_fail, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<not> C r s \\<Longrightarrow> return r s = condition (C r)\n               (B r >>= whileLoop C\n                          B)\n               (return r)\n              s", "apply (clarsimp simp: condition_def bind_def return_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> C ?r ?s \\<Longrightarrow>\n  whileLoop C\n    B\n   ?r ?s =\n  condition (C ?r)\n    (B ?r >>= whileLoop C\n                B)\n    (return ?r)\n   ?s\n\ngoal (1 subgoal):\n 1. whileLoop C\n      B\n     r =\n    condition (C r)\n      (B r >>= whileLoop C\n                 B)\n      (return r)", "have cond_pass: \"\\<And>r s. C r s \\<Longrightarrow> whileLoop C B r s = (B r >>= (whileLoop C B)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       C r s \\<Longrightarrow> whileLoop C\n                                 B\n                                r s =\n                               (B r >>= whileLoop C\n    B)\n                                s", "apply (rule monad_state_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r s ra t.\n       \\<lbrakk>C r s; (ra, t) \\<in> fst (whileLoop C\n      B\n     r s)\\<rbrakk>\n       \\<Longrightarrow> (ra, t) \\<in> fst ((B r >>= whileLoop C\n                 B)\n       s)\n 2. \\<And>r s ra t.\n       \\<lbrakk>C r s; (ra, t) \\<in> fst ((B r >>= whileLoop C\n               B)\n     s)\\<rbrakk>\n       \\<Longrightarrow> (ra, t) \\<in> fst (whileLoop C\n        B\n       r s)\n 3. \\<And>r s.\n       C r s \\<Longrightarrow>\n       snd (whileLoop C\n              B\n             r s) =\n       snd ((B r >>= whileLoop C\n                       B)\n             s)", "apply (clarsimp simp: whileLoop_def bind_def split_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r s ra t.\n       \\<lbrakk>C r s;\n        (Some (r, s), Some (ra, t)) \\<in> whileLoop_results C B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>fst (B r s).\n                            (Some x, Some (ra, t))\n                            \\<in> whileLoop_results C B\n 2. \\<And>r s ra t.\n       \\<lbrakk>C r s; (ra, t) \\<in> fst ((B r >>= whileLoop C\n               B)\n     s)\\<rbrakk>\n       \\<Longrightarrow> (ra, t) \\<in> fst (whileLoop C\n        B\n       r s)\n 3. \\<And>r s.\n       C r s \\<Longrightarrow>\n       snd (whileLoop C\n              B\n             r s) =\n       snd ((B r >>= whileLoop C\n                       B)\n             s)", "apply (subst (asm) whileLoop_results_simps_valid)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r s ra t.\n       \\<lbrakk>C r s;\n        (\\<exists>rb sa.\n            (r, s) = (rb, sa) \\<and>\n            (ra, t) = (rb, sa) \\<and> \\<not> C rb sa) \\<or>\n        (\\<exists>rb sa.\n            (r, s) = (rb, sa) \\<and>\n            C rb sa \\<and>\n            (\\<exists>r' s'.\n                (r', s') \\<in> fst (B rb sa) \\<and>\n                (Some (r', s'), Some (ra, t))\n                \\<in> whileLoop_results C B))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>fst (B r s).\n                            (Some x, Some (ra, t))\n                            \\<in> whileLoop_results C B\n 2. \\<And>r s ra t.\n       \\<lbrakk>C r s; (ra, t) \\<in> fst ((B r >>= whileLoop C\n               B)\n     s)\\<rbrakk>\n       \\<Longrightarrow> (ra, t) \\<in> fst (whileLoop C\n        B\n       r s)\n 3. \\<And>r s.\n       C r s \\<Longrightarrow>\n       snd (whileLoop C\n              B\n             r s) =\n       snd ((B r >>= whileLoop C\n                       B)\n             s)", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r s ra t.\n       \\<lbrakk>C r s; (ra, t) \\<in> fst ((B r >>= whileLoop C\n               B)\n     s)\\<rbrakk>\n       \\<Longrightarrow> (ra, t) \\<in> fst (whileLoop C\n        B\n       r s)\n 2. \\<And>r s.\n       C r s \\<Longrightarrow>\n       snd (whileLoop C\n              B\n             r s) =\n       snd ((B r >>= whileLoop C\n                       B)\n             s)", "apply (clarsimp simp: whileLoop_def bind_def split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r s ra t a b.\n       \\<lbrakk>C r s; (a, b) \\<in> fst (B r s);\n        (Some (a, b), Some (ra, t)) \\<in> whileLoop_results C B\\<rbrakk>\n       \\<Longrightarrow> (Some (r, s), Some (ra, t))\n                         \\<in> whileLoop_results C B\n 2. \\<And>r s.\n       C r s \\<Longrightarrow>\n       snd (whileLoop C\n              B\n             r s) =\n       snd ((B r >>= whileLoop C\n                       B)\n             s)", "apply (subst whileLoop_results.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r s ra t a b.\n       \\<lbrakk>C r s; (a, b) \\<in> fst (B r s);\n        (Some (a, b), Some (ra, t)) \\<in> whileLoop_results C B\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>rb sa.\n                             Some (r, s) = Some (rb, sa) \\<and>\n                             Some (ra, t) = Some (rb, sa) \\<and>\n                             \\<not> C rb sa) \\<or>\n                         (\\<exists>rb sa.\n                             Some (r, s) = Some (rb, sa) \\<and>\n                             Some (ra, t) = None \\<and>\n                             C rb sa \\<and> snd (B rb sa)) \\<or>\n                         (\\<exists>rb sa r' s' z.\n                             Some (r, s) = Some (rb, sa) \\<and>\n                             Some (ra, t) = z \\<and>\n                             C rb sa \\<and>\n                             (r', s') \\<in> fst (B rb sa) \\<and>\n                             (Some (r', s'), z) \\<in> whileLoop_results C B)\n 2. \\<And>r s.\n       C r s \\<Longrightarrow>\n       snd (whileLoop C\n              B\n             r s) =\n       snd ((B r >>= whileLoop C\n                       B)\n             s)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       C r s \\<Longrightarrow>\n       snd (whileLoop C\n              B\n             r s) =\n       snd ((B r >>= whileLoop C\n                       B)\n             s)", "apply (clarsimp simp: whileLoop_def bind_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       C r s \\<Longrightarrow>\n       ((Some (r, s), None) \\<in> whileLoop_results C B \\<or>\n        \\<not> whileLoop_terminates C B r s) =\n       ((\\<exists>x\\<in>fst (B r s).\n            (Some x, None) \\<in> whileLoop_results C B \\<or>\n            \\<not> whileLoop_terminates C B (fst x) (snd x)) \\<or>\n        snd (B r s))", "apply (subst whileLoop_results.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       C r s \\<Longrightarrow>\n       (((\\<exists>ra sa.\n             Some (r, s) = Some (ra, sa) \\<and>\n             None = Some (ra, sa) \\<and> \\<not> C ra sa) \\<or>\n         (\\<exists>ra sa.\n             Some (r, s) = Some (ra, sa) \\<and>\n             None = None \\<and> C ra sa \\<and> snd (B ra sa)) \\<or>\n         (\\<exists>ra sa r' s' z.\n             Some (r, s) = Some (ra, sa) \\<and>\n             None = z \\<and>\n             C ra sa \\<and>\n             (r', s') \\<in> fst (B ra sa) \\<and>\n             (Some (r', s'), z) \\<in> whileLoop_results C B)) \\<or>\n        \\<not> whileLoop_terminates C B r s) =\n       ((\\<exists>x\\<in>fst (B r s).\n            (Some x, None) \\<in> whileLoop_results C B \\<or>\n            \\<not> whileLoop_terminates C B (fst x) (snd x)) \\<or>\n        snd (B r s))", "apply (subst whileLoop_terminates.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       C r s \\<Longrightarrow>\n       (((\\<exists>ra sa.\n             Some (r, s) = Some (ra, sa) \\<and>\n             None = Some (ra, sa) \\<and> \\<not> C ra sa) \\<or>\n         (\\<exists>ra sa.\n             Some (r, s) = Some (ra, sa) \\<and>\n             None = None \\<and> C ra sa \\<and> snd (B ra sa)) \\<or>\n         (\\<exists>ra sa r' s' z.\n             Some (r, s) = Some (ra, sa) \\<and>\n             None = z \\<and>\n             C ra sa \\<and>\n             (r', s') \\<in> fst (B ra sa) \\<and>\n             (Some (r', s'), z) \\<in> whileLoop_results C B)) \\<or>\n        \\<not> ((\\<exists>ra sa.\n                    r = ra \\<and> s = sa \\<and> \\<not> C ra sa) \\<or>\n                (\\<exists>ra sa.\n                    r = ra \\<and>\n                    s = sa \\<and>\n                    C ra sa \\<and>\n                    (\\<forall>(x, y)\\<in>fst (B ra sa).\n                        whileLoop_terminates C B x y)))) =\n       ((\\<exists>x\\<in>fst (B r s).\n            (Some x, None) \\<in> whileLoop_results C B \\<or>\n            \\<not> whileLoop_terminates C B (fst x) (snd x)) \\<or>\n        snd (B r s))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  C ?r ?s \\<Longrightarrow> whileLoop C\n                              B\n                             ?r ?s =\n                            (B ?r >>= whileLoop C\n  B)\n                             ?s\n\ngoal (1 subgoal):\n 1. whileLoop C\n      B\n     r =\n    condition (C r)\n      (B r >>= whileLoop C\n                 B)\n      (return r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. whileLoop C\n      B\n     r =\n    condition (C r)\n      (B r >>= whileLoop C\n                 B)\n      (return r)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. whileLoop C\n               B\n              r x =\n             condition (C r)\n               (B r >>= whileLoop C\n                          B)\n               (return r)\n              x", "apply (metis cond_fail cond_pass condition_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  whileLoop C\n    B\n   r =\n  condition (C r)\n    (B r >>= whileLoop C\n               B)\n    (return r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma whileLoop_unroll':\n    \"(whileLoop C B r) = ((condition (C r) (B r) (return r)) >>= (whileLoop C B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. whileLoop C\n      B\n     r =\n    condition (C r)\n      (B r)\n      (return r) >>=\n    whileLoop C\n      B", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. whileLoop C\n               B\n              r x =\n             (condition (C r)\n                (B r)\n                (return r) >>=\n              whileLoop C\n                B)\n              x", "apply (subst whileLoop_unroll)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. condition (C r)\n               (B r >>= whileLoop C\n                          B)\n               (return r)\n              x =\n             (condition (C r)\n                (B r)\n                (return r) >>=\n              whileLoop C\n                B)\n              x", "apply (clarsimp simp: condition_def bind_def return_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> C r x \\<Longrightarrow> ({(r, x)}, False) = whileLoop C\n                      B\n                     r x", "apply (subst whileLoop_cond_fail, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> C r x \\<Longrightarrow> ({(r, x)}, False) = return r x", "apply (clarsimp simp: return_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma whileLoopE_unroll:\n  \"(whileLoopE C B r) =  ((condition (C r) (B r >>=E (whileLoopE C B)) (returnOk r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. whileLoopE C\n      B\n     r =\n    condition (C r)\n      (B r >>=E whileLoopE C\n                  B)\n      (returnOk r)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. whileLoopE C\n               B\n              r x =\n             condition (C r)\n               (B r >>=E whileLoopE C\n                           B)\n               (returnOk r)\n              x", "apply (unfold whileLoopE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       whileLoop (\\<lambda>r s.\n                     case r of Inl a \\<Rightarrow> False\n                     | Inr v \\<Rightarrow> C v s)\n         (lift B)\n        (Inr r) x =\n       condition (C r)\n         (doE r \\<leftarrow> B r;\n              whileLoop (\\<lambda>r s.\n                            case r of Inl a \\<Rightarrow> False\n                            | Inr v \\<Rightarrow> C v s)\n                (lift B)\n               (Inr r)\n          odE)\n         (returnOk r)\n        x", "apply (subst whileLoop_unroll)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       condition (\\<lambda>s.\n                     case Inr r of Inl a \\<Rightarrow> False\n                     | Inr v \\<Rightarrow> C v s)\n         (lift B (Inr r) >>=\n          whileLoop (\\<lambda>r s.\n                        case r of Inl a \\<Rightarrow> False\n                        | Inr v \\<Rightarrow> C v s)\n            (lift B))\n         (return (Inr r))\n        x =\n       condition (C r)\n         (doE r \\<leftarrow> B r;\n              whileLoop (\\<lambda>r s.\n                            case r of Inl a \\<Rightarrow> False\n                            | Inr v \\<Rightarrow> C v s)\n                (lift B)\n               (Inr r)\n          odE)\n         (returnOk r)\n        x", "apply (clarsimp simp: whileLoopE_def bindE_def returnOk_def split: condition_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       C r x \\<Longrightarrow>\n       (lift B (Inr r) >>=\n        whileLoop (\\<lambda>r s.\n                      case r of Inl a \\<Rightarrow> False\n                      | Inr v \\<Rightarrow> C v s)\n          (lift B))\n        x =\n       (B r >>=\n        lift\n         (\\<lambda>r.\n             whileLoop (\\<lambda>r s.\n                           case r of Inl a \\<Rightarrow> False\n                           | Inr v \\<Rightarrow> C v s)\n               (lift B)\n              (Inr r)))\n        x", "apply (clarsimp simp: lift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       C r x \\<Longrightarrow>\n       (B r >>=\n        whileLoop (\\<lambda>r s.\n                      case r of Inl a \\<Rightarrow> False\n                      | Inr v \\<Rightarrow> C v s)\n          (lift B))\n        x =\n       (B r >>=\n        lift\n         (\\<lambda>r.\n             whileLoop (\\<lambda>r s.\n                           case r of Inl a \\<Rightarrow> False\n                           | Inr v \\<Rightarrow> C v s)\n               (lift B)\n              (Inr r)))\n        x", "apply (rename_tac x, rule_tac f=\"\\<lambda>a. (B r >>= a) x\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       C r x \\<Longrightarrow>\n       whileLoop (\\<lambda>r s.\n                     case r of Inl a \\<Rightarrow> False\n                     | Inr v \\<Rightarrow> C v s)\n         (lift B) =\n       lift\n        (\\<lambda>r.\n            whileLoop (\\<lambda>r s.\n                          case r of Inl a \\<Rightarrow> False\n                          | Inr v \\<Rightarrow> C v s)\n              (lift B)\n             (Inr r))", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       C r x \\<Longrightarrow>\n       whileLoop (\\<lambda>r s.\n                     case r of Inl a \\<Rightarrow> False\n                     | Inr v \\<Rightarrow> C v s)\n         (lift B)\n        xa xb =\n       lift\n        (\\<lambda>r.\n            whileLoop (\\<lambda>r s.\n                          case r of Inl a \\<Rightarrow> False\n                          | Inr v \\<Rightarrow> C v s)\n              (lift B)\n             (Inr r))\n        xa xb", "apply (clarsimp simp: lift_def split: sum.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xb x1.\n       C r x \\<Longrightarrow>\n       whileLoop (\\<lambda>r s.\n                     (\\<forall>x1. r \\<noteq> Inl x1) \\<and>\n                     (\\<forall>x2. r = Inr x2 \\<longrightarrow> C x2 s))\n         (lift B)\n        (Inl x1) xb =\n       throwError x1 xb", "apply (subst whileLoop_unroll)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xb x1.\n       C r x \\<Longrightarrow>\n       condition (\\<lambda>s.\n                     (\\<forall>x1a. Inl x1 \\<noteq> Inl x1a) \\<and>\n                     (\\<forall>x2.\n                         Inl x1 = Inr x2 \\<longrightarrow> C x2 s))\n         (lift B (Inl x1) >>=\n          whileLoop (\\<lambda>r s.\n                        (\\<forall>x1. r \\<noteq> Inl x1) \\<and>\n                        (\\<forall>x2. r = Inr x2 \\<longrightarrow> C x2 s))\n            (lift B))\n         (return (Inl x1))\n        xb =\n       throwError x1 xb", "apply (subst condition_false)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xb x1.\n       C r x \\<Longrightarrow>\n       \\<not> ((\\<forall>x1a. Inl x1 \\<noteq> Inl x1a) \\<and>\n               (\\<forall>x2. Inl x1 = Inr x2 \\<longrightarrow> C x2 xb))\n 2. \\<And>x xb x1.\n       C r x \\<Longrightarrow> return (Inl x1) xb = throwError x1 xb", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xb x1.\n       C r x \\<Longrightarrow> return (Inl x1) xb = throwError x1 xb", "apply (clarsimp simp: throwError_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma whileLoopE_unroll':\n  \"(whileLoopE C B r) =  ((condition (C r) (B r) (returnOk r)) >>=E (whileLoopE C B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. whileLoopE C\n      B\n     r =\n    condition (C r)\n      (B r)\n      (returnOk r) >>=E\n    whileLoopE C\n      B", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. whileLoopE C\n               B\n              r x =\n             (condition (C r)\n                (B r)\n                (returnOk r) >>=E\n              whileLoopE C\n                B)\n              x", "apply (subst whileLoopE_unroll)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       condition (C r)\n         (B r >>=E whileLoopE C\n                     B)\n         (returnOk r)\n        x =\n       (condition (C r)\n          (B r)\n          (returnOk r) >>=E\n        whileLoopE C\n          B)\n        x", "apply (clarsimp simp: condition_def bindE_def bind_def returnOk_def return_def lift_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> C r x \\<Longrightarrow>\n       ({(Inr r, x)}, False) = whileLoopE C\n                                 B\n                                r x", "apply (subst whileLoopE_cond_fail, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> C r x \\<Longrightarrow> ({(Inr r, x)}, False) = returnOk r x", "apply (clarsimp simp: returnOk_def return_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* These lemmas are useful to apply to rules to convert valid rules into\n * a format suitable for wp. *)"], ["", "lemma valid_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace> \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>", "by (auto simp add: valid_def no_fail_def split: prod.splits)"], ["", "lemma validNF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>!", "by (auto simp add: valid_def validNF_def no_fail_def split: prod.splits)"], ["", "lemma validE_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace>, \\<lbrace>E s0\\<rbrace> \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s') \\<and>\n                   (\\<forall>rv s'.\n                       E s0 rv s' \\<longrightarrow> E' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>, \\<lbrace>E'\\<rbrace>", "by (auto simp add: validE_def valid_def no_fail_def split: prod.splits sum.splits)"], ["", "lemma validE_NF_make_schematic_post:\n  \"(\\<forall>s0. \\<lbrace> \\<lambda>s. P s0 s \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q s0 rv s \\<rbrace>, \\<lbrace> \\<lambda>rv s. E s0 rv s \\<rbrace>!) \\<Longrightarrow>\n   \\<lbrace> \\<lambda>s. \\<exists>s0. P s0 s \\<and> (\\<forall>rv s'. Q s0 rv s' \\<longrightarrow> Q' rv s')\n        \\<and> (\\<forall>rv s'. E s0 rv s' \\<longrightarrow> E' rv s') \\<rbrace> f \\<lbrace> Q' \\<rbrace>, \\<lbrace> E' \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s0. \\<lbrace>P s0\\<rbrace> f \n       \\<lbrace>Q s0\\<rbrace>, \\<lbrace>E s0\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>\\<lambda>s.\n                \\<exists>s0.\n                   P s0 s \\<and>\n                   (\\<forall>rv s'.\n                       Q s0 rv s' \\<longrightarrow> Q' rv s') \\<and>\n                   (\\<forall>rv s'.\n                       E s0 rv s' \\<longrightarrow> E' rv s')\\<rbrace>\n    f \\<lbrace>Q'\\<rbrace>, \\<lbrace>E'\\<rbrace>!", "by (auto simp add: validE_NF_def validE_def valid_def no_fail_def split: prod.splits sum.splits)"], ["", "lemma validNF_conjD1: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> f \n    \\<lbrace>\\<lambda>rv s.\n                Q rv s \\<and> Q' rv s\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>P\\<rbrace> f \\<lbrace>Q\\<rbrace>!", "by (fastforce simp: validNF_def valid_def no_fail_def)"], ["", "lemma validNF_conjD2: \"\\<lbrace> P \\<rbrace> f \\<lbrace> \\<lambda>rv s. Q rv s \\<and> Q' rv s \\<rbrace>! \\<Longrightarrow> \\<lbrace> P \\<rbrace> f \\<lbrace> Q' \\<rbrace>!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>P\\<rbrace> f \n    \\<lbrace>\\<lambda>rv s.\n                Q rv s \\<and> Q' rv s\\<rbrace>! \\<Longrightarrow>\n    \\<lbrace>P\\<rbrace> f \\<lbrace>Q'\\<rbrace>!", "by (fastforce simp: validNF_def valid_def no_fail_def)"], ["", "end"]]}