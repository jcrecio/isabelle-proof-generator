{"file_name": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates/Verification/Check_Non_Planarity_Verification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates", "problem_names": ["lemma cas_nonempty_ends:\n  assumes \"p \\<noteq> []\" \"cas u p v\" \"cas u' p v'\"\n  shows \"u = u'\" \"v = v'\"", "lemma awalk_nonempty_ends:\n  assumes \"p \\<noteq> []\" \"awalk u p v\" \"awalk u' p v'\"\n  shows \"u = u'\" \"v = v'\"", "lemma (in pair_graph) verts2_awalk_distinct:\n  assumes V: \"verts3 G \\<subseteq> V\" \"V \\<subseteq> pverts G\" \"u \\<in> V\"\n  assumes p: \"awalk u p v\" \"set (inner_verts p) \\<inter> V = {}\" \"progressing p\"\n  shows \"distinct (inner_verts p)\"", "lemma (in wf_digraph) inner_verts_conv':\n  assumes \"awalk u p v\" \"2 \\<le> length p\" shows \"inner_verts p = awalk_verts (head G (hd p)) (butlast (tl p))\"", "lemma verts3_in_verts:\n  assumes \"x \\<in> verts3 G\" shows \"x \\<in> verts G\"", "lemma (in pair_graph) deg2_awalk_is_iapath:\n  assumes V: \"verts3 G \\<subseteq> V\" \"V \\<subseteq> pverts G\"\n  assumes p: \"awalk u p v\" \"set (inner_verts p) \\<inter> V = {}\" \"progressing p\"\n  assumes in_V: \"u \\<in> V\" \"v \\<in> V\"\n  assumes \"u \\<noteq> v\"\n  shows \"gen_iapath V u p v\"", "lemma (in pair_graph) inner_verts_min_degree:\n  assumes walk_p: \"awalk u p v\" and progress: \"progressing p\"\n  and w_p: \"w \\<in> set (inner_verts p)\"\n  shows \"2 \\<le>in_degree G w\"", "lemma (in pair_pseudo_graph) gen_iapath_same2E:\n  assumes \"verts3 G \\<subseteq> V\" \"V \\<subseteq> pverts G\"\n  and \"gen_iapath V u p v\" \"gen_iapath V w q x\"\n  and \"e \\<in> set p\" \"e \\<in> set q\"\n  obtains \"p = q\"", "lemma verts_mkg': \"pverts (mk_graph' G) = set (ig_verts G)\"", "lemma arcs_mkg': \"parcs (mk_graph' G) = set (ig_arcs G)\"", "lemmas mkg'_simps = verts_mkg' arcs_mkg'", "lemma verts_mkg: \"pverts (mk_graph G) = set (ig_verts G)\"", "lemma parcs_mk_symmetric_symcl: \"parcs (mk_symmetric G) = (arcs_ends G)\\<^sup>s\"", "lemma arcs_mkg: \"parcs (mk_graph G) = (set (ig_arcs G))\\<^sup>s\"", "lemmas mkg_simps = verts_mkg arcs_mkg", "lemma ig_opposite_simps:\n  \"ig_opposite G (u,v) u = v\" \"ig_opposite G (v,u) u = v\"", "lemma distinct_ig_verts:\n  \"distinct (ig_verts G)\"", "lemma set_ig_arcs_verts:\n  assumes \"IGraph_inv G\" \"(u,v) \\<in> set (ig_arcs G)\" shows \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\"", "lemma IGraph_inv_conv:\n  \"IGraph_inv G \\<longleftrightarrow> pair_fin_digraph (mk_graph' G)\"", "lemma IGraph_inv_conv':\n  \"IGraph_inv G \\<longleftrightarrow> pair_pseudo_graph (mk_graph G)\"", "lemma iadj_io_edge:\n  assumes \"u \\<in> set (ig_verts G)\" \"e \\<in> set (ig_in_out_arcs G u)\"\n  shows \"iadj G u (ig_opposite G e u)\"", "lemma All_set_ig_verts: \"(\\<forall>v \\<in> set (ig_verts G). P v) \\<longleftrightarrow> (\\<forall>i < ig_verts_cnt G. P (ig_verts G ! i))\"", "lemma IGraph_imp_ppd_mkg':\n  assumes \"IGraph_inv G\" shows \"pair_fin_digraph (mk_graph' G)\"", "lemma finite_symcl_iff: \"finite (R\\<^sup>s) \\<longleftrightarrow> finite R\"", "lemma (in pair_fin_digraph) pair_pseudo_graphI_mk_symmetric:\n  \"pair_pseudo_graph (mk_symmetric G)\"", "lemma IGraph_imp_ppg_mkg:\n  assumes \"IGraph_inv G\" shows \"pair_pseudo_graph (mk_graph G)\"", "lemma IGraph_lf_imp_pg_mkg:\n  assumes \"IGraph_inv G\" \"loop_free (mk_graph G)\" shows \"pair_graph (mk_graph G)\"", "lemma set_ig_arcs_imp_verts:\n  assumes \"(u,v) \\<in> set (ig_arcs G)\" \"IGraph_inv G\" shows \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\"", "lemma iadj_imp_verts:\n  assumes \"iadj G u v\" \"IGraph_inv G\" shows \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\"", "lemma card_ig_neighbors_indegree:\n  assumes \"IGraph_inv G\"\n  shows \"card (ig_neighbors G u) = in_degree (mk_graph G) u\"", "lemma iadjD:\n  assumes \"iadj G u v\"\n  shows \"\\<exists>e \\<in> set (ig_in_out_arcs G u). (e = (u,v) \\<or> e = (v,u))\"", "lemma\n  ig_verts_empty[simp]: \"ig_verts ig_empty = []\" and\n  ig_verts_add_e[simp]: \"ig_verts (ig_add_e G u v) = ig_verts G\" and\n  ig_verts_add_v[simp]: \"ig_verts (ig_add_v G v) = ig_verts G @ (if v \\<in> set (ig_verts G) then [] else [v])\"", "lemma\n  ig_arcs_empty[simp]: \"ig_arcs ig_empty = []\" and\n  ig_arcs_add_e[simp]: \"ig_arcs (ig_add_e G u v) = ig_arcs G @ [(u,v)]\" and\n  ig_arcs_add_v[simp]: \"ig_arcs (ig_add_v G v) = ig_arcs G\"", "lemma is_subgraph_verts_0: \"is_subgraph_verts_inv G H 0\"", "lemma is_subgraph_verts_step:\n  assumes \"is_subgraph_verts_inv G H i\" \"ig_verts G ! i \\<in> set (ig_verts H)\"\n  assumes \"i < length (ig_verts G)\"\n  shows \"is_subgraph_verts_inv G H (Suc i)\"", "lemma is_subgraph_verts_last:\n  \"is_subgraph_verts_inv G H (length (ig_verts G)) \\<longleftrightarrow> pverts (mk_graph G) \\<subseteq> pverts (mk_graph H)\"", "lemma is_subgraph_arcs_0: \"is_subgraph_arcs_inv G H 0\"", "lemma is_subgraph_arcs_step:\n  assumes \"is_subgraph_arcs_inv G H i\"\n    \"e \\<in> set (ig_arcs H) \\<or> (snd e, fst e) \\<in> set (ig_arcs H)\"\n    \"fst e \\<in> set (ig_verts G)\" \"snd e \\<in> set (ig_verts G)\"\n  assumes \"e = ig_arcs G ! i\"\n  assumes \"i < length (ig_arcs G)\"\n  shows \"is_subgraph_arcs_inv G H (Suc i)\"", "lemma wellformed_pseudo_graph_mkg:\n  shows \"pair_wf_digraph (mk_graph G) = pair_pseudo_graph(mk_graph G)\" (is \"?L = ?R\")", "lemma is_subgraph_arcs_last:\n  \"is_subgraph_arcs_inv G H (length (ig_arcs G)) \\<longleftrightarrow> parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and> pair_pseudo_graph (mk_graph G)\"", "lemma is_subgraph_verts_arcs_last:\n  assumes \"is_subgraph_verts_inv G H (ig_verts_cnt G)\"\n  assumes \"is_subgraph_arcs_inv G H (ig_arcs_cnt G)\"\n  assumes \"IGraph_inv H\"\n  shows \"subgraph (mk_graph G) (mk_graph H)\" (is ?T1)\n        \"pair_pseudo_graph (mk_graph G)\" (is ?T2)", "lemma is_subgraph_false:\n  assumes \"subgraph (mk_graph G) (mk_graph H)\"\n  obtains \"\\<forall>i < length (ig_verts G). ig_verts G ! i \\<in> set (ig_verts H)\"\n    \"\\<forall>i < length (ig_arcs G). let (u,v) = ig_arcs G ! i in\n      ((u,v)\\<in> set (ig_arcs H) \\<or> (v,u) \\<in> set (ig_arcs H))\n      \\<and> u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)\"", "lemma (in is_subgraph_impl) is_subgraph_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>H \\<rbrace> \\<acute>R :== PROC is_subgraph(\\<acute>G, \\<acute>H) \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and> \\<acute>R = (subgraph (mk_graph \\<acute>G) (mk_graph \\<acute>H) \\<and> IGraph_inv \\<acute>G)\\<rbrace>\"", "lemma is_loopfree_0:\n  \"is_loopfree_inv G 0\"", "lemma is_loopfree_step1:\n  assumes \"is_loopfree_inv G n\"\n  assumes \"fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)\"\n  assumes \"n < ig_arcs_cnt G\"\n  shows \"is_loopfree_inv G (Suc n)\"", "lemma is_loopfree_step2:\n  assumes \"loop_free (mk_graph G)\"\n  assumes \"n < ig_arcs_cnt G\"\n  shows \"fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)\"", "lemma is_loopfree_last:\n  assumes \"is_loopfree_inv G (ig_arcs_cnt G)\"\n  shows \"loop_free (mk_graph G)\"", "lemma (in is_loopfree_impl) is_loopfree_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G \\<rbrace> \\<acute>R :== PROC is_loopfree(\\<acute>G) \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>R = loop_free (mk_graph \\<acute>G) \\<rbrace>\"", "lemma select_nodes_inv_step:\n  fixes G H i\n  defines \"v \\<equiv> ig_verts G ! i\"\n  assumes G_inv: \"IGraph_inv G\"\n  assumes sni_inv: \"select_nodes_inv G H i\"\n  assumes less: \"i < ig_verts_cnt G\"\n  assumes H': \"H' = (if 3 \\<le> card (ig_neighbors G v) then ig_add_v H v else H)\"\n  shows \"select_nodes_inv G H' (Suc i)\"", "lemma (in select_nodes_impl) select_nodes_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G\\<rbrace> \\<acute>R :== PROC select_nodes(\\<acute>G)\n   \\<lbrace> select_nodes_prop \\<^bsup>\\<sigma>\\<^esup>G \\<acute>R \\<and> IGraph_inv \\<acute>R \\<and> set (ig_arcs \\<acute>R) = {}\\<rbrace>\"", "lemma find_endpoint_path_first:\n  assumes \"iadj G u v\" \"u \\<noteq> v\" \"IGraph_inv G\"\n  shows \"find_endpoint_path_inv G H (Suc 0) u v u v\"", "lemma find_endpoint_arcs_0:\n  \"find_endpoint_arcs_inv G False 0 v0 v1 v0 v1\"", "lemma find_endpoint_path_lastE:\n  assumes \"find_endpoint_path_inv G H len u v w x\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes \"0 < len\"\n  assumes u: \"u \\<in> set (ig_verts H)\"\n  obtains p where \"pre_digraph.awalk (mk_graph G) u ((u,v) # p) x\"\n    and \"progressing ((u,v) # p)\"\n    and \"set (pre_digraph.inner_verts (mk_graph G) ((u,v) # p)) \\<inter> set (ig_verts H) = {}\"\n    and \"len \\<le> ig_verts_cnt G\"", "lemma find_endpoint_path_last1:\n  assumes \"find_endpoint_path_inv G H len u v w x\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes \"0 < len\"\n  assumes mem: \"u \\<in> set (ig_verts H)\" \"x \\<in> set (ig_verts H)\" \"u \\<noteq> x\"\n  shows \"\\<exists>p. pre_digraph.iapath (mk_graph G) u ((u,v) # p) x\"", "lemma find_endpoint_path_last2D:\n  assumes path: \"find_endpoint_path_inv G H len u v w u\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes \"0 < len\"\n  assumes mem: \"u \\<in> set (ig_verts H)\"\n  assumes iapath: \"pre_digraph.iapath (mk_graph G) u ((u,v) # p) x\"\n  shows False", "lemma find_endpoint_arcs_last:\n  assumes arcs: \"find_endpoint_arcs_inv G False (length (ig_in_out_arcs G v1)) v0 v1 v0a v1a\"\n  assumes path: \"find_endpoint_path_inv G H len v_tail v_next v0 v1\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes mem: \"v_tail \\<in> set (ig_verts H)\"\n  assumes \"0 < len\"\n  shows \"\\<not> pre_digraph.iapath (mk_graph G) v_tail ((v_tail, v_next) # p) x\"", "lemma find_endpoint_arcs_step1E:\n  assumes \"find_endpoint_arcs_inv G False k v0 v1 v0' v1'\"\n  assumes \"ig_opposite G (ig_in_out_arcs G v1 ! k) v1' \\<noteq> v0'\"\n  obtains \"v0 = v0'\" \"v1 = v1'\" \"find_endpoint_arcs_inv G True (Suc k) v0 v1 v1 (ig_opposite G (ig_in_out_arcs G v1 ! k) v1)\"", "lemma find_endpoint_arcs_step2E:\n  assumes \"find_endpoint_arcs_inv G False k v0 v1 v0' v1'\"\n  assumes \"ig_opposite G (ig_in_out_arcs G v1 ! k) v1' = v0'\"\n  obtains \"v0 = v0'\" \"v1 = v1'\" \"find_endpoint_arcs_inv G False (Suc k) v0 v1 v0 v1\"", "lemma find_endpoint_path_step:\n  assumes path: \"find_endpoint_path_inv G H len u v w x\" and \"0 < len\"\n  assumes arcs: \"find_endpoint_arcs_inv G True k w x w' x'\"\n  \"k \\<le> length (ig_in_out_arcs G x)\"\n  assumes ig: \"IGraph_inv G\"\n  assumes not_end: \"x \\<notin> set (ig_verts H)\"\n  shows \"find_endpoint_path_inv G H (Suc len) u v w' x'\"", "lemma no_loop_path:\n  assumes \"u = v\" and ig: \"IGraph_inv G\"\n  shows \"\\<not> (\\<exists>p w. pre_digraph.iapath (mk_graph G) u ((u, v) # p) w)\"", "lemma (in find_endpoint_impl) find_endpoint_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop \\<acute>G \\<acute>H \\<and> loop_free (mk_graph \\<acute>G) \\<and> \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and> iadj \\<acute>G \\<acute>v_tail \\<acute>v_next \\<and> IGraph_inv \\<acute>G\\<rbrace>\n    \\<acute>R :== PROC find_endpoint(\\<acute>G, \\<acute>H, \\<acute>v_tail, \\<acute>v_next)\n  \\<lbrace>case \\<acute>R of None \\<Rightarrow> \\<not>(\\<exists>p w. pre_digraph.iapath (mk_graph \\<^bsup>\\<sigma>\\<^esup>G) \\<^bsup>\\<sigma>\\<^esup>v_tail ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) # p) w)\n    | Some w \\<Rightarrow> (\\<exists>p. pre_digraph.iapath (mk_graph \\<^bsup>\\<sigma>\\<^esup>G) \\<^bsup>\\<sigma>\\<^esup>v_tail ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) # p) w) \\<rbrace>\"", "lemma contract_iter_adj_invE:\n  assumes \"contract_iter_adj_inv G H0 H u l\"\n  obtains \"set (ig_arcs H) - ({u} \\<times> UNIV) = set (ig_arcs H0)\" \"ig_verts H = ig_verts H0\"\n    \"\\<And>v. (u,v) \\<in> set (ig_arcs H) \\<longleftrightarrow> ((\\<exists>j<l. \\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\"", "lemma contract_iter_adj_inv_def':\n  \"contract_iter_adj_inv G H0 H u l \\<longleftrightarrow> (\n    set (ig_arcs H) - ({u} \\<times> UNIV) = set (ig_arcs H0)) \\<and> ig_verts H = ig_verts H0 \\<and>\n    (\\<forall>v. ((\\<exists>j<l. \\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v) \\<longrightarrow> (u,v) \\<in> set (ig_arcs H)) \\<and>\n      ((u,v) \\<in> set (ig_arcs H) \\<longrightarrow> ((\\<exists>j<l. \\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))))\"", "lemma select_nodes_prop_add_e[simp]:\n  \"select_nodes_prop G (ig_add_e H u v) = select_nodes_prop G H\"", "lemma contract_iter_adj_inv_step1:\n  assumes \"pair_pseudo_graph (mk_graph G)\"\n  assumes ciai: \"contract_iter_adj_inv G H0 H u l\"\n  assumes iapath: \"pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\"\n  shows \"contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)\"", "lemma contract_iter_adj_inv_step2:\n  assumes ciai: \"contract_iter_adj_inv G H0 H u l\"\n  assumes iapath: \"\\<And>p w. \\<not>pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\"\n  shows \"contract_iter_adj_inv G H0 H u (Suc l)\"", "lemma contract_iter_adj_propI:\n  assumes nodes: \"contract_iter_nodes_inv G H i\"\n  assumes ciai: \"contract_iter_adj_inv G H H' u (length (ig_in_out_arcs G u))\"\n  assumes u: \"u = ig_verts H ! i\"\n  shows \"contract_iter_adj_prop G H H' u\"", "lemma contract_iter_nodes_inv_step:\n  assumes nodes: \"contract_iter_nodes_inv G H i\"\n  assumes adj: \"contract_iter_adj_inv G H H' (ig_verts H ! i) (length (ig_in_out_arcs G (ig_verts H ! i)))\"\n  assumes snp: \"select_nodes_prop G H\"\n  shows \"contract_iter_nodes_inv G H' (Suc i)\"", "lemma contract_iter_nodes_0:\n  assumes \"set (ig_arcs H) = {}\" shows \"contract_iter_nodes_inv G H 0\"", "lemma contract_iter_adj_0:\n  assumes nodes: \"contract_iter_nodes_inv G H i\"\n  assumes i: \"i < ig_verts_cnt H\"\n  shows \"contract_iter_adj_inv G H H (ig_verts H ! i) 0\"", "lemma snp_vertexes:\n  assumes \"select_nodes_prop G H\" \"u \\<in> set (ig_verts H)\" shows \"u \\<in> set (ig_verts G)\"", "lemma igraph_ig_add_eI:\n  assumes \"IGraph_inv G\"\n  assumes \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\"\n  shows \"IGraph_inv (ig_add_e G u v)\"", "lemma snp_iapath_ends_in:\n  assumes \"select_nodes_prop G H\"\n  assumes \"pre_digraph.iapath (mk_graph G) u p v\"\n  shows \"u \\<in> set (ig_verts H)\" \"v \\<in> set (ig_verts H)\"", "lemma contract_iter_nodes_last:\n  assumes nodes: \"contract_iter_nodes_inv G H (ig_verts_cnt H)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes igraph: \"IGraph_inv G\"\n  shows \"mk_graph' H = contr_graph (mk_graph G)\" (is ?t1)\n    and \"symmetric (mk_graph' H)\" (is ?t2)", "lemma (in contract_impl) contract_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop \\<acute>G \\<acute>H \\<and> IGraph_inv \\<acute>G \\<and> loop_free (mk_graph \\<acute>G) \\<and> IGraph_inv \\<acute>H \\<and> set (ig_arcs \\<acute>H) = {}\\<rbrace>\n    \\<acute>R :== PROC contract(\\<acute>G, \\<acute>H)\n  \\<lbrace>\\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> mk_graph' \\<acute>R = contr_graph (mk_graph \\<acute>G) \\<and> symmetric (mk_graph' \\<acute>R) \\<and> IGraph_inv \\<acute>R\\<rbrace>\"", "lemma is_K33_colorize_0: \"is_K33_colorize_inv G u 0 (\\<lambda>_. False)\"", "lemma is_K33_component_size_0: \"is_K33_component_size_inv G 0 blue 0\"", "lemma is_K33_outer_0: \"is_K33_outer_inv G 0 blue\"", "lemma is_K33_inner_0: \"is_K33_inner_inv G k 0 blue\"", "lemma is_K33_colorize_last:\n  assumes \"u \\<in> set (ig_verts G)\"\n  shows \"is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\n    = (\\<forall>v \\<in> set (ig_verts G). blue v \\<longleftrightarrow> iadj G u v)\" (is \"?L = ?R\")", "lemma is_K33_component_size_last:\n  assumes \"k = ig_verts_cnt G\"\n  shows \"is_K33_component_size_inv G k blue cnt \\<longleftrightarrow> card {u \\<in> set (ig_verts G). blue u} = cnt\"", "lemma is_K33_outer_last:\n  \"is_K33_outer_inv G (ig_verts_cnt G) blue \\<longleftrightarrow> (\\<forall>u \\<in> set (ig_verts G). \\<forall>v \\<in> set (ig_verts G).\n    blue u = blue v \\<longleftrightarrow> (u,v) \\<notin> set (ig_arcs G))\"", "lemma is_K33_inner_last:\n  \"is_K33_inner_inv G k (ig_verts_cnt G) blue \\<longleftrightarrow> (\\<forall>v \\<in> set (ig_verts G).\n    blue (ig_verts G ! k) = blue v \\<longleftrightarrow> (ig_verts G ! k, v) \\<notin> set (ig_arcs G))\"", "lemma is_K33_colorize_step:\n  fixes G u i blue\n  assumes colorize: \"is_K33_colorize_inv G u k blue\"\n  shows \" is_K33_colorize_inv G u (Suc k) (blue (ig_opposite G (ig_in_out_arcs G u ! k) u := True))\"", "lemma is_K33_component_size_step1:\n  assumes comp:\"is_K33_component_size_inv G k blue blue_cnt\"\n  assumes blue: \"blue (ig_verts G ! k)\"\n  shows \"is_K33_component_size_inv G (Suc k) blue (Suc blue_cnt)\"", "lemma is_K33_component_size_step2:\n  assumes comp:\"is_K33_component_size_inv G k blue blue_cnt\"\n  assumes blue: \"\\<not>blue (ig_verts G ! k)\"\n  shows \"is_K33_component_size_inv G (Suc k) blue blue_cnt\"", "lemma is_K33_outer_step:\n  assumes \"is_K33_outer_inv G i blue\"\n  assumes \"is_K33_inner_inv G i (ig_verts_cnt G) blue\"\n  shows \"is_K33_outer_inv G (Suc i) blue\"", "lemma is_K33_inner_step:\n  assumes \"is_K33_inner_inv G i j blue\"\n  assumes \"(blue (ig_verts G ! i) = blue (ig_verts G ! j)) \\<longleftrightarrow> (ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G)\"\n  shows \"is_K33_inner_inv G i (Suc j) blue\"", "lemma K33_mkg'I:\n  fixes G col cnt\n  defines \"u \\<equiv> ig_verts G ! 0\"\n  assumes ig: \"IGraph_inv G\"\n  assumes iv_cnt: \"ig_verts_cnt G = 6\" and c1_cnt: \"cnt = 3\"\n  assumes colorize: \"is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\"\n  assumes comp: \"is_K33_component_size_inv G (ig_verts_cnt G) blue cnt\"\n  assumes outer: \"is_K33_outer_inv G (ig_verts_cnt G) blue\"\n  shows \"K\\<^bsub>3,3\\<^esub> (mk_graph' G)\"", "lemma K33_mkg'E:\n  assumes K33: \"K\\<^bsub>3,3\\<^esub> (mk_graph' G)\"\n  assumes ig: \"IGraph_inv G\"\n  assumes colorize: \"is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\"\n  and u: \"u \\<in> set (ig_verts G)\"\n  obtains \"is_K33_component_size_inv G (ig_verts_cnt G) blue 3\"\n    \"is_K33_outer_inv G (ig_verts_cnt G) blue\"", "lemma K33_card:\n  assumes \"K\\<^bsub>3,3\\<^esub> (mk_graph' G)\" shows \"ig_verts_cnt G = 6\"", "lemma is_K33_outerD:\n  assumes \"is_K33_outer_inv G (ig_verts_cnt G) blue\"\n  assumes \"i < ig_verts_cnt G\" \"j < ig_verts_cnt G\"\n  shows \"(blue (ig_verts G ! i) = blue (ig_verts G ! j)) \\<longleftrightarrow> (ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G)\"", "lemma (in is_K33_impl) is_K33_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G \\<and> symmetric (mk_graph' \\<acute>G)\\<rbrace>\n    \\<acute>R :== PROC is_K33(\\<acute>G)\n  \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>R = K\\<^bsub>3,3\\<^esub>(mk_graph' \\<acute>G) \\<rbrace>\"", "lemma K5_card:\n  assumes \"K\\<^bsub>5\\<^esub> (mk_graph' G)\" shows \"ig_verts_cnt G = 5\"", "lemma is_K5_inner_0: \"is_K5_inner_inv G k 0\"", "lemma is_K5_inner_last:\n  assumes \"l = ig_verts_cnt G\"\n  shows \"is_K5_inner_inv G k l \\<longleftrightarrow> (\\<forall>v \\<in> set (ig_verts G). ig_verts G ! k \\<noteq> v\n    \\<longleftrightarrow> (ig_verts G ! k, v) \\<in> set (ig_arcs G))\"", "lemma is_K5_outer_step:\n  assumes \"is_K5_outer_inv G k\"\n  assumes \"is_K5_inner_inv G k (ig_verts_cnt G)\"\n  shows \"is_K5_outer_inv G (Suc k)\"", "lemma is_K5_outer_last:\n  assumes \"is_K5_outer_inv G (ig_verts_cnt G)\"\n  assumes \"IGraph_inv G\" \"ig_verts_cnt G = 5\" \"symmetric (mk_graph' G)\"\n  shows \"K\\<^bsub>5\\<^esub> (mk_graph' G)\"", "lemma is_K5_inner_step:\n  assumes \"is_K5_inner_inv G k l\"\n  assumes \"k < ig_verts_cnt G\"\n  assumes \"k \\<noteq> l \\<longleftrightarrow> (ig_verts G ! k, ig_verts G ! l) \\<in> set (ig_arcs G)\"\n  shows \"is_K5_inner_inv G k (Suc l)\"", "lemma iK5E:\n  assumes \"K\\<^bsub>5\\<^esub> (mk_graph' G)\"\n  obtains \"ig_verts_cnt G = 5\" \"\\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk> \\<Longrightarrow> i \\<noteq> j \\<longleftrightarrow> (ig_verts G ! i, ig_verts G ! j) \\<in> set (ig_arcs G)\"", "lemma (in is_K5_impl) is_K5_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G \\<and> symmetric (mk_graph' \\<acute>G)\\<rbrace>\n    \\<acute>R :== PROC is_K5(\\<acute>G)\n  \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>R = K\\<^bsub>5\\<^esub>(mk_graph' \\<acute>G) \\<rbrace>\"", "lemma planar_theorem:\n  assumes \"pair_pseudo_graph G\" \"pair_pseudo_graph K\"\n  and \"subgraph K G\"\n  and \"K\\<^bsub>3,3\\<^esub> (contr_graph K) \\<or> K\\<^bsub>5\\<^esub> (contr_graph K)\"\n  shows \"\\<not>kuratowski_planar G\"", "lemma \"witness (mk_graph G) (mk_graph K) \\<longleftrightarrow> pair_pre_digraph.certify (mk_graph G) (mk_graph K) \\<and> loop_free (mk_graph K)\"", "lemma pwd_imp_ppg_mkg:\n  assumes \"pair_wf_digraph (mk_graph G)\"\n  shows \"pair_pseudo_graph (mk_graph G)\"", "theorem (in check_kuratowski_impl) check_kuratowski_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. pair_wf_digraph (mk_graph \\<acute>G)\\<rbrace>\n    \\<acute>R :== PROC check_kuratowski(\\<acute>G, \\<acute>K)\n  \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>K = \\<^bsup>\\<sigma>\\<^esup>K \\<and> \\<acute>R \\<longleftrightarrow> witness (mk_graph \\<acute>G) (mk_graph \\<acute>K)\\<rbrace>\"", "lemma check_kuratowski_correct:\n  assumes \"pair_pseudo_graph G\"\n  assumes \"witness G K\"\n  shows \"\\<not>kuratowski_planar G\"", "lemma check_kuratowski_correct_comb:\n  assumes \"pair_pseudo_graph G\"\n  assumes \"witness G K\"\n  shows \"\\<not>comb_planar G\"", "lemma check_kuratowski_complete:\n  assumes \"pair_pseudo_graph G\" \"pair_pseudo_graph K\" \"loop_free K\"\n  assumes \"subgraph K G\"\n  assumes \"subdivision_pair H K\" \"K\\<^bsub>3,3\\<^esub> H \\<or> K\\<^bsub>5\\<^esub> H\"\n  shows \"witness G K\""], "translations": [["", "lemma cas_nonempty_ends:\n  assumes \"p \\<noteq> []\" \"cas u p v\" \"cas u' p v'\"\n  shows \"u = u'\" \"v = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = u' &&& v = v'", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  cas u p v\n  cas u' p v'\n\ngoal (1 subgoal):\n 1. u = u' &&& v = v'", "apply (metis cas_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v'", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  cas u p v\n  cas u' p v'\n\ngoal (1 subgoal):\n 1. v = v'", "by (metis append_Nil2 cas.simps(1) cas_append_iff cas_simp)"], ["", "lemma awalk_nonempty_ends:\n  assumes \"p \\<noteq> []\" \"awalk u p v\" \"awalk u' p v'\"\n  shows \"u = u'\" \"v = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = u' &&& v = v'", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  awalk u p v\n  awalk u' p v'\n\ngoal (1 subgoal):\n 1. u = u' &&& v = v'", "by (auto simp: awalk_def intro: cas_nonempty_ends)"], ["", "end"], ["", "lemma (in pair_graph) verts2_awalk_distinct:\n  assumes V: \"verts3 G \\<subseteq> V\" \"V \\<subseteq> pverts G\" \"u \\<in> V\"\n  assumes p: \"awalk u p v\" \"set (inner_verts p) \\<inter> V = {}\" \"progressing p\"\n  shows \"distinct (inner_verts p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inner_verts p)", "using p"], ["proof (prove)\nusing this:\n  awalk u p v\n  set (inner_verts p) \\<inter> V = {}\n  progressing p\n\ngoal (1 subgoal):\n 1. distinct (inner_verts p)", "proof (induct p arbitrary: v rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>awalk u [] v; set (inner_verts []) \\<inter> V = {};\n        progressing []\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts [])\n 2. \\<And>x xs v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>awalk u xs v;\n                    set (inner_verts xs) \\<inter> V = {};\n                    progressing xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (inner_verts xs);\n        awalk u (xs @ [x]) v; set (inner_verts (xs @ [x])) \\<inter> V = {};\n        progressing (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  awalk u [] v\n  set (inner_verts []) \\<inter> V = {}\n  progressing []\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>awalk u [] v; set (inner_verts []) \\<inter> V = {};\n        progressing []\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts [])\n 2. \\<And>x xs v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>awalk u xs v;\n                    set (inner_verts xs) \\<inter> V = {};\n                    progressing xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (inner_verts xs);\n        awalk u (xs @ [x]) v; set (inner_verts (xs @ [x])) \\<inter> V = {};\n        progressing (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  awalk u [] v\n  set (inner_verts []) \\<inter> V = {}\n  progressing []", "show ?case"], ["proof (prove)\nusing this:\n  awalk u [] v\n  set (inner_verts []) \\<inter> V = {}\n  progressing []\n\ngoal (1 subgoal):\n 1. distinct (inner_verts [])", "by auto"], ["proof (state)\nthis:\n  distinct (inner_verts [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>awalk u xs v;\n                    set (inner_verts xs) \\<inter> V = {};\n                    progressing xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (inner_verts xs);\n        awalk u (xs @ [x]) v; set (inner_verts (xs @ [x])) \\<inter> V = {};\n        progressing (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>awalk u xs v;\n                    set (inner_verts xs) \\<inter> V = {};\n                    progressing xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (inner_verts xs);\n        awalk u (xs @ [x]) v; set (inner_verts (xs @ [x])) \\<inter> V = {};\n        progressing (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts (xs @ [x]))", "case (snoc e es)"], ["proof (state)\nthis:\n  \\<lbrakk>awalk u es ?v1; set (inner_verts es) \\<inter> V = {};\n   progressing es\\<rbrakk>\n  \\<Longrightarrow> distinct (inner_verts es)\n  awalk u (es @ [e]) v\n  set (inner_verts (es @ [e])) \\<inter> V = {}\n  progressing (es @ [e])\n\ngoal (1 subgoal):\n 1. \\<And>x xs v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>awalk u xs v;\n                    set (inner_verts xs) \\<inter> V = {};\n                    progressing xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (inner_verts xs);\n        awalk u (xs @ [x]) v; set (inner_verts (xs @ [x])) \\<inter> V = {};\n        progressing (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts (xs @ [x]))", "have \"distinct (inner_verts es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inner_verts es)", "apply (rule snoc.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. awalk u es ?v1\n 2. set (inner_verts es) \\<inter> V = {}\n 3. progressing es", "using snoc.prems"], ["proof (prove)\nusing this:\n  awalk u (es @ [e]) v\n  set (inner_verts (es @ [e])) \\<inter> V = {}\n  progressing (es @ [e])\n\ngoal (3 subgoals):\n 1. awalk u es ?v1\n 2. set (inner_verts es) \\<inter> V = {}\n 3. progressing es", "apply (auto dest: progressing_appendD1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>set (inner_verts (es @ [e])) \\<inter> V = {};\n        progressing (es @ [e]); awalk u es (last (pawalk_verts u es));\n        awalk (last (pawalk_verts u es)) [e] v;\n        x \\<in> set (inner_verts es); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis (hide_lams, no_types) disjoint_iff_not_equal in_set_inner_verts_appendI_l)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (inner_verts es)\n\ngoal (1 subgoal):\n 1. \\<And>x xs v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>awalk u xs v;\n                    set (inner_verts xs) \\<inter> V = {};\n                    progressing xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (inner_verts xs);\n        awalk u (xs @ [x]) v; set (inner_verts (xs @ [x])) \\<inter> V = {};\n        progressing (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (inner_verts (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (inner_verts (es @ [e]))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "assume A: \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> distinct (inner_verts (es @ [e]))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (inner_verts (es @ [e]))", "obtain es' e' where \"es = es' @ [e']\" \"es \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> distinct (inner_verts (es @ [e]))\n\ngoal (1 subgoal):\n 1. (\\<And>es' e'.\n        \\<lbrakk>es = es' @ [e']; es \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases es rule: rev_cases) auto"], ["proof (state)\nthis:\n  es = es' @ [e']\n  es \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "have \"fst e \\<in> set (inner_verts es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e \\<in> set (inner_verts es)", "using A \\<open>distinct (inner_verts es)\\<close>  \\<open>es \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  \\<not> distinct (inner_verts (es @ [e]))\n  distinct (inner_verts es)\n  es \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst e \\<in> set (inner_verts es)", "by (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  fst e \\<in> set (inner_verts es)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst e \\<in> set (inner_verts es)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "have \"fst e' \\<noteq> fst e\" \"snd e' = fst e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e' \\<noteq> fst e &&& snd e' = fst e", "using \\<open>es = es' @ [e']\\<close> snoc.prems(1)"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  awalk u (es @ [e]) v\n\ngoal (1 subgoal):\n 1. fst e' \\<noteq> fst e &&& snd e' = fst e", "by (auto simp: awalk_Cons_iff dest: no_loops)"], ["proof (state)\nthis:\n  fst e' \\<noteq> fst e\n  snd e' = fst e\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst e \\<in> set (inner_verts es)\n  fst e' \\<noteq> fst e\n  snd e' = fst e", "obtain es'' e'' where \"es' = es'' @ [e'']\""], ["proof (prove)\nusing this:\n  fst e \\<in> set (inner_verts es)\n  fst e' \\<noteq> fst e\n  snd e' = fst e\n\ngoal (1 subgoal):\n 1. (\\<And>es'' e''.\n        es' = es'' @ [e''] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases es' rule: rev_cases) (auto simp: \\<open>es = es' @ [e']\\<close> inner_verts_def)"], ["proof (state)\nthis:\n  es' = es'' @ [e'']\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  es' = es'' @ [e'']", "have \"fst e'' \\<noteq> fst e\""], ["proof (prove)\nusing this:\n  es' = es'' @ [e'']\n\ngoal (1 subgoal):\n 1. fst e'' \\<noteq> fst e", "using \\<open>snd e' = fst e\\<close>[symmetric] snoc.prems(1,3)"], ["proof (prove)\nusing this:\n  es' = es'' @ [e'']\n  fst e = snd e'\n  awalk u (es @ [e]) v\n  progressing (es @ [e])\n\ngoal (1 subgoal):\n 1. fst e'' \\<noteq> fst e", "unfolding \\<open>es = _\\<close>"], ["proof (prove)\nusing this:\n  es' = es'' @ [e'']\n  fst e = snd e'\n  awalk u ((es' @ [e']) @ [e]) v\n  progressing ((es' @ [e']) @ [e])\n\ngoal (1 subgoal):\n 1. fst e'' \\<noteq> fst e", "by (simp add: \\<open>es = _\\<close> awalk_Cons_iff progressing_append_iff progressing_Cons)"], ["proof (state)\nthis:\n  fst e'' \\<noteq> fst e\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "have \"fst e' \\<in> set (inner_verts es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e' \\<in> set (inner_verts es)", "using \\<open>es = es' @ [e']\\<close> \\<open>es' = es'' @ [e'']\\<close>"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  es' = es'' @ [e'']\n\ngoal (1 subgoal):\n 1. fst e' \\<in> set (inner_verts es)", "by (cases es'') (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  fst e' \\<in> set (inner_verts es)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "have \"fst e \\<in> set (inner_verts es')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e \\<in> set (inner_verts es')", "using \\<open>es = es' @ [e']\\<close> \\<open>fst e \\<in> set (inner_verts es)\\<close> \\<open>fst e' \\<noteq> fst e\\<close>"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  fst e \\<in> set (inner_verts es)\n  fst e' \\<noteq> fst e\n\ngoal (1 subgoal):\n 1. fst e \\<in> set (inner_verts es')", "by (cases es')  (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  fst e \\<in> set (inner_verts es')\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fst e \\<in> set (inner_verts es')", "obtain q e'2 e'3 r where Z: \"es' = q @ [e'2, e'3] @ r\" \"snd e'2 = fst e\" \"fst e'3 = fst e\""], ["proof (prove)\nusing this:\n  fst e \\<in> set (inner_verts es')\n\ngoal (1 subgoal):\n 1. (\\<And>q e'2 e'3 r.\n        \\<lbrakk>es' = q @ [e'2, e'3] @ r; snd e'2 = fst e;\n         fst e'3 = fst e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q e'2 e'3 r.\n                \\<lbrakk>es' = q @ [e'2, e'3] @ r; snd e'2 = fst e;\n                 fst e'3 = fst e\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst e \\<in> set (inner_verts es')\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain e'3' where \"e'3' \\<in> set (tl es')\" \"fst e'3' = fst e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e'3'.\n        \\<lbrakk>e'3' \\<in> set (tl es'); fst e'3' = fst e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>fst e \\<in> set (inner_verts es')\\<close>"], ["proof (prove)\nusing this:\n  fst e \\<in> set (inner_verts es')\n\ngoal (1 subgoal):\n 1. (\\<And>e'3'.\n        \\<lbrakk>e'3' \\<in> set (tl es'); fst e'3' = fst e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases es') (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  e'3' \\<in> set (tl es')\n  fst e'3' = fst e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q e'2 e'3 r.\n                \\<lbrakk>es' = q @ [e'2, e'3] @ r; snd e'2 = fst e;\n                 fst e'3 = fst e\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst e \\<in> set (inner_verts es')\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  e'3' \\<in> set (tl es')\n  fst e'3' = fst e", "obtain q r where \"tl es' = q @ e'3' # r\""], ["proof (prove)\nusing this:\n  e'3' \\<in> set (tl es')\n  fst e'3' = fst e\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        tl es' = q @ e'3' # r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis split_list)"], ["proof (state)\nthis:\n  tl es' = q @ e'3' # r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q e'2 e'3 r.\n                \\<lbrakk>es' = q @ [e'2, e'3] @ r; snd e'2 = fst e;\n                 fst e'3 = fst e\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst e \\<in> set (inner_verts es')\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  tl es' = q @ e'3' # r", "have F2: \"snd (last (hd es' # q)) = fst e\""], ["proof (prove)\nusing this:\n  tl es' = q @ e'3' # r\n\ngoal (1 subgoal):\n 1. snd (last (hd es' # q)) = fst e", "using \\<open>es = es' @ [e']\\<close> snoc.prems(1) \\<open>fst e'3' = fst e\\<close>"], ["proof (prove)\nusing this:\n  tl es' = q @ e'3' # r\n  es = es' @ [e']\n  awalk u (es @ [e]) v\n  fst e'3' = fst e\n\ngoal (1 subgoal):\n 1. snd (last (hd es' # q)) = fst e", "apply (cases es')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tl es' = q @ e'3' # r; es = es' @ [e']; awalk u (es @ [e]) v;\n     fst e'3' = fst e; es' = []\\<rbrakk>\n    \\<Longrightarrow> snd (last (hd es' # q)) = fst e\n 2. \\<And>a list.\n       \\<lbrakk>tl es' = q @ e'3' # r; es = es' @ [e'];\n        awalk u (es @ [e]) v; fst e'3' = fst e; es' = a # list\\<rbrakk>\n       \\<Longrightarrow> snd (last (hd es' # q)) = fst e", "apply (case_tac [2] q rule: rev_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>tl es' = q @ e'3' # r; es = es' @ [e']; awalk u (es @ [e]) v;\n     fst e'3' = fst e; es' = []\\<rbrakk>\n    \\<Longrightarrow> snd (last (hd es' # q)) = fst e\n 2. \\<And>a list.\n       \\<lbrakk>tl es' = q @ e'3' # r; es = es' @ [e'];\n        awalk u (es @ [e]) v; fst e'3' = fst e; es' = a # list;\n        q = []\\<rbrakk>\n       \\<Longrightarrow> snd (last (hd es' # q)) = fst e\n 3. \\<And>a list ys y.\n       \\<lbrakk>tl es' = q @ e'3' # r; es = es' @ [e'];\n        awalk u (es @ [e]) v; fst e'3' = fst e; es' = a # list;\n        q = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> snd (last (hd es' # q)) = fst e", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  snd (last (hd es' # q)) = fst e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q e'2 e'3 r.\n                \\<lbrakk>es' = q @ [e'2, e'3] @ r; snd e'2 = fst e;\n                 fst e'3 = fst e\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst e \\<in> set (inner_verts es')\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  snd (last (hd es' # q)) = fst e", "have \"es' = (butlast (hd es' # q)) @ [last (hd es' # q), e'3'] @ r\""], ["proof (prove)\nusing this:\n  snd (last (hd es' # q)) = fst e\n\ngoal (1 subgoal):\n 1. es' = butlast (hd es' # q) @ [last (hd es' # q), e'3'] @ r", "using \\<open>tl es' = q @ e'3' # r\\<close>"], ["proof (prove)\nusing this:\n  snd (last (hd es' # q)) = fst e\n  tl es' = q @ e'3' # r\n\ngoal (1 subgoal):\n 1. es' = butlast (hd es' # q) @ [last (hd es' # q), e'3'] @ r", "by (cases es') auto"], ["proof (state)\nthis:\n  es' = butlast (hd es' # q) @ [last (hd es' # q), e'3'] @ r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q e'2 e'3 r.\n                \\<lbrakk>es' = q @ [e'2, e'3] @ r; snd e'2 = fst e;\n                 fst e'3 = fst e\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst e \\<in> set (inner_verts es')\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  es' = butlast (hd es' # q) @ [last (hd es' # q), e'3'] @ r", "show ?thesis"], ["proof (prove)\nusing this:\n  es' = butlast (hd es' # q) @ [last (hd es' # q), e'3'] @ r\n\ngoal (1 subgoal):\n 1. thesis", "using F2 \\<open>fst e'3' = fst e\\<close>"], ["proof (prove)\nusing this:\n  es' = butlast (hd es' # q) @ [last (hd es' # q), e'3'] @ r\n  snd (last (hd es' # q)) = fst e\n  fst e'3' = fst e\n\ngoal (1 subgoal):\n 1. thesis", "by fact"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e", "have \"fst e'2 \\<noteq> snd e'3\""], ["proof (prove)\nusing this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> snd e'3", "using snoc.prems(3)"], ["proof (prove)\nusing this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n  progressing (es @ [e])\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> snd e'3", "unfolding \\<open>es = _\\<close>"], ["proof (prove)\nusing this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n  progressing ((es' @ [e']) @ [e])\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> snd e'3", "by (simp add: progressing_append_iff progressing_Cons)"], ["proof (state)\nthis:\n  fst e'2 \\<noteq> snd e'3\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst e'2 \\<noteq> snd e'3\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "from Z"], ["proof (chain)\npicking this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e", "have B: \"fst e'2 = u \\<or> fst e'2 \\<in> set (inner_verts es')\""], ["proof (prove)\nusing this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n\ngoal (1 subgoal):\n 1. fst e'2 = u \\<or> fst e'2 \\<in> set (inner_verts es')", "using \\<open>es = es' @ [e']\\<close> snoc.prems(1)"], ["proof (prove)\nusing this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n  es = es' @ [e']\n  awalk u (es @ [e]) v\n\ngoal (1 subgoal):\n 1. fst e'2 = u \\<or> fst e'2 \\<in> set (inner_verts es')", "by (cases q) (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  fst e'2 = u \\<or> fst e'2 \\<in> set (inner_verts es')\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fst e'2 = u \\<or> fst e'2 \\<in> set (inner_verts es')", "have \"fst e'2 \\<noteq> fst e'\""], ["proof (prove)\nusing this:\n  fst e'2 = u \\<or> fst e'2 \\<in> set (inner_verts es')\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> fst e'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. fst e'2 = u \\<Longrightarrow> fst e'2 \\<noteq> fst e'\n 2. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "assume \"fst e'2 = u\""], ["proof (state)\nthis:\n  fst e'2 = u\n\ngoal (2 subgoals):\n 1. fst e'2 = u \\<Longrightarrow> fst e'2 \\<noteq> fst e'\n 2. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "then"], ["proof (chain)\npicking this:\n  fst e'2 = u", "have \"fst e'2 \\<notin> set (inner_verts es)\""], ["proof (prove)\nusing this:\n  fst e'2 = u\n\ngoal (1 subgoal):\n 1. fst e'2 \\<notin> set (inner_verts es)", "using V \\<open>es = es' @ [e']\\<close> snoc.prems(2)"], ["proof (prove)\nusing this:\n  fst e'2 = u\n  verts3 (with_proj G) \\<subseteq> V\n  V \\<subseteq> pverts G\n  u \\<in> V\n  es = es' @ [e']\n  set (inner_verts (es @ [e])) \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. fst e'2 \\<notin> set (inner_verts es)", "by (cases es') (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  fst e'2 \\<notin> set (inner_verts es)\n\ngoal (2 subgoals):\n 1. fst e'2 = u \\<Longrightarrow> fst e'2 \\<noteq> fst e'\n 2. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "moreover"], ["proof (state)\nthis:\n  fst e'2 \\<notin> set (inner_verts es)\n\ngoal (2 subgoals):\n 1. fst e'2 = u \\<Longrightarrow> fst e'2 \\<noteq> fst e'\n 2. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "have \"fst e' \\<in> set (inner_verts es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e' \\<in> set (inner_verts es)", "using \\<open>es = es' @ [e']\\<close> \\<open>es' = es'' @ [e'']\\<close>"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  es' = es'' @ [e'']\n\ngoal (1 subgoal):\n 1. fst e' \\<in> set (inner_verts es)", "by (cases es'') (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  fst e' \\<in> set (inner_verts es)\n\ngoal (2 subgoals):\n 1. fst e'2 = u \\<Longrightarrow> fst e'2 \\<noteq> fst e'\n 2. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "ultimately"], ["proof (chain)\npicking this:\n  fst e'2 \\<notin> set (inner_verts es)\n  fst e' \\<in> set (inner_verts es)", "show ?thesis"], ["proof (prove)\nusing this:\n  fst e'2 \\<notin> set (inner_verts es)\n  fst e' \\<in> set (inner_verts es)\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> fst e'", "by auto"], ["proof (state)\nthis:\n  fst e'2 \\<noteq> fst e'\n\ngoal (1 subgoal):\n 1. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "assume \"fst e'2 \\<in> set (inner_verts es')\""], ["proof (state)\nthis:\n  fst e'2 \\<in> set (inner_verts es')\n\ngoal (1 subgoal):\n 1. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "moreover"], ["proof (state)\nthis:\n  fst e'2 \\<in> set (inner_verts es')\n\ngoal (1 subgoal):\n 1. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "have \"fst e' \\<in> set (inner_verts es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e' \\<in> set (inner_verts es)", "using \\<open>es = es' @ [e']\\<close> \\<open>es' = es'' @ [e'']\\<close>"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  es' = es'' @ [e'']\n\ngoal (1 subgoal):\n 1. fst e' \\<in> set (inner_verts es)", "by (cases es'') (auto simp: inner_verts_def)"], ["proof (state)\nthis:\n  fst e' \\<in> set (inner_verts es)\n\ngoal (1 subgoal):\n 1. fst e'2 \\<in> set (inner_verts es') \\<Longrightarrow>\n    fst e'2 \\<noteq> fst e'", "ultimately"], ["proof (chain)\npicking this:\n  fst e'2 \\<in> set (inner_verts es')\n  fst e' \\<in> set (inner_verts es)", "show ?thesis"], ["proof (prove)\nusing this:\n  fst e'2 \\<in> set (inner_verts es')\n  fst e' \\<in> set (inner_verts es)\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> fst e'", "using \\<open>distinct (inner_verts es)\\<close>"], ["proof (prove)\nusing this:\n  fst e'2 \\<in> set (inner_verts es')\n  fst e' \\<in> set (inner_verts es)\n  distinct (inner_verts es)\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> fst e'", "unfolding \\<open>es = es' @ [e']\\<close>"], ["proof (prove)\nusing this:\n  fst e'2 \\<in> set (inner_verts es')\n  fst e' \\<in> set (inner_verts (es' @ [e']))\n  distinct (inner_verts (es' @ [e']))\n\ngoal (1 subgoal):\n 1. fst e'2 \\<noteq> fst e'", "by (cases es') (fastforce simp: inner_verts_def)+"], ["proof (state)\nthis:\n  fst e'2 \\<noteq> fst e'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst e'2 \\<noteq> fst e'\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst e'2 \\<noteq> fst e'\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "have \"snd e'3 \\<noteq> fst e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd e'3 \\<noteq> fst e'", "proof (rule notI, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>snd e'3 = fst e'; ?P2\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>snd e'3 = fst e'; \\<not> ?P2\\<rbrakk> \\<Longrightarrow> False", "assume \"r = []\" \"snd e'3 = fst e'\""], ["proof (state)\nthis:\n  r = []\n  snd e'3 = fst e'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>snd e'3 = fst e'; ?P2\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>snd e'3 = fst e'; \\<not> ?P2\\<rbrakk> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r = []\n  snd e'3 = fst e'", "show False"], ["proof (prove)\nusing this:\n  r = []\n  snd e'3 = fst e'\n\ngoal (1 subgoal):\n 1. False", "using Z \\<open>es = es' @ [e']\\<close> snoc.prems(3) \\<open>snd e' = fst e\\<close>"], ["proof (prove)\nusing this:\n  r = []\n  snd e'3 = fst e'\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n  es = es' @ [e']\n  progressing (es @ [e])\n  snd e' = fst e\n\ngoal (1 subgoal):\n 1. False", "by (simp add: progressing_append_iff progressing_Cons)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd e'3 = fst e'; r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>snd e'3 = fst e'; r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "assume A: \"r \\<noteq> []\" \"snd e'3 = fst e'\""], ["proof (state)\nthis:\n  r \\<noteq> []\n  snd e'3 = fst e'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd e'3 = fst e'; r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r \\<noteq> []\n  snd e'3 = fst e'", "obtain r0 rs where \"r = r0 # rs\""], ["proof (prove)\nusing this:\n  r \\<noteq> []\n  snd e'3 = fst e'\n\ngoal (1 subgoal):\n 1. (\\<And>r0 rs. r = r0 # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) auto"], ["proof (state)\nthis:\n  r = r0 # rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd e'3 = fst e'; r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r = r0 # rs", "have \"snd e'3 = fst r0\""], ["proof (prove)\nusing this:\n  r = r0 # rs\n\ngoal (1 subgoal):\n 1. snd e'3 = fst r0", "using Z \\<open>es = es' @ [e']\\<close> snoc.prems(1)"], ["proof (prove)\nusing this:\n  r = r0 # rs\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n  es = es' @ [e']\n  awalk u (es @ [e]) v\n\ngoal (1 subgoal):\n 1. snd e'3 = fst r0", "by (auto simp: awalk_Cons_iff)"], ["proof (state)\nthis:\n  snd e'3 = fst r0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd e'3 = fst e'; r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  r \\<noteq> []\n  snd e'3 = fst e'\n  snd e'3 = fst r0", "have \"fst r0 = fst e'\""], ["proof (prove)\nusing this:\n  r \\<noteq> []\n  snd e'3 = fst e'\n  snd e'3 = fst r0\n\ngoal (1 subgoal):\n 1. fst r0 = fst e'", "by auto"], ["proof (state)\nthis:\n  fst r0 = fst e'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd e'3 = fst e'; r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<not>distinct (inner_verts es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts es)", "by (cases q) (auto simp add: Z(1) \\<open>es = es' @ [e']\\<close>\n          \\<open>r = r0 # rs\\<close> \\<open>fst r0 = fst e'\\<close> inner_verts_def)"], ["proof (state)\nthis:\n  \\<not> distinct (inner_verts es)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>snd e'3 = fst e'; r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (inner_verts es)", "show False"], ["proof (prove)\nusing this:\n  \\<not> distinct (inner_verts es)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>distinct (inner_verts es)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> distinct (inner_verts es)\n  distinct (inner_verts es)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd e'3 \\<noteq> fst e'\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst e'2 \\<noteq> snd e'3\n  fst e'2 \\<noteq> fst e'\n  snd e'3 \\<noteq> fst e'", "have card_to_fst_e: \"card {e'2, (snd e'3, fst e'3), e'} = 3\""], ["proof (prove)\nusing this:\n  fst e'2 \\<noteq> snd e'3\n  fst e'2 \\<noteq> fst e'\n  snd e'3 \\<noteq> fst e'\n\ngoal (1 subgoal):\n 1. card {e'2, (snd e'3, fst e'3), e'} = 3", "by (auto simp: card_insert_if)"], ["proof (state)\nthis:\n  card {e'2, (snd e'3, fst e'3), e'} = 3\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  card {e'2, (snd e'3, fst e'3), e'} = 3\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "have \"e'3 \\<in> parcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e'3 \\<in> parcs G", "using Z"], ["proof (prove)\nusing this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n\ngoal (1 subgoal):\n 1. e'3 \\<in> parcs G", "using snoc.prems(1) \\<open>es = es' @ [e']\\<close>"], ["proof (prove)\nusing this:\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n  awalk u (es @ [e]) v\n  es = es' @ [e']\n\ngoal (1 subgoal):\n 1. e'3 \\<in> parcs G", "by (auto intro: arcs_symmetric)"], ["proof (state)\nthis:\n  e'3 \\<in> parcs G\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  e'3 \\<in> parcs G", "have \"(snd e'3, fst e'3) \\<in> parcs G\""], ["proof (prove)\nusing this:\n  e'3 \\<in> parcs G\n\ngoal (1 subgoal):\n 1. (snd e'3, fst e'3) \\<in> parcs G", "by (auto intro: arcs_symmetric)"], ["proof (state)\nthis:\n  (snd e'3, fst e'3) \\<in> parcs G\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (snd e'3, fst e'3) \\<in> parcs G", "have \"{e'2, (snd e'3, fst e'3), e'} \\<subseteq> {ed \\<in> parcs G. snd ed = fst e}\""], ["proof (prove)\nusing this:\n  (snd e'3, fst e'3) \\<in> parcs G\n\ngoal (1 subgoal):\n 1. {e'2, (snd e'3, fst e'3), e'}\n    \\<subseteq> {ed \\<in> parcs G. snd ed = fst e}", "using snoc.prems(1) \\<open>es = es' @ [e']\\<close> Z"], ["proof (prove)\nusing this:\n  (snd e'3, fst e'3) \\<in> parcs G\n  awalk u (es @ [e]) v\n  es = es' @ [e']\n  es' = q @ [e'2, e'3] @ r\n  snd e'2 = fst e\n  fst e'3 = fst e\n\ngoal (1 subgoal):\n 1. {e'2, (snd e'3, fst e'3), e'}\n    \\<subseteq> {ed \\<in> parcs G. snd ed = fst e}", "by auto"], ["proof (state)\nthis:\n  {e'2, (snd e'3, fst e'3), e'}\n  \\<subseteq> {ed \\<in> parcs G. snd ed = fst e}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  {e'2, (snd e'3, fst e'3), e'}\n  \\<subseteq> {ed \\<in> parcs G. snd ed = fst e}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "have \"fst e \\<in> pverts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e \\<in> pverts G", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  awalk u (es @ [e]) v\n\ngoal (1 subgoal):\n 1. fst e \\<in> pverts G", "by auto"], ["proof (state)\nthis:\n  fst e \\<in> pverts G\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fst e \\<in> pverts G", "have card_to_fst_e_abs: \"card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2\""], ["proof (prove)\nusing this:\n  fst e \\<in> pverts G\n\ngoal (1 subgoal):\n 1. card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2", "using \\<open>fst e \\<in> set (inner_verts es)\\<close> V snoc.prems(2)"], ["proof (prove)\nusing this:\n  fst e \\<in> pverts G\n  fst e \\<in> set (inner_verts es)\n  verts3 (with_proj G) \\<subseteq> V\n  V \\<subseteq> pverts G\n  u \\<in> V\n  set (inner_verts (es @ [e])) \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2", "unfolding verts3_def in_degree_def"], ["proof (prove)\nusing this:\n  fst e \\<in> pverts G\n  fst e \\<in> set (inner_verts es)\n  {v \\<in> verts (with_proj G). 2 < card (in_arcs (with_proj G) v)}\n  \\<subseteq> V\n  V \\<subseteq> pverts G\n  u \\<in> V\n  set (inner_verts (es @ [e])) \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2", "by (cases es) (auto simp: inner_verts_def in_arcs_def)"], ["proof (state)\nthis:\n  card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  card {e'2, (snd e'3, fst e'3), e'} = 3\n  {e'2, (snd e'3, fst e'3), e'}\n  \\<subseteq> {ed \\<in> parcs G. snd ed = fst e}\n  card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2", "have \"{e'2, (snd e'3, fst e'3), e'} = {ed \\<in> parcs G. snd ed = fst e}\""], ["proof (prove)\nusing this:\n  card {e'2, (snd e'3, fst e'3), e'} = 3\n  {e'2, (snd e'3, fst e'3), e'}\n  \\<subseteq> {ed \\<in> parcs G. snd ed = fst e}\n  card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2\n\ngoal (1 subgoal):\n 1. {e'2, (snd e'3, fst e'3), e'} = {ed \\<in> parcs G. snd ed = fst e}", "by (intro card_seteq) auto"], ["proof (state)\nthis:\n  {e'2, (snd e'3, fst e'3), e'} = {ed \\<in> parcs G. snd ed = fst e}\n\ngoal (1 subgoal):\n 1. \\<not> distinct (inner_verts (es @ [e])) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {e'2, (snd e'3, fst e'3), e'} = {ed \\<in> parcs G. snd ed = fst e}", "show False"], ["proof (prove)\nusing this:\n  {e'2, (snd e'3, fst e'3), e'} = {ed \\<in> parcs G. snd ed = fst e}\n\ngoal (1 subgoal):\n 1. False", "using card_to_fst_e card_to_fst_e_abs"], ["proof (prove)\nusing this:\n  {e'2, (snd e'3, fst e'3), e'} = {ed \\<in> parcs G. snd ed = fst e}\n  card {e'2, (snd e'3, fst e'3), e'} = 3\n  card {ed \\<in> parcs G. snd ed = fst e} \\<le> 2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (inner_verts (es @ [e]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) inner_verts_conv':\n  assumes \"awalk u p v\" \"2 \\<le> length p\" shows \"inner_verts p = awalk_verts (head G (hd p)) (butlast (tl p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inner_verts p = awalk_verts (pre_digraph.head G (hd p)) (butlast (tl p))", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  2 \\<le> length p\n\ngoal (1 subgoal):\n 1. inner_verts p = awalk_verts (pre_digraph.head G (hd p)) (butlast (tl p))", "apply (cases p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>awalk u p v; 2 \\<le> length p; p = []\\<rbrakk>\n    \\<Longrightarrow> inner_verts p =\n                      awalk_verts (pre_digraph.head G (hd p))\n                       (butlast (tl p))\n 2. \\<And>a list.\n       \\<lbrakk>awalk u p v; 2 \\<le> length p; p = a # list\\<rbrakk>\n       \\<Longrightarrow> inner_verts p =\n                         awalk_verts (pre_digraph.head G (hd p))\n                          (butlast (tl p))", "apply (auto simp: awalk_Cons_iff; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>awalk u p v; 2 \\<le> length p; p = a # list\\<rbrakk>\n       \\<Longrightarrow> inner_verts p =\n                         awalk_verts (pre_digraph.head G (hd p))\n                          (butlast (tl p))", "apply (match premises in \"p = _ # as\" for as \\<Rightarrow> \\<open>cases as rule: rev_cases\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>awalk u p v; 2 \\<le> length p; p = a # list;\n        list = []\\<rbrakk>\n       \\<Longrightarrow> inner_verts p =\n                         awalk_verts (pre_digraph.head G (hd p))\n                          (butlast (tl p))\n 2. \\<And>a list ys y.\n       \\<lbrakk>awalk u p v; 2 \\<le> length p; p = a # list;\n        list = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> inner_verts p =\n                         awalk_verts (pre_digraph.head G (hd p))\n                          (butlast (tl p))", "apply (auto simp: inner_verts_def awalk_verts_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma verts3_in_verts:\n  assumes \"x \\<in> verts3 G\" shows \"x \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> verts G", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> verts3 G\n\ngoal (1 subgoal):\n 1. x \\<in> verts G", "unfolding verts3_def"], ["proof (prove)\nusing this:\n  x \\<in> {v \\<in> verts G. 2 < in_degree G v}\n\ngoal (1 subgoal):\n 1. x \\<in> verts G", "by auto"], ["", "lemma (in pair_graph) deg2_awalk_is_iapath:\n  assumes V: \"verts3 G \\<subseteq> V\" \"V \\<subseteq> pverts G\"\n  assumes p: \"awalk u p v\" \"set (inner_verts p) \\<inter> V = {}\" \"progressing p\"\n  assumes in_V: \"u \\<in> V\" \"v \\<in> V\"\n  assumes \"u \\<noteq> v\"\n  shows \"gen_iapath V u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_iapath V u p v", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> gen_iapath V u p v\n 2. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> gen_iapath V u p v\n 2. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "then"], ["proof (chain)\npicking this:\n  p = []", "show ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. gen_iapath V u p v", "using p(1) in_V \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  p = []\n  awalk u p v\n  u \\<in> V\n  v \\<in> V\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. gen_iapath V u p v", "by (auto simp: apath_def gen_iapath_def)"], ["proof (state)\nthis:\n  gen_iapath V u p v\n\ngoal (1 subgoal):\n 1. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "case (Cons p0 ps)"], ["proof (state)\nthis:\n  p = p0 # ps\n\ngoal (1 subgoal):\n 1. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "then"], ["proof (chain)\npicking this:\n  p = p0 # ps", "have ev_p: \"awalk_verts u p = u # butlast (tl (awalk_verts u p)) @ [v]\""], ["proof (prove)\nusing this:\n  p = p0 # ps\n\ngoal (1 subgoal):\n 1. pawalk_verts u p = u # butlast (tl (pawalk_verts u p)) @ [v]", "using p(1)"], ["proof (prove)\nusing this:\n  p = p0 # ps\n  awalk u p v\n\ngoal (1 subgoal):\n 1. pawalk_verts u p = u # butlast (tl (pawalk_verts u p)) @ [v]", "by (cases p) auto"], ["proof (state)\nthis:\n  pawalk_verts u p = u # butlast (tl (pawalk_verts u p)) @ [v]\n\ngoal (1 subgoal):\n 1. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "have \"u \\<notin> set (inner_verts p)\" \"v \\<notin> set (inner_verts p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> set (inner_verts p) &&& v \\<notin> set (inner_verts p)", "using p(2) in_V"], ["proof (prove)\nusing this:\n  set (inner_verts p) \\<inter> V = {}\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. u \\<notin> set (inner_verts p) &&& v \\<notin> set (inner_verts p)", "by auto"], ["proof (state)\nthis:\n  u \\<notin> set (inner_verts p)\n  v \\<notin> set (inner_verts p)\n\ngoal (1 subgoal):\n 1. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "with verts2_awalk_distinct[OF V in_V(1) p]"], ["proof (chain)\npicking this:\n  distinct (inner_verts p)\n  u \\<notin> set (inner_verts p)\n  v \\<notin> set (inner_verts p)", "have \"distinct (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  distinct (inner_verts p)\n  u \\<notin> set (inner_verts p)\n  v \\<notin> set (inner_verts p)\n\ngoal (1 subgoal):\n 1. distinct (pawalk_verts u p)", "using p(1) \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  distinct (inner_verts p)\n  u \\<notin> set (inner_verts p)\n  v \\<notin> set (inner_verts p)\n  awalk u p v\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. distinct (pawalk_verts u p)", "by (subst ev_p) (auto simp: inner_verts_conv[of p u] verts3_def)"], ["proof (state)\nthis:\n  distinct (pawalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<And>a list. p = a # list \\<Longrightarrow> gen_iapath V u p v", "then"], ["proof (chain)\npicking this:\n  distinct (pawalk_verts u p)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (pawalk_verts u p)\n\ngoal (1 subgoal):\n 1. gen_iapath V u p v", "using p(1-2) in_V \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  distinct (pawalk_verts u p)\n  awalk u p v\n  set (inner_verts p) \\<inter> V = {}\n  u \\<in> V\n  v \\<in> V\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. gen_iapath V u p v", "by (auto simp: apath_def gen_iapath_def)"], ["proof (state)\nthis:\n  gen_iapath V u p v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in pair_graph) inner_verts_min_degree:\n  assumes walk_p: \"awalk u p v\" and progress: \"progressing p\"\n  and w_p: \"w \\<in> set (inner_verts p)\"\n  shows \"2 \\<le>in_degree G w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "from w_p"], ["proof (chain)\npicking this:\n  w \\<in> set (inner_verts p)", "have \"2 \\<le> length p\""], ["proof (prove)\nusing this:\n  w \\<in> set (inner_verts p)\n\ngoal (1 subgoal):\n 1. 2 \\<le> length p", "using not_le"], ["proof (prove)\nusing this:\n  w \\<in> set (inner_verts p)\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. 2 \\<le> length p", "by fastforce"], ["proof (state)\nthis:\n  2 \\<le> length p\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "moreover"], ["proof (state)\nthis:\n  2 \\<le> length p\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "then"], ["proof (chain)\npicking this:\n  2 \\<le> length p", "obtain e1 es e2 where p_decomp: \"p = e1 # es @ [e2]\""], ["proof (prove)\nusing this:\n  2 \\<le> length p\n\ngoal (1 subgoal):\n 1. (\\<And>e1 es e2.\n        p = e1 # es @ [e2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def Suc_1 Suc_eq_plus1 le0 list.size(3) list.size(4) neq_Nil_conv not_less_eq_eq rev_cases)"], ["proof (state)\nthis:\n  p = e1 # es @ [e2]\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "ultimately"], ["proof (chain)\npicking this:\n  2 \\<le> length p\n  p = e1 # es @ [e2]", "have w_es: \"w \\<in> set (awalk_verts (snd e1) es)\""], ["proof (prove)\nusing this:\n  2 \\<le> length p\n  p = e1 # es @ [e2]\n\ngoal (1 subgoal):\n 1. w \\<in> set (pawalk_verts (snd e1) es)", "using walk_p w_p"], ["proof (prove)\nusing this:\n  2 \\<le> length p\n  p = e1 # es @ [e2]\n  awalk u p v\n  w \\<in> set (inner_verts p)\n\ngoal (1 subgoal):\n 1. w \\<in> set (pawalk_verts (snd e1) es)", "by (auto simp: apath_def inner_verts_conv')"], ["proof (state)\nthis:\n  w \\<in> set (pawalk_verts (snd e1) es)\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "have walk_es: \"awalk (snd e1) es (fst e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk (snd e1) es (fst e2)", "using walk_p"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. awalk (snd e1) es (fst e2)", "by (auto simp: p_decomp awalk_simps)"], ["proof (state)\nthis:\n  awalk (snd e1) es (fst e2)\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "obtain q r where es_decomp: \"es = q @ r\" \"awalk (snd e1) q w\" \"awalk w r (fst e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>es = q @ r; awalk (snd e1) q w; awalk w r (fst e2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using awalk_decomp[OF walk_es w_es]"], ["proof (prove)\nusing this:\n  \\<exists>q r.\n     es = q @ r \\<and> awalk (snd e1) q w \\<and> awalk w r (fst e2)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>es = q @ r; awalk (snd e1) q w; awalk w r (fst e2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  es = q @ r\n  awalk (snd e1) q w\n  awalk w r (fst e2)\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "define xs x y ys\n    where \"xs = butlast (e1 # q)\" and \"x = last (e1 # q)\"\n      and \"y = hd (r @ [e2])\" and \"ys = tl (r @ [e2])\""], ["proof (state)\nthis:\n  xs = butlast (e1 # q)\n  x = last (e1 # q)\n  y = hd (r @ [e2])\n  ys = tl (r @ [e2])\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "then"], ["proof (chain)\npicking this:\n  xs = butlast (e1 # q)\n  x = last (e1 # q)\n  y = hd (r @ [e2])\n  ys = tl (r @ [e2])", "have \"p = xs @ x # y # ys\""], ["proof (prove)\nusing this:\n  xs = butlast (e1 # q)\n  x = last (e1 # q)\n  y = hd (r @ [e2])\n  ys = tl (r @ [e2])\n\ngoal (1 subgoal):\n 1. p = xs @ x # y # ys", "by (auto simp: p_decomp es_decomp)"], ["proof (state)\nthis:\n  p = xs @ x # y # ys\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "moreover"], ["proof (state)\nthis:\n  p = xs @ x # y # ys\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "have \"awalk u (e1 # q) w\" \"awalk w (r @ [e2]) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u (e1 # q) w &&& awalk w (r @ [e2]) v", "using walk_p es_decomp p_decomp"], ["proof (prove)\nusing this:\n  awalk u p v\n  es = q @ r\n  awalk (snd e1) q w\n  awalk w r (fst e2)\n  p = e1 # es @ [e2]\n\ngoal (1 subgoal):\n 1. awalk u (e1 # q) w &&& awalk w (r @ [e2]) v", "by (auto simp: awalk_Cons_iff)"], ["proof (state)\nthis:\n  awalk u (e1 # q) w\n  awalk w (r @ [e2]) v\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "then"], ["proof (chain)\npicking this:\n  awalk u (e1 # q) w\n  awalk w (r @ [e2]) v", "have inc_w: \"snd x = w\" \"fst y = w\""], ["proof (prove)\nusing this:\n  awalk u (e1 # q) w\n  awalk w (r @ [e2]) v\n\ngoal (1 subgoal):\n 1. snd x = w &&& fst y = w", "unfolding x_def y_def"], ["proof (prove)\nusing this:\n  awalk u (e1 # q) w\n  awalk w (r @ [e2]) v\n\ngoal (1 subgoal):\n 1. snd (last (e1 # q)) = w &&& fst (hd (r @ [e2])) = w", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>awalk u (e1 # q) w; awalk w (r @ [e2]) v\\<rbrakk>\n    \\<Longrightarrow> snd (last (e1 # q)) = w\n 2. \\<lbrakk>awalk u (e1 # q) w; awalk w (r @ [e2]) v\\<rbrakk>\n    \\<Longrightarrow> fst (hd (r @ [e2])) = w", "apply (auto simp: awalk_Cons_iff awalk_verts_conv; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>awalk u (e1 # q) w; awalk w (r @ [e2]) v\\<rbrakk>\n    \\<Longrightarrow> fst (hd (r @ [e2])) = w", "apply (cases r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>awalk u (e1 # q) w; awalk w (r @ [e2]) v; r = []\\<rbrakk>\n    \\<Longrightarrow> fst (hd (r @ [e2])) = w\n 2. \\<And>a list.\n       \\<lbrakk>awalk u (e1 # q) w; awalk w (r @ [e2]) v;\n        r = a # list\\<rbrakk>\n       \\<Longrightarrow> fst (hd (r @ [e2])) = w", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  snd x = w\n  fst y = w\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "ultimately"], ["proof (chain)\npicking this:\n  p = xs @ x # y # ys\n  snd x = w\n  fst y = w", "have \"fst x \\<noteq> snd y\""], ["proof (prove)\nusing this:\n  p = xs @ x # y # ys\n  snd x = w\n  fst y = w\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> snd y", "using progress"], ["proof (prove)\nusing this:\n  p = xs @ x # y # ys\n  snd x = w\n  fst y = w\n  progressing p\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> snd y", "by (auto simp: progressing_append_iff progressing_Cons)"], ["proof (state)\nthis:\n  fst x \\<noteq> snd y\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "have \"x \\<in> parcs G\" \"y \\<in> parcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> parcs G &&& y \\<in> parcs G", "using walk_p \\<open>p = xs @ x # y # ys\\<close>"], ["proof (prove)\nusing this:\n  awalk u p v\n  p = xs @ x # y # ys\n\ngoal (1 subgoal):\n 1. x \\<in> parcs G &&& y \\<in> parcs G", "by auto"], ["proof (state)\nthis:\n  x \\<in> parcs G\n  y \\<in> parcs G\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "then"], ["proof (chain)\npicking this:\n  x \\<in> parcs G\n  y \\<in> parcs G", "have \"{x, (snd y, w)} \\<subseteq> {e \\<in> parcs G. snd e = w}\""], ["proof (prove)\nusing this:\n  x \\<in> parcs G\n  y \\<in> parcs G\n\ngoal (1 subgoal):\n 1. {x, (snd y, w)} \\<subseteq> {e \\<in> parcs G. snd e = w}", "using inc_w"], ["proof (prove)\nusing this:\n  x \\<in> parcs G\n  y \\<in> parcs G\n  snd x = w\n  fst y = w\n\ngoal (1 subgoal):\n 1. {x, (snd y, w)} \\<subseteq> {e \\<in> parcs G. snd e = w}", "by auto (metis arcs_symmetric surjective_pairing)"], ["proof (state)\nthis:\n  {x, (snd y, w)} \\<subseteq> {e \\<in> parcs G. snd e = w}\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "then"], ["proof (chain)\npicking this:\n  {x, (snd y, w)} \\<subseteq> {e \\<in> parcs G. snd e = w}", "have \"card {x, (snd y, w)} \\<le> in_degree G w\""], ["proof (prove)\nusing this:\n  {x, (snd y, w)} \\<subseteq> {e \\<in> parcs G. snd e = w}\n\ngoal (1 subgoal):\n 1. card {x, (snd y, w)} \\<le> in_degree (with_proj G) w", "unfolding in_degree_def"], ["proof (prove)\nusing this:\n  {x, (snd y, w)} \\<subseteq> {e \\<in> parcs G. snd e = w}\n\ngoal (1 subgoal):\n 1. card {x, (snd y, w)} \\<le> card (in_arcs (with_proj G) w)", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card {x, (snd y, w)} \\<le> in_degree (with_proj G) w\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "then"], ["proof (chain)\npicking this:\n  card {x, (snd y, w)} \\<le> in_degree (with_proj G) w", "show ?thesis"], ["proof (prove)\nusing this:\n  card {x, (snd y, w)} \\<le> in_degree (with_proj G) w\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "using \\<open>fst x \\<noteq> snd y\\<close> inc_w"], ["proof (prove)\nusing this:\n  card {x, (snd y, w)} \\<le> in_degree (with_proj G) w\n  fst x \\<noteq> snd y\n  snd x = w\n  fst y = w\n\ngoal (1 subgoal):\n 1. 2 \\<le> in_degree (with_proj G) w", "by (auto simp: card_insert_if split: if_split_asm)"], ["proof (state)\nthis:\n  2 \\<le> in_degree (with_proj G) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in pair_pseudo_graph) gen_iapath_same2E:\n  assumes \"verts3 G \\<subseteq> V\" \"V \\<subseteq> pverts G\"\n  and \"gen_iapath V u p v\" \"gen_iapath V w q x\"\n  and \"e \\<in> set p\" \"e \\<in> set q\"\n  obtains \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms same_gen_iapath_by_common_arc"], ["proof (prove)\nusing this:\n  verts3 (with_proj G) \\<subseteq> V\n  V \\<subseteq> pverts G\n  gen_iapath V u p v\n  gen_iapath V w q x\n  e \\<in> set p\n  e \\<in> set q\n  \\<lbrakk>verts3 (with_proj G) \\<subseteq> ?V; ?V \\<subseteq> pverts G;\n   gen_iapath ?V ?u ?p ?v; gen_iapath ?V ?w ?q ?x; ?e \\<in> set ?p;\n   ?e \\<in> set ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q\n\ngoal (1 subgoal):\n 1. (p = q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by metis"], ["", "definition mk_graph' :: \"IGraph \\<Rightarrow> ig_vertex pair_pre_digraph\" where\n  \"mk_graph' IG \\<equiv> \\<lparr> pverts = set (ig_verts IG), parcs = set (ig_arcs IG)\\<rparr>\""], ["", "definition mk_graph :: \"IGraph \\<Rightarrow> ig_vertex pair_pre_digraph\" where\n  \"mk_graph IG \\<equiv> mk_symmetric (mk_graph' IG)\""], ["", "lemma verts_mkg': \"pverts (mk_graph' G) = set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pverts (mk_graph' G) = set (ig_verts G)", "unfolding mk_graph'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pverts\n     \\<lparr>pverts = set (ig_verts G), parcs = set (ig_arcs G)\\<rparr> =\n    set (ig_verts G)", "by simp"], ["", "lemma arcs_mkg': \"parcs (mk_graph' G) = set (ig_arcs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parcs (mk_graph' G) = set (ig_arcs G)", "unfolding mk_graph'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. parcs\n     \\<lparr>pverts = set (ig_verts G), parcs = set (ig_arcs G)\\<rparr> =\n    set (ig_arcs G)", "by simp"], ["", "lemmas mkg'_simps = verts_mkg' arcs_mkg'"], ["", "lemma verts_mkg: \"pverts (mk_graph G) = set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pverts (mk_graph G) = set (ig_verts G)", "unfolding mk_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pverts (mk_symmetric (with_proj (mk_graph' G))) = set (ig_verts G)", "by (simp add: mkg'_simps )"], ["", "lemma parcs_mk_symmetric_symcl: \"parcs (mk_symmetric G) = (arcs_ends G)\\<^sup>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parcs (mk_symmetric G) = (arcs_ends G)\\<^sup>s", "by (auto simp: parcs_mk_symmetric symcl_def arcs_ends_conv)"], ["", "lemma arcs_mkg: \"parcs (mk_graph G) = (set (ig_arcs G))\\<^sup>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parcs (mk_graph G) = (set (ig_arcs G))\\<^sup>s", "unfolding mk_graph_def parcs_mk_symmetric_symcl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (arcs_ends (with_proj (mk_graph' G)))\\<^sup>s =\n    (set (ig_arcs G))\\<^sup>s", "by (simp add: arcs_mkg')"], ["", "lemmas mkg_simps = verts_mkg arcs_mkg"], ["", "definition iadj :: \"IGraph \\<Rightarrow> ig_vertex \\<Rightarrow> ig_vertex \\<Rightarrow> bool\" where\n  \"iadj G u v \\<equiv> (u,v) \\<in> set (ig_arcs G) \\<or> (v,u) \\<in> set (ig_arcs G)\""], ["", "definition \"loop_free G \\<equiv> (\\<forall>e \\<in> parcs G. fst e \\<noteq> snd e)\""], ["", "lemma ig_opposite_simps:\n  \"ig_opposite G (u,v) u = v\" \"ig_opposite G (v,u) u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_opposite G (u, v) u = v &&& ig_opposite G (v, u) u = v", "unfolding ig_opposite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if fst (u, v) = u then snd (u, v) else fst (u, v)) = v &&&\n    (if fst (v, u) = u then snd (v, u) else fst (v, u)) = v", "by auto"], ["", "lemma distinct_ig_verts:\n  \"distinct (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ig_verts G)", "by (cases G) (auto simp: ig_verts_def Abs_IGraph_inverse)"], ["", "lemma set_ig_arcs_verts:\n  assumes \"IGraph_inv G\" \"(u,v) \\<in> set (ig_arcs G)\" shows \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "using assms"], ["proof (prove)\nusing this:\n  IGraph_inv G\n  (u, v) \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "unfolding IGraph_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n  (u, v) \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "by (auto simp: mkg'_simps dest: all_nth_imp_all_set)"], ["", "lemma IGraph_inv_conv:\n  \"IGraph_inv G \\<longleftrightarrow> pair_fin_digraph (mk_graph' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "assume \"\\<forall>e\\<in>set (ig_arcs G). fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\""], ["proof (state)\nthis:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "then"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)", "have \"pair_fin_digraph (mk_graph' G)\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "by unfold_locales (auto simp: mkg'_simps)"], ["proof (state)\nthis:\n  pair_fin_digraph (mk_graph' G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "}"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and>\n     snd e \\<in> set (ig_verts G) \\<Longrightarrow>\n  pair_fin_digraph (mk_graph' G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "moreover"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and>\n     snd e \\<in> set (ig_verts G) \\<Longrightarrow>\n  pair_fin_digraph (mk_graph' G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "{"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and>\n     snd e \\<in> set (ig_verts G) \\<Longrightarrow>\n  pair_fin_digraph (mk_graph' G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "assume \"pair_fin_digraph (mk_graph' G)\""], ["proof (state)\nthis:\n  pair_fin_digraph (mk_graph' G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "then"], ["proof (chain)\npicking this:\n  pair_fin_digraph (mk_graph' G)", "interpret pair_fin_digraph \"mk_graph' G\""], ["proof (prove)\nusing this:\n  pair_fin_digraph (mk_graph' G)\n\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "have \"\\<forall>e\\<in>set (ig_arcs G). fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (ig_arcs G).\n       fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)", "using tail_in_verts head_in_verts"], ["proof (prove)\nusing this:\n  ?e \\<in> parcs (mk_graph' G) \\<Longrightarrow>\n  fst ?e \\<in> pverts (mk_graph' G)\n  ?e \\<in> parcs (mk_graph' G) \\<Longrightarrow>\n  snd ?e \\<in> pverts (mk_graph' G)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (ig_arcs G).\n       fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)", "by (fastforce simp: mkg'_simps in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "}"], ["proof (state)\nthis:\n  pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and>\n     snd e \\<in> set (ig_verts G) \\<Longrightarrow>\n  pair_fin_digraph (mk_graph' G)\n  pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and>\n     snd e \\<in> set (ig_verts G) \\<Longrightarrow>\n  pair_fin_digraph (mk_graph' G)\n  pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_fin_digraph (mk_graph' G)", "unfolding IGraph_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and>\n     snd e \\<in> set (ig_verts G) \\<Longrightarrow>\n  pair_fin_digraph (mk_graph' G)\n  pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>set (ig_arcs G).\n        fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)) =\n    pair_fin_digraph (mk_graph' G)", "by blast"], ["proof (state)\nthis:\n  IGraph_inv G = pair_fin_digraph (mk_graph' G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma IGraph_inv_conv':\n  \"IGraph_inv G \\<longleftrightarrow> pair_pseudo_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IGraph_inv G = pair_pseudo_graph (mk_graph G)", "unfolding IGraph_inv_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G) = pair_pseudo_graph (mk_graph G)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)\n 2. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "assume \"pair_fin_digraph (mk_graph' G)\""], ["proof (state)\nthis:\n  pair_fin_digraph (mk_graph' G)\n\ngoal (2 subgoals):\n 1. pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)\n 2. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "interpret ppd: pair_fin_digraph \"mk_graph' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)\n 2. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "interpret pd: pair_fin_digraph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph G)", "unfolding mk_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_symmetric (with_proj (mk_graph' G)))", ".."], ["proof (state)\ngoal (2 subgoals):\n 1. pair_fin_digraph (mk_graph' G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)\n 2. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "show \"pair_pseudo_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by unfold_locales (auto simp: mk_graph_def symmetric_mk_symmetric)"], ["proof (state)\nthis:\n  pair_pseudo_graph (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "assume A: \"pair_pseudo_graph (mk_graph G)\""], ["proof (state)\nthis:\n  pair_pseudo_graph (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "interpret ppg: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_fin_digraph (mk_graph' G)", "show \"pair_fin_digraph (mk_graph' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "using ppg.wellformed'"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> parcs (mk_graph G) \\<Longrightarrow>\n  ?u \\<in> pverts (mk_graph G)\n  (?u, ?v) \\<in> parcs (mk_graph G) \\<Longrightarrow>\n  ?v \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "by unfold_locales (auto simp: mkg_simps mkg'_simps symcl_def, auto)"], ["proof (state)\nthis:\n  pair_fin_digraph (mk_graph' G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iadj_io_edge:\n  assumes \"u \\<in> set (ig_verts G)\" \"e \\<in> set (ig_in_out_arcs G u)\"\n  shows \"iadj G u (ig_opposite G e u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iadj G u (ig_opposite G e u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. iadj G u (ig_opposite G e u)", "from assms"], ["proof (chain)\npicking this:\n  u \\<in> set (ig_verts G)\n  e \\<in> set (ig_in_out_arcs G u)", "obtain v where e: \"e = (u,v) \\<or>  e = (v,u)\" \"e \\<in> set (ig_arcs G)\""], ["proof (prove)\nusing this:\n  u \\<in> set (ig_verts G)\n  e \\<in> set (ig_in_out_arcs G u)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>e = (u, v) \\<or> e = (v, u);\n         e \\<in> set (ig_arcs G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ig_in_out_arcs_def"], ["proof (prove)\nusing this:\n  u \\<in> set (ig_verts G)\n  e \\<in> set (filter (\\<lambda>e. fst e = u \\<or> snd e = u) (ig_arcs G))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>e = (u, v) \\<or> e = (v, u);\n         e \\<in> set (ig_arcs G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e) auto"], ["proof (state)\nthis:\n  e = (u, v) \\<or> e = (v, u)\n  e \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. iadj G u (ig_opposite G e u)", "then"], ["proof (chain)\npicking this:\n  e = (u, v) \\<or> e = (v, u)\n  e \\<in> set (ig_arcs G)", "have *: \"ig_opposite G e u = v\""], ["proof (prove)\nusing this:\n  e = (u, v) \\<or> e = (v, u)\n  e \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. ig_opposite G e u = v", "by safe (auto simp: ig_opposite_def)"], ["proof (state)\nthis:\n  ig_opposite G e u = v\n\ngoal (1 subgoal):\n 1. iadj G u (ig_opposite G e u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. iadj G u (ig_opposite G e u)", "using e"], ["proof (prove)\nusing this:\n  e = (u, v) \\<or> e = (v, u)\n  e \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. iadj G u (ig_opposite G e u)", "unfolding iadj_def *"], ["proof (prove)\nusing this:\n  e = (u, v) \\<or> e = (v, u)\n  e \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs G) \\<or> (v, u) \\<in> set (ig_arcs G)", "by auto"], ["proof (state)\nthis:\n  iadj G u (ig_opposite G e u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma All_set_ig_verts: \"(\\<forall>v \\<in> set (ig_verts G). P v) \\<longleftrightarrow> (\\<forall>i < ig_verts_cnt G. P (ig_verts G ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (ig_verts G). P v) =\n    (\\<forall>i<ig_verts_cnt G. P (ig_verts G ! i))", "by (metis in_set_conv_nth ig_verts_cnt_def)"], ["", "lemma IGraph_imp_ppd_mkg':\n  assumes \"IGraph_inv G\" shows \"pair_fin_digraph (mk_graph' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "using assms"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "unfolding IGraph_inv_conv"], ["proof (prove)\nusing this:\n  pair_fin_digraph (mk_graph' G)\n\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "by auto"], ["", "lemma finite_symcl_iff: \"finite (R\\<^sup>s) \\<longleftrightarrow> finite R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R\\<^sup>s) = finite R", "unfolding symcl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R \\<union> (\\<lambda>(a, b). (b, a)) ` R) = finite R", "by blast"], ["", "lemma (in pair_fin_digraph) pair_pseudo_graphI_mk_symmetric:\n  \"pair_pseudo_graph (mk_symmetric G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_symmetric (with_proj G))", "by unfold_locales\n     (auto simp: parcs_mk_symmetric symmetric_mk_symmetric wellformed')"], ["", "lemma IGraph_imp_ppg_mkg:\n  assumes \"IGraph_inv G\" shows \"pair_pseudo_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using assms"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "unfolding mk_graph_def"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_symmetric (with_proj (mk_graph' G)))", "by (intro pair_fin_digraph.pair_pseudo_graphI_mk_symmetric IGraph_imp_ppd_mkg')"], ["", "lemma IGraph_lf_imp_pg_mkg:\n  assumes \"IGraph_inv G\" \"loop_free (mk_graph G)\" shows \"pair_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "interpret ppg: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using assms(1)"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by (rule IGraph_imp_ppg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "show \"pair_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "using assms"], ["proof (prove)\nusing this:\n  IGraph_inv G\n  loop_free (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "by unfold_locales (auto simp: loop_free_def)"], ["proof (state)\nthis:\n  pair_graph (mk_graph G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_ig_arcs_imp_verts:\n  assumes \"(u,v) \\<in> set (ig_arcs G)\" \"IGraph_inv G\" shows \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> set (ig_verts G)\n 2. v \\<in> set (ig_verts G)", "interpret pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> set (ig_arcs G)\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by (auto intro: IGraph_imp_ppg_mkg)"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> set (ig_verts G)\n 2. v \\<in> set (ig_verts G)", "from assms"], ["proof (chain)\npicking this:\n  (u, v) \\<in> set (ig_arcs G)\n  IGraph_inv G", "have \"(u,v) \\<in> parcs (mk_graph G)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> set (ig_arcs G)\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> parcs (mk_graph G)", "by (simp add: mkg_simps symcl_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> parcs (mk_graph G)\n\ngoal (2 subgoals):\n 1. u \\<in> set (ig_verts G)\n 2. v \\<in> set (ig_verts G)", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> parcs (mk_graph G)", "have \"u \\<in> pverts (mk_graph G)\" \"v \\<in> pverts (mk_graph G)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> parcs (mk_graph G)\n\ngoal (1 subgoal):\n 1. u \\<in> pverts (mk_graph G) &&& v \\<in> pverts (mk_graph G)", "by (auto dest: wellformed')"], ["proof (state)\nthis:\n  u \\<in> pverts (mk_graph G)\n  v \\<in> pverts (mk_graph G)\n\ngoal (2 subgoals):\n 1. u \\<in> set (ig_verts G)\n 2. v \\<in> set (ig_verts G)", "then"], ["proof (chain)\npicking this:\n  u \\<in> pverts (mk_graph G)\n  v \\<in> pverts (mk_graph G)", "show \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\""], ["proof (prove)\nusing this:\n  u \\<in> pverts (mk_graph G)\n  v \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "by (auto simp: mkg_simps)"], ["proof (state)\nthis:\n  u \\<in> set (ig_verts G)\n  v \\<in> set (ig_verts G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iadj_imp_verts:\n  assumes \"iadj G u v\" \"IGraph_inv G\" shows \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "using assms"], ["proof (prove)\nusing this:\n  iadj G u v\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "unfolding iadj_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> set (ig_arcs G) \\<or> (v, u) \\<in> set (ig_arcs G)\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G) &&& v \\<in> set (ig_verts G)", "by (auto dest: set_ig_arcs_imp_verts)"], ["", "lemma card_ig_neighbors_indegree:\n  assumes \"IGraph_inv G\"\n  shows \"card (ig_neighbors G u) = in_degree (mk_graph G) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "have inj2: \"inj_on (\\<lambda>e. ig_opposite G e u) {e \\<in> parcs (mk_graph G). snd e = u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>e. ig_opposite G e u)\n     {e \\<in> parcs (mk_graph G). snd e = u}", "unfolding ig_opposite_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>e. if fst e = u then snd e else fst e)\n     {e \\<in> parcs (mk_graph G). snd e = u}", "by (rule inj_onI) (fastforce split: if_split_asm)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>e. ig_opposite G e u)\n   {e \\<in> parcs (mk_graph G). snd e = u}\n\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "have \"ig_neighbors G u = (\\<lambda>e. ig_opposite G e u) ` {e \\<in> parcs (mk_graph G). snd e = u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_neighbors G u =\n    (\\<lambda>e. ig_opposite G e u) `\n    {e \\<in> parcs (mk_graph G). snd e = u}", "using assms"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. ig_neighbors G u =\n    (\\<lambda>e. ig_opposite G e u) `\n    {e \\<in> parcs (mk_graph G). snd e = u}", "unfolding ig_neighbors_def"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. {v \\<in> set (ig_verts G).\n     (u, v) \\<in> set (ig_arcs G) \\<or> (v, u) \\<in> set (ig_arcs G)} =\n    (\\<lambda>e. ig_opposite G e u) `\n    {e \\<in> parcs (mk_graph G). snd e = u}", "by (auto simp: ig_opposite_simps symcl_def mkg_simps set_ig_arcs_verts intro!: rev_image_eqI)"], ["proof (state)\nthis:\n  ig_neighbors G u =\n  (\\<lambda>e. ig_opposite G e u) ` {e \\<in> parcs (mk_graph G). snd e = u}\n\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "then"], ["proof (chain)\npicking this:\n  ig_neighbors G u =\n  (\\<lambda>e. ig_opposite G e u) ` {e \\<in> parcs (mk_graph G). snd e = u}", "have \"card (ig_neighbors G u) = card ((\\<lambda>e. ig_opposite G e u) ` {e \\<in> parcs (mk_graph G). snd e = u})\""], ["proof (prove)\nusing this:\n  ig_neighbors G u =\n  (\\<lambda>e. ig_opposite G e u) ` {e \\<in> parcs (mk_graph G). snd e = u}\n\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) =\n    card\n     ((\\<lambda>e. ig_opposite G e u) `\n      {e \\<in> parcs (mk_graph G). snd e = u})", "by simp"], ["proof (state)\nthis:\n  card (ig_neighbors G u) =\n  card\n   ((\\<lambda>e. ig_opposite G e u) `\n    {e \\<in> parcs (mk_graph G). snd e = u})\n\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "also"], ["proof (state)\nthis:\n  card (ig_neighbors G u) =\n  card\n   ((\\<lambda>e. ig_opposite G e u) `\n    {e \\<in> parcs (mk_graph G). snd e = u})\n\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "have \"\\<dots> = in_degree (mk_graph G) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>e. ig_opposite G e u) `\n      {e \\<in> parcs (mk_graph G). snd e = u}) =\n    in_degree (with_proj (mk_graph G)) u", "unfolding in_degree_def in_arcs_def with_proj_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>e. ig_opposite G e u) `\n      {e \\<in> parcs (mk_graph G). snd e = u}) =\n    card {e \\<in> parcs (mk_graph G). snd e = u}", "using inj2"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>e. ig_opposite G e u)\n   {e \\<in> parcs (mk_graph G). snd e = u}\n\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>e. ig_opposite G e u) `\n      {e \\<in> parcs (mk_graph G). snd e = u}) =\n    card {e \\<in> parcs (mk_graph G). snd e = u}", "by (rule card_image)"], ["proof (state)\nthis:\n  card\n   ((\\<lambda>e. ig_opposite G e u) `\n    {e \\<in> parcs (mk_graph G). snd e = u}) =\n  in_degree (with_proj (mk_graph G)) u\n\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "finally"], ["proof (chain)\npicking this:\n  card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "show ?thesis"], ["proof (prove)\nusing this:\n  card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u\n\ngoal (1 subgoal):\n 1. card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u", "."], ["proof (state)\nthis:\n  card (ig_neighbors G u) = in_degree (with_proj (mk_graph G)) u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iadjD:\n  assumes \"iadj G u v\"\n  shows \"\\<exists>e \\<in> set (ig_in_out_arcs G u). (e = (u,v) \\<or> e = (v,u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (ig_in_out_arcs G u). e = (u, v) \\<or> e = (v, u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (ig_in_out_arcs G u). e = (u, v) \\<or> e = (v, u)", "from assms"], ["proof (chain)\npicking this:\n  iadj G u v", "obtain e where \"e \\<in> set (ig_arcs G)\" \"e = (u,v) \\<or> e = (v,u)\""], ["proof (prove)\nusing this:\n  iadj G u v\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set (ig_arcs G);\n         e = (u, v) \\<or> e = (v, u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding iadj_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> set (ig_arcs G) \\<or> (v, u) \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set (ig_arcs G);\n         e = (u, v) \\<or> e = (v, u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e \\<in> set (ig_arcs G)\n  e = (u, v) \\<or> e = (v, u)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (ig_in_out_arcs G u). e = (u, v) \\<or> e = (v, u)", "then"], ["proof (chain)\npicking this:\n  e \\<in> set (ig_arcs G)\n  e = (u, v) \\<or> e = (v, u)", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> set (ig_arcs G)\n  e = (u, v) \\<or> e = (v, u)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (ig_in_out_arcs G u). e = (u, v) \\<or> e = (v, u)", "unfolding ig_in_out_arcs_def"], ["proof (prove)\nusing this:\n  e \\<in> set (ig_arcs G)\n  e = (u, v) \\<or> e = (v, u)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (filter (\\<lambda>e. fst e = u \\<or> snd e = u)\n                         (ig_arcs G)).\n       e = (u, v) \\<or> e = (v, u)", "by auto"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set (ig_in_out_arcs G u). e = (u, v) \\<or> e = (v, u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  ig_verts_empty[simp]: \"ig_verts ig_empty = []\" and\n  ig_verts_add_e[simp]: \"ig_verts (ig_add_e G u v) = ig_verts G\" and\n  ig_verts_add_v[simp]: \"ig_verts (ig_add_v G v) = ig_verts G @ (if v \\<in> set (ig_verts G) then [] else [v])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_verts ig_empty = [] &&&\n    ig_verts (ig_add_e G u v) = ig_verts G &&&\n    ig_verts (ig_add_v G v) =\n    ig_verts G @ (if v \\<in> set (ig_verts G) then [] else [v])", "unfolding ig_verts_def ig_empty_def ig_add_e_def ig_add_v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Rep_IGraph (Abs_IGraph ([], []))) = [] &&&\n    fst (Rep_IGraph\n          (Abs_IGraph (fst (Rep_IGraph G), ig_arcs G @ [(u, v)]))) =\n    fst (Rep_IGraph G) &&&\n    fst (Rep_IGraph\n          (if v \\<in> set (fst (Rep_IGraph G)) then G\n           else Abs_IGraph (fst (Rep_IGraph G) @ [v], ig_arcs G))) =\n    fst (Rep_IGraph G) @\n    (if v \\<in> set (fst (Rep_IGraph G)) then [] else [v])", "by (auto simp: Abs_IGraph_inverse distinct_ig_verts[simplified ig_verts_def])"], ["", "lemma\n  ig_arcs_empty[simp]: \"ig_arcs ig_empty = []\" and\n  ig_arcs_add_e[simp]: \"ig_arcs (ig_add_e G u v) = ig_arcs G @ [(u,v)]\" and\n  ig_arcs_add_v[simp]: \"ig_arcs (ig_add_v G v) = ig_arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_arcs ig_empty = [] &&&\n    ig_arcs (ig_add_e G u v) = ig_arcs G @ [(u, v)] &&&\n    ig_arcs (ig_add_v G v) = ig_arcs G", "unfolding ig_arcs_def ig_empty_def ig_add_e_def ig_add_v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (Rep_IGraph (Abs_IGraph ([], []))) = [] &&&\n    snd (Rep_IGraph\n          (Abs_IGraph (ig_verts G, snd (Rep_IGraph G) @ [(u, v)]))) =\n    snd (Rep_IGraph G) @ [(u, v)] &&&\n    snd (Rep_IGraph\n          (if v \\<in> set (ig_verts G) then G\n           else Abs_IGraph (ig_verts G @ [v], snd (Rep_IGraph G)))) =\n    snd (Rep_IGraph G)", "by (auto simp: Abs_IGraph_inverse distinct_ig_verts)"], ["", "subsection \\<open>Total Correctness\\<close>"], ["", "subsubsection \\<open>Procedure @{term is_subgraph}\\<close>"], ["", "definition is_subgraph_verts_inv :: \"IGraph \\<Rightarrow> IGraph \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"is_subgraph_verts_inv G H i \\<equiv> set (take i (ig_verts G)) \\<subseteq> set (ig_verts H)\""], ["", "definition is_subgraph_arcs_inv :: \"IGraph \\<Rightarrow> IGraph \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"is_subgraph_arcs_inv G H i \\<equiv> \\<forall>j < i. let (u,v) = ig_arcs G ! j in\n    ((u,v) \\<in> set (ig_arcs H) \\<or> (v,u) \\<in> set (ig_arcs H))\n    \\<and> u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)\""], ["", "lemma is_subgraph_verts_0: \"is_subgraph_verts_inv G H 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subgraph_verts_inv G H 0", "unfolding is_subgraph_verts_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take 0 (ig_verts G)) \\<subseteq> set (ig_verts H)", "by auto"], ["", "lemma is_subgraph_verts_step:\n  assumes \"is_subgraph_verts_inv G H i\" \"ig_verts G ! i \\<in> set (ig_verts H)\"\n  assumes \"i < length (ig_verts G)\"\n  shows \"is_subgraph_verts_inv G H (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subgraph_verts_inv G H (Suc i)", "using assms"], ["proof (prove)\nusing this:\n  is_subgraph_verts_inv G H i\n  ig_verts G ! i \\<in> set (ig_verts H)\n  i < length (ig_verts G)\n\ngoal (1 subgoal):\n 1. is_subgraph_verts_inv G H (Suc i)", "by (auto simp: is_subgraph_verts_inv_def take_Suc_conv_app_nth)"], ["", "lemma is_subgraph_verts_last:\n  \"is_subgraph_verts_inv G H (length (ig_verts G)) \\<longleftrightarrow> pverts (mk_graph G) \\<subseteq> pverts (mk_graph H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subgraph_verts_inv G H (length (ig_verts G)) =\n    (pverts (mk_graph G) \\<subseteq> pverts (mk_graph H))", "apply (auto simp: is_subgraph_verts_inv_def mkg_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_subgraph_arcs_0: \"is_subgraph_arcs_inv G H 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H 0", "unfolding is_subgraph_arcs_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<0.\n       let (u, v) = ig_arcs G ! j\n       in ((u, v) \\<in> set (ig_arcs H) \\<or>\n           (v, u) \\<in> set (ig_arcs H)) \\<and>\n          u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)", "by auto"], ["", "lemma is_subgraph_arcs_step:\n  assumes \"is_subgraph_arcs_inv G H i\"\n    \"e \\<in> set (ig_arcs H) \\<or> (snd e, fst e) \\<in> set (ig_arcs H)\"\n    \"fst e \\<in> set (ig_verts G)\" \"snd e \\<in> set (ig_verts G)\"\n  assumes \"e = ig_arcs G ! i\"\n  assumes \"i < length (ig_arcs G)\"\n  shows \"is_subgraph_arcs_inv G H (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (Suc i)", "using assms"], ["proof (prove)\nusing this:\n  is_subgraph_arcs_inv G H i\n  e \\<in> set (ig_arcs H) \\<or> (snd e, fst e) \\<in> set (ig_arcs H)\n  fst e \\<in> set (ig_verts G)\n  snd e \\<in> set (ig_verts G)\n  e = ig_arcs G ! i\n  i < length (ig_arcs G)\n\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (Suc i)", "by (auto simp: is_subgraph_arcs_inv_def less_Suc_eq)"], ["", "lemma wellformed_pseudo_graph_mkg:\n  shows \"pair_wf_digraph (mk_graph G) = pair_pseudo_graph(mk_graph G)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G) = pair_pseudo_graph (mk_graph G)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)\n 2. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_wf_digraph (mk_graph G)", "assume ?R"], ["proof (state)\nthis:\n  pair_pseudo_graph (mk_graph G)\n\ngoal (2 subgoals):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)\n 2. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_wf_digraph (mk_graph G)", "then"], ["proof (chain)\npicking this:\n  pair_pseudo_graph (mk_graph G)", "interpret ppg: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\nusing this:\n  pair_pseudo_graph (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)\n 2. pair_pseudo_graph (mk_graph G) \\<Longrightarrow>\n    pair_wf_digraph (mk_graph G)", "show ?L"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G)", "by unfold_locales"], ["proof (state)\nthis:\n  pair_wf_digraph (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)", "assume ?L"], ["proof (state)\nthis:\n  pair_wf_digraph (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)", "moreover"], ["proof (state)\nthis:\n  pair_wf_digraph (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)", "have \"symmetric (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (with_proj (mk_graph G))", "unfolding mk_graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (with_proj (mk_symmetric (with_proj (mk_graph' G))))", "by (simp add: symmetric_mk_symmetric)"], ["proof (state)\nthis:\n  symmetric (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G) \\<Longrightarrow>\n    pair_pseudo_graph (mk_graph G)", "ultimately"], ["proof (chain)\npicking this:\n  pair_wf_digraph (mk_graph G)\n  symmetric (with_proj (mk_graph G))", "show ?R"], ["proof (prove)\nusing this:\n  pair_wf_digraph (mk_graph G)\n  symmetric (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "unfolding pair_wf_digraph_def"], ["proof (prove)\nusing this:\n  (\\<forall>e.\n      e \\<in> parcs (mk_graph G) \\<longrightarrow>\n      fst e \\<in> pverts (mk_graph G)) \\<and>\n  (\\<forall>e.\n      e \\<in> parcs (mk_graph G) \\<longrightarrow>\n      snd e \\<in> pverts (mk_graph G))\n  symmetric (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by unfold_locales (auto simp: mkg_simps finite_symcl_iff)"], ["proof (state)\nthis:\n  pair_pseudo_graph (mk_graph G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_subgraph_arcs_last:\n  \"is_subgraph_arcs_inv G H (length (ig_arcs G)) \\<longleftrightarrow> parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and> pair_pseudo_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_pseudo_graph (mk_graph G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_pseudo_graph (mk_graph G))", "have \"is_subgraph_arcs_inv G H (length (ig_arcs G))\n      = (\\<forall>(u,v) \\<in> set (ig_arcs G). ((u,v) \\<in> set (ig_arcs H) \\<or> (v,u) \\<in> set (ig_arcs H))\n        \\<and> u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n    (\\<forall>(u, v)\\<in>set (ig_arcs G).\n        ((u, v) \\<in> set (ig_arcs H) \\<or>\n         (v, u) \\<in> set (ig_arcs H)) \\<and>\n        u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G))", "unfolding is_subgraph_arcs_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<length (ig_arcs G).\n        let (u, v) = ig_arcs G ! j\n        in ((u, v) \\<in> set (ig_arcs H) \\<or>\n            (v, u) \\<in> set (ig_arcs H)) \\<and>\n           u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)) =\n    (\\<forall>(u, v)\\<in>set (ig_arcs G).\n        ((u, v) \\<in> set (ig_arcs H) \\<or>\n         (v, u) \\<in> set (ig_arcs H)) \\<and>\n        u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G))", "by (metis (lifting, no_types) all_nth_imp_all_set nth_mem)"], ["proof (state)\nthis:\n  is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n  (\\<forall>(u, v)\\<in>set (ig_arcs G).\n      ((u, v) \\<in> set (ig_arcs H) \\<or>\n       (v, u) \\<in> set (ig_arcs H)) \\<and>\n      u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G))\n\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_pseudo_graph (mk_graph G))", "also"], ["proof (state)\nthis:\n  is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n  (\\<forall>(u, v)\\<in>set (ig_arcs G).\n      ((u, v) \\<in> set (ig_arcs H) \\<or>\n       (v, u) \\<in> set (ig_arcs H)) \\<and>\n      u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G))\n\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_pseudo_graph (mk_graph G))", "have \"... \\<longleftrightarrow> parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and> pair_pseudo_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(u, v)\\<in>set (ig_arcs G).\n        ((u, v) \\<in> set (ig_arcs H) \\<or>\n         (v, u) \\<in> set (ig_arcs H)) \\<and>\n        u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_pseudo_graph (mk_graph G))", "unfolding wellformed_pseudo_graph_mkg[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(u, v)\\<in>set (ig_arcs G).\n        ((u, v) \\<in> set (ig_arcs H) \\<or>\n         (v, u) \\<in> set (ig_arcs H)) \\<and>\n        u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_wf_digraph (mk_graph G))", "by (auto simp: mkg_simps pair_wf_digraph_def symcl_def)"], ["proof (state)\nthis:\n  (\\<forall>(u, v)\\<in>set (ig_arcs G).\n      ((u, v) \\<in> set (ig_arcs H) \\<or>\n       (v, u) \\<in> set (ig_arcs H)) \\<and>\n      u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)) =\n  (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n   pair_pseudo_graph (mk_graph G))\n\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_pseudo_graph (mk_graph G))", "finally"], ["proof (chain)\npicking this:\n  is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n  (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n   pair_pseudo_graph (mk_graph G))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n  (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n   pair_pseudo_graph (mk_graph G))\n\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n    (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n     pair_pseudo_graph (mk_graph G))", "."], ["proof (state)\nthis:\n  is_subgraph_arcs_inv G H (length (ig_arcs G)) =\n  (parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n   pair_pseudo_graph (mk_graph G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_subgraph_verts_arcs_last:\n  assumes \"is_subgraph_verts_inv G H (ig_verts_cnt G)\"\n  assumes \"is_subgraph_arcs_inv G H (ig_arcs_cnt G)\"\n  assumes \"IGraph_inv H\"\n  shows \"subgraph (mk_graph G) (mk_graph H)\" (is ?T1)\n        \"pair_pseudo_graph (mk_graph G)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H)) &&&\n    pair_pseudo_graph (mk_graph G)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))\n 2. pair_pseudo_graph (mk_graph G)", "interpret ppg: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using assms"], ["proof (prove)\nusing this:\n  is_subgraph_verts_inv G H (ig_verts_cnt G)\n  is_subgraph_arcs_inv G H (ig_arcs_cnt G)\n  IGraph_inv H\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by (simp add: is_subgraph_arcs_last)"], ["proof (state)\ngoal (2 subgoals):\n 1. subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))\n 2. pair_pseudo_graph (mk_graph G)", "interpret ppgH: pair_pseudo_graph \"mk_graph H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph H)", "using assms"], ["proof (prove)\nusing this:\n  is_subgraph_verts_inv G H (ig_verts_cnt G)\n  is_subgraph_arcs_inv G H (ig_arcs_cnt G)\n  IGraph_inv H\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph H)", "by (intro IGraph_imp_ppg_mkg)"], ["proof (state)\ngoal (2 subgoals):\n 1. subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))\n 2. pair_pseudo_graph (mk_graph G)", "have \"wf_digraph (with_proj (mk_graph G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_digraph (with_proj (mk_graph G))", "by unfold_locales"], ["proof (state)\nthis:\n  wf_digraph (with_proj (mk_graph G))\n\ngoal (2 subgoals):\n 1. subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))\n 2. pair_pseudo_graph (mk_graph G)", "with assms"], ["proof (chain)\npicking this:\n  is_subgraph_verts_inv G H (ig_verts_cnt G)\n  is_subgraph_arcs_inv G H (ig_arcs_cnt G)\n  IGraph_inv H\n  wf_digraph (with_proj (mk_graph G))", "show ?T1 ?T2"], ["proof (prove)\nusing this:\n  is_subgraph_verts_inv G H (ig_verts_cnt G)\n  is_subgraph_arcs_inv G H (ig_arcs_cnt G)\n  IGraph_inv H\n  wf_digraph (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H)) &&&\n    pair_pseudo_graph (mk_graph G)", "by (auto simp: is_subgraph_verts_last is_subgraph_arcs_last subgraph_def ppgH.wf_digraph)"], ["proof (state)\nthis:\n  subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))\n  pair_pseudo_graph (mk_graph G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_subgraph_false:\n  assumes \"subgraph (mk_graph G) (mk_graph H)\"\n  obtains \"\\<forall>i < length (ig_verts G). ig_verts G ! i \\<in> set (ig_verts H)\"\n    \"\\<forall>i < length (ig_arcs G). let (u,v) = ig_arcs G ! i in\n      ((u,v)\\<in> set (ig_arcs H) \\<or> (v,u) \\<in> set (ig_arcs H))\n      \\<and> u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>i<length (ig_verts G).\n                 ig_verts G ! i \\<in> set (ig_verts H);\n      \\<forall>i<length (ig_arcs G).\n         let (u, v) = ig_arcs G ! i\n         in ((u, v) \\<in> set (ig_arcs H) \\<or>\n             (v, u) \\<in> set (ig_arcs H)) \\<and>\n            u \\<in> set (ig_verts G) \\<and>\n            v \\<in> set (ig_verts G)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lbrakk>\\<forall>i<length (ig_verts G).\n                 ig_verts G ! i \\<in> set (ig_verts H);\n      \\<forall>i<length (ig_arcs G).\n         let (u, v) = ig_arcs G ! i\n         in ((u, v) \\<in> set (ig_arcs H) \\<or>\n             (v, u) \\<in> set (ig_arcs H)) \\<and>\n            u \\<in> set (ig_verts G) \\<and>\n            v \\<in> set (ig_verts G)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<forall>i<length (ig_verts G). ig_verts G ! i \\<in> set (ig_verts H)\n 2. (\\<lbrakk>\\<forall>i<length (ig_verts G).\n                 ig_verts G ! i \\<in> set (ig_verts H);\n      \\<forall>i<length (ig_arcs G).\n         let (u, v) = ig_arcs G ! i\n         in ((u, v) \\<in> set (ig_arcs H) \\<or>\n             (v, u) \\<in> set (ig_arcs H)) \\<and>\n            u \\<in> set (ig_verts G) \\<and>\n            v \\<in> set (ig_verts G)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<forall>i<length (ig_arcs G).\n       let (u, v) = ig_arcs G ! i\n       in ((u, v) \\<in> set (ig_arcs H) \\<or>\n           (v, u) \\<in> set (ig_arcs H)) \\<and>\n          u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)", "from assms"], ["proof (chain)\npicking this:\n  subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))", "show \"\\<forall>i < length (ig_verts G). ig_verts G ! i \\<in> set (ig_verts H)\""], ["proof (prove)\nusing this:\n  subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (ig_verts G). ig_verts G ! i \\<in> set (ig_verts H)", "unfolding subgraph_def"], ["proof (prove)\nusing this:\n  verts (with_proj (mk_graph G))\n  \\<subseteq> verts (with_proj (mk_graph H)) \\<and>\n  arcs (with_proj (mk_graph G))\n  \\<subseteq> arcs (with_proj (mk_graph H)) \\<and>\n  wf_digraph (with_proj (mk_graph H)) \\<and>\n  wf_digraph (with_proj (mk_graph G)) \\<and>\n  compatible (with_proj (mk_graph H)) (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (ig_verts G). ig_verts G ! i \\<in> set (ig_verts H)", "by (auto simp: mkg_simps)"], ["proof (state)\nthis:\n  \\<forall>i<length (ig_verts G). ig_verts G ! i \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>i<length (ig_verts G).\n                 ig_verts G ! i \\<in> set (ig_verts H);\n      \\<forall>i<length (ig_arcs G).\n         let (u, v) = ig_arcs G ! i\n         in ((u, v) \\<in> set (ig_arcs H) \\<or>\n             (v, u) \\<in> set (ig_arcs H)) \\<and>\n            u \\<in> set (ig_verts G) \\<and>\n            v \\<in> set (ig_verts G)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<forall>i<length (ig_arcs G).\n       let (u, v) = ig_arcs G ! i\n       in ((u, v) \\<in> set (ig_arcs H) \\<or>\n           (v, u) \\<in> set (ig_arcs H)) \\<and>\n          u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>i<length (ig_verts G).\n                 ig_verts G ! i \\<in> set (ig_verts H);\n      \\<forall>i<length (ig_arcs G).\n         let (u, v) = ig_arcs G ! i\n         in ((u, v) \\<in> set (ig_arcs H) \\<or>\n             (v, u) \\<in> set (ig_arcs H)) \\<and>\n            u \\<in> set (ig_verts G) \\<and>\n            v \\<in> set (ig_verts G)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<forall>i<length (ig_arcs G).\n       let (u, v) = ig_arcs G ! i\n       in ((u, v) \\<in> set (ig_arcs H) \\<or>\n           (v, u) \\<in> set (ig_arcs H)) \\<and>\n          u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)", "from assms"], ["proof (chain)\npicking this:\n  subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))", "have \"is_subgraph_arcs_inv G H (length (ig_arcs G))\""], ["proof (prove)\nusing this:\n  subgraph (with_proj (mk_graph G)) (with_proj (mk_graph H))\n\ngoal (1 subgoal):\n 1. is_subgraph_arcs_inv G H (length (ig_arcs G))", "unfolding is_subgraph_arcs_last subgraph_def wellformed_pseudo_graph_mkg[symmetric]"], ["proof (prove)\nusing this:\n  verts (with_proj (mk_graph G))\n  \\<subseteq> verts (with_proj (mk_graph H)) \\<and>\n  arcs (with_proj (mk_graph G))\n  \\<subseteq> arcs (with_proj (mk_graph H)) \\<and>\n  wf_digraph (with_proj (mk_graph H)) \\<and>\n  wf_digraph (with_proj (mk_graph G)) \\<and>\n  compatible (with_proj (mk_graph H)) (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. parcs (mk_graph G) \\<subseteq> parcs (mk_graph H) \\<and>\n    pair_wf_digraph (mk_graph G)", "by (auto simp: wf_digraph_wp_iff)"], ["proof (state)\nthis:\n  is_subgraph_arcs_inv G H (length (ig_arcs G))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>i<length (ig_verts G).\n                 ig_verts G ! i \\<in> set (ig_verts H);\n      \\<forall>i<length (ig_arcs G).\n         let (u, v) = ig_arcs G ! i\n         in ((u, v) \\<in> set (ig_arcs H) \\<or>\n             (v, u) \\<in> set (ig_arcs H)) \\<and>\n            u \\<in> set (ig_verts G) \\<and>\n            v \\<in> set (ig_verts G)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<forall>i<length (ig_arcs G).\n       let (u, v) = ig_arcs G ! i\n       in ((u, v) \\<in> set (ig_arcs H) \\<or>\n           (v, u) \\<in> set (ig_arcs H)) \\<and>\n          u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)", "then"], ["proof (chain)\npicking this:\n  is_subgraph_arcs_inv G H (length (ig_arcs G))", "show \"\\<forall>i < length (ig_arcs G). let (u,v) = ig_arcs G ! i in\n      ((u,v)\\<in> set (ig_arcs H) \\<or> (v,u) \\<in> set (ig_arcs H))\n      \\<and> u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)\""], ["proof (prove)\nusing this:\n  is_subgraph_arcs_inv G H (length (ig_arcs G))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (ig_arcs G).\n       let (u, v) = ig_arcs G ! i\n       in ((u, v) \\<in> set (ig_arcs H) \\<or>\n           (v, u) \\<in> set (ig_arcs H)) \\<and>\n          u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)", "by (auto simp: is_subgraph_arcs_inv_def)"], ["proof (state)\nthis:\n  \\<forall>i<length (ig_arcs G).\n     let (u, v) = ig_arcs G ! i\n     in ((u, v) \\<in> set (ig_arcs H) \\<or>\n         (v, u) \\<in> set (ig_arcs H)) \\<and>\n        u \\<in> set (ig_verts G) \\<and> v \\<in> set (ig_verts G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in is_subgraph_impl) is_subgraph_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>H \\<rbrace> \\<acute>R :== PROC is_subgraph(\\<acute>G, \\<acute>H) \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and> \\<acute>R = (subgraph (mk_graph \\<acute>G) (mk_graph \\<acute>H) \\<and> IGraph_inv \\<acute>G)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>H\\<rbrace>\n                               \\<acute>R :== PROC is_subgraph(\\<acute>G,\n                               \\<acute>H)\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n  \\<acute>R =\n  (subgraph (with_proj (mk_graph \\<acute>G))\n    (with_proj (mk_graph \\<acute>H)) \\<and>\n   IGraph_inv \\<acute>G)\\<rbrace>", "apply (vcg_step spec=none)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>H\\<rbrace>\n                               TRY \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV named_loop ''verts'' \n                                   DO \\<acute>v :==\nig_verts \\<acute>G ! \\<acute>i;;\nIF \\<acute>v \\<notin> set (ig_verts \\<acute>H)\nTHEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_arcs_cnt \\<acute>G\n                                   INV named_loop ''arcs'' \n                                   DO \\<acute>ends :==\nig_arcs \\<acute>G ! \\<acute>i;;\nIF \\<acute>ends \\<notin> set (ig_arcs \\<acute>H) \\<and>\n   (snd \\<acute>ends, fst \\<acute>ends) \\<notin> set (ig_arcs \\<acute>H)\nTHEN RAISE \\<acute>R :== False FI;;\nIF fst \\<acute>ends \\<notin> set (ig_verts \\<acute>G) \\<or>\n   snd \\<acute>ends \\<notin> set (ig_verts \\<acute>G)\nTHEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n  \\<acute>R =\n  (subgraph (with_proj (mk_graph \\<acute>G))\n    (with_proj (mk_graph \\<acute>H)) \\<and>\n   IGraph_inv \\<acute>G)\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''verts'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace> is_subgraph_verts_inv \\<acute>G \\<acute>H \\<acute>i \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and> \\<acute>i \\<le> ig_verts_cnt \\<acute>G\n      \\<and> IGraph_inv \\<acute>H\\<rbrace>\n      (MEASURE ig_verts_cnt \\<acute>G - \\<acute>i)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>H\\<rbrace>\n                               TRY \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV \\<lbrace>is_subgraph_verts_inv\n           \\<acute>G \\<acute>H \\<acute>i \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n          \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n          IGraph_inv \\<acute>H\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_verts_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_subgraph_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_subgraph_' (locals s)) \n                                   DO \\<acute>v :==\nig_verts \\<acute>G ! \\<acute>i;;\nIF \\<acute>v \\<notin> set (ig_verts \\<acute>H)\nTHEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_arcs_cnt \\<acute>G\n                                   INV named_loop ''arcs'' \n                                   DO \\<acute>ends :==\nig_arcs \\<acute>G ! \\<acute>i;;\nIF \\<acute>ends \\<notin> set (ig_arcs \\<acute>H) \\<and>\n   (snd \\<acute>ends, fst \\<acute>ends) \\<notin> set (ig_arcs \\<acute>H)\nTHEN RAISE \\<acute>R :== False FI;;\nIF fst \\<acute>ends \\<notin> set (ig_verts \\<acute>G) \\<or>\n   snd \\<acute>ends \\<notin> set (ig_verts \\<acute>G)\nTHEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n  \\<acute>R =\n  (subgraph (with_proj (mk_graph \\<acute>G))\n    (with_proj (mk_graph \\<acute>H)) \\<and>\n   IGraph_inv \\<acute>G)\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''arcs'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace> is_subgraph_arcs_inv \\<acute>G \\<acute>H \\<acute>i \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and> \\<acute>i \\<le> ig_arcs_cnt \\<acute>G\n      \\<and> is_subgraph_verts_inv \\<acute>G \\<acute>H (length (ig_verts \\<acute>G)) \\<and> IGraph_inv \\<acute>H \\<rbrace>\n      (MEASURE ig_arcs_cnt \\<acute>G - \\<acute>i)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>H\\<rbrace>\n                               TRY \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV \\<lbrace>is_subgraph_verts_inv\n           \\<acute>G \\<acute>H \\<acute>i \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n          \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n          IGraph_inv \\<acute>H\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_verts_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_subgraph_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_subgraph_' (locals s)) \n                                   DO \\<acute>v :==\nig_verts \\<acute>G ! \\<acute>i;;\nIF \\<acute>v \\<notin> set (ig_verts \\<acute>H)\nTHEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_arcs_cnt \\<acute>G\n                                   INV \\<lbrace>is_subgraph_arcs_inv\n           \\<acute>G \\<acute>H \\<acute>i \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n          \\<acute>i \\<le> ig_arcs_cnt \\<acute>G \\<and>\n          is_subgraph_verts_inv \\<acute>G \\<acute>H\n           (length (ig_verts \\<acute>G)) \\<and>\n          IGraph_inv \\<acute>H\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_arcs_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_subgraph_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_subgraph_' (locals s)) \n                                   DO \\<acute>ends :==\nig_arcs \\<acute>G ! \\<acute>i;;\nIF \\<acute>ends \\<notin> set (ig_arcs \\<acute>H) \\<and>\n   (snd \\<acute>ends, fst \\<acute>ends) \\<notin> set (ig_arcs \\<acute>H)\nTHEN RAISE \\<acute>R :== False FI;;\nIF fst \\<acute>ends \\<notin> set (ig_verts \\<acute>G) \\<or>\n   snd \\<acute>ends \\<notin> set (ig_verts \\<acute>G)\nTHEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n  \\<acute>R =\n  (subgraph (with_proj (mk_graph \\<acute>G))\n    (with_proj (mk_graph \\<acute>H)) \\<and>\n   IGraph_inv \\<acute>G)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>G H.\n       IGraph_inv H \\<Longrightarrow>\n       is_subgraph_verts_inv G H 0 \\<and>\n       G = G \\<and> H = H \\<and> 0 \\<le> ig_verts_cnt G \\<and> IGraph_inv H\n 2. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_verts_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_verts_cnt Ga; IGraph_inv Ha; i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (ig_verts Ga ! i\n                          \\<notin> set (ig_verts Ha) \\<longrightarrow>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          \\<not> (subgraph (with_proj (mk_graph Ga))\n                                   (with_proj (mk_graph Ha)) \\<and>\n                                  IGraph_inv Ga)) \\<and>\n                         (\\<not> ig_verts Ga ! i\n                                 \\<notin> set\n     (ig_verts Ha) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_subgraph_verts_inv Ga Ha (i + 1) \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and> IGraph_inv Ha)\n 3. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_verts_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_verts_cnt Ga; IGraph_inv Ha;\n        \\<not> i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_subgraph_arcs_inv Ga Ha 0 \\<and>\n                         Ga = G \\<and>\n                         Ha = H \\<and>\n                         0 \\<le> ig_arcs_cnt Ga \\<and>\n                         is_subgraph_verts_inv Ga Ha\n                          (length (ig_verts Ga)) \\<and>\n                         IGraph_inv Ha\n 4. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (ig_arcs Ga ! i \\<notin> set (ig_arcs Ha) \\<and>\n                          (snd (ig_arcs Ga ! i), fst (ig_arcs Ga ! i))\n                          \\<notin> set (ig_arcs Ha) \\<longrightarrow>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          \\<not> (subgraph (with_proj (mk_graph Ga))\n                                   (with_proj (mk_graph Ha)) \\<and>\n                                  IGraph_inv Ga)) \\<and>\n                         (\\<not> (ig_arcs Ga ! i\n                                  \\<notin> set (ig_arcs Ha) \\<and>\n                                  (snd (ig_arcs Ga ! i),\n                                   fst (ig_arcs Ga ! i))\n                                  \\<notin> set\n      (ig_arcs Ha)) \\<longrightarrow>\n                          (fst (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<or>\n                           snd (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<longrightarrow>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           \\<not> (subgraph (with_proj (mk_graph Ga))\n                                    (with_proj (mk_graph Ha)) \\<and>\n                                   IGraph_inv Ga)) \\<and>\n                          (\\<not> (fst (ig_arcs Ga ! i)\n                                   \\<notin> set (ig_verts Ga) \\<or>\n                                   snd (ig_arcs Ga ! i)\n                                   \\<notin> set\n       (ig_verts Ga)) \\<longrightarrow>\n                           ig_arcs_cnt Ga - (i + 1)\n                           < ig_arcs_cnt Ga - i \\<and>\n                           is_subgraph_arcs_inv Ga Ha (i + 1) \\<and>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           i + 1 \\<le> ig_arcs_cnt Ga \\<and>\n                           is_subgraph_verts_inv Ga Ha\n                            (length (ig_verts Ga)) \\<and>\n                           IGraph_inv Ha))\n 5. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         Ha = H \\<and>\n                         True =\n                         (subgraph (with_proj (mk_graph Ga))\n                           (with_proj (mk_graph Ha)) \\<and>\n                          IGraph_inv Ga)", "apply (fastforce simp: is_subgraph_verts_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_verts_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_verts_cnt Ga; IGraph_inv Ha; i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (ig_verts Ga ! i\n                          \\<notin> set (ig_verts Ha) \\<longrightarrow>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          \\<not> (subgraph (with_proj (mk_graph Ga))\n                                   (with_proj (mk_graph Ha)) \\<and>\n                                  IGraph_inv Ga)) \\<and>\n                         (\\<not> ig_verts Ga ! i\n                                 \\<notin> set\n     (ig_verts Ha) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_subgraph_verts_inv Ga Ha (i + 1) \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and> IGraph_inv Ha)\n 2. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_verts_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_verts_cnt Ga; IGraph_inv Ha;\n        \\<not> i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_subgraph_arcs_inv Ga Ha 0 \\<and>\n                         Ga = G \\<and>\n                         Ha = H \\<and>\n                         0 \\<le> ig_arcs_cnt Ga \\<and>\n                         is_subgraph_verts_inv Ga Ha\n                          (length (ig_verts Ga)) \\<and>\n                         IGraph_inv Ha\n 3. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (ig_arcs Ga ! i \\<notin> set (ig_arcs Ha) \\<and>\n                          (snd (ig_arcs Ga ! i), fst (ig_arcs Ga ! i))\n                          \\<notin> set (ig_arcs Ha) \\<longrightarrow>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          \\<not> (subgraph (with_proj (mk_graph Ga))\n                                   (with_proj (mk_graph Ha)) \\<and>\n                                  IGraph_inv Ga)) \\<and>\n                         (\\<not> (ig_arcs Ga ! i\n                                  \\<notin> set (ig_arcs Ha) \\<and>\n                                  (snd (ig_arcs Ga ! i),\n                                   fst (ig_arcs Ga ! i))\n                                  \\<notin> set\n      (ig_arcs Ha)) \\<longrightarrow>\n                          (fst (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<or>\n                           snd (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<longrightarrow>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           \\<not> (subgraph (with_proj (mk_graph Ga))\n                                    (with_proj (mk_graph Ha)) \\<and>\n                                   IGraph_inv Ga)) \\<and>\n                          (\\<not> (fst (ig_arcs Ga ! i)\n                                   \\<notin> set (ig_verts Ga) \\<or>\n                                   snd (ig_arcs Ga ! i)\n                                   \\<notin> set\n       (ig_verts Ga)) \\<longrightarrow>\n                           ig_arcs_cnt Ga - (i + 1)\n                           < ig_arcs_cnt Ga - i \\<and>\n                           is_subgraph_arcs_inv Ga Ha (i + 1) \\<and>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           i + 1 \\<le> ig_arcs_cnt Ga \\<and>\n                           is_subgraph_verts_inv Ga Ha\n                            (length (ig_verts Ga)) \\<and>\n                           IGraph_inv Ha))\n 4. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         Ha = H \\<and>\n                         True =\n                         (subgraph (with_proj (mk_graph Ga))\n                           (with_proj (mk_graph Ha)) \\<and>\n                          IGraph_inv Ga)", "apply (fastforce simp: is_subgraph_verts_step elim: is_subgraph_false)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_verts_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_verts_cnt Ga; IGraph_inv Ha;\n        \\<not> i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_subgraph_arcs_inv Ga Ha 0 \\<and>\n                         Ga = G \\<and>\n                         Ha = H \\<and>\n                         0 \\<le> ig_arcs_cnt Ga \\<and>\n                         is_subgraph_verts_inv Ga Ha\n                          (length (ig_verts Ga)) \\<and>\n                         IGraph_inv Ha\n 2. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (ig_arcs Ga ! i \\<notin> set (ig_arcs Ha) \\<and>\n                          (snd (ig_arcs Ga ! i), fst (ig_arcs Ga ! i))\n                          \\<notin> set (ig_arcs Ha) \\<longrightarrow>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          \\<not> (subgraph (with_proj (mk_graph Ga))\n                                   (with_proj (mk_graph Ha)) \\<and>\n                                  IGraph_inv Ga)) \\<and>\n                         (\\<not> (ig_arcs Ga ! i\n                                  \\<notin> set (ig_arcs Ha) \\<and>\n                                  (snd (ig_arcs Ga ! i),\n                                   fst (ig_arcs Ga ! i))\n                                  \\<notin> set\n      (ig_arcs Ha)) \\<longrightarrow>\n                          (fst (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<or>\n                           snd (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<longrightarrow>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           \\<not> (subgraph (with_proj (mk_graph Ga))\n                                    (with_proj (mk_graph Ha)) \\<and>\n                                   IGraph_inv Ga)) \\<and>\n                          (\\<not> (fst (ig_arcs Ga ! i)\n                                   \\<notin> set (ig_verts Ga) \\<or>\n                                   snd (ig_arcs Ga ! i)\n                                   \\<notin> set\n       (ig_verts Ga)) \\<longrightarrow>\n                           ig_arcs_cnt Ga - (i + 1)\n                           < ig_arcs_cnt Ga - i \\<and>\n                           is_subgraph_arcs_inv Ga Ha (i + 1) \\<and>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           i + 1 \\<le> ig_arcs_cnt Ga \\<and>\n                           is_subgraph_verts_inv Ga Ha\n                            (length (ig_verts Ga)) \\<and>\n                           IGraph_inv Ha))\n 3. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         Ha = H \\<and>\n                         True =\n                         (subgraph (with_proj (mk_graph Ga))\n                           (with_proj (mk_graph Ha)) \\<and>\n                          IGraph_inv Ga)", "apply (fastforce simp: is_subgraph_arcs_0 not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (ig_arcs Ga ! i \\<notin> set (ig_arcs Ha) \\<and>\n                          (snd (ig_arcs Ga ! i), fst (ig_arcs Ga ! i))\n                          \\<notin> set (ig_arcs Ha) \\<longrightarrow>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          \\<not> (subgraph (with_proj (mk_graph Ga))\n                                   (with_proj (mk_graph Ha)) \\<and>\n                                  IGraph_inv Ga)) \\<and>\n                         (\\<not> (ig_arcs Ga ! i\n                                  \\<notin> set (ig_arcs Ha) \\<and>\n                                  (snd (ig_arcs Ga ! i),\n                                   fst (ig_arcs Ga ! i))\n                                  \\<notin> set\n      (ig_arcs Ha)) \\<longrightarrow>\n                          (fst (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<or>\n                           snd (ig_arcs Ga ! i)\n                           \\<notin> set (ig_verts Ga) \\<longrightarrow>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           \\<not> (subgraph (with_proj (mk_graph Ga))\n                                    (with_proj (mk_graph Ha)) \\<and>\n                                   IGraph_inv Ga)) \\<and>\n                          (\\<not> (fst (ig_arcs Ga ! i)\n                                   \\<notin> set (ig_verts Ga) \\<or>\n                                   snd (ig_arcs Ga ! i)\n                                   \\<notin> set\n       (ig_verts Ga)) \\<longrightarrow>\n                           ig_arcs_cnt Ga - (i + 1)\n                           < ig_arcs_cnt Ga - i \\<and>\n                           is_subgraph_arcs_inv Ga Ha (i + 1) \\<and>\n                           Ga = G \\<and>\n                           Ha = H \\<and>\n                           i + 1 \\<le> ig_arcs_cnt Ga \\<and>\n                           is_subgraph_verts_inv Ga Ha\n                            (length (ig_verts Ga)) \\<and>\n                           IGraph_inv Ha))\n 2. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         Ha = H \\<and>\n                         True =\n                         (subgraph (with_proj (mk_graph Ga))\n                           (with_proj (mk_graph Ha)) \\<and>\n                          IGraph_inv Ga)", "apply (auto simp: is_subgraph_arcs_step elim!: is_subgraph_false; fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G H Ga Ha i.\n       \\<lbrakk>is_subgraph_arcs_inv Ga Ha i; Ga = G; Ha = H;\n        i \\<le> ig_arcs_cnt Ga;\n        is_subgraph_verts_inv Ga Ha (length (ig_verts Ga)); IGraph_inv Ha;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         Ha = H \\<and>\n                         True =\n                         (subgraph (with_proj (mk_graph Ga))\n                           (with_proj (mk_graph Ha)) \\<and>\n                          IGraph_inv Ga)", "apply (fastforce simp: IGraph_inv_conv' is_subgraph_verts_arcs_last)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Procedure @{term is_loop_free}\\<close>"], ["", "definition \"is_loopfree_inv G k \\<equiv> \\<forall>j<k. fst (ig_arcs G ! j) \\<noteq> snd (ig_arcs G ! j)\""], ["", "lemma is_loopfree_0:\n  \"is_loopfree_inv G 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_loopfree_inv G 0", "by (auto simp: is_loopfree_inv_def)"], ["", "lemma is_loopfree_step1:\n  assumes \"is_loopfree_inv G n\"\n  assumes \"fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)\"\n  assumes \"n < ig_arcs_cnt G\"\n  shows \"is_loopfree_inv G (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_loopfree_inv G (Suc n)", "using assms"], ["proof (prove)\nusing this:\n  is_loopfree_inv G n\n  fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)\n  n < ig_arcs_cnt G\n\ngoal (1 subgoal):\n 1. is_loopfree_inv G (Suc n)", "unfolding is_loopfree_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>j<n. fst (ig_arcs G ! j) \\<noteq> snd (ig_arcs G ! j)\n  fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)\n  n < ig_arcs_cnt G\n\ngoal (1 subgoal):\n 1. \\<forall>j<Suc n. fst (ig_arcs G ! j) \\<noteq> snd (ig_arcs G ! j)", "by (auto intro: less_SucI elim: less_SucE)"], ["", "lemma is_loopfree_step2:\n  assumes \"loop_free (mk_graph G)\"\n  assumes \"n < ig_arcs_cnt G\"\n  shows \"fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)", "using assms"], ["proof (prove)\nusing this:\n  loop_free (mk_graph G)\n  n < ig_arcs_cnt G\n\ngoal (1 subgoal):\n 1. fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)", "unfolding is_loopfree_inv_def loop_free_def"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>parcs (mk_graph G). fst e \\<noteq> snd e\n  n < ig_arcs_cnt G\n\ngoal (1 subgoal):\n 1. fst (ig_arcs G ! n) \\<noteq> snd (ig_arcs G ! n)", "by (auto simp: mkg_simps symcl_def)"], ["", "lemma is_loopfree_last:\n  assumes \"is_loopfree_inv G (ig_arcs_cnt G)\"\n  shows \"loop_free (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_free (mk_graph G)", "using assms"], ["proof (prove)\nusing this:\n  is_loopfree_inv G (ig_arcs_cnt G)\n\ngoal (1 subgoal):\n 1. loop_free (mk_graph G)", "apply (auto simp: is_loopfree_inv_def loop_free_def mkg_simps in_set_conv_nth symcl_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b i.\n       \\<lbrakk>\\<forall>j<length (ig_arcs G).\n                   fst (ig_arcs G ! j) \\<noteq> snd (ig_arcs G ! j);\n        i < length (ig_arcs G); ig_arcs G ! i = (b, b)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa i.\n       \\<lbrakk>\\<forall>j<length (ig_arcs G).\n                   fst (ig_arcs G ! j) \\<noteq> snd (ig_arcs G ! j);\n        i < length (ig_arcs G); ig_arcs G ! i = (aa, aa)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis fst_eqD snd_eqD)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in is_loopfree_impl) is_loopfree_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G \\<rbrace> \\<acute>R :== PROC is_loopfree(\\<acute>G) \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>R = loop_free (mk_graph \\<acute>G) \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G\\<rbrace>\n                               \\<acute>R :== PROC is_loopfree(\\<acute>G)\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R = loop_free (mk_graph \\<acute>G)\\<rbrace>", "apply (vcg_step spec=none)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G\\<rbrace>\n                               TRY \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_arcs_cnt \\<acute>G\n                                   INV named_loop ''loop'' \n                                   DO \\<acute>ends :==\nig_arcs \\<acute>G ! \\<acute>i;;\nIF fst \\<acute>ends = snd \\<acute>ends THEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R = loop_free (mk_graph \\<acute>G)\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''loop'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace> is_loopfree_inv \\<acute>G \\<acute>i \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>i \\<le> ig_arcs_cnt \\<acute>G \\<rbrace>\n      (MEASURE ig_arcs_cnt \\<acute>G - \\<acute>i)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G\\<rbrace>\n                               TRY \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_arcs_cnt \\<acute>G\n                                   INV \\<lbrace>is_loopfree_inv \\<acute>G\n           \\<acute>i \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          \\<acute>i \\<le> ig_arcs_cnt \\<acute>G\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_arcs_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_loopfree_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_loopfree_' (locals s)) \n                                   DO \\<acute>ends :==\nig_arcs \\<acute>G ! \\<acute>i;;\nIF fst \\<acute>ends = snd \\<acute>ends THEN RAISE \\<acute>R :== False FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R = loop_free (mk_graph \\<acute>G)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G.\n       IGraph_inv G \\<Longrightarrow>\n       is_loopfree_inv G 0 \\<and> G = G \\<and> 0 \\<le> ig_arcs_cnt G\n 2. \\<And>G Ga i.\n       \\<lbrakk>is_loopfree_inv Ga i; Ga = G; i \\<le> ig_arcs_cnt Ga;\n        i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (fst (ig_arcs Ga ! i) =\n                          snd (ig_arcs Ga ! i) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> loop_free (mk_graph Ga)) \\<and>\n                         (fst (ig_arcs Ga ! i) \\<noteq>\n                          snd (ig_arcs Ga ! i) \\<longrightarrow>\n                          ig_arcs_cnt Ga - (i + 1)\n                          < ig_arcs_cnt Ga - i \\<and>\n                          is_loopfree_inv Ga (i + 1) \\<and>\n                          Ga = G \\<and> i + 1 \\<le> ig_arcs_cnt Ga)\n 3. \\<And>G Ga i.\n       \\<lbrakk>is_loopfree_inv Ga i; Ga = G; i \\<le> ig_arcs_cnt Ga;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and> True = loop_free (mk_graph Ga)", "apply (fastforce simp: is_loopfree_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G Ga i.\n       \\<lbrakk>is_loopfree_inv Ga i; Ga = G; i \\<le> ig_arcs_cnt Ga;\n        i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (fst (ig_arcs Ga ! i) =\n                          snd (ig_arcs Ga ! i) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> loop_free (mk_graph Ga)) \\<and>\n                         (fst (ig_arcs Ga ! i) \\<noteq>\n                          snd (ig_arcs Ga ! i) \\<longrightarrow>\n                          ig_arcs_cnt Ga - (i + 1)\n                          < ig_arcs_cnt Ga - i \\<and>\n                          is_loopfree_inv Ga (i + 1) \\<and>\n                          Ga = G \\<and> i + 1 \\<le> ig_arcs_cnt Ga)\n 2. \\<And>G Ga i.\n       \\<lbrakk>is_loopfree_inv Ga i; Ga = G; i \\<le> ig_arcs_cnt Ga;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and> True = loop_free (mk_graph Ga)", "apply (fastforce intro: is_loopfree_step1 dest: is_loopfree_step2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G Ga i.\n       \\<lbrakk>is_loopfree_inv Ga i; Ga = G; i \\<le> ig_arcs_cnt Ga;\n        \\<not> i < ig_arcs_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and> True = loop_free (mk_graph Ga)", "apply (fastforce simp: is_loopfree_last)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Procedure @{term select_nodes}\\<close>"], ["", "definition select_nodes_inv :: \"IGraph \\<Rightarrow> IGraph \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"select_nodes_inv G H i \\<equiv> set (ig_verts H) = {v \\<in> set (take i (ig_verts G)). card (ig_neighbors G v) \\<ge> 3} \\<and> IGraph_inv H\""], ["", "lemma select_nodes_inv_step:\n  fixes G H i\n  defines \"v \\<equiv> ig_verts G ! i\"\n  assumes G_inv: \"IGraph_inv G\"\n  assumes sni_inv: \"select_nodes_inv G H i\"\n  assumes less: \"i < ig_verts_cnt G\"\n  assumes H': \"H' = (if 3 \\<le> card (ig_neighbors G v) then ig_add_v H v else H)\"\n  shows \"select_nodes_inv G H' (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_nodes_inv G H' (Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. select_nodes_inv G H' (Suc i)", "have *: \"IGraph_inv H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IGraph_inv H'", "using sni_inv H'"], ["proof (prove)\nusing this:\n  select_nodes_inv G H i\n  H' = (if 3 \\<le> card (ig_neighbors G v) then ig_add_v H v else H)\n\ngoal (1 subgoal):\n 1. IGraph_inv H'", "unfolding IGraph_inv_def select_nodes_inv_def"], ["proof (prove)\nusing this:\n  set (ig_verts H) =\n  {v \\<in> set (take i (ig_verts G)).\n   3 \\<le> card (ig_neighbors G v)} \\<and>\n  (\\<forall>e\\<in>set (ig_arcs H).\n      fst e \\<in> set (ig_verts H) \\<and> snd e \\<in> set (ig_verts H))\n  H' = (if 3 \\<le> card (ig_neighbors G v) then ig_add_v H v else H)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (ig_arcs H').\n       fst e \\<in> set (ig_verts H') \\<and> snd e \\<in> set (ig_verts H')", "by auto"], ["proof (state)\nthis:\n  IGraph_inv H'\n\ngoal (1 subgoal):\n 1. select_nodes_inv G H' (Suc i)", "have take_Suc_i: \"take (Suc i) (ig_verts G) = take i (ig_verts G) @ [v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc i) (ig_verts G) = take i (ig_verts G) @ [v]", "using less"], ["proof (prove)\nusing this:\n  i < ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. take (Suc i) (ig_verts G) = take i (ig_verts G) @ [v]", "unfolding v_def"], ["proof (prove)\nusing this:\n  i < ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. take (Suc i) (ig_verts G) = take i (ig_verts G) @ [ig_verts G ! i]", "by (auto simp: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take (Suc i) (ig_verts G) = take i (ig_verts G) @ [v]\n\ngoal (1 subgoal):\n 1. select_nodes_inv G H' (Suc i)", "have X: \"v \\<notin> set (take i (ig_verts G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set (take i (ig_verts G))", "using G_inv less distinct_ig_verts"], ["proof (prove)\nusing this:\n  IGraph_inv G\n  i < ig_verts_cnt G\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (take i (ig_verts G))", "unfolding v_def IGraph_inv_conv"], ["proof (prove)\nusing this:\n  pair_fin_digraph (mk_graph' G)\n  i < ig_verts_cnt G\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. ig_verts G ! i \\<notin> set (take i (ig_verts G))", "by (auto simp: distinct_conv_nth in_set_conv_nth)"], ["proof (state)\nthis:\n  v \\<notin> set (take i (ig_verts G))\n\ngoal (1 subgoal):\n 1. select_nodes_inv G H' (Suc i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. select_nodes_inv G H' (Suc i)", "unfolding select_nodes_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ig_verts H') =\n    {v \\<in> set (take (Suc i) (ig_verts G)).\n     3 \\<le> card (ig_neighbors G v)} \\<and>\n    IGraph_inv H'", "using X sni_inv"], ["proof (prove)\nusing this:\n  v \\<notin> set (take i (ig_verts G))\n  select_nodes_inv G H i\n\ngoal (1 subgoal):\n 1. set (ig_verts H') =\n    {v \\<in> set (take (Suc i) (ig_verts G)).\n     3 \\<le> card (ig_neighbors G v)} \\<and>\n    IGraph_inv H'", "by (simp only: *) (auto simp: take_Suc_i select_nodes_inv_def H')"], ["proof (state)\nthis:\n  select_nodes_inv G H' (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition select_nodes_prop :: \"IGraph \\<Rightarrow> IGraph \\<Rightarrow> bool\" where\n  \"select_nodes_prop G H \\<equiv> pverts (mk_graph H) = verts3 (mk_graph G)\""], ["", "lemma (in select_nodes_impl) select_nodes_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G\\<rbrace> \\<acute>R :== PROC select_nodes(\\<acute>G)\n   \\<lbrace> select_nodes_prop \\<^bsup>\\<sigma>\\<^esup>G \\<acute>R \\<and> IGraph_inv \\<acute>R \\<and> set (ig_arcs \\<acute>R) = {}\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G\\<rbrace>\n                               \\<acute>R :== PROC select_nodes(\\<acute>G)\n                               \\<lbrace>select_nodes_prop\n   \\<^bsup>\\<sigma>\\<^esup>G \\<acute>R \\<and>\n  IGraph_inv \\<acute>R \\<and> set (ig_arcs \\<acute>R) = {}\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G\\<rbrace>\n                               \\<acute>R :== ig_empty;; \\<acute>i :== 0;;\n                               WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                               INV named_loop ''loop'' \n                               DO \\<acute>v :==\n                                  ig_verts \\<acute>G ! \\<acute>i;;\n                                  IF 2 < card\n    (ig_neighbors \\<acute>G \\<acute>v)\n                                  THEN \\<acute>R :==\n ig_add_v \\<acute>R \\<acute>v\n                                  FI;;\n                                  \\<acute>i :== \\<acute>i + 1 \n                               OD\n                               \\<lbrace>select_nodes_prop\n   \\<^bsup>\\<sigma>\\<^esup>G \\<acute>R \\<and>\n  IGraph_inv \\<acute>R \\<and> set (ig_arcs \\<acute>R) = {}\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''loop'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace> select_nodes_inv \\<acute>G \\<acute>R \\<acute>i \\<and> \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G  \\<and> IGraph_inv \\<acute>G \\<and> set (ig_arcs \\<acute>R) = {}\\<rbrace>\n      (MEASURE ig_verts_cnt \\<acute>G - \\<acute>i)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G\\<rbrace>\n                               \\<acute>R :== ig_empty;; \\<acute>i :== 0;;\n                               WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                               INV \\<lbrace>select_nodes_inv \\<acute>G\n       \\<acute>R \\<acute>i \\<and>\n      \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n      \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n      IGraph_inv \\<acute>G \\<and> set (ig_arcs \\<acute>R) = {}\\<rbrace>\n                               VAR measure\n                                    (\\<lambda>s.\n  ig_verts_cnt\n   (lookup project_Check_Non_Planarity_Impl_IGraph G_'select_nodes_'\n     (locals s)) -\n  lookup project_Nat_nat i_'select_nodes_' (locals s)) \n                               DO \\<acute>v :==\n                                  ig_verts \\<acute>G ! \\<acute>i;;\n                                  IF 2 < card\n    (ig_neighbors \\<acute>G \\<acute>v)\n                                  THEN \\<acute>R :==\n ig_add_v \\<acute>R \\<acute>v\n                                  FI;;\n                                  \\<acute>i :== \\<acute>i + 1 \n                               OD\n                               \\<lbrace>select_nodes_prop\n   \\<^bsup>\\<sigma>\\<^esup>G \\<acute>R \\<and>\n  IGraph_inv \\<acute>R \\<and> set (ig_arcs \\<acute>R) = {}\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G.\n       IGraph_inv G \\<Longrightarrow>\n       select_nodes_inv G ig_empty 0 \\<and>\n       0 \\<le> ig_verts_cnt G \\<and>\n       G = G \\<and> IGraph_inv G \\<and> set (ig_arcs ig_empty) = {}\n 2. \\<And>G Ga R i.\n       \\<lbrakk>select_nodes_inv Ga R i; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; set (ig_arcs R) = {}; i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (2 < card\n                               (ig_neighbors Ga\n                                 (ig_verts Ga ! i)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          select_nodes_inv Ga (ig_add_v R (ig_verts Ga ! i))\n                           (i + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          set (ig_arcs (ig_add_v R (ig_verts Ga ! i))) =\n                          {}) \\<and>\n                         (\\<not> 2 < card\n(ig_neighbors Ga (ig_verts Ga ! i)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          select_nodes_inv Ga R (i + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and> set (ig_arcs R) = {})\n 3. \\<And>G Ga R i.\n       \\<lbrakk>select_nodes_inv Ga R i; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; set (ig_arcs R) = {};\n        \\<not> i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> select_nodes_prop G R \\<and>\n                         IGraph_inv R \\<and> set (ig_arcs R) = {}", "apply (fastforce simp: select_nodes_inv_def IGraph_inv_def mkg'_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G Ga R i.\n       \\<lbrakk>select_nodes_inv Ga R i; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; set (ig_arcs R) = {}; i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (2 < card\n                               (ig_neighbors Ga\n                                 (ig_verts Ga ! i)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          select_nodes_inv Ga (ig_add_v R (ig_verts Ga ! i))\n                           (i + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          set (ig_arcs (ig_add_v R (ig_verts Ga ! i))) =\n                          {}) \\<and>\n                         (\\<not> 2 < card\n(ig_neighbors Ga (ig_verts Ga ! i)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          select_nodes_inv Ga R (i + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and> set (ig_arcs R) = {})\n 2. \\<And>G Ga R i.\n       \\<lbrakk>select_nodes_inv Ga R i; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; set (ig_arcs R) = {};\n        \\<not> i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> select_nodes_prop G R \\<and>\n                         IGraph_inv R \\<and> set (ig_arcs R) = {}", "apply (fastforce simp add: select_nodes_inv_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G Ga R i.\n       \\<lbrakk>select_nodes_inv Ga R i; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; set (ig_arcs R) = {};\n        \\<not> i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> select_nodes_prop G R \\<and>\n                         IGraph_inv R \\<and> set (ig_arcs R) = {}", "apply (fastforce simp add: select_nodes_inv_def select_nodes_prop_def card_ig_neighbors_indegree verts3_def mkg_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Procedure @{term find_endpoint}\\<close>"], ["", "definition find_endpoint_path_inv where\n  \"find_endpoint_path_inv G H len u v w x \\<equiv>\n    \\<exists>p. pre_digraph.awalk (mk_graph G) u p x \\<and> length p = len \\<and>\n      hd p = (u,v) \\<and> last p = (w, x) \\<and>\n      set (pre_digraph.inner_verts (mk_graph G) p) \\<inter> set (ig_verts H) = {} \\<and>\n      progressing p \""], ["", "definition find_endpoint_arcs_inv where\n  \"find_endpoint_arcs_inv G found k v0 v1 v0' v1' \\<equiv>\n    (found \\<longrightarrow> (\\<exists>i < k. v1' = ig_opposite G (ig_in_out_arcs G v1 ! i) v1 \\<and> v0' = v1 \\<and> v0 \\<noteq> v1')) \\<and>\n    (\\<not>found \\<longrightarrow> (\\<forall>i < k. v0 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1) \\<and> v0 = v0' \\<and> v1 = v1')\""], ["", "lemma find_endpoint_path_first:\n  assumes \"iadj G u v\" \"u \\<noteq> v\" \"IGraph_inv G\"\n  shows \"find_endpoint_path_inv G H (Suc 0) u v u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "interpret ppg: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using assms"], ["proof (prove)\nusing this:\n  iadj G u v\n  u \\<noteq> v\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by (auto intro: IGraph_imp_ppg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "have \"(u,v) \\<in> parcs (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> parcs (mk_graph G)", "using assms"], ["proof (prove)\nusing this:\n  iadj G u v\n  u \\<noteq> v\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> parcs (mk_graph G)", "by (auto simp: iadj_def mkg_simps symcl_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> parcs (mk_graph G)\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> parcs (mk_graph G)", "have \"ppg.awalk u [(u,v)] v\" \"length [(u,v)] = Suc 0\" \"hd [(u,v)] = (u,v)\" \"last [(u,v)] = (u,v)\" \"progressing [(u,v)]\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> parcs (mk_graph G)\n\ngoal (1 subgoal):\n 1. (ppg.awalk u [(u, v)] v &&& length [(u, v)] = Suc 0) &&&\n    hd [(u, v)] = (u, v) &&& last [(u, v)] = (u, v) &&& progressing [(u, v)]", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> parcs (mk_graph G)\n  iadj G u v\n  u \\<noteq> v\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. (ppg.awalk u [(u, v)] v &&& length [(u, v)] = Suc 0) &&&\n    hd [(u, v)] = (u, v) &&& last [(u, v)] = (u, v) &&& progressing [(u, v)]", "by (auto simp: ppg.awalk_simps iadj_imp_verts mkg_simps progressing_Cons)"], ["proof (state)\nthis:\n  ppg.awalk u [(u, v)] v\n  length [(u, v)] = Suc 0\n  hd [(u, v)] = (u, v)\n  last [(u, v)] = (u, v)\n  progressing [(u, v)]\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "moreover"], ["proof (state)\nthis:\n  ppg.awalk u [(u, v)] v\n  length [(u, v)] = Suc 0\n  hd [(u, v)] = (u, v)\n  last [(u, v)] = (u, v)\n  progressing [(u, v)]\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "have \"set (ppg.inner_verts [(u,v)]) \\<inter> set (ig_verts H) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ppg.inner_verts [(u, v)]) \\<inter> set (ig_verts H) = {}", "by (auto simp: ppg.inner_verts_def)"], ["proof (state)\nthis:\n  set (ppg.inner_verts [(u, v)]) \\<inter> set (ig_verts H) = {}\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "ultimately"], ["proof (chain)\npicking this:\n  ppg.awalk u [(u, v)] v\n  length [(u, v)] = Suc 0\n  hd [(u, v)] = (u, v)\n  last [(u, v)] = (u, v)\n  progressing [(u, v)]\n  set (ppg.inner_verts [(u, v)]) \\<inter> set (ig_verts H) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ppg.awalk u [(u, v)] v\n  length [(u, v)] = Suc 0\n  hd [(u, v)] = (u, v)\n  last [(u, v)] = (u, v)\n  progressing [(u, v)]\n  set (ppg.inner_verts [(u, v)]) \\<inter> set (ig_verts H) = {}\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc 0) u v u v", "unfolding find_endpoint_path_inv_def"], ["proof (prove)\nusing this:\n  ppg.awalk u [(u, v)] v\n  length [(u, v)] = Suc 0\n  hd [(u, v)] = (u, v)\n  last [(u, v)] = (u, v)\n  progressing [(u, v)]\n  set (ppg.inner_verts [(u, v)]) \\<inter> set (ig_verts H) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       ppg.awalk u p v \\<and>\n       length p = Suc 0 \\<and>\n       hd p = (u, v) \\<and>\n       last p = (u, v) \\<and>\n       set (ppg.inner_verts p) \\<inter> set (ig_verts H) = {} \\<and>\n       progressing p", "by blast"], ["proof (state)\nthis:\n  find_endpoint_path_inv G H (Suc 0) u v u v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_endpoint_arcs_0:\n  \"find_endpoint_arcs_inv G False 0 v0 v1 v0 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_endpoint_arcs_inv G False 0 v0 v1 v0 v1", "unfolding find_endpoint_arcs_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (False \\<longrightarrow>\n     (\\<exists>i<0.\n         v1 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1 \\<and>\n         v0 = v1 \\<and> v0 \\<noteq> v1)) \\<and>\n    (\\<not> False \\<longrightarrow>\n     (\\<forall>i<0. v0 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1) \\<and>\n     v0 = v0 \\<and> v1 = v1)", "by auto"], ["", "lemma find_endpoint_path_lastE:\n  assumes \"find_endpoint_path_inv G H len u v w x\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes \"0 < len\"\n  assumes u: \"u \\<in> set (ig_verts H)\"\n  obtains p where \"pre_digraph.awalk (mk_graph G) u ((u,v) # p) x\"\n    and \"progressing ((u,v) # p)\"\n    and \"set (pre_digraph.inner_verts (mk_graph G) ((u,v) # p)) \\<inter> set (ig_verts H) = {}\"\n    and \"len \\<le> ig_verts_cnt G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>pre_digraph.awalk (with_proj (mk_graph G)) u ((u, v) # p)\n                  x;\n         progressing ((u, v) # p);\n         set (pre_digraph.inner_verts (with_proj (mk_graph G))\n               ((u, v) # p)) \\<inter>\n         set (ig_verts H) =\n         {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>pre_digraph.awalk (with_proj (mk_graph G)) u ((u, v) # p)\n                  x;\n         progressing ((u, v) # p);\n         set (pre_digraph.inner_verts (with_proj (mk_graph G))\n               ((u, v) # p)) \\<inter>\n         set (ig_verts H) =\n         {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ig and lf"], ["proof (chain)\npicking this:\n  IGraph_inv G\n  loop_free (mk_graph G)", "interpret pair_graph \"mk_graph G\""], ["proof (prove)\nusing this:\n  IGraph_inv G\n  loop_free (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "by (rule IGraph_lf_imp_pg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n         set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \"verts3 (mk_graph G) = set (ig_verts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "using assms"], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w x\n  IGraph_inv G\n  loop_free (mk_graph G)\n  select_nodes_prop G H\n  0 < len\n  u \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "unfolding select_nodes_prop_def"], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w x\n  IGraph_inv G\n  loop_free (mk_graph G)\n  pverts (mk_graph H) = verts3 (with_proj (mk_graph G))\n  0 < len\n  u \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "by (auto simp: mkg_simps)"], ["proof (state)\nthis:\n  verts3 (with_proj (mk_graph G)) = set (ig_verts H)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n         set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  find_endpoint_path_inv G H len u v w x\n  IGraph_inv G\n  loop_free (mk_graph G)\n  select_nodes_prop G H\n  0 < len\n  u \\<in> set (ig_verts H)", "obtain q where q: \"awalk u q x\" \"length q = len\" \"hd q = (u,v)\"\n    and iv: \"set (inner_verts q) \\<inter> verts3 (mk_graph G) = {}\"\n    and prg: \"progressing q\""], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w x\n  IGraph_inv G\n  loop_free (mk_graph G)\n  select_nodes_prop G H\n  0 < len\n  u \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>awalk u q x; length q = len; hd q = (u, v);\n         set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {};\n         progressing q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding find_endpoint_path_inv_def"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     awalk u p x \\<and>\n     length p = len \\<and>\n     hd p = (u, v) \\<and>\n     last p = (w, x) \\<and>\n     set (inner_verts p) \\<inter> set (ig_verts H) = {} \\<and> progressing p\n  IGraph_inv G\n  loop_free (mk_graph G)\n  select_nodes_prop G H\n  0 < len\n  u \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>awalk u q x; length q = len; hd q = (u, v);\n         set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {};\n         progressing q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n         set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n         set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q", "obtain q0 qs where \"q = q0 # qs\""], ["proof (prove)\nusing this:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n\ngoal (1 subgoal):\n 1. (\\<And>q0 qs. q = q0 # qs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>0 < len\\<close>"], ["proof (prove)\nusing this:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n  0 < len\n\ngoal (1 subgoal):\n 1. (\\<And>q0 qs. q = q0 # qs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases q) auto"], ["proof (state)\nthis:\n  q = q0 # qs\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n         set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  q = q0 # qs\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n         set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"len \\<le> ig_verts_cnt G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "have ev_q: \"awalk_verts u q = u # inner_verts q @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pawalk_verts u q = u # inner_verts q @ [x]", "unfolding inner_verts_conv[of q u]"], ["proof (prove)\ngoal (1 subgoal):\n 1. pawalk_verts u q = u # butlast (tl (pawalk_verts u q)) @ [x]", "using q \\<open>q = q0 # qs\\<close>"], ["proof (prove)\nusing this:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  q = q0 # qs\n\ngoal (1 subgoal):\n 1. pawalk_verts u q = u # butlast (tl (pawalk_verts u q)) @ [x]", "by auto"], ["proof (state)\nthis:\n  pawalk_verts u q = u # inner_verts q @ [x]\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "then"], ["proof (chain)\npicking this:\n  pawalk_verts u q = u # inner_verts q @ [x]", "have len_ev: \"length (awalk_verts u q) = 2 + length (inner_verts q)\""], ["proof (prove)\nusing this:\n  pawalk_verts u q = u # inner_verts q @ [x]\n\ngoal (1 subgoal):\n 1. length (pawalk_verts u q) = 2 + length (inner_verts q)", "by auto"], ["proof (state)\nthis:\n  length (pawalk_verts u q) = 2 + length (inner_verts q)\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "have set_av: \"set (awalk_verts u q) \\<subseteq> pverts (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pawalk_verts u q) \\<subseteq> pverts (mk_graph G)", "using q(1)"], ["proof (prove)\nusing this:\n  awalk u q x\n\ngoal (1 subgoal):\n 1. set (pawalk_verts u q) \\<subseteq> pverts (mk_graph G)", "by auto"], ["proof (state)\nthis:\n  set (pawalk_verts u q) \\<subseteq> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "from snp u"], ["proof (chain)\npicking this:\n  select_nodes_prop G H\n  u \\<in> set (ig_verts H)", "have \"u \\<in> verts3 (mk_graph G)\""], ["proof (prove)\nusing this:\n  select_nodes_prop G H\n  u \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. u \\<in> verts3 (with_proj (mk_graph G))", "by simp"], ["proof (state)\nthis:\n  u \\<in> verts3 (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "moreover"], ["proof (state)\nthis:\n  u \\<in> verts3 (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "with _ _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  u \\<in> verts3 (with_proj (mk_graph G))", "have \"distinct (inner_verts  q)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  u \\<in> verts3 (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. distinct (inner_verts q)", "using q(1) iv prg"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  u \\<in> verts3 (with_proj (mk_graph G))\n  awalk u q x\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n\ngoal (1 subgoal):\n 1. distinct (inner_verts q)", "by (rule verts2_awalk_distinct) (auto simp: verts3_def)"], ["proof (state)\nthis:\n  distinct (inner_verts q)\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> verts3 (with_proj (mk_graph G))\n  distinct (inner_verts q)", "have \"distinct (u # inner_verts q)\""], ["proof (prove)\nusing this:\n  u \\<in> verts3 (with_proj (mk_graph G))\n  distinct (inner_verts q)\n\ngoal (1 subgoal):\n 1. distinct (u # inner_verts q)", "using iv"], ["proof (prove)\nusing this:\n  u \\<in> verts3 (with_proj (mk_graph G))\n  distinct (inner_verts q)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n\ngoal (1 subgoal):\n 1. distinct (u # inner_verts q)", "by auto"], ["proof (state)\nthis:\n  distinct (u # inner_verts q)\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "moreover"], ["proof (state)\nthis:\n  distinct (u # inner_verts q)\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "have \"set (u # inner_verts q) \\<subseteq> pverts (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (u # inner_verts q) \\<subseteq> pverts (mk_graph G)", "using ev_q set_av"], ["proof (prove)\nusing this:\n  pawalk_verts u q = u # inner_verts q @ [x]\n  set (pawalk_verts u q) \\<subseteq> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. set (u # inner_verts q) \\<subseteq> pverts (mk_graph G)", "by auto"], ["proof (state)\nthis:\n  set (u # inner_verts q) \\<subseteq> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "ultimately"], ["proof (chain)\npicking this:\n  distinct (u # inner_verts q)\n  set (u # inner_verts q) \\<subseteq> pverts (mk_graph G)", "have \"length (u # inner_verts q) \\<le> card (pverts (mk_graph G))\""], ["proof (prove)\nusing this:\n  distinct (u # inner_verts q)\n  set (u # inner_verts q) \\<subseteq> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. length (u # inner_verts q) \\<le> card (pverts (mk_graph G))", "by (metis card_mono distinct_card finite_set verts_mkg)"], ["proof (state)\nthis:\n  length (u # inner_verts q) \\<le> card (pverts (mk_graph G))\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "then"], ["proof (chain)\npicking this:\n  length (u # inner_verts q) \\<le> card (pverts (mk_graph G))", "have \"length (awalk_verts u q) \\<le> 1 + card (pverts (mk_graph G))\""], ["proof (prove)\nusing this:\n  length (u # inner_verts q) \\<le> card (pverts (mk_graph G))\n\ngoal (1 subgoal):\n 1. length (pawalk_verts u q) \\<le> 1 + card (pverts (mk_graph G))", "by (simp add: len_ev)"], ["proof (state)\nthis:\n  length (pawalk_verts u q) \\<le> 1 + card (pverts (mk_graph G))\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "then"], ["proof (chain)\npicking this:\n  length (pawalk_verts u q) \\<le> 1 + card (pverts (mk_graph G))", "have \"length q \\<le> card (pverts (mk_graph G))\""], ["proof (prove)\nusing this:\n  length (pawalk_verts u q) \\<le> 1 + card (pverts (mk_graph G))\n\ngoal (1 subgoal):\n 1. length q \\<le> card (pverts (mk_graph G))", "by (auto simp: length_awalk_verts)"], ["proof (state)\nthis:\n  length q \\<le> card (pverts (mk_graph G))\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "also"], ["proof (state)\nthis:\n  length q \\<le> card (pverts (mk_graph G))\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "have \"\\<dots> \\<le> ig_verts_cnt G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (pverts (mk_graph G)) \\<le> ig_verts_cnt G", "by (auto simp: mkg_simps card_length)"], ["proof (state)\nthis:\n  card (pverts (mk_graph G)) \\<le> ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "finally"], ["proof (chain)\npicking this:\n  length q \\<le> ig_verts_cnt G", "show ?thesis"], ["proof (prove)\nusing this:\n  length q \\<le> ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. len \\<le> ig_verts_cnt G", "by (simp add: q)"], ["proof (state)\nthis:\n  len \\<le> ig_verts_cnt G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  len \\<le> ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n         set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n         len \\<le> ig_verts_cnt G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n  q = q0 # qs\n  len \\<le> ig_verts_cnt G", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk u q x\n  length q = len\n  hd q = (u, v)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n  q = q0 # qs\n  len \\<le> ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_endpoint_path_last1:\n  assumes \"find_endpoint_path_inv G H len u v w x\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes \"0 < len\"\n  assumes mem: \"u \\<in> set (ig_verts H)\" \"x \\<in> set (ig_verts H)\" \"u \\<noteq> x\"\n  shows \"\\<exists>p. pre_digraph.iapath (mk_graph G) u ((u,v) # p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       pre_digraph.gen_iapath (with_proj (mk_graph G))\n        (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       pre_digraph.gen_iapath (with_proj (mk_graph G))\n        (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x", "from ig and lf"], ["proof (chain)\npicking this:\n  IGraph_inv G\n  loop_free (mk_graph G)", "interpret pair_graph \"mk_graph G\""], ["proof (prove)\nusing this:\n  IGraph_inv G\n  loop_free (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "by (rule IGraph_lf_imp_pg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x", "have [simp]: \"verts3 (mk_graph G) = set (ig_verts H)\"\n    \"\\<And>x. x \\<in> set (ig_verts H) \\<Longrightarrow> x \\<in> pverts (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H) &&&\n    (\\<And>x.\n        x \\<in> set (ig_verts H) \\<Longrightarrow>\n        x \\<in> pverts (mk_graph G))", "using assms"], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w x\n  IGraph_inv G\n  loop_free (mk_graph G)\n  select_nodes_prop G H\n  0 < len\n  u \\<in> set (ig_verts H)\n  x \\<in> set (ig_verts H)\n  u \\<noteq> x\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H) &&&\n    (\\<And>x.\n        x \\<in> set (ig_verts H) \\<Longrightarrow>\n        x \\<in> pverts (mk_graph G))", "unfolding select_nodes_prop_def"], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w x\n  IGraph_inv G\n  loop_free (mk_graph G)\n  pverts (mk_graph H) = verts3 (with_proj (mk_graph G))\n  0 < len\n  u \\<in> set (ig_verts H)\n  x \\<in> set (ig_verts H)\n  u \\<noteq> x\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H) &&&\n    (\\<And>x.\n        x \\<in> set (ig_verts H) \\<Longrightarrow>\n        x \\<in> pverts (mk_graph G))", "by (auto simp: mkg_simps verts3_def)"], ["proof (state)\nthis:\n  verts3 (with_proj (mk_graph G)) = set (ig_verts H)\n  ?x1 \\<in> set (ig_verts H) \\<Longrightarrow> ?x1 \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x", "apply (rule find_endpoint_path_lastE[OF assms(1-5) mem(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>awalk u ((u, v) # p) x; progressing ((u, v) # p);\n        set (inner_verts ((u, v) # p)) \\<inter> set (ig_verts H) = {};\n        len \\<le> ig_verts_cnt G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            gen_iapath (verts3 (with_proj (mk_graph G))) u\n                             ((u, v) # p) x", "by (drule deg2_awalk_is_iapath[rotated 2]) (auto simp: mem)"], ["proof (state)\nthis:\n  \\<exists>p. gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_endpoint_path_last2D:\n  assumes path: \"find_endpoint_path_inv G H len u v w u\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes \"0 < len\"\n  assumes mem: \"u \\<in> set (ig_verts H)\"\n  assumes iapath: \"pre_digraph.iapath (mk_graph G) u ((u,v) # p) x\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from ig and lf"], ["proof (chain)\npicking this:\n  IGraph_inv G\n  loop_free (mk_graph G)", "interpret pair_graph \"mk_graph G\""], ["proof (prove)\nusing this:\n  IGraph_inv G\n  loop_free (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "by (rule IGraph_lf_imp_pg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have [simp]: \"verts3 (mk_graph G) = set (ig_verts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "using assms"], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w u\n  IGraph_inv G\n  loop_free (mk_graph G)\n  select_nodes_prop G H\n  0 < len\n  u \\<in> set (ig_verts H)\n  gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "unfolding select_nodes_prop_def"], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w u\n  IGraph_inv G\n  loop_free (mk_graph G)\n  pverts (mk_graph H) = verts3 (with_proj (mk_graph G))\n  0 < len\n  u \\<in> set (ig_verts H)\n  gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "by (auto simp: mkg_simps)"], ["proof (state)\nthis:\n  verts3 (with_proj (mk_graph G)) = set (ig_verts H)\n\ngoal (1 subgoal):\n 1. False", "have V: \"verts3 (mk_graph G) \\<subseteq> verts3 (mk_graph G)\" \"verts3 (mk_graph G) \\<subseteq> pverts (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G))\n    \\<subseteq> verts3 (with_proj (mk_graph G)) &&&\n    verts3 (with_proj (mk_graph G)) \\<subseteq> pverts (mk_graph G)", "using verts3_in_verts[where G=\"mk_graph G\"]"], ["proof (prove)\nusing this:\n  ?x \\<in> verts3 (with_proj (mk_graph G)) \\<Longrightarrow>\n  ?x \\<in> verts (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G))\n    \\<subseteq> verts3 (with_proj (mk_graph G)) &&&\n    verts3 (with_proj (mk_graph G)) \\<subseteq> pverts (mk_graph G)", "by auto"], ["proof (state)\nthis:\n  verts3 (with_proj (mk_graph G))\n  \\<subseteq> verts3 (with_proj (mk_graph G))\n  verts3 (with_proj (mk_graph G)) \\<subseteq> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. False", "obtain q where walk_q: \"awalk u ((u, v) # q) u\" and\n      progress_q: \"progressing ((u, v) # q)\" and\n      iv_q: \"set (inner_verts  ((u, v) # q)) \\<inter> verts3 (mk_graph G) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>awalk u ((u, v) # q) u; progressing ((u, v) # q);\n         set (inner_verts ((u, v) # q)) \\<inter>\n         verts3 (with_proj (mk_graph G)) =\n         {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule find_endpoint_path_lastE[OF path ig lf snp \\<open>0 < len\\<close> mem]) auto"], ["proof (state)\nthis:\n  awalk u ((u, v) # q) u\n  progressing ((u, v) # q)\n  set (inner_verts ((u, v) # q)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {}\n\ngoal (1 subgoal):\n 1. False", "from iapath"], ["proof (chain)\npicking this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x", "have walk_p: \"awalk u ((u,v) # p) x\" and\n      iv_p: \"set (inner_verts ((u, v) # p)) \\<inter> verts3 (mk_graph G) = {}\" and\n      uv_verts3: \"u \\<in> verts3 (mk_graph G)\" \"x \\<in> verts3 (mk_graph G)\""], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x\n\ngoal (1 subgoal):\n 1. awalk u ((u, v) # p) x &&&\n    set (inner_verts ((u, v) # p)) \\<inter>\n    verts3 (with_proj (mk_graph G)) =\n    {} &&&\n    u \\<in> verts3 (with_proj (mk_graph G)) &&&\n    x \\<in> verts3 (with_proj (mk_graph G))", "unfolding gen_iapath_def apath_def"], ["proof (prove)\nusing this:\n  u \\<in> verts3 (with_proj (mk_graph G)) \\<and>\n  x \\<in> verts3 (with_proj (mk_graph G)) \\<and>\n  (awalk u ((u, v) # p) x \\<and>\n   distinct (pawalk_verts u ((u, v) # p))) \\<and>\n  set (inner_verts ((u, v) # p)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {} \\<and>\n  (u, v) # p \\<noteq> []\n\ngoal (1 subgoal):\n 1. awalk u ((u, v) # p) x &&&\n    set (inner_verts ((u, v) # p)) \\<inter>\n    verts3 (with_proj (mk_graph G)) =\n    {} &&&\n    u \\<in> verts3 (with_proj (mk_graph G)) &&&\n    x \\<in> verts3 (with_proj (mk_graph G))", "by auto"], ["proof (state)\nthis:\n  awalk u ((u, v) # p) x\n  set (inner_verts ((u, v) # p)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {}\n  u \\<in> verts3 (with_proj (mk_graph G))\n  x \\<in> verts3 (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. False", "from iapath"], ["proof (chain)\npicking this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x", "have progress_p: \"progressing ((u,v) # p)\""], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) x\n\ngoal (1 subgoal):\n 1. progressing ((u, v) # p)", "unfolding gen_iapath_def"], ["proof (prove)\nusing this:\n  u \\<in> verts3 (with_proj (mk_graph G)) \\<and>\n  x \\<in> verts3 (with_proj (mk_graph G)) \\<and>\n  apath u ((u, v) # p) x \\<and>\n  set (inner_verts ((u, v) # p)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {} \\<and>\n  (u, v) # p \\<noteq> []\n\ngoal (1 subgoal):\n 1. progressing ((u, v) # p)", "by (auto intro: apath_imp_progressing)"], ["proof (state)\nthis:\n  progressing ((u, v) # p)\n\ngoal (1 subgoal):\n 1. False", "from V walk_q walk_p progress_q progress_p iv_q iv_p"], ["proof (chain)\npicking this:\n  verts3 (with_proj (mk_graph G))\n  \\<subseteq> verts3 (with_proj (mk_graph G))\n  verts3 (with_proj (mk_graph G)) \\<subseteq> pverts (mk_graph G)\n  awalk u ((u, v) # q) u\n  awalk u ((u, v) # p) x\n  progressing ((u, v) # q)\n  progressing ((u, v) # p)\n  set (inner_verts ((u, v) # q)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {}\n  set (inner_verts ((u, v) # p)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {}", "have \"(u,v) # q = (u,v) # p\""], ["proof (prove)\nusing this:\n  verts3 (with_proj (mk_graph G))\n  \\<subseteq> verts3 (with_proj (mk_graph G))\n  verts3 (with_proj (mk_graph G)) \\<subseteq> pverts (mk_graph G)\n  awalk u ((u, v) # q) u\n  awalk u ((u, v) # p) x\n  progressing ((u, v) # q)\n  progressing ((u, v) # p)\n  set (inner_verts ((u, v) # q)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {}\n  set (inner_verts ((u, v) # p)) \\<inter> verts3 (with_proj (mk_graph G)) =\n  {}\n\ngoal (1 subgoal):\n 1. (u, v) # q = (u, v) # p", "apply (rule same_awalk_by_common_arc[where e=\"(u,v)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {u, u, u, x} \\<subseteq> verts3 (with_proj (mk_graph G))\n 2. (u, v) \\<in> set ((u, v) # q)\n 3. (u, v) \\<in> set ((u, v) # p)", "using uv_verts3"], ["proof (prove)\nusing this:\n  u \\<in> verts3 (with_proj (mk_graph G))\n  x \\<in> verts3 (with_proj (mk_graph G))\n\ngoal (3 subgoals):\n 1. {u, u, u, x} \\<subseteq> verts3 (with_proj (mk_graph G))\n 2. (u, v) \\<in> set ((u, v) # q)\n 3. (u, v) \\<in> set ((u, v) # p)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (u, v) # q = (u, v) # p\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  (u, v) # q = (u, v) # p", "show False"], ["proof (prove)\nusing this:\n  (u, v) # q = (u, v) # p\n\ngoal (1 subgoal):\n 1. False", "by (metis iapath apath_nonempty_ends gen_iapath_def awalk_nonempty_ends(2) walk_p walk_q)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_endpoint_arcs_last:\n  assumes arcs: \"find_endpoint_arcs_inv G False (length (ig_in_out_arcs G v1)) v0 v1 v0a v1a\"\n  assumes path: \"find_endpoint_path_inv G H len v_tail v_next v0 v1\"\n  assumes ig: \"IGraph_inv G\" and lf: \"loop_free (mk_graph G)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes mem: \"v_tail \\<in> set (ig_verts H)\"\n  assumes \"0 < len\"\n  shows \"\\<not> pre_digraph.iapath (mk_graph G) v_tail ((v_tail, v_next) # p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n            x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. pre_digraph.gen_iapath (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n     x \\<Longrightarrow>\n    False", "let \"\\<not>?A\" = \"?thesis\""], ["proof (state)\ngoal (1 subgoal):\n 1. pre_digraph.gen_iapath (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n     x \\<Longrightarrow>\n    False", "assume ?A"], ["proof (state)\nthis:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p) x\n\ngoal (1 subgoal):\n 1. pre_digraph.gen_iapath (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n     x \\<Longrightarrow>\n    False", "interpret pair_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "using ig lf"], ["proof (prove)\nusing this:\n  IGraph_inv G\n  loop_free (mk_graph G)\n\ngoal (1 subgoal):\n 1. pair_graph (mk_graph G)", "by (rule IGraph_lf_imp_pg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have v3G_eq: \"verts3 (mk_graph G) = set (ig_verts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "using assms"], ["proof (prove)\nusing this:\n  find_endpoint_arcs_inv G False (length (ig_in_out_arcs G v1)) v0 v1 v0a\n   v1a\n  find_endpoint_path_inv G H len v_tail v_next v0 v1\n  IGraph_inv G\n  loop_free (mk_graph G)\n  select_nodes_prop G H\n  v_tail \\<in> set (ig_verts H)\n  0 < len\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "unfolding select_nodes_prop_def"], ["proof (prove)\nusing this:\n  find_endpoint_arcs_inv G False (length (ig_in_out_arcs G v1)) v0 v1 v0a\n   v1a\n  find_endpoint_path_inv G H len v_tail v_next v0 v1\n  IGraph_inv G\n  loop_free (mk_graph G)\n  pverts (mk_graph H) = verts3 (with_proj (mk_graph G))\n  v_tail \\<in> set (ig_verts H)\n  0 < len\n\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) = set (ig_verts H)", "by (auto simp: mkg_simps)"], ["proof (state)\nthis:\n  verts3 (with_proj (mk_graph G)) = set (ig_verts H)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "txt \\<open>\n    If no extending edge was found (as implied by @{thm arcs}), the last vertex of the walk\n    computed (as implied by @{thm path}) is of degree 1. Hence we consider all vertices\n    except the degree-2 nodes.\n  \\<close>"], ["proof (state)\nthis:\n  verts3 (with_proj (mk_graph G)) = set (ig_verts H)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "define V where \"V = {v \\<in> pverts (mk_graph G). in_degree (mk_graph G) v \\<noteq> 2}\""], ["proof (state)\nthis:\n  V =\n  {v \\<in> pverts (mk_graph G).\n   in_degree (with_proj (mk_graph G)) v \\<noteq> 2}\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have V: \"verts3 (mk_graph G) \\<subseteq> V\" \"V \\<subseteq> pverts (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts3 (with_proj (mk_graph G)) \\<subseteq> V &&&\n    V \\<subseteq> pverts (mk_graph G)", "unfolding verts3_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> verts (with_proj (mk_graph G)).\n     2 < in_degree (with_proj (mk_graph G)) v}\n    \\<subseteq> {v \\<in> pverts (mk_graph G).\n                 in_degree (with_proj (mk_graph G)) v \\<noteq> 2} &&&\n    {v \\<in> pverts (mk_graph G).\n     in_degree (with_proj (mk_graph G)) v \\<noteq> 2}\n    \\<subseteq> pverts (mk_graph G)", "by auto"], ["proof (state)\nthis:\n  verts3 (with_proj (mk_graph G)) \\<subseteq> V\n  V \\<subseteq> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "from \\<open>?A\\<close>"], ["proof (chain)\npicking this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x", "have walk_p: \"awalk v_tail ((v_tail, v_next) # p) x\" and\n      progress_p: \"progressing ((v_tail, v_next) # p)\""], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x\n\ngoal (1 subgoal):\n 1. awalk v_tail ((v_tail, v_next) # p) x &&&\n    progressing ((v_tail, v_next) # p)", "by (auto simp: gen_iapath_def apath_def intro: apath_imp_progressing)"], ["proof (state)\nthis:\n  awalk v_tail ((v_tail, v_next) # p) x\n  progressing ((v_tail, v_next) # p)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have iapath_V_p: \"gen_iapath  V v_tail ((v_tail, v_next) # p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "assume A: \"u \\<in> set (inner_verts ((v_tail, v_next) # p))\""], ["proof (state)\nthis:\n  u \\<in> set (inner_verts ((v_tail, v_next) # p))\n\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "then"], ["proof (chain)\npicking this:\n  u \\<in> set (inner_verts ((v_tail, v_next) # p))", "have \"u \\<in> pverts (mk_graph G)\""], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts ((v_tail, v_next) # p))\n\ngoal (1 subgoal):\n 1. u \\<in> pverts (mk_graph G)", "using \\<open>?A\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts ((v_tail, v_next) # p))\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x\n\ngoal (1 subgoal):\n 1. u \\<in> pverts (mk_graph G)", "by (auto 2 4 simp: set_inner_verts gen_iapath_def apath_Cons_iff dest: awalkI_apath)"], ["proof (state)\nthis:\n  u \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "with A \\<open>?A\\<close> inner_verts_min_degree[OF walk_p progress_p A]"], ["proof (chain)\npicking this:\n  u \\<in> set (inner_verts ((v_tail, v_next) # p))\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x\n  2 \\<le> in_degree (with_proj (mk_graph G)) u\n  u \\<in> pverts (mk_graph G)", "have \"u \\<notin> V\""], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts ((v_tail, v_next) # p))\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x\n  2 \\<le> in_degree (with_proj (mk_graph G)) u\n  u \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. u \\<notin> V", "unfolding gen_iapath_def verts3_def V_def"], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts ((v_tail, v_next) # p))\n  v_tail\n  \\<in> {v \\<in> verts (with_proj (mk_graph G)).\n         2 < in_degree (with_proj (mk_graph G)) v} \\<and>\n  x \\<in> {v \\<in> verts (with_proj (mk_graph G)).\n           2 < in_degree (with_proj (mk_graph G)) v} \\<and>\n  apath v_tail ((v_tail, v_next) # p) x \\<and>\n  set (inner_verts ((v_tail, v_next) # p)) \\<inter>\n  {v \\<in> verts (with_proj (mk_graph G)).\n   2 < in_degree (with_proj (mk_graph G)) v} =\n  {} \\<and>\n  (v_tail, v_next) # p \\<noteq> []\n  2 \\<le> in_degree (with_proj (mk_graph G)) u\n  u \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. u \\<notin> {v \\<in> pverts (mk_graph G).\n                in_degree (with_proj (mk_graph G)) v \\<noteq> 2}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> V\n\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> set (inner_verts ((v_tail, v_next) # p)) \\<Longrightarrow>\n  ?u3 \\<notin> V\n\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "with \\<open>?A\\<close> V"], ["proof (chain)\npicking this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x\n  verts3 (with_proj (mk_graph G)) \\<subseteq> V\n  V \\<subseteq> pverts (mk_graph G)\n  ?u3 \\<in> set (inner_verts ((v_tail, v_next) # p)) \\<Longrightarrow>\n  ?u3 \\<notin> V", "show ?thesis"], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x\n  verts3 (with_proj (mk_graph G)) \\<subseteq> V\n  V \\<subseteq> pverts (mk_graph G)\n  ?u3 \\<in> set (inner_verts ((v_tail, v_next) # p)) \\<Longrightarrow>\n  ?u3 \\<notin> V\n\ngoal (1 subgoal):\n 1. gen_iapath V v_tail ((v_tail, v_next) # p) x", "by (auto simp: gen_iapath_def)"], ["proof (state)\nthis:\n  gen_iapath V v_tail ((v_tail, v_next) # p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gen_iapath V v_tail ((v_tail, v_next) # p) x\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have arcs_p: \"(v_tail, v_next) \\<in> set ((v_tail, v_next) # p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v_tail, v_next) \\<in> set ((v_tail, v_next) # p)", "unfolding gen_iapath_def apath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v_tail, v_next) \\<in> set ((v_tail, v_next) # p)", "by auto"], ["proof (state)\nthis:\n  (v_tail, v_next) \\<in> set ((v_tail, v_next) # p)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have id_x: \"2 < in_degree (mk_graph G) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < in_degree (with_proj (mk_graph G)) x", "using \\<open>?A\\<close>"], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n   x\n\ngoal (1 subgoal):\n 1. 2 < in_degree (with_proj (mk_graph G)) x", "unfolding gen_iapath_def verts3_def"], ["proof (prove)\nusing this:\n  v_tail\n  \\<in> {v \\<in> verts (with_proj (mk_graph G)).\n         2 < in_degree (with_proj (mk_graph G)) v} \\<and>\n  x \\<in> {v \\<in> verts (with_proj (mk_graph G)).\n           2 < in_degree (with_proj (mk_graph G)) v} \\<and>\n  apath v_tail ((v_tail, v_next) # p) x \\<and>\n  set (inner_verts ((v_tail, v_next) # p)) \\<inter>\n  {v \\<in> verts (with_proj (mk_graph G)).\n   2 < in_degree (with_proj (mk_graph G)) v} =\n  {} \\<and>\n  (v_tail, v_next) # p \\<noteq> []\n\ngoal (1 subgoal):\n 1. 2 < in_degree (with_proj (mk_graph G)) x", "by auto"], ["proof (state)\nthis:\n  2 < in_degree (with_proj (mk_graph G)) x\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "from arcs"], ["proof (chain)\npicking this:\n  find_endpoint_arcs_inv G False (length (ig_in_out_arcs G v1)) v0 v1 v0a\n   v1a", "have edge_no_pr: \"\\<And>e. e \\<in> set (ig_in_out_arcs G v1) \\<Longrightarrow>\n      v0 = ig_opposite G e v1\" and\"v0 = v0a\" \"v1 = v1a\""], ["proof (prove)\nusing this:\n  find_endpoint_arcs_inv G False (length (ig_in_out_arcs G v1)) v0 v1 v0a\n   v1a\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        e \\<in> set (ig_in_out_arcs G v1) \\<Longrightarrow>\n        v0 = ig_opposite G e v1) &&&\n    v0 = v0a &&& v1 = v1a", "by (auto simp: find_endpoint_arcs_inv_def in_set_conv_nth)"], ["proof (state)\nthis:\n  ?e1 \\<in> set (ig_in_out_arcs G v1) \\<Longrightarrow>\n  v0 = ig_opposite G ?e1 v1\n  v0 = v0a\n  v1 = v1a\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have \"{e \\<in> parcs (mk_graph G). snd e = v1} \\<subseteq> {(v0,v1)}\" (is \"?L \\<subseteq> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {e \\<in> parcs (mk_graph G). snd e = v1} \\<subseteq> {(v0, v1)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> parcs (mk_graph G). snd e = v1} \\<Longrightarrow>\n       x \\<in> {(v0, v1)}", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> parcs (mk_graph G). snd e = v1} \\<Longrightarrow>\n       x \\<in> {(v0, v1)}", "assume \"e \\<in> ?L\""], ["proof (state)\nthis:\n  e \\<in> {e \\<in> parcs (mk_graph G). snd e = v1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> parcs (mk_graph G). snd e = v1} \\<Longrightarrow>\n       x \\<in> {(v0, v1)}", "then"], ["proof (chain)\npicking this:\n  e \\<in> {e \\<in> parcs (mk_graph G). snd e = v1}", "have \"fst e \\<noteq> snd e\""], ["proof (prove)\nusing this:\n  e \\<in> {e \\<in> parcs (mk_graph G). snd e = v1}\n\ngoal (1 subgoal):\n 1. fst e \\<noteq> snd e", "by (auto dest: no_loops)"], ["proof (state)\nthis:\n  fst e \\<noteq> snd e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> parcs (mk_graph G). snd e = v1} \\<Longrightarrow>\n       x \\<in> {(v0, v1)}", "moreover"], ["proof (state)\nthis:\n  fst e \\<noteq> snd e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> parcs (mk_graph G). snd e = v1} \\<Longrightarrow>\n       x \\<in> {(v0, v1)}", "from \\<open>e \\<in> ?L\\<close>"], ["proof (chain)\npicking this:\n  e \\<in> {e \\<in> parcs (mk_graph G). snd e = v1}", "have \"e \\<in> set (ig_in_out_arcs G v1) \\<or> (snd e, fst e) \\<in> set (ig_in_out_arcs G v1)\""], ["proof (prove)\nusing this:\n  e \\<in> {e \\<in> parcs (mk_graph G). snd e = v1}\n\ngoal (1 subgoal):\n 1. e \\<in> set (ig_in_out_arcs G v1) \\<or>\n    (snd e, fst e) \\<in> set (ig_in_out_arcs G v1)", "by (auto simp: mkg_simps ig_in_out_arcs_def symcl_def)"], ["proof (state)\nthis:\n  e \\<in> set (ig_in_out_arcs G v1) \\<or>\n  (snd e, fst e) \\<in> set (ig_in_out_arcs G v1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> parcs (mk_graph G). snd e = v1} \\<Longrightarrow>\n       x \\<in> {(v0, v1)}", "then"], ["proof (chain)\npicking this:\n  e \\<in> set (ig_in_out_arcs G v1) \\<or>\n  (snd e, fst e) \\<in> set (ig_in_out_arcs G v1)", "have \"v0 = ig_opposite G e v1 \\<or> v0 = ig_opposite G (snd e, fst e) v1\""], ["proof (prove)\nusing this:\n  e \\<in> set (ig_in_out_arcs G v1) \\<or>\n  (snd e, fst e) \\<in> set (ig_in_out_arcs G v1)\n\ngoal (1 subgoal):\n 1. v0 = ig_opposite G e v1 \\<or> v0 = ig_opposite G (snd e, fst e) v1", "by (auto intro: edge_no_pr)"], ["proof (state)\nthis:\n  v0 = ig_opposite G e v1 \\<or> v0 = ig_opposite G (snd e, fst e) v1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {e \\<in> parcs (mk_graph G). snd e = v1} \\<Longrightarrow>\n       x \\<in> {(v0, v1)}", "ultimately"], ["proof (chain)\npicking this:\n  fst e \\<noteq> snd e\n  v0 = ig_opposite G e v1 \\<or> v0 = ig_opposite G (snd e, fst e) v1", "show \"e \\<in> ?R\""], ["proof (prove)\nusing this:\n  fst e \\<noteq> snd e\n  v0 = ig_opposite G e v1 \\<or> v0 = ig_opposite G (snd e, fst e) v1\n\ngoal (1 subgoal):\n 1. e \\<in> {(v0, v1)}", "using \\<open>e \\<in> ?L\\<close>"], ["proof (prove)\nusing this:\n  fst e \\<noteq> snd e\n  v0 = ig_opposite G e v1 \\<or> v0 = ig_opposite G (snd e, fst e) v1\n  e \\<in> {e \\<in> parcs (mk_graph G). snd e = v1}\n\ngoal (1 subgoal):\n 1. e \\<in> {(v0, v1)}", "by (auto simp: ig_opposite_def)"], ["proof (state)\nthis:\n  e \\<in> {(v0, v1)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {e \\<in> parcs (mk_graph G). snd e = v1} \\<subseteq> {(v0, v1)}\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  {e \\<in> parcs (mk_graph G). snd e = v1} \\<subseteq> {(v0, v1)}", "have id_v1: \"in_degree (mk_graph G) v1 \\<le> card {(v0,v1)}\""], ["proof (prove)\nusing this:\n  {e \\<in> parcs (mk_graph G). snd e = v1} \\<subseteq> {(v0, v1)}\n\ngoal (1 subgoal):\n 1. in_degree (with_proj (mk_graph G)) v1 \\<le> card {(v0, v1)}", "unfolding in_degree_def in_arcs_def"], ["proof (prove)\nusing this:\n  {e \\<in> parcs (mk_graph G). snd e = v1} \\<subseteq> {(v0, v1)}\n\ngoal (1 subgoal):\n 1. card\n     {e \\<in> arcs (with_proj (mk_graph G)).\n      pre_digraph.head (with_proj (mk_graph G)) e = v1}\n    \\<le> card {(v0, v1)}", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  in_degree (with_proj (mk_graph G)) v1 \\<le> card {(v0, v1)}\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "from path"], ["proof (chain)\npicking this:\n  find_endpoint_path_inv G H len v_tail v_next v0 v1", "obtain q where walk_q: \"awalk v_tail q v1\" and\n      q_props: \"length q = len\" \"hd q = (v_tail, v_next)\" and\n      iv_q': \"set (inner_verts q) \\<inter> verts3 (mk_graph G) = {}\" and\n      progress_q: \"progressing q\""], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len v_tail v_next v0 v1\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>awalk v_tail q v1; length q = len; hd q = (v_tail, v_next);\n         set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {};\n         progressing q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: find_endpoint_path_inv_def v3G_eq)"], ["proof (state)\nthis:\n  awalk v_tail q v1\n  length q = len\n  hd q = (v_tail, v_next)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  awalk v_tail q v1\n  length q = len\n  hd q = (v_tail, v_next)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q", "have \"v1 \\<in> pverts (mk_graph G)\""], ["proof (prove)\nusing this:\n  awalk v_tail q v1\n  length q = len\n  hd q = (v_tail, v_next)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  progressing q\n\ngoal (1 subgoal):\n 1. v1 \\<in> pverts (mk_graph G)", "by (metis awalk_last_in_verts)"], ["proof (state)\nthis:\n  v1 \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v1 \\<in> pverts (mk_graph G)", "have \"v1 \\<in> V\""], ["proof (prove)\nusing this:\n  v1 \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. v1 \\<in> V", "using id_v1"], ["proof (prove)\nusing this:\n  v1 \\<in> pverts (mk_graph G)\n  in_degree (with_proj (mk_graph G)) v1 \\<le> card {(v0, v1)}\n\ngoal (1 subgoal):\n 1. v1 \\<in> V", "unfolding V_def"], ["proof (prove)\nusing this:\n  v1 \\<in> pverts (mk_graph G)\n  in_degree (with_proj (mk_graph G)) v1 \\<le> card {(v0, v1)}\n\ngoal (1 subgoal):\n 1. v1 \\<in> {v \\<in> pverts (mk_graph G).\n              in_degree (with_proj (mk_graph G)) v \\<noteq> 2}", "by auto"], ["proof (state)\nthis:\n  v1 \\<in> V\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  v1 \\<in> V\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "assume A: \"u \\<in> set (inner_verts q)\""], ["proof (state)\nthis:\n  u \\<in> set (inner_verts q)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  u \\<in> set (inner_verts q)", "have \"u \\<in> set (pawalk_verts v_tail q)\""], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts q)\n\ngoal (1 subgoal):\n 1. u \\<in> set (pawalk_verts v_tail q)", "using walk_q"], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts q)\n  awalk v_tail q v1\n\ngoal (1 subgoal):\n 1. u \\<in> set (pawalk_verts v_tail q)", "by (auto simp: inner_verts_conv[where u=v_tail] awalk_def dest: in_set_butlastD list_set_tl)"], ["proof (state)\nthis:\n  u \\<in> set (pawalk_verts v_tail q)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  u \\<in> set (pawalk_verts v_tail q)", "have \"u \\<in> pverts (mk_graph G)\""], ["proof (prove)\nusing this:\n  u \\<in> set (pawalk_verts v_tail q)\n\ngoal (1 subgoal):\n 1. u \\<in> pverts (mk_graph G)", "using walk_q"], ["proof (prove)\nusing this:\n  u \\<in> set (pawalk_verts v_tail q)\n  awalk v_tail q v1\n\ngoal (1 subgoal):\n 1. u \\<in> pverts (mk_graph G)", "by auto"], ["proof (state)\nthis:\n  u \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "with A iv_q' inner_verts_min_degree[OF walk_q progress_q A]"], ["proof (chain)\npicking this:\n  u \\<in> set (inner_verts q)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  2 \\<le> in_degree (with_proj (mk_graph G)) u\n  u \\<in> pverts (mk_graph G)", "have \"u \\<notin> V\""], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts q)\n  set (inner_verts q) \\<inter> verts3 (with_proj (mk_graph G)) = {}\n  2 \\<le> in_degree (with_proj (mk_graph G)) u\n  u \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. u \\<notin> V", "unfolding verts3_def V_def"], ["proof (prove)\nusing this:\n  u \\<in> set (inner_verts q)\n  set (inner_verts q) \\<inter>\n  {v \\<in> verts (with_proj (mk_graph G)).\n   2 < in_degree (with_proj (mk_graph G)) v} =\n  {}\n  2 \\<le> in_degree (with_proj (mk_graph G)) u\n  u \\<in> pverts (mk_graph G)\n\ngoal (1 subgoal):\n 1. u \\<notin> {v \\<in> pverts (mk_graph G).\n                in_degree (with_proj (mk_graph G)) v \\<noteq> 2}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> V\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> set (inner_verts q) \\<Longrightarrow> ?u3 \\<notin> V\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ?u3 \\<in> set (inner_verts q) \\<Longrightarrow> ?u3 \\<notin> V", "have iv_q: \"set (inner_verts q) \\<inter> V = {}\""], ["proof (prove)\nusing this:\n  ?u3 \\<in> set (inner_verts q) \\<Longrightarrow> ?u3 \\<notin> V\n\ngoal (1 subgoal):\n 1. set (inner_verts q) \\<inter> V = {}", "by auto"], ["proof (state)\nthis:\n  set (inner_verts q) \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have arcs_q: \"(v_tail, v_next) \\<in> set q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v_tail, v_next) \\<in> set q", "using q_props \\<open>0 < len\\<close>"], ["proof (prove)\nusing this:\n  length q = len\n  hd q = (v_tail, v_next)\n  0 < len\n\ngoal (1 subgoal):\n 1. (v_tail, v_next) \\<in> set q", "by (cases q) auto"], ["proof (state)\nthis:\n  (v_tail, v_next) \\<in> set q\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have neq: \"v_tail \\<noteq> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v_tail \\<noteq> v1", "using find_endpoint_path_last2D[OF _ ig lf snp \\<open>0 < len\\<close> \\<open>v_tail \\<in> _\\<close> \\<open>?A\\<close>] path"], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len v_tail v_next ?w v_tail \\<Longrightarrow>\n  False\n  find_endpoint_path_inv G H len v_tail v_next v0 v1\n\ngoal (1 subgoal):\n 1. v_tail \\<noteq> v1", "by auto"], ["proof (state)\nthis:\n  v_tail \\<noteq> v1\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have in_V: \"v_tail \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v_tail \\<in> V", "using iapath_V_p"], ["proof (prove)\nusing this:\n  gen_iapath V v_tail ((v_tail, v_next) # p) x\n\ngoal (1 subgoal):\n 1. v_tail \\<in> V", "unfolding gen_iapath_def"], ["proof (prove)\nusing this:\n  v_tail \\<in> V \\<and>\n  x \\<in> V \\<and>\n  apath v_tail ((v_tail, v_next) # p) x \\<and>\n  set (inner_verts ((v_tail, v_next) # p)) \\<inter> V = {} \\<and>\n  (v_tail, v_next) # p \\<noteq> []\n\ngoal (1 subgoal):\n 1. v_tail \\<in> V", "by auto"], ["proof (state)\nthis:\n  v_tail \\<in> V\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have iapath_V_q: \"gen_iapath V v_tail q v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_iapath V v_tail q v1", "using V walk_q iv_q progress_q in_V \\<open>v1 \\<in> V\\<close> neq"], ["proof (prove)\nusing this:\n  verts3 (with_proj (mk_graph G)) \\<subseteq> V\n  V \\<subseteq> pverts (mk_graph G)\n  awalk v_tail q v1\n  set (inner_verts q) \\<inter> V = {}\n  progressing q\n  v_tail \\<in> V\n  v1 \\<in> V\n  v_tail \\<noteq> v1\n\ngoal (1 subgoal):\n 1. gen_iapath V v_tail q v1", "by (rule deg2_awalk_is_iapath)"], ["proof (state)\nthis:\n  gen_iapath V v_tail q v1\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "have \"((v_tail, v_next) # p) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v_tail, v_next) # p = q", "using V iapath_V_p iapath_V_q arcs_p arcs_q"], ["proof (prove)\nusing this:\n  verts3 (with_proj (mk_graph G)) \\<subseteq> V\n  V \\<subseteq> pverts (mk_graph G)\n  gen_iapath V v_tail ((v_tail, v_next) # p) x\n  gen_iapath V v_tail q v1\n  (v_tail, v_next) \\<in> set ((v_tail, v_next) # p)\n  (v_tail, v_next) \\<in> set q\n\ngoal (1 subgoal):\n 1. (v_tail, v_next) # p = q", "by (rule same_gen_iapath_by_common_arc)"], ["proof (state)\nthis:\n  (v_tail, v_next) # p = q\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (v_tail, v_next) # p = q", "have \"v1 = x\""], ["proof (prove)\nusing this:\n  (v_tail, v_next) # p = q\n\ngoal (1 subgoal):\n 1. v1 = x", "using walk_p walk_q"], ["proof (prove)\nusing this:\n  (v_tail, v_next) # p = q\n  awalk v_tail ((v_tail, v_next) # p) x\n  awalk v_tail q v1\n\ngoal (1 subgoal):\n 1. v1 = x", "by auto"], ["proof (state)\nthis:\n  v1 = x\n\ngoal (1 subgoal):\n 1. gen_iapath (verts3 (with_proj (mk_graph G))) v_tail\n     ((v_tail, v_next) # p) x \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v1 = x", "show False"], ["proof (prove)\nusing this:\n  v1 = x\n\ngoal (1 subgoal):\n 1. False", "using id_v1 id_x"], ["proof (prove)\nusing this:\n  v1 = x\n  in_degree (with_proj (mk_graph G)) v1 \\<le> card {(v0, v1)}\n  2 < in_degree (with_proj (mk_graph G)) x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_endpoint_arcs_step1E:\n  assumes \"find_endpoint_arcs_inv G False k v0 v1 v0' v1'\"\n  assumes \"ig_opposite G (ig_in_out_arcs G v1 ! k) v1' \\<noteq> v0'\"\n  obtains \"v0 = v0'\" \"v1 = v1'\" \"find_endpoint_arcs_inv G True (Suc k) v0 v1 v1 (ig_opposite G (ig_in_out_arcs G v1 ! k) v1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>v0 = v0'; v1 = v1';\n      find_endpoint_arcs_inv G True (Suc k) v0 v1 v1\n       (ig_opposite G (ig_in_out_arcs G v1 ! k) v1)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  find_endpoint_arcs_inv G False k v0 v1 v0' v1'\n  ig_opposite G (ig_in_out_arcs G v1 ! k) v1' \\<noteq> v0'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>v0 = v0'; v1 = v1';\n      find_endpoint_arcs_inv G True (Suc k) v0 v1 v1\n       (ig_opposite G (ig_in_out_arcs G v1 ! k) v1)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding find_endpoint_arcs_inv_def"], ["proof (prove)\nusing this:\n  (False \\<longrightarrow>\n   (\\<exists>i<k.\n       v1' = ig_opposite G (ig_in_out_arcs G v1 ! i) v1 \\<and>\n       v0' = v1 \\<and> v0 \\<noteq> v1')) \\<and>\n  (\\<not> False \\<longrightarrow>\n   (\\<forall>i<k. v0 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1) \\<and>\n   v0 = v0' \\<and> v1 = v1')\n  ig_opposite G (ig_in_out_arcs G v1 ! k) v1' \\<noteq> v0'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>v0 = v0'; v1 = v1';\n      (True \\<longrightarrow>\n       (\\<exists>i<Suc k.\n           ig_opposite G (ig_in_out_arcs G v1 ! k) v1 =\n           ig_opposite G (ig_in_out_arcs G v1 ! i) v1 \\<and>\n           v1 = v1 \\<and>\n           v0 \\<noteq> ig_opposite G (ig_in_out_arcs G v1 ! k) v1)) \\<and>\n      (\\<not> True \\<longrightarrow>\n       (\\<forall>i<Suc k.\n           v0 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1) \\<and>\n       v0 = v1 \\<and>\n       v1 = ig_opposite G (ig_in_out_arcs G v1 ! k) v1)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: less_SucI elim: less_SucE)"], ["", "lemma find_endpoint_arcs_step2E:\n  assumes \"find_endpoint_arcs_inv G False k v0 v1 v0' v1'\"\n  assumes \"ig_opposite G (ig_in_out_arcs G v1 ! k) v1' = v0'\"\n  obtains \"v0 = v0'\" \"v1 = v1'\" \"find_endpoint_arcs_inv G False (Suc k) v0 v1 v0 v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>v0 = v0'; v1 = v1';\n      find_endpoint_arcs_inv G False (Suc k) v0 v1 v0 v1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  find_endpoint_arcs_inv G False k v0 v1 v0' v1'\n  ig_opposite G (ig_in_out_arcs G v1 ! k) v1' = v0'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>v0 = v0'; v1 = v1';\n      find_endpoint_arcs_inv G False (Suc k) v0 v1 v0 v1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding find_endpoint_arcs_inv_def"], ["proof (prove)\nusing this:\n  (False \\<longrightarrow>\n   (\\<exists>i<k.\n       v1' = ig_opposite G (ig_in_out_arcs G v1 ! i) v1 \\<and>\n       v0' = v1 \\<and> v0 \\<noteq> v1')) \\<and>\n  (\\<not> False \\<longrightarrow>\n   (\\<forall>i<k. v0 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1) \\<and>\n   v0 = v0' \\<and> v1 = v1')\n  ig_opposite G (ig_in_out_arcs G v1 ! k) v1' = v0'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>v0 = v0'; v1 = v1';\n      (False \\<longrightarrow>\n       (\\<exists>i<Suc k.\n           v1 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1 \\<and>\n           v0 = v1 \\<and> v0 \\<noteq> v1)) \\<and>\n      (\\<not> False \\<longrightarrow>\n       (\\<forall>i<Suc k.\n           v0 = ig_opposite G (ig_in_out_arcs G v1 ! i) v1) \\<and>\n       v0 = v0 \\<and> v1 = v1)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: less_SucI elim: less_SucE)"], ["", "lemma find_endpoint_path_step:\n  assumes path: \"find_endpoint_path_inv G H len u v w x\" and \"0 < len\"\n  assumes arcs: \"find_endpoint_arcs_inv G True k w x w' x'\"\n  \"k \\<le> length (ig_in_out_arcs G x)\"\n  assumes ig: \"IGraph_inv G\"\n  assumes not_end: \"x \\<notin> set (ig_verts H)\"\n  shows \"find_endpoint_path_inv G H (Suc len) u v w' x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "interpret pg: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using ig"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by (auto intro: IGraph_imp_ppg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "from path"], ["proof (chain)\npicking this:\n  find_endpoint_path_inv G H len u v w x", "obtain p where awalk: \"pg.awalk u p x\" and\n      p: \"length p = len\" \"hd p = (u, v)\" \"last p = (w, x)\" and\n      iv: \"set (pg.inner_verts p) \\<inter> set (ig_verts H) = {}\" and\n      progress: \"progressing p\""], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>pg.awalk u p x; length p = len; hd p = (u, v);\n         last p = (w, x);\n         set (pg.inner_verts p) \\<inter> set (ig_verts H) = {};\n         progressing p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: find_endpoint_path_inv_def)"], ["proof (state)\nthis:\n  pg.awalk u p x\n  length p = len\n  hd p = (u, v)\n  last p = (w, x)\n  set (pg.inner_verts p) \\<inter> set (ig_verts H) = {}\n  progressing p\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "define p' where \"p' = p @ [(x,x')]\""], ["proof (state)\nthis:\n  p' = p @ [(x, x')]\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "from path"], ["proof (chain)\npicking this:\n  find_endpoint_path_inv G H len u v w x", "have \"x \\<in> set (ig_verts G)\""], ["proof (prove)\nusing this:\n  find_endpoint_path_inv G H len u v w x\n\ngoal (1 subgoal):\n 1. x \\<in> set (ig_verts G)", "by (metis awalk pg.awalk_last_in_verts verts_mkg)"], ["proof (state)\nthis:\n  x \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "with arcs"], ["proof (chain)\npicking this:\n  find_endpoint_arcs_inv G True k w x w' x'\n  k \\<le> length (ig_in_out_arcs G x)\n  x \\<in> set (ig_verts G)", "have \"iadj G x x'\" \"x = w'\" \"w \\<noteq> x'\""], ["proof (prove)\nusing this:\n  find_endpoint_arcs_inv G True k w x w' x'\n  k \\<le> length (ig_in_out_arcs G x)\n  x \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. iadj G x x' &&& x = w' &&& w \\<noteq> x'", "using \\<open>x \\<in> set (ig_verts G)\\<close>"], ["proof (prove)\nusing this:\n  find_endpoint_arcs_inv G True k w x w' x'\n  k \\<le> length (ig_in_out_arcs G x)\n  x \\<in> set (ig_verts G)\n  x \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. iadj G x x' &&& x = w' &&& w \\<noteq> x'", "unfolding find_endpoint_arcs_inv_def"], ["proof (prove)\nusing this:\n  (True \\<longrightarrow>\n   (\\<exists>i<k.\n       x' = ig_opposite G (ig_in_out_arcs G x ! i) x \\<and>\n       w' = x \\<and> w \\<noteq> x')) \\<and>\n  (\\<not> True \\<longrightarrow>\n   (\\<forall>i<k. w = ig_opposite G (ig_in_out_arcs G x ! i) x) \\<and>\n   w = w' \\<and> x = x')\n  k \\<le> length (ig_in_out_arcs G x)\n  x \\<in> set (ig_verts G)\n  x \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. iadj G x x' &&& x = w' &&& w \\<noteq> x'", "by (auto intro: iadj_io_edge)"], ["proof (state)\nthis:\n  iadj G x x'\n  x = w'\n  w \\<noteq> x'\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "then"], ["proof (chain)\npicking this:\n  iadj G x x'\n  x = w'\n  w \\<noteq> x'", "have \"(x,x') \\<in> parcs (mk_graph G)\" \"x' \\<in> set (ig_verts G)\""], ["proof (prove)\nusing this:\n  iadj G x x'\n  x = w'\n  w \\<noteq> x'\n\ngoal (1 subgoal):\n 1. (x, x') \\<in> parcs (mk_graph G) &&& x' \\<in> set (ig_verts G)", "using ig"], ["proof (prove)\nusing this:\n  iadj G x x'\n  x = w'\n  w \\<noteq> x'\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. (x, x') \\<in> parcs (mk_graph G) &&& x' \\<in> set (ig_verts G)", "unfolding iadj_def"], ["proof (prove)\nusing this:\n  (x, x') \\<in> set (ig_arcs G) \\<or> (x', x) \\<in> set (ig_arcs G)\n  x = w'\n  w \\<noteq> x'\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. (x, x') \\<in> parcs (mk_graph G) &&& x' \\<in> set (ig_verts G)", "by (auto simp: mkg_simps set_ig_arcs_imp_verts symcl_def)"], ["proof (state)\nthis:\n  (x, x') \\<in> parcs (mk_graph G)\n  x' \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "then"], ["proof (chain)\npicking this:\n  (x, x') \\<in> parcs (mk_graph G)\n  x' \\<in> set (ig_verts G)", "have \"pg.awalk u p' x'\""], ["proof (prove)\nusing this:\n  (x, x') \\<in> parcs (mk_graph G)\n  x' \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. pg.awalk u p' x'", "unfolding p'_def"], ["proof (prove)\nusing this:\n  (x, x') \\<in> parcs (mk_graph G)\n  x' \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. pg.awalk u (p @ [(x, x')]) x'", "using awalk"], ["proof (prove)\nusing this:\n  (x, x') \\<in> parcs (mk_graph G)\n  x' \\<in> set (ig_verts G)\n  pg.awalk u p x\n\ngoal (1 subgoal):\n 1. pg.awalk u (p @ [(x, x')]) x'", "by (auto simp: pg.awalk_simps mkg_simps)"], ["proof (state)\nthis:\n  pg.awalk u p' x'\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "moreover"], ["proof (state)\nthis:\n  pg.awalk u p' x'\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "have \"length p' = Suc len\" \"hd p' = (u,v)\" \"last p' = (w',x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p' = Suc len &&& hd p' = (u, v) &&& last p' = (w', x')", "using \\<open>x = w'\\<close> \\<open>0 < len\\<close> p"], ["proof (prove)\nusing this:\n  x = w'\n  0 < len\n  length p = len\n  hd p = (u, v)\n  last p = (w, x)\n\ngoal (1 subgoal):\n 1. length p' = Suc len &&& hd p' = (u, v) &&& last p' = (w', x')", "by (auto simp: p'_def)"], ["proof (state)\nthis:\n  length p' = Suc len\n  hd p' = (u, v)\n  last p' = (w', x')\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "moreover"], ["proof (state)\nthis:\n  length p' = Suc len\n  hd p' = (u, v)\n  last p' = (w', x')\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "have \"set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}", "using iv not_end p \\<open>0 < len\\<close>"], ["proof (prove)\nusing this:\n  set (pg.inner_verts p) \\<inter> set (ig_verts H) = {}\n  x \\<notin> set (ig_verts H)\n  length p = len\n  hd p = (u, v)\n  last p = (w, x)\n  0 < len\n\ngoal (1 subgoal):\n 1. set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}", "unfolding p'_def"], ["proof (prove)\nusing this:\n  set (pg.inner_verts p) \\<inter> set (ig_verts H) = {}\n  x \\<notin> set (ig_verts H)\n  length p = len\n  hd p = (u, v)\n  last p = (w, x)\n  0 < len\n\ngoal (1 subgoal):\n 1. set (pg.inner_verts (p @ [(x, x')])) \\<inter> set (ig_verts H) = {}", "by (auto simp: pg.inner_verts_def)"], ["proof (state)\nthis:\n  set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "moreover"], ["proof (state)\nthis:\n  set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "{"], ["proof (state)\nthis:\n  set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "fix ys y z zs"], ["proof (state)\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "have \"p' \\<noteq> ys @ [(y,z), (z,y)] @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<noteq> ys @ [(y, z), (z, y)] @ zs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p' = ys @ [(y, z), (z, y)] @ zs \\<Longrightarrow> False", "let \"\\<not>?A\" = \"?thesis\""], ["proof (state)\ngoal (1 subgoal):\n 1. p' = ys @ [(y, z), (z, y)] @ zs \\<Longrightarrow> False", "assume ?A"], ["proof (state)\nthis:\n  p' = ys @ [(y, z), (z, y)] @ zs\n\ngoal (1 subgoal):\n 1. p' = ys @ [(y, z), (z, y)] @ zs \\<Longrightarrow> False", "from progress"], ["proof (chain)\npicking this:\n  progressing p", "have \"\\<And>zs. p \\<noteq> ys @ (y,z) # (z,y) # zs\""], ["proof (prove)\nusing this:\n  progressing p\n\ngoal (1 subgoal):\n 1. \\<And>zs. p \\<noteq> ys @ (y, z) # (z, y) # zs", "by (auto simp: progressing_append_iff progressing_Cons)"], ["proof (state)\nthis:\n  p \\<noteq> ys @ (y, z) # (z, y) # ?zs1\n\ngoal (1 subgoal):\n 1. p' = ys @ [(y, z), (z, y)] @ zs \\<Longrightarrow> False", "with \\<open>?A\\<close>"], ["proof (chain)\npicking this:\n  p' = ys @ [(y, z), (z, y)] @ zs\n  p \\<noteq> ys @ (y, z) # (z, y) # ?zs1", "have \"zs = []\""], ["proof (prove)\nusing this:\n  p' = ys @ [(y, z), (z, y)] @ zs\n  p \\<noteq> ys @ (y, z) # (z, y) # ?zs1\n\ngoal (1 subgoal):\n 1. zs = []", "unfolding p'_def"], ["proof (prove)\nusing this:\n  p @ [(x, x')] = ys @ [(y, z), (z, y)] @ zs\n  p \\<noteq> ys @ (y, z) # (z, y) # ?zs1\n\ngoal (1 subgoal):\n 1. zs = []", "by (cases zs rule: rev_cases) auto"], ["proof (state)\nthis:\n  zs = []\n\ngoal (1 subgoal):\n 1. p' = ys @ [(y, z), (z, y)] @ zs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  zs = []", "show False"], ["proof (prove)\nusing this:\n  zs = []\n\ngoal (1 subgoal):\n 1. False", "using \\<open>?A\\<close>"], ["proof (prove)\nusing this:\n  zs = []\n  p' = ys @ [(y, z), (z, y)] @ zs\n\ngoal (1 subgoal):\n 1. False", "using \\<open>w \\<noteq> x'\\<close> \\<open>last p = (w,x)\\<close>"], ["proof (prove)\nusing this:\n  zs = []\n  p' = ys @ [(y, z), (z, y)] @ zs\n  w \\<noteq> x'\n  last p = (w, x)\n\ngoal (1 subgoal):\n 1. False", "unfolding p'_def"], ["proof (prove)\nusing this:\n  zs = []\n  p @ [(x, x')] = ys @ [(y, z), (z, y)] @ zs\n  w \\<noteq> x'\n  last p = (w, x)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p' \\<noteq> ys @ [(y, z), (z, y)] @ zs\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "}"], ["proof (state)\nthis:\n  p' \\<noteq> ?ys3 @ [(?y3, ?z3), (?z3, ?y3)] @ ?zs3\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "then"], ["proof (chain)\npicking this:\n  p' \\<noteq> ?ys3 @ [(?y3, ?z3), (?z3, ?y3)] @ ?zs3", "have \"progressing p'\""], ["proof (prove)\nusing this:\n  p' \\<noteq> ?ys3 @ [(?y3, ?z3), (?z3, ?y3)] @ ?zs3\n\ngoal (1 subgoal):\n 1. progressing p'", "by (auto simp: progressing_def)"], ["proof (state)\nthis:\n  progressing p'\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "ultimately"], ["proof (chain)\npicking this:\n  pg.awalk u p' x'\n  length p' = Suc len\n  hd p' = (u, v)\n  last p' = (w', x')\n  set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}\n  progressing p'", "show ?thesis"], ["proof (prove)\nusing this:\n  pg.awalk u p' x'\n  length p' = Suc len\n  hd p' = (u, v)\n  last p' = (w', x')\n  set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}\n  progressing p'\n\ngoal (1 subgoal):\n 1. find_endpoint_path_inv G H (Suc len) u v w' x'", "unfolding find_endpoint_path_inv_def"], ["proof (prove)\nusing this:\n  pg.awalk u p' x'\n  length p' = Suc len\n  hd p' = (u, v)\n  last p' = (w', x')\n  set (pg.inner_verts p') \\<inter> set (ig_verts H) = {}\n  progressing p'\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       pg.awalk u p x' \\<and>\n       length p = Suc len \\<and>\n       hd p = (u, v) \\<and>\n       last p = (w', x') \\<and>\n       set (pg.inner_verts p) \\<inter> set (ig_verts H) = {} \\<and>\n       progressing p", "by blast"], ["proof (state)\nthis:\n  find_endpoint_path_inv G H (Suc len) u v w' x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_loop_path:\n  assumes \"u = v\" and ig: \"IGraph_inv G\"\n  shows \"\\<not> (\\<exists>p w. pre_digraph.iapath (mk_graph G) u ((u, v) # p) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>p w.\n       pre_digraph.gen_iapath (with_proj (mk_graph G))\n        (verts3 (with_proj (mk_graph G))) u ((u, v) # p) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>p w.\n       pre_digraph.gen_iapath (with_proj (mk_graph G))\n        (verts3 (with_proj (mk_graph G))) u ((u, v) # p) w", "interpret ppg: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using ig"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by (rule IGraph_imp_ppg_mkg)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>p w.\n       ppg.gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) w", "from \\<open>u = v\\<close>"], ["proof (chain)\npicking this:\n  u = v", "show ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. \\<nexists>p w.\n       ppg.gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) w", "by (auto simp: ppg.gen_iapath_def ppg.apath_Cons_iff)\n       (metis hd_in_set ppg.awalk_verts_non_Nil ppg.awhd_of_awalk pre_digraph.awalkI_apath)"], ["proof (state)\nthis:\n  \\<nexists>p w.\n     ppg.gen_iapath (verts3 (with_proj (mk_graph G))) u ((u, v) # p) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in find_endpoint_impl) find_endpoint_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop \\<acute>G \\<acute>H \\<and> loop_free (mk_graph \\<acute>G) \\<and> \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and> iadj \\<acute>G \\<acute>v_tail \\<acute>v_next \\<and> IGraph_inv \\<acute>G\\<rbrace>\n    \\<acute>R :== PROC find_endpoint(\\<acute>G, \\<acute>H, \\<acute>v_tail, \\<acute>v_next)\n  \\<lbrace>case \\<acute>R of None \\<Rightarrow> \\<not>(\\<exists>p w. pre_digraph.iapath (mk_graph \\<^bsup>\\<sigma>\\<^esup>G) \\<^bsup>\\<sigma>\\<^esup>v_tail ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) # p) w)\n    | Some w \\<Rightarrow> (\\<exists>p. pre_digraph.iapath (mk_graph \\<^bsup>\\<sigma>\\<^esup>G) \\<^bsup>\\<sigma>\\<^esup>v_tail ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) # p) w) \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and>\n            iadj \\<acute>G \\<acute>v_tail \\<acute>v_next \\<and>\n            IGraph_inv \\<acute>G\\<rbrace>\n                               \\<acute>R :== PROC find_endpoint(\\<acute>G,\n                               \\<acute>H,\\<acute>v_tail,\\<acute>v_next)\n                               \\<lbrace>case \\<acute>R of\n  None \\<Rightarrow>\n    \\<nexists>p w.\n       pre_digraph.gen_iapath\n        (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n        (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n        \\<^bsup>\\<sigma>\\<^esup>v_tail\n        ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) #\n         p)\n        w\n  | Some w \\<Rightarrow>\n      \\<exists>p.\n         pre_digraph.gen_iapath\n          (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n          (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n          \\<^bsup>\\<sigma>\\<^esup>v_tail\n          ((\\<^bsup>\\<sigma>\\<^esup>v_tail,\n            \\<^bsup>\\<sigma>\\<^esup>v_next) #\n           p)\n          w\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and>\n            iadj \\<acute>G \\<acute>v_tail \\<acute>v_next \\<and>\n            IGraph_inv \\<acute>G\\<rbrace>\n                               TRY IF \\<acute>v_tail = \\<acute>v_next\n                                   THEN RAISE \\<acute>R :== None FI;;\n                                   \\<acute>v0 :== \\<acute>v_tail;;\n                                   \\<acute>v1 :== \\<acute>v_next;;\n                                   \\<acute>len :== 1;;\n                                   WHILE \\<acute>v1\n   \\<notin> set (ig_verts \\<acute>H)\n                                   INV named_loop ''path'' \n                                   DO \\<acute>io_arcs :==\nig_in_out_arcs \\<acute>G \\<acute>v1;;\n\\<acute>i :== 0;; \\<acute>found :== False;;\nWHILE \\<acute>found = False \\<and> \\<acute>i < length \\<acute>io_arcs\nINV named_loop ''arcs'' \nDO \\<acute>vt :==\n   ig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>v1;;\n   IF \\<acute>vt \\<noteq> \\<acute>v0\n   THEN \\<acute>found :== True;; \\<acute>v0 :== \\<acute>v1;;\n     \\<acute>v1 :== \\<acute>vt\n   FI;;\n   \\<acute>i :== \\<acute>i + 1 \nOD;;\n\\<acute>len :== \\<acute>len + 1;;\nIF \\<not> \\<acute>found THEN RAISE \\<acute>R :== None FI \n                                   OD;;\n                                   IF \\<acute>v1 = \\<acute>v_tail\n                                   THEN RAISE \\<acute>R :== None FI;;\n                                   \\<acute>R :== Some \\<acute>v1\n                               CATCH SKIP END\n                               \\<lbrace>case \\<acute>R of\n  None \\<Rightarrow>\n    \\<nexists>p w.\n       pre_digraph.gen_iapath\n        (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n        (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n        \\<^bsup>\\<sigma>\\<^esup>v_tail\n        ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) #\n         p)\n        w\n  | Some w \\<Rightarrow>\n      \\<exists>p.\n         pre_digraph.gen_iapath\n          (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n          (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n          \\<^bsup>\\<sigma>\\<^esup>v_tail\n          ((\\<^bsup>\\<sigma>\\<^esup>v_tail,\n            \\<^bsup>\\<sigma>\\<^esup>v_next) #\n           p)\n          w\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''path'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace> find_endpoint_path_inv \\<acute>G \\<acute>H \\<acute>len \\<acute>v_tail \\<acute>v_next \\<acute>v0 \\<acute>v1\n        \\<and> \\<acute>v_tail = \\<^bsup>\\<sigma>\\<^esup>v_tail \\<and> \\<acute>v_next = \\<^bsup>\\<sigma>\\<^esup>v_next \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H\n        \\<and> 0 < \\<acute> len\n        \\<and> \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and> select_nodes_prop \\<acute>G \\<acute>H \\<and> IGraph_inv \\<acute>G \\<and> loop_free (mk_graph \\<acute>G) \\<rbrace>\n      (MEASURE Suc (ig_verts_cnt \\<acute>G) - \\<acute>len)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and>\n            iadj \\<acute>G \\<acute>v_tail \\<acute>v_next \\<and>\n            IGraph_inv \\<acute>G\\<rbrace>\n                               TRY IF \\<acute>v_tail = \\<acute>v_next\n                                   THEN RAISE \\<acute>R :== None FI;;\n                                   \\<acute>v0 :== \\<acute>v_tail;;\n                                   \\<acute>v1 :== \\<acute>v_next;;\n                                   \\<acute>len :== 1;;\n                                   WHILE \\<acute>v1\n   \\<notin> set (ig_verts \\<acute>H)\n                                   INV \\<lbrace>find_endpoint_path_inv\n           \\<acute>G \\<acute>H \\<acute>len \\<acute>v_tail \\<acute>v_next\n           \\<acute>v0 \\<acute>v1 \\<and>\n          \\<acute>v_tail = \\<^bsup>\\<sigma>\\<^esup>v_tail \\<and>\n          \\<acute>v_next = \\<^bsup>\\<sigma>\\<^esup>v_next \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n          0 < \\<acute>len \\<and>\n          \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and>\n          select_nodes_prop \\<acute>G \\<acute>H \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          loop_free (mk_graph \\<acute>G)\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      Suc (ig_verts_cnt\n            (lookup project_Check_Non_Planarity_Impl_IGraph\n              G_'find_endpoint_' (locals s))) -\n      lookup project_Nat_nat len_'find_endpoint_' (locals s)) \n                                   DO \\<acute>io_arcs :==\nig_in_out_arcs \\<acute>G \\<acute>v1;;\n\\<acute>i :== 0;; \\<acute>found :== False;;\nWHILE \\<acute>found = False \\<and> \\<acute>i < length \\<acute>io_arcs\nINV named_loop ''arcs'' \nDO \\<acute>vt :==\n   ig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>v1;;\n   IF \\<acute>vt \\<noteq> \\<acute>v0\n   THEN \\<acute>found :== True;; \\<acute>v0 :== \\<acute>v1;;\n     \\<acute>v1 :== \\<acute>vt\n   FI;;\n   \\<acute>i :== \\<acute>i + 1 \nOD;;\n\\<acute>len :== \\<acute>len + 1;;\nIF \\<not> \\<acute>found THEN RAISE \\<acute>R :== None FI \n                                   OD;;\n                                   IF \\<acute>v1 = \\<acute>v_tail\n                                   THEN RAISE \\<acute>R :== None FI;;\n                                   \\<acute>R :== Some \\<acute>v1\n                               CATCH SKIP END\n                               \\<lbrace>case \\<acute>R of\n  None \\<Rightarrow>\n    \\<nexists>p w.\n       pre_digraph.gen_iapath\n        (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n        (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n        \\<^bsup>\\<sigma>\\<^esup>v_tail\n        ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) #\n         p)\n        w\n  | Some w \\<Rightarrow>\n      \\<exists>p.\n         pre_digraph.gen_iapath\n          (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n          (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n          \\<^bsup>\\<sigma>\\<^esup>v_tail\n          ((\\<^bsup>\\<sigma>\\<^esup>v_tail,\n            \\<^bsup>\\<sigma>\\<^esup>v_next) #\n           p)\n          w\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''arcs'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnnoFix _\n      (\\<lambda>(v0,v1,len). \\<lbrace> find_endpoint_arcs_inv \\<acute>G \\<acute>found \\<acute>i v0 v1 \\<acute>v0 \\<acute>v1\n        \\<and> \\<acute>i \\<le> length (ig_in_out_arcs \\<acute>G v1) \\<and> \\<acute>io_arcs = ig_in_out_arcs \\<acute>G v1\n        \\<and> \\<acute>v_tail = \\<^bsup>\\<sigma>\\<^esup>v_tail \\<and> \\<acute>v_next = \\<^bsup>\\<sigma>\\<^esup>v_next \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>H = \\<^bsup>\\<sigma>\\<^esup> H\n        \\<and> \\<acute>len = len\n        \\<and> \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and> select_nodes_prop \\<acute>G \\<acute>H \\<and> IGraph_inv \\<acute>G \\<rbrace>)\n      (\\<lambda>_. (MEASURE length \\<acute>io_arcs - \\<acute>i))\n      _\"\n    annotate_named_loop_var_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and>\n            iadj \\<acute>G \\<acute>v_tail \\<acute>v_next \\<and>\n            IGraph_inv \\<acute>G\\<rbrace>\n                               TRY IF \\<acute>v_tail = \\<acute>v_next\n                                   THEN RAISE \\<acute>R :== None FI;;\n                                   \\<acute>v0 :== \\<acute>v_tail;;\n                                   \\<acute>v1 :== \\<acute>v_next;;\n                                   \\<acute>len :== 1;;\n                                   WHILE \\<acute>v1\n   \\<notin> set (ig_verts \\<acute>H)\n                                   INV \\<lbrace>find_endpoint_path_inv\n           \\<acute>G \\<acute>H \\<acute>len \\<acute>v_tail \\<acute>v_next\n           \\<acute>v0 \\<acute>v1 \\<and>\n          \\<acute>v_tail = \\<^bsup>\\<sigma>\\<^esup>v_tail \\<and>\n          \\<acute>v_next = \\<^bsup>\\<sigma>\\<^esup>v_next \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n          0 < \\<acute>len \\<and>\n          \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and>\n          select_nodes_prop \\<acute>G \\<acute>H \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          loop_free (mk_graph \\<acute>G)\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      Suc (ig_verts_cnt\n            (lookup project_Check_Non_Planarity_Impl_IGraph\n              G_'find_endpoint_' (locals s))) -\n      lookup project_Nat_nat len_'find_endpoint_' (locals s)) \n                                   DO \\<acute>io_arcs :==\nig_in_out_arcs \\<acute>G \\<acute>v1;;\n\\<acute>i :== 0;; \\<acute>found :== False;;\nWHILE \\<lbrace>\\<acute>found = False \\<and>\n               \\<acute>i < length \\<acute>io_arcs\\<rbrace>\nFIX (v0, v1, len).\nINV \\<lbrace>find_endpoint_arcs_inv \\<acute>G \\<acute>found \\<acute>i v0 v1\n              \\<acute>v0 \\<acute>v1 \\<and>\n             \\<acute>i \\<le> length (ig_in_out_arcs \\<acute>G v1) \\<and>\n             \\<acute>io_arcs = ig_in_out_arcs \\<acute>G v1 \\<and>\n             \\<acute>v_tail = \\<^bsup>\\<sigma>\\<^esup>v_tail \\<and>\n             \\<acute>v_next = \\<^bsup>\\<sigma>\\<^esup>v_next \\<and>\n             \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n             \\<acute>H = \\<^bsup>\\<sigma>\\<^esup>H \\<and>\n             \\<acute>len = len \\<and>\n             \\<acute>v_tail \\<in> set (ig_verts \\<acute>H) \\<and>\n             select_nodes_prop \\<acute>G \\<acute>H \\<and>\n             IGraph_inv \\<acute>G\\<rbrace>\nVAR measure\n     (\\<lambda>s.\n         length\n          (lookup project_Nat_nat_Nat_nat_Product_Type_prod_List_list\n            io_arcs_'find_endpoint_' (locals s)) -\n         lookup project_Nat_nat i_'find_endpoint_' (locals s)) \n(\\<acute>vt :==\n ig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>v1;;\n IF \\<acute>vt \\<noteq> \\<acute>v0\n THEN \\<acute>found :== True;; \\<acute>v0 :== \\<acute>v1;;\n   \\<acute>v1 :== \\<acute>vt\n FI;;\n \\<acute>i :== \\<acute>i + 1);;\n\\<acute>len :== \\<acute>len + 1;;\nIF \\<not> \\<acute>found THEN RAISE \\<acute>R :== None FI \n                                   OD;;\n                                   IF \\<acute>v1 = \\<acute>v_tail\n                                   THEN RAISE \\<acute>R :== None FI;;\n                                   \\<acute>R :== Some \\<acute>v1\n                               CATCH SKIP END\n                               \\<lbrace>case \\<acute>R of\n  None \\<Rightarrow>\n    \\<nexists>p w.\n       pre_digraph.gen_iapath\n        (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n        (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n        \\<^bsup>\\<sigma>\\<^esup>v_tail\n        ((\\<^bsup>\\<sigma>\\<^esup>v_tail, \\<^bsup>\\<sigma>\\<^esup>v_next) #\n         p)\n        w\n  | Some w \\<Rightarrow>\n      \\<exists>p.\n         pre_digraph.gen_iapath\n          (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G))\n          (verts3 (with_proj (mk_graph \\<^bsup>\\<sigma>\\<^esup>G)))\n          \\<^bsup>\\<sigma>\\<^esup>v_tail\n          ((\\<^bsup>\\<sigma>\\<^esup>v_tail,\n            \\<^bsup>\\<sigma>\\<^esup>v_next) #\n           p)\n          w\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G H v_next v_tail.\n       \\<lbrakk>select_nodes_prop G H; loop_free (mk_graph G);\n        v_tail \\<in> set (ig_verts H); iadj G v_tail v_next;\n        IGraph_inv G\\<rbrakk>\n       \\<Longrightarrow> (v_tail = v_next \\<longrightarrow>\n                          (case None of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w)) \\<and>\n                         (v_tail \\<noteq> v_next \\<longrightarrow>\n                          find_endpoint_path_inv G H 1 v_tail v_next v_tail\n                           v_next \\<and>\n                          v_tail = v_tail \\<and>\n                          v_next = v_next \\<and>\n                          G = G \\<and>\n                          H = H \\<and>\n                          0 < 1 \\<and>\n                          v_tail \\<in> set (ig_verts H) \\<and>\n                          select_nodes_prop G H \\<and>\n                          IGraph_inv G \\<and> loop_free (mk_graph G))\n 2. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v0a v1a.\n                            find_endpoint_arcs_inv Ga False 0 v0a v1a v0\n                             v1 \\<and>\n                            0 \\<le> length (ig_in_out_arcs Ga v1a) \\<and>\n                            ig_in_out_arcs Ga v1 =\n                            ig_in_out_arcs Ga v1a \\<and>\n                            v_taila = v_tail \\<and>\n                            v_nexta = v_next \\<and>\n                            Ga = G \\<and>\n                            Ha = H \\<and>\n                            v_taila \\<in> set (ig_verts Ha) \\<and>\n                            select_nodes_prop Ga Ha \\<and>\n                            IGraph_inv Ga \\<and>\n                            (\\<forall>Gaa Ha found i io_arcs lena v0 v1\n                                v_nexta v_taila.\n                                find_endpoint_arcs_inv Gaa found i v0a v1a\n                                 v0 v1 \\<and>\n                                i \\<le> length\n   (ig_in_out_arcs Gaa v1a) \\<and>\n                                io_arcs = ig_in_out_arcs Gaa v1a \\<and>\n                                v_taila = v_tail \\<and>\n                                v_nexta = v_next \\<and>\n                                Gaa = G \\<and>\n                                Ha = H \\<and>\n                                lena = len \\<and>\n                                v_taila \\<in> set (ig_verts Ha) \\<and>\n                                select_nodes_prop Gaa Ha \\<and>\n                                IGraph_inv Gaa \\<and>\n                                \\<not> (\\<not> found \\<and>\n  i < length io_arcs) \\<longrightarrow>\n                                (\\<not> found \\<longrightarrow>\n                                 (case None of\n                                  None \\<Rightarrow>\n                                    \\<nexists>p.\n Ex (pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p))\n                                  | Some w \\<Rightarrow>\n\\<exists>p.\n   pre_digraph.gen_iapath (with_proj (mk_graph G))\n    (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n    w)) \\<and>\n                                (found \\<longrightarrow>\n                                 Suc (ig_verts_cnt G) - (len + 1)\n                                 < Suc (ig_verts_cnt Ga) - len \\<and>\n                                 find_endpoint_path_inv G H (len + 1) v_tail\n                                  v_next v0 v1 \\<and>\n                                 0 < len + 1 \\<and>\n                                 v_tail \\<in> set (ig_verts H) \\<and>\n                                 select_nodes_prop G H \\<and>\n                                 IGraph_inv G \\<and>\n                                 loop_free (mk_graph G)))\n 3. \\<And>G H v_next v_tail v0 v1 Ga Ha found i io_arcs len v0a v1a v_nexta\n       v_taila.\n       \\<lbrakk>find_endpoint_arcs_inv Ga found i v0 v1 v0a v1a;\n        i \\<le> length (ig_in_out_arcs Ga v1);\n        io_arcs = ig_in_out_arcs Ga v1; v_taila = v_tail; v_nexta = v_next;\n        Ga = G; Ha = H; v_taila \\<in> set (ig_verts Ha);\n        select_nodes_prop Ga Ha; IGraph_inv Ga; found = False;\n        i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> (ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                          v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga True (i + 1) v0 v1 v1a\n                           (ig_opposite Ga (io_arcs ! i) v1a) \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and>\n                          IGraph_inv Ga) \\<and>\n                         (\\<not> ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                                 v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga found (i + 1) v0 v1 v0a\n                           v1a \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and> IGraph_inv Ga)\n 4. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        \\<not> v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> (v1 = v_taila \\<longrightarrow>\n                          (case None of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w)) \\<and>\n                         (v1 \\<noteq> v_taila \\<longrightarrow>\n                          (case Some v1 of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w))", "apply (fastforce simp: find_endpoint_path_first no_loop_path)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v0a v1a.\n                            find_endpoint_arcs_inv Ga False 0 v0a v1a v0\n                             v1 \\<and>\n                            0 \\<le> length (ig_in_out_arcs Ga v1a) \\<and>\n                            ig_in_out_arcs Ga v1 =\n                            ig_in_out_arcs Ga v1a \\<and>\n                            v_taila = v_tail \\<and>\n                            v_nexta = v_next \\<and>\n                            Ga = G \\<and>\n                            Ha = H \\<and>\n                            v_taila \\<in> set (ig_verts Ha) \\<and>\n                            select_nodes_prop Ga Ha \\<and>\n                            IGraph_inv Ga \\<and>\n                            (\\<forall>Gaa Ha found i io_arcs lena v0 v1\n                                v_nexta v_taila.\n                                find_endpoint_arcs_inv Gaa found i v0a v1a\n                                 v0 v1 \\<and>\n                                i \\<le> length\n   (ig_in_out_arcs Gaa v1a) \\<and>\n                                io_arcs = ig_in_out_arcs Gaa v1a \\<and>\n                                v_taila = v_tail \\<and>\n                                v_nexta = v_next \\<and>\n                                Gaa = G \\<and>\n                                Ha = H \\<and>\n                                lena = len \\<and>\n                                v_taila \\<in> set (ig_verts Ha) \\<and>\n                                select_nodes_prop Gaa Ha \\<and>\n                                IGraph_inv Gaa \\<and>\n                                \\<not> (\\<not> found \\<and>\n  i < length io_arcs) \\<longrightarrow>\n                                (\\<not> found \\<longrightarrow>\n                                 (case None of\n                                  None \\<Rightarrow>\n                                    \\<nexists>p.\n Ex (pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p))\n                                  | Some w \\<Rightarrow>\n\\<exists>p.\n   pre_digraph.gen_iapath (with_proj (mk_graph G))\n    (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p)\n    w)) \\<and>\n                                (found \\<longrightarrow>\n                                 Suc (ig_verts_cnt G) - (len + 1)\n                                 < Suc (ig_verts_cnt Ga) - len \\<and>\n                                 find_endpoint_path_inv G H (len + 1) v_tail\n                                  v_next v0 v1 \\<and>\n                                 0 < len + 1 \\<and>\n                                 v_tail \\<in> set (ig_verts H) \\<and>\n                                 select_nodes_prop G H \\<and>\n                                 IGraph_inv G \\<and>\n                                 loop_free (mk_graph G)))\n 2. \\<And>G H v_next v_tail v0 v1 Ga Ha found i io_arcs len v0a v1a v_nexta\n       v_taila.\n       \\<lbrakk>find_endpoint_arcs_inv Ga found i v0 v1 v0a v1a;\n        i \\<le> length (ig_in_out_arcs Ga v1);\n        io_arcs = ig_in_out_arcs Ga v1; v_taila = v_tail; v_nexta = v_next;\n        Ga = G; Ha = H; v_taila \\<in> set (ig_verts Ha);\n        select_nodes_prop Ga Ha; IGraph_inv Ga; found = False;\n        i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> (ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                          v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga True (i + 1) v0 v1 v1a\n                           (ig_opposite Ga (io_arcs ! i) v1a) \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and>\n                          IGraph_inv Ga) \\<and>\n                         (\\<not> ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                                 v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga found (i + 1) v0 v1 v0a\n                           v1a \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and> IGraph_inv Ga)\n 3. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        \\<not> v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> (v1 = v_taila \\<longrightarrow>\n                          (case None of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w)) \\<and>\n                         (v1 \\<noteq> v_taila \\<longrightarrow>\n                          (case Some v1 of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w))", "apply (match premises in \"find_endpoint_path_inv _ _ _ _ _ v0 v1\" for v0 v1\n      \\<Rightarrow> \\<open>rule exI[where x=v0], rule exI[where x=v1]\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> find_endpoint_arcs_inv Ga False 0 v0 v1 v0\n                          v1 \\<and>\n                         0 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                         ig_in_out_arcs Ga v1 = ig_in_out_arcs Ga v1 \\<and>\n                         v_taila = v_tail \\<and>\n                         v_nexta = v_next \\<and>\n                         Ga = G \\<and>\n                         Ha = H \\<and>\n                         v_taila \\<in> set (ig_verts Ha) \\<and>\n                         select_nodes_prop Ga Ha \\<and>\n                         IGraph_inv Ga \\<and>\n                         (\\<forall>Gaa Ha found i io_arcs lena v0a v1a\n                             v_nexta v_taila.\n                             find_endpoint_arcs_inv Gaa found i v0 v1 v0a\n                              v1a \\<and>\n                             i \\<le> length (ig_in_out_arcs Gaa v1) \\<and>\n                             io_arcs = ig_in_out_arcs Gaa v1 \\<and>\n                             v_taila = v_tail \\<and>\n                             v_nexta = v_next \\<and>\n                             Gaa = G \\<and>\n                             Ha = H \\<and>\n                             lena = len \\<and>\n                             v_taila \\<in> set (ig_verts Ha) \\<and>\n                             select_nodes_prop Gaa Ha \\<and>\n                             IGraph_inv Gaa \\<and>\n                             \\<not> (\\<not> found \\<and>\n                                     i < length io_arcs) \\<longrightarrow>\n                             (\\<not> found \\<longrightarrow>\n                              (case None of\n                               None \\<Rightarrow>\n                                 \\<nexists>p.\n                                    Ex (pre_digraph.gen_iapath\n   (with_proj (mk_graph G)) (verts3 (with_proj (mk_graph G))) v_tail\n   ((v_tail, v_next) # p))\n                               | Some w \\<Rightarrow>\n                                   \\<exists>p.\npre_digraph.gen_iapath (with_proj (mk_graph G))\n (verts3 (with_proj (mk_graph G))) v_tail ((v_tail, v_next) # p) w)) \\<and>\n                             (found \\<longrightarrow>\n                              Suc (ig_verts_cnt G) - (len + 1)\n                              < Suc (ig_verts_cnt Ga) - len \\<and>\n                              find_endpoint_path_inv G H (len + 1) v_tail\n                               v_next v0a v1a \\<and>\n                              0 < len + 1 \\<and>\n                              v_tail \\<in> set (ig_verts H) \\<and>\n                              select_nodes_prop G H \\<and>\n                              IGraph_inv G \\<and> loop_free (mk_graph G)))\n 2. \\<And>G H v_next v_tail v0 v1 Ga Ha found i io_arcs len v0a v1a v_nexta\n       v_taila.\n       \\<lbrakk>find_endpoint_arcs_inv Ga found i v0 v1 v0a v1a;\n        i \\<le> length (ig_in_out_arcs Ga v1);\n        io_arcs = ig_in_out_arcs Ga v1; v_taila = v_tail; v_nexta = v_next;\n        Ga = G; Ha = H; v_taila \\<in> set (ig_verts Ha);\n        select_nodes_prop Ga Ha; IGraph_inv Ga; found = False;\n        i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> (ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                          v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga True (i + 1) v0 v1 v1a\n                           (ig_opposite Ga (io_arcs ! i) v1a) \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and>\n                          IGraph_inv Ga) \\<and>\n                         (\\<not> ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                                 v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga found (i + 1) v0 v1 v0a\n                           v1a \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and> IGraph_inv Ga)\n 3. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        \\<not> v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> (v1 = v_taila \\<longrightarrow>\n                          (case None of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w)) \\<and>\n                         (v1 \\<noteq> v_taila \\<longrightarrow>\n                          (case Some v1 of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w))", "apply (fastforce simp: find_endpoint_arcs_last find_endpoint_arcs_0 find_endpoint_path_step elim: find_endpoint_path_lastE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G H v_next v_tail v0 v1 Ga Ha found i io_arcs len v0a v1a v_nexta\n       v_taila.\n       \\<lbrakk>find_endpoint_arcs_inv Ga found i v0 v1 v0a v1a;\n        i \\<le> length (ig_in_out_arcs Ga v1);\n        io_arcs = ig_in_out_arcs Ga v1; v_taila = v_tail; v_nexta = v_next;\n        Ga = G; Ha = H; v_taila \\<in> set (ig_verts Ha);\n        select_nodes_prop Ga Ha; IGraph_inv Ga; found = False;\n        i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> (ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                          v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga True (i + 1) v0 v1 v1a\n                           (ig_opposite Ga (io_arcs ! i) v1a) \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and>\n                          IGraph_inv Ga) \\<and>\n                         (\\<not> ig_opposite Ga (io_arcs ! i) v1a \\<noteq>\n                                 v0a \\<longrightarrow>\n                          length io_arcs - (i + 1)\n                          < length io_arcs - i \\<and>\n                          find_endpoint_arcs_inv Ga found (i + 1) v0 v1 v0a\n                           v1a \\<and>\n                          i + 1 \\<le> length (ig_in_out_arcs Ga v1) \\<and>\n                          io_arcs = ig_in_out_arcs Ga v1 \\<and>\n                          v_taila = v_tail \\<and>\n                          v_nexta = v_next \\<and>\n                          Ga = G \\<and>\n                          Ha = H \\<and>\n                          len = len \\<and>\n                          v_taila \\<in> set (ig_verts Ha) \\<and>\n                          select_nodes_prop Ga Ha \\<and> IGraph_inv Ga)\n 2. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        \\<not> v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> (v1 = v_taila \\<longrightarrow>\n                          (case None of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w)) \\<and>\n                         (v1 \\<noteq> v_taila \\<longrightarrow>\n                          (case Some v1 of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w))", "apply (fastforce elim: find_endpoint_arcs_step1E find_endpoint_arcs_step2E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G H v_next v_tail Ga Ha len v0 v1 v_nexta v_taila.\n       \\<lbrakk>find_endpoint_path_inv Ga Ha len v_taila v_nexta v0 v1;\n        v_taila = v_tail; v_nexta = v_next; Ga = G; Ha = H; 0 < len;\n        v_taila \\<in> set (ig_verts Ha); select_nodes_prop Ga Ha;\n        IGraph_inv Ga; loop_free (mk_graph Ga);\n        \\<not> v1 \\<notin> set (ig_verts Ha)\\<rbrakk>\n       \\<Longrightarrow> (v1 = v_taila \\<longrightarrow>\n                          (case None of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w)) \\<and>\n                         (v1 \\<noteq> v_taila \\<longrightarrow>\n                          (case Some v1 of\n                           None \\<Rightarrow>\n                             \\<nexists>p.\n                                Ex (pre_digraph.gen_iapath\n                                     (with_proj (mk_graph G))\n                                     (verts3 (with_proj (mk_graph G)))\n                                     v_tail ((v_tail, v_next) # p))\n                           | Some w \\<Rightarrow>\n                               \\<exists>p.\n                                  pre_digraph.gen_iapath\n                                   (with_proj (mk_graph G))\n                                   (verts3 (with_proj (mk_graph G))) v_tail\n                                   ((v_tail, v_next) # p) w))", "apply (fastforce dest: find_endpoint_path_last1 find_endpoint_path_last2D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Procedure @{term contract}\\<close>"], ["", "definition contract_iter_nodes_inv where\n  \"contract_iter_nodes_inv G H k \\<equiv>\n    set (ig_arcs H) = (\\<Union>i<k. {(u,v). u = (ig_verts H ! i) \\<and> (\\<exists>p. pre_digraph.iapath (mk_graph G) u p v)})\""], ["", "definition contract_iter_adj_inv :: \"IGraph \\<Rightarrow> IGraph \\<Rightarrow> IGraph \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"contract_iter_adj_inv G H0 H u l \\<equiv> (set (ig_arcs H) - ({u} \\<times> UNIV) = set (ig_arcs H0)) \\<and>\n    ig_verts H = ig_verts H0 \\<and>\n    (\\<forall>v. (u,v) \\<in> set (ig_arcs H) \\<longleftrightarrow>\n      ((\\<exists>j<l. \\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v)))\""], ["", "lemma contract_iter_adj_invE:\n  assumes \"contract_iter_adj_inv G H0 H u l\"\n  obtains \"set (ig_arcs H) - ({u} \\<times> UNIV) = set (ig_arcs H0)\" \"ig_verts H = ig_verts H0\"\n    \"\\<And>v. (u,v) \\<in> set (ig_arcs H) \\<longleftrightarrow> ((\\<exists>j<l. \\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0);\n      ig_verts H = ig_verts H0;\n      \\<And>v.\n         ((u, v) \\<in> set (ig_arcs H)) =\n         (\\<exists>j<l.\n             \\<exists>p.\n                pre_digraph.gen_iapath (with_proj (mk_graph G))\n                 (verts3 (with_proj (mk_graph G))) u\n                 ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n                 v)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  contract_iter_adj_inv G H0 H u l\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0);\n      ig_verts H = ig_verts H0;\n      \\<And>v.\n         ((u, v) \\<in> set (ig_arcs H)) =\n         (\\<exists>j<l.\n             \\<exists>p.\n                pre_digraph.gen_iapath (with_proj (mk_graph G))\n                 (verts3 (with_proj (mk_graph G))) u\n                 ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n                 v)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n  ig_verts H = ig_verts H0 \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H)) =\n      (\\<exists>j<l.\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0);\n      ig_verts H = ig_verts H0;\n      \\<And>v.\n         ((u, v) \\<in> set (ig_arcs H)) =\n         (\\<exists>j<l.\n             \\<exists>p.\n                pre_digraph.gen_iapath (with_proj (mk_graph G))\n                 (verts3 (with_proj (mk_graph G))) u\n                 ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n                 v)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma contract_iter_adj_inv_def':\n  \"contract_iter_adj_inv G H0 H u l \\<longleftrightarrow> (\n    set (ig_arcs H) - ({u} \\<times> UNIV) = set (ig_arcs H0)) \\<and> ig_verts H = ig_verts H0 \\<and>\n    (\\<forall>v. ((\\<exists>j<l. \\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v) \\<longrightarrow> (u,v) \\<in> set (ig_arcs H)) \\<and>\n      ((u,v) \\<in> set (ig_arcs H) \\<longrightarrow> ((\\<exists>j<l. \\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u l =\n    (set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n     ig_verts H = ig_verts H0 \\<and>\n     (\\<forall>v.\n         ((\\<exists>j<l.\n              \\<exists>p.\n                 pre_digraph.gen_iapath (with_proj (mk_graph G))\n                  (verts3 (with_proj (mk_graph G))) u\n                  ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n                  v) \\<longrightarrow>\n          (u, v) \\<in> set (ig_arcs H)) \\<and>\n         ((u, v) \\<in> set (ig_arcs H) \\<longrightarrow>\n          (\\<exists>j<l.\n              \\<exists>p.\n                 pre_digraph.gen_iapath (with_proj (mk_graph G))\n                  (verts3 (with_proj (mk_graph G))) u\n                  ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))))", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n     ig_verts H = ig_verts H0 \\<and>\n     (\\<forall>v.\n         ((u, v) \\<in> set (ig_arcs H)) =\n         (\\<exists>j<l.\n             \\<exists>p.\n                pre_digraph.gen_iapath (with_proj (mk_graph G))\n                 (verts3 (with_proj (mk_graph G))) u\n                 ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))) =\n    (set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n     ig_verts H = ig_verts H0 \\<and>\n     (\\<forall>v.\n         ((\\<exists>j<l.\n              \\<exists>p.\n                 pre_digraph.gen_iapath (with_proj (mk_graph G))\n                  (verts3 (with_proj (mk_graph G))) u\n                  ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n                  v) \\<longrightarrow>\n          (u, v) \\<in> set (ig_arcs H)) \\<and>\n         ((u, v) \\<in> set (ig_arcs H) \\<longrightarrow>\n          (\\<exists>j<l.\n              \\<exists>p.\n                 pre_digraph.gen_iapath (with_proj (mk_graph G))\n                  (verts3 (with_proj (mk_graph G))) u\n                  ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))))", "by metis"], ["", "lemma select_nodes_prop_add_e[simp]:\n  \"select_nodes_prop G (ig_add_e H u v) = select_nodes_prop G H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_nodes_prop G (ig_add_e H u v) = select_nodes_prop G H", "by (simp add: select_nodes_prop_def mkg_simps)"], ["", "lemma contract_iter_adj_inv_step1:\n  assumes \"pair_pseudo_graph (mk_graph G)\"\n  assumes ciai: \"contract_iter_adj_inv G H0 H u l\"\n  assumes iapath: \"pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\"\n  shows \"contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "interpret pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "fix v j"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "assume *: \"j < Suc l\" \"\\<exists>p. iapath u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\""], ["proof (state)\nthis:\n  j < Suc l\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "then"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "have \"(u, v) \\<in> set (ig_arcs (ig_add_e H u w))\""], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "proof (cases \"j < l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n 2. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "case True"], ["proof (state)\nthis:\n  j < l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n 2. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "with * ciai"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  contract_iter_adj_inv G H0 H u l\n  j < l", "show ?thesis"], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  contract_iter_adj_inv G H0 H u l\n  j < l\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "by (auto simp: contract_iter_adj_inv_def)[]"], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "case False"], ["proof (state)\nthis:\n  \\<not> j < l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "with *"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  \\<not> j < l", "have \"j = l\""], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  \\<not> j < l\n\ngoal (1 subgoal):\n 1. j = l", "by arith"], ["proof (state)\nthis:\n  j = l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "with *(2)"], ["proof (chain)\npicking this:\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  j = l", "obtain q where **: \"iapath u ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q) v\""], ["proof (prove)\nusing this:\n  \\<exists>p.\n     gen_iapath (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  j = l\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q)\n         v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q) v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "with iapath"], ["proof (chain)\npicking this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q) v", "have \"p = q\""], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q) v\n\ngoal (1 subgoal):\n 1. p = q", "using verts3_in_verts[where G=\"mk_graph G\"]"], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q) v\n  ?x \\<in> verts3 (with_proj (mk_graph G)) \\<Longrightarrow>\n  ?x \\<in> verts (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. p = q", "by (auto elim: gen_iapath_same2E[rotated 2])"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "with ** iapath"], ["proof (chain)\npicking this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q) v\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\n  p = q", "have \"v = w\""], ["proof (prove)\nusing this:\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # q) v\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\n  p = q\n\ngoal (1 subgoal):\n 1. v = w", "by (auto simp: pre_digraph.gen_iapath_def pre_digraph.apath_def elim: pre_digraph.awalk_nonempty_ends[rotated])"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "then"], ["proof (chain)\npicking this:\n  v = w", "show ?thesis"], ["proof (prove)\nusing this:\n  v = w\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs (ig_add_e H u w))", "by simp"], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < Suc l;\n   \\<exists>p.\n      gen_iapath (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j3) u) # p) ?v3\\<rbrakk>\n  \\<Longrightarrow> (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < Suc l;\n   \\<exists>p.\n      gen_iapath (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j3) u) # p) ?v3\\<rbrakk>\n  \\<Longrightarrow> (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < Suc l;\n   \\<exists>p.\n      gen_iapath (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j3) u) # p) ?v3\\<rbrakk>\n  \\<Longrightarrow> (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "assume *: \"(u,v) \\<in> set (ig_arcs (ig_add_e H u w))\""], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "have \"(\\<exists>j<Suc l. \\<exists>p. gen_iapath (verts3 (mk_graph G)) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "assume \"v = w\""], ["proof (state)\nthis:\n  v = w\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "then"], ["proof (chain)\npicking this:\n  v = w", "show ?thesis"], ["proof (prove)\nusing this:\n  v = w\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "using iapath"], ["proof (prove)\nusing this:\n  v = w\n  gen_iapath (verts3 (with_proj (mk_graph G))) u\n   ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "by auto"], ["proof (state)\nthis:\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow>\n    \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow>\n    \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "assume \"v \\<noteq> w\""], ["proof (state)\nthis:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. v \\<noteq> w \\<Longrightarrow>\n    \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "then"], ["proof (chain)\npicking this:\n  v \\<noteq> w", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "using ciai *"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n  contract_iter_adj_inv G H0 H u l\n  (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  v \\<noteq> w\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n  ig_verts H = ig_verts H0 \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H)) =\n      (\\<exists>j<l.\n          \\<exists>p.\n             gen_iapath (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n  (u, v) \\<in> set (ig_arcs (ig_add_e H u w))\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          gen_iapath (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "by (auto intro: less_SucI)"], ["proof (state)\nthis:\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "}"], ["proof (state)\nthis:\n  (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w)) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v3\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "moreover"], ["proof (state)\nthis:\n  (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w)) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v3\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "have \"set (ig_arcs (ig_add_e H u w)) - ({u} \\<times> UNIV) = set (ig_arcs H0)\"\n      \"ig_verts (ig_add_e H u w) = ig_verts H0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV =\n    set (ig_arcs H0) &&&\n    ig_verts (ig_add_e H u w) = ig_verts H0", "using ciai"], ["proof (prove)\nusing this:\n  contract_iter_adj_inv G H0 H u l\n\ngoal (1 subgoal):\n 1. set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV =\n    set (ig_arcs H0) &&&\n    ig_verts (ig_add_e H u w) = ig_verts H0", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n  ig_verts H = ig_verts H0 \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H)) =\n      (\\<exists>j<l.\n          \\<exists>p.\n             gen_iapath (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n\ngoal (1 subgoal):\n 1. set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV =\n    set (ig_arcs H0) &&&\n    ig_verts (ig_add_e H u w) = ig_verts H0", "by auto"], ["proof (state)\nthis:\n  set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts (ig_add_e H u w) = ig_verts H0\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j3 < Suc l;\n   \\<exists>p.\n      gen_iapath (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j3) u) # p) ?v3\\<rbrakk>\n  \\<Longrightarrow> (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w))\n  (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w)) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v3\n  set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts (ig_add_e H u w) = ig_verts H0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j3 < Suc l;\n   \\<exists>p.\n      gen_iapath (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j3) u) # p) ?v3\\<rbrakk>\n  \\<Longrightarrow> (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w))\n  (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w)) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v3\n  set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts (ig_add_e H u w) = ig_verts H0\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j3 < Suc l;\n   \\<exists>p.\n      gen_iapath (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j3) u) # p) ?v3\\<rbrakk>\n  \\<Longrightarrow> (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w))\n  (u, ?v3) \\<in> set (ig_arcs (ig_add_e H u w)) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        gen_iapath (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v3\n  set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts (ig_add_e H u w) = ig_verts H0\n\ngoal (1 subgoal):\n 1. set (ig_arcs (ig_add_e H u w)) - {u} \\<times> UNIV =\n    set (ig_arcs H0) \\<and>\n    ig_verts (ig_add_e H u w) = ig_verts H0 \\<and>\n    (\\<forall>v.\n        ((u, v) \\<in> set (ig_arcs (ig_add_e H u w))) =\n        (\\<exists>j<Suc l.\n            \\<exists>p.\n               gen_iapath (verts3 (with_proj (mk_graph G))) u\n                ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))", "by metis"], ["proof (state)\nthis:\n  contract_iter_adj_inv G H0 (ig_add_e H u w) u (Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contract_iter_adj_inv_step2:\n  assumes ciai: \"contract_iter_adj_inv G H0 H u l\"\n  assumes iapath: \"\\<And>p w. \\<not>pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # p) w\"\n  shows \"contract_iter_adj_inv G H0 H u (Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "fix v j"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "assume *: \"j < Suc l\" \"\\<exists>p. pre_digraph.iapath (mk_graph G) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\""], ["proof (state)\nthis:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "then"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "have \"(u, v) \\<in> set (ig_arcs H)\""], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs H)", "proof (cases \"j < l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)\n 2. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)", "case True"], ["proof (state)\nthis:\n  j < l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)\n 2. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)", "with * ciai"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  contract_iter_adj_inv G H0 H u l\n  j < l", "show ?thesis"], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  contract_iter_adj_inv G H0 H u l\n  j < l\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs H)", "by (auto simp: contract_iter_adj_inv_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs H)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)", "case False"], ["proof (state)\nthis:\n  \\<not> j < l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)", "with *"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  \\<not> j < l", "have \"j = l\""], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  \\<not> j < l\n\ngoal (1 subgoal):\n 1. j = l", "by auto"], ["proof (state)\nthis:\n  j = l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc l;\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v;\n     \\<not> j < l\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H)", "with *"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  j = l", "show ?thesis"], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  j = l\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs H)", "using iapath"], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<exists>p.\n     pre_digraph.gen_iapath (with_proj (mk_graph G))\n      (verts3 (with_proj (mk_graph G))) u\n      ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n  j = l\n  \\<not> pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) u\n          ((u, ig_opposite G (ig_in_out_arcs G u ! l) u) # ?p) ?w\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs H)", "by metis"], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs H)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs H)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < Suc l;\n   \\<exists>p.\n      pre_digraph.gen_iapath (with_proj (mk_graph G))\n       (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j2) u) # p) ?v2\\<rbrakk>\n  \\<Longrightarrow> (u, ?v2) \\<in> set (ig_arcs H)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < Suc l;\n   \\<exists>p.\n      pre_digraph.gen_iapath (with_proj (mk_graph G))\n       (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j2) u) # p) ?v2\\<rbrakk>\n  \\<Longrightarrow> (u, ?v2) \\<in> set (ig_arcs H)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < Suc l;\n   \\<exists>p.\n      pre_digraph.gen_iapath (with_proj (mk_graph G))\n       (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j2) u) # p) ?v2\\<rbrakk>\n  \\<Longrightarrow> (u, ?v2) \\<in> set (ig_arcs H)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "assume *: \"(u,v) \\<in> set (ig_arcs H)\""], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs H)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> set (ig_arcs H)", "have \"(\\<exists>j<Suc l. \\<exists>p. pre_digraph.gen_iapath (mk_graph G) (verts3 (mk_graph G)) u ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> set (ig_arcs H)\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          pre_digraph.gen_iapath (with_proj (mk_graph G))\n           (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "using ciai"], ["proof (prove)\nusing this:\n  (u, v) \\<in> set (ig_arcs H)\n  contract_iter_adj_inv G H0 H u l\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          pre_digraph.gen_iapath (with_proj (mk_graph G))\n           (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> set (ig_arcs H)\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n  ig_verts H = ig_verts H0 \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H)) =\n      (\\<exists>j<l.\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n\ngoal (1 subgoal):\n 1. \\<exists>j<Suc l.\n       \\<exists>p.\n          pre_digraph.gen_iapath (with_proj (mk_graph G))\n           (verts3 (with_proj (mk_graph G))) u\n           ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v", "by (auto intro: less_SucI)"], ["proof (state)\nthis:\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "}"], ["proof (state)\nthis:\n  (u, ?v2) \\<in> set (ig_arcs H) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v2\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "moreover"], ["proof (state)\nthis:\n  (u, ?v2) \\<in> set (ig_arcs H) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v2\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "have \"set (ig_arcs H) - ({u} \\<times> UNIV) = set (ig_arcs H0)\" \"ig_verts H = ig_verts H0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) &&&\n    ig_verts H = ig_verts H0", "using ciai"], ["proof (prove)\nusing this:\n  contract_iter_adj_inv G H0 H u l\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) &&&\n    ig_verts H = ig_verts H0", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n  ig_verts H = ig_verts H0 \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H)) =\n      (\\<exists>j<l.\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) &&&\n    ig_verts H = ig_verts H0", "by (auto simp:)"], ["proof (state)\nthis:\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts H = ig_verts H0\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?j2 < Suc l;\n   \\<exists>p.\n      pre_digraph.gen_iapath (with_proj (mk_graph G))\n       (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j2) u) # p) ?v2\\<rbrakk>\n  \\<Longrightarrow> (u, ?v2) \\<in> set (ig_arcs H)\n  (u, ?v2) \\<in> set (ig_arcs H) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v2\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts H = ig_verts H0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j2 < Suc l;\n   \\<exists>p.\n      pre_digraph.gen_iapath (with_proj (mk_graph G))\n       (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j2) u) # p) ?v2\\<rbrakk>\n  \\<Longrightarrow> (u, ?v2) \\<in> set (ig_arcs H)\n  (u, ?v2) \\<in> set (ig_arcs H) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v2\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts H = ig_verts H0\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H0 H u (Suc l)", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j2 < Suc l;\n   \\<exists>p.\n      pre_digraph.gen_iapath (with_proj (mk_graph G))\n       (verts3 (with_proj (mk_graph G))) u\n       ((u, ig_opposite G (ig_in_out_arcs G u ! ?j2) u) # p) ?v2\\<rbrakk>\n  \\<Longrightarrow> (u, ?v2) \\<in> set (ig_arcs H)\n  (u, ?v2) \\<in> set (ig_arcs H) \\<Longrightarrow>\n  \\<exists>j<Suc l.\n     \\<exists>p.\n        pre_digraph.gen_iapath (with_proj (mk_graph G))\n         (verts3 (with_proj (mk_graph G))) u\n         ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) ?v2\n  set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0)\n  ig_verts H = ig_verts H0\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) - {u} \\<times> UNIV = set (ig_arcs H0) \\<and>\n    ig_verts H = ig_verts H0 \\<and>\n    (\\<forall>v.\n        ((u, v) \\<in> set (ig_arcs H)) =\n        (\\<exists>j<Suc l.\n            \\<exists>p.\n               pre_digraph.gen_iapath (with_proj (mk_graph G))\n                (verts3 (with_proj (mk_graph G))) u\n                ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))", "by metis"], ["proof (state)\nthis:\n  contract_iter_adj_inv G H0 H u (Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition contract_iter_adj_prop where\n  \"contract_iter_adj_prop G H0 H u \\<equiv> ig_verts H = ig_verts H0\n    \\<and> set (ig_arcs H) = set (ig_arcs H0) \\<union> ({u} \\<times> {v. \\<exists>p. pre_digraph.iapath (mk_graph G) u p v})\""], ["", "lemma contract_iter_adj_propI:\n  assumes nodes: \"contract_iter_nodes_inv G H i\"\n  assumes ciai: \"contract_iter_adj_inv G H H' u (length (ig_in_out_arcs G u))\"\n  assumes u: \"u = ig_verts H ! i\"\n  shows \"contract_iter_adj_prop G H H' u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "have \"ig_verts H' = ig_verts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_verts H' = ig_verts H", "using ciai"], ["proof (prove)\nusing this:\n  contract_iter_adj_inv G H H' u (length (ig_in_out_arcs G u))\n\ngoal (1 subgoal):\n 1. ig_verts H' = ig_verts H", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H) \\<and>\n  ig_verts H' = ig_verts H \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H')) =\n      (\\<exists>j<length (ig_in_out_arcs G u).\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n\ngoal (1 subgoal):\n 1. ig_verts H' = ig_verts H", "by auto"], ["proof (state)\nthis:\n  ig_verts H' = ig_verts H\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "moreover"], ["proof (state)\nthis:\n  ig_verts H' = ig_verts H\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "have \"set (ig_arcs H') \\<subseteq> set (ig_arcs H) \\<union>({u} \\<times> {v. \\<exists>p. pre_digraph.iapath (mk_graph G) u p v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ig_arcs H')\n    \\<subseteq> set (ig_arcs H) \\<union>\n                {u} \\<times>\n                {v. \\<exists>p.\n                       pre_digraph.gen_iapath (with_proj (mk_graph G))\n                        (verts3 (with_proj (mk_graph G))) u p v}", "using ciai"], ["proof (prove)\nusing this:\n  contract_iter_adj_inv G H H' u (length (ig_in_out_arcs G u))\n\ngoal (1 subgoal):\n 1. set (ig_arcs H')\n    \\<subseteq> set (ig_arcs H) \\<union>\n                {u} \\<times>\n                {v. \\<exists>p.\n                       pre_digraph.gen_iapath (with_proj (mk_graph G))\n                        (verts3 (with_proj (mk_graph G))) u p v}", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H) \\<and>\n  ig_verts H' = ig_verts H \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H')) =\n      (\\<exists>j<length (ig_in_out_arcs G u).\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n\ngoal (1 subgoal):\n 1. set (ig_arcs H')\n    \\<subseteq> set (ig_arcs H) \\<union>\n                {u} \\<times>\n                {v. \\<exists>p.\n                       pre_digraph.gen_iapath (with_proj (mk_graph G))\n                        (verts3 (with_proj (mk_graph G))) u p v}", "by auto"], ["proof (state)\nthis:\n  set (ig_arcs H')\n  \\<subseteq> set (ig_arcs H) \\<union>\n              {u} \\<times>\n              {v. \\<exists>p.\n                     pre_digraph.gen_iapath (with_proj (mk_graph G))\n                      (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "moreover"], ["proof (state)\nthis:\n  set (ig_arcs H')\n  \\<subseteq> set (ig_arcs H) \\<union>\n              {u} \\<times>\n              {v. \\<exists>p.\n                     pre_digraph.gen_iapath (with_proj (mk_graph G))\n                      (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "{"], ["proof (state)\nthis:\n  set (ig_arcs H')\n  \\<subseteq> set (ig_arcs H) \\<union>\n              {u} \\<times>\n              {v. \\<exists>p.\n                     pre_digraph.gen_iapath (with_proj (mk_graph G))\n                      (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "fix v p"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "assume path: \"pre_digraph.iapath (mk_graph G) u p v\""], ["proof (state)\nthis:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u p v\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "then"], ["proof (chain)\npicking this:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u p v", "obtain e es where \"p = e # es\""], ["proof (prove)\nusing this:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u p v\n\ngoal (1 subgoal):\n 1. (\\<And>e es. p = e # es \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) (auto simp: pre_digraph.gen_iapath_def)"], ["proof (state)\nthis:\n  p = e # es\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "then"], ["proof (chain)\npicking this:\n  p = e # es", "have \"e \\<in> parcs (mk_graph G)\""], ["proof (prove)\nusing this:\n  p = e # es\n\ngoal (1 subgoal):\n 1. e \\<in> parcs (mk_graph G)", "using path"], ["proof (prove)\nusing this:\n  p = e # es\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u p v\n\ngoal (1 subgoal):\n 1. e \\<in> parcs (mk_graph G)", "by (auto simp: pre_digraph.gen_iapath_def pre_digraph.apath_def pre_digraph.awalk_def)"], ["proof (state)\nthis:\n  e \\<in> parcs (mk_graph G)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "moreover"], ["proof (state)\nthis:\n  e \\<in> parcs (mk_graph G)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "then"], ["proof (chain)\npicking this:\n  e \\<in> parcs (mk_graph G)", "obtain w where \"e = (u,w)\""], ["proof (prove)\nusing this:\n  e \\<in> parcs (mk_graph G)\n\ngoal (1 subgoal):\n 1. (\\<And>w. e = (u, w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>p = e # es\\<close> path"], ["proof (prove)\nusing this:\n  e \\<in> parcs (mk_graph G)\n  p = e # es\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u p v\n\ngoal (1 subgoal):\n 1. (\\<And>w. e = (u, w) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases e) (auto simp: pre_digraph.gen_iapath_def pre_digraph.apath_def pre_digraph.awalk_def pre_digraph.cas.simps)"], ["proof (state)\nthis:\n  e = (u, w)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "ultimately"], ["proof (chain)\npicking this:\n  e \\<in> parcs (mk_graph G)\n  e = (u, w)", "have \"(u,w) \\<in> set (ig_arcs G) \\<or> (w,u) \\<in> set (ig_arcs G)\""], ["proof (prove)\nusing this:\n  e \\<in> parcs (mk_graph G)\n  e = (u, w)\n\ngoal (1 subgoal):\n 1. (u, w) \\<in> set (ig_arcs G) \\<or> (w, u) \\<in> set (ig_arcs G)", "unfolding mk_graph_def"], ["proof (prove)\nusing this:\n  e \\<in> parcs (mk_symmetric (with_proj (mk_graph' G)))\n  e = (u, w)\n\ngoal (1 subgoal):\n 1. (u, w) \\<in> set (ig_arcs G) \\<or> (w, u) \\<in> set (ig_arcs G)", "by (auto simp: parcs_mk_symmetric mkg'_simps)"], ["proof (state)\nthis:\n  (u, w) \\<in> set (ig_arcs G) \\<or> (w, u) \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "then"], ["proof (chain)\npicking this:\n  (u, w) \\<in> set (ig_arcs G) \\<or> (w, u) \\<in> set (ig_arcs G)", "obtain e' where H1: \"e' = (u,w) \\<or> e' = (w,u)\" and \"e' \\<in> set (ig_arcs G)\""], ["proof (prove)\nusing this:\n  (u, w) \\<in> set (ig_arcs G) \\<or> (w, u) \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' = (u, w) \\<or> e' = (w, u);\n         e' \\<in> set (ig_arcs G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e' = (u, w) \\<or> e' = (w, u)\n  e' \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "then"], ["proof (chain)\npicking this:\n  e' = (u, w) \\<or> e' = (w, u)\n  e' \\<in> set (ig_arcs G)", "have \"e' \\<in>  set (ig_in_out_arcs G u)\""], ["proof (prove)\nusing this:\n  e' = (u, w) \\<or> e' = (w, u)\n  e' \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. e' \\<in> set (ig_in_out_arcs G u)", "unfolding ig_in_out_arcs_def"], ["proof (prove)\nusing this:\n  e' = (u, w) \\<or> e' = (w, u)\n  e' \\<in> set (ig_arcs G)\n\ngoal (1 subgoal):\n 1. e' \\<in> set (filter (\\<lambda>e. fst e = u \\<or> snd e = u)\n                   (ig_arcs G))", "by auto"], ["proof (state)\nthis:\n  e' \\<in> set (ig_in_out_arcs G u)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "then"], ["proof (chain)\npicking this:\n  e' \\<in> set (ig_in_out_arcs G u)", "obtain k where H2: \"ig_in_out_arcs G u ! k = e'\" \"k < length (ig_in_out_arcs G u)\""], ["proof (prove)\nusing this:\n  e' \\<in> set (ig_in_out_arcs G u)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>ig_in_out_arcs G u ! k = e';\n         k < length (ig_in_out_arcs G u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  ig_in_out_arcs G u ! k = e'\n  k < length (ig_in_out_arcs G u)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "have opp_e': \"ig_opposite G e' u = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_opposite G e' u = w", "using H1"], ["proof (prove)\nusing this:\n  e' = (u, w) \\<or> e' = (w, u)\n\ngoal (1 subgoal):\n 1. ig_opposite G e' u = w", "unfolding ig_opposite_def"], ["proof (prove)\nusing this:\n  e' = (u, w) \\<or> e' = (w, u)\n\ngoal (1 subgoal):\n 1. (if fst e' = u then snd e' else fst e') = w", "by auto"], ["proof (state)\nthis:\n  ig_opposite G e' u = w\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "have \"(u,v) \\<in> set (ig_arcs H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs H')", "using ciai"], ["proof (prove)\nusing this:\n  contract_iter_adj_inv G H H' u (length (ig_in_out_arcs G u))\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs H')", "unfolding contract_iter_adj_inv_def'"], ["proof (prove)\nusing this:\n  set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H) \\<and>\n  ig_verts H' = ig_verts H \\<and>\n  (\\<forall>v.\n      ((\\<exists>j<length (ig_in_out_arcs G u).\n           \\<exists>p.\n              pre_digraph.gen_iapath (with_proj (mk_graph G))\n               (verts3 (with_proj (mk_graph G))) u\n               ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n               v) \\<longrightarrow>\n       (u, v) \\<in> set (ig_arcs H')) \\<and>\n      ((u, v) \\<in> set (ig_arcs H') \\<longrightarrow>\n       (\\<exists>j<length (ig_in_out_arcs G u).\n           \\<exists>p.\n              pre_digraph.gen_iapath (with_proj (mk_graph G))\n               (verts3 (with_proj (mk_graph G))) u\n               ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v)))\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> set (ig_arcs H')", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H);\n     ig_verts H' = ig_verts H;\n     \\<forall>v.\n        ((\\<exists>j<length (ig_in_out_arcs G u).\n             \\<exists>p.\n                pre_digraph.gen_iapath (with_proj (mk_graph G))\n                 (verts3 (with_proj (mk_graph G))) u\n                 ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n                 v) \\<longrightarrow>\n         (u, v) \\<in> set (ig_arcs H')) \\<and>\n        ((u, v) \\<in> set (ig_arcs H') \\<longrightarrow>\n         (\\<exists>j<length (ig_in_out_arcs G u).\n             \\<exists>p.\n                pre_digraph.gen_iapath (with_proj (mk_graph G))\n                 (verts3 (with_proj (mk_graph G))) u\n                 ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n                 v))\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H')", "apply (erule allE[where x=v])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H);\n     ig_verts H' = ig_verts H;\n     ((\\<exists>j<length (ig_in_out_arcs G u).\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n              v) \\<longrightarrow>\n      (u, v) \\<in> set (ig_arcs H')) \\<and>\n     ((u, v) \\<in> set (ig_arcs H') \\<longrightarrow>\n      (\\<exists>j<length (ig_in_out_arcs G u).\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p)\n              v))\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H')", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H);\n     ig_verts H' = ig_verts H;\n     \\<not> (\\<exists>j<length (ig_in_out_arcs G u).\n                \\<exists>p.\n                   pre_digraph.gen_iapath (with_proj (mk_graph G))\n                    (verts3 (with_proj (mk_graph G))) u\n                    ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v);\n     (u, v) \\<notin> set (ig_arcs H')\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> set (ig_arcs H')", "apply (erule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H);\n     ig_verts H' = ig_verts H; (u, v) \\<notin> set (ig_arcs H')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>j<length (ig_in_out_arcs G u).\n                         \\<exists>p.\n                            pre_digraph.gen_iapath (with_proj (mk_graph G))\n                             (verts3 (with_proj (mk_graph G))) u\n                             ((u, ig_opposite G (ig_in_out_arcs G u ! j)\n                                   u) #\n                              p)\n                             v", "apply (rule exI[where x=k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H);\n     ig_verts H' = ig_verts H; (u, v) \\<notin> set (ig_arcs H')\\<rbrakk>\n    \\<Longrightarrow> k < length (ig_in_out_arcs G u) \\<and>\n                      (\\<exists>p.\n                          pre_digraph.gen_iapath (with_proj (mk_graph G))\n                           (verts3 (with_proj (mk_graph G))) u\n                           ((u, ig_opposite G (ig_in_out_arcs G u ! k) u) #\n                            p)\n                           v)", "apply (simp add: H2 opp_e')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H);\n     ig_verts H' = ig_verts H; (u, v) \\<notin> set (ig_arcs H')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         pre_digraph.gen_iapath (with_proj (mk_graph G))\n                          (verts3 (with_proj (mk_graph G))) u ((u, w) # p) v", "using path \\<open>e = (u,w)\\<close> \\<open>p = e # es\\<close>"], ["proof (prove)\nusing this:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u p v\n  e = (u, w)\n  p = e # es\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H);\n     ig_verts H' = ig_verts H; (u, v) \\<notin> set (ig_arcs H')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p.\n                         pre_digraph.gen_iapath (with_proj (mk_graph G))\n                          (verts3 (with_proj (mk_graph G))) u ((u, w) # p) v", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> set (ig_arcs H')\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "}"], ["proof (state)\nthis:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u ?p2 ?v2 \\<Longrightarrow>\n  (u, ?v2) \\<in> set (ig_arcs H')\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "then"], ["proof (chain)\npicking this:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u ?p2 ?v2 \\<Longrightarrow>\n  (u, ?v2) \\<in> set (ig_arcs H')", "have \"set (ig_arcs H) \\<union>({u} \\<times> {v. \\<exists>p. pre_digraph.iapath (mk_graph G) u p v}) \\<subseteq> set (ig_arcs H')\""], ["proof (prove)\nusing this:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u ?p2 ?v2 \\<Longrightarrow>\n  (u, ?v2) \\<in> set (ig_arcs H')\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) \\<union>\n    {u} \\<times>\n    {v. \\<exists>p.\n           pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) u p v}\n    \\<subseteq> set (ig_arcs H')", "using ciai"], ["proof (prove)\nusing this:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u ?p2 ?v2 \\<Longrightarrow>\n  (u, ?v2) \\<in> set (ig_arcs H')\n  contract_iter_adj_inv G H H' u (length (ig_in_out_arcs G u))\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) \\<union>\n    {u} \\<times>\n    {v. \\<exists>p.\n           pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) u p v}\n    \\<subseteq> set (ig_arcs H')", "unfolding contract_iter_adj_inv_def"], ["proof (prove)\nusing this:\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u ?p2 ?v2 \\<Longrightarrow>\n  (u, ?v2) \\<in> set (ig_arcs H')\n  set (ig_arcs H') - {u} \\<times> UNIV = set (ig_arcs H) \\<and>\n  ig_verts H' = ig_verts H \\<and>\n  (\\<forall>v.\n      ((u, v) \\<in> set (ig_arcs H')) =\n      (\\<exists>j<length (ig_in_out_arcs G u).\n          \\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u\n              ((u, ig_opposite G (ig_in_out_arcs G u ! j) u) # p) v))\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) \\<union>\n    {u} \\<times>\n    {v. \\<exists>p.\n           pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) u p v}\n    \\<subseteq> set (ig_arcs H')", "by auto"], ["proof (state)\nthis:\n  set (ig_arcs H) \\<union>\n  {u} \\<times>\n  {v. \\<exists>p.\n         pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) u p v}\n  \\<subseteq> set (ig_arcs H')\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "ultimately"], ["proof (chain)\npicking this:\n  ig_verts H' = ig_verts H\n  set (ig_arcs H')\n  \\<subseteq> set (ig_arcs H) \\<union>\n              {u} \\<times>\n              {v. \\<exists>p.\n                     pre_digraph.gen_iapath (with_proj (mk_graph G))\n                      (verts3 (with_proj (mk_graph G))) u p v}\n  set (ig_arcs H) \\<union>\n  {u} \\<times>\n  {v. \\<exists>p.\n         pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) u p v}\n  \\<subseteq> set (ig_arcs H')", "show ?thesis"], ["proof (prove)\nusing this:\n  ig_verts H' = ig_verts H\n  set (ig_arcs H')\n  \\<subseteq> set (ig_arcs H) \\<union>\n              {u} \\<times>\n              {v. \\<exists>p.\n                     pre_digraph.gen_iapath (with_proj (mk_graph G))\n                      (verts3 (with_proj (mk_graph G))) u p v}\n  set (ig_arcs H) \\<union>\n  {u} \\<times>\n  {v. \\<exists>p.\n         pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) u p v}\n  \\<subseteq> set (ig_arcs H')\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' u", "unfolding contract_iter_adj_prop_def"], ["proof (prove)\nusing this:\n  ig_verts H' = ig_verts H\n  set (ig_arcs H')\n  \\<subseteq> set (ig_arcs H) \\<union>\n              {u} \\<times>\n              {v. \\<exists>p.\n                     pre_digraph.gen_iapath (with_proj (mk_graph G))\n                      (verts3 (with_proj (mk_graph G))) u p v}\n  set (ig_arcs H) \\<union>\n  {u} \\<times>\n  {v. \\<exists>p.\n         pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) u p v}\n  \\<subseteq> set (ig_arcs H')\n\ngoal (1 subgoal):\n 1. ig_verts H' = ig_verts H \\<and>\n    set (ig_arcs H') =\n    set (ig_arcs H) \\<union>\n    {u} \\<times>\n    {v. \\<exists>p.\n           pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) u p v}", "by blast"], ["proof (state)\nthis:\n  contract_iter_adj_prop G H H' u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contract_iter_nodes_inv_step:\n  assumes nodes: \"contract_iter_nodes_inv G H i\"\n  assumes adj: \"contract_iter_adj_inv G H H' (ig_verts H ! i) (length (ig_in_out_arcs G (ig_verts H ! i)))\"\n  assumes snp: \"select_nodes_prop G H\"\n  shows \"contract_iter_nodes_inv G H' (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H' (Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H' (Suc i)", "have ciap: \"contract_iter_adj_prop G H H' (ig_verts H ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' (ig_verts H ! i)", "using nodes adj"], ["proof (prove)\nusing this:\n  contract_iter_nodes_inv G H i\n  contract_iter_adj_inv G H H' (ig_verts H ! i)\n   (length (ig_in_out_arcs G (ig_verts H ! i)))\n\ngoal (1 subgoal):\n 1. contract_iter_adj_prop G H H' (ig_verts H ! i)", "by (rule contract_iter_adj_propI) simp"], ["proof (state)\nthis:\n  contract_iter_adj_prop G H H' (ig_verts H ! i)\n\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H' (Suc i)", "then"], ["proof (chain)\npicking this:\n  contract_iter_adj_prop G H H' (ig_verts H ! i)", "have ie_H': \"set (ig_arcs H') = set (ig_arcs H) \\<union> {(u,v). u = ig_verts H' ! i \\<and> (\\<exists>p. pre_digraph.gen_iapath (mk_graph G) (verts3 (mk_graph G)) u p v)}\"\n      and [simp]: \"ig_verts H' = ig_verts H\""], ["proof (prove)\nusing this:\n  contract_iter_adj_prop G H H' (ig_verts H ! i)\n\ngoal (1 subgoal):\n 1. set (ig_arcs H') =\n    set (ig_arcs H) \\<union>\n    {(u, v).\n     u = ig_verts H' ! i \\<and>\n     (\\<exists>p.\n         pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) u p v)} &&&\n    ig_verts H' = ig_verts H", "unfolding contract_iter_adj_prop_def"], ["proof (prove)\nusing this:\n  ig_verts H' = ig_verts H \\<and>\n  set (ig_arcs H') =\n  set (ig_arcs H) \\<union>\n  {ig_verts H ! i} \\<times>\n  {v. \\<exists>p.\n         pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) (ig_verts H ! i) p v}\n\ngoal (1 subgoal):\n 1. set (ig_arcs H') =\n    set (ig_arcs H) \\<union>\n    {(u, v).\n     u = ig_verts H' ! i \\<and>\n     (\\<exists>p.\n         pre_digraph.gen_iapath (with_proj (mk_graph G))\n          (verts3 (with_proj (mk_graph G))) u p v)} &&&\n    ig_verts H' = ig_verts H", "by auto"], ["proof (state)\nthis:\n  set (ig_arcs H') =\n  set (ig_arcs H) \\<union>\n  {(u, v).\n   u = ig_verts H' ! i \\<and>\n   (\\<exists>p.\n       pre_digraph.gen_iapath (with_proj (mk_graph G))\n        (verts3 (with_proj (mk_graph G))) u p v)}\n  ig_verts H' = ig_verts H\n\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H' (Suc i)", "have ie_H: \"set (ig_arcs H) = (\\<Union> j<i. {(u, v). u = ig_verts H' ! j \\<and> (\\<exists>p. pre_digraph.gen_iapath (mk_graph G) (verts3 (mk_graph G)) u p v)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    (\\<Union>j<i.\n        {(u, v).\n         u = ig_verts H' ! j \\<and>\n         (\\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u p v)})", "using nodes"], ["proof (prove)\nusing this:\n  contract_iter_nodes_inv G H i\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    (\\<Union>j<i.\n        {(u, v).\n         u = ig_verts H' ! j \\<and>\n         (\\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u p v)})", "unfolding contract_iter_nodes_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  (\\<Union>i<i.\n      {(u, v).\n       u = ig_verts H ! i \\<and>\n       (\\<exists>p.\n           pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) u p v)})\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    (\\<Union>j<i.\n        {(u, v).\n         u = ig_verts H' ! j \\<and>\n         (\\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u p v)})", "by simp"], ["proof (state)\nthis:\n  set (ig_arcs H) =\n  (\\<Union>j<i.\n      {(u, v).\n       u = ig_verts H' ! j \\<and>\n       (\\<exists>p.\n           pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) u p v)})\n\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H' (Suc i)", "have *: \"\\<And>S k. (\\<Union>i < Suc k. S i) = (\\<Union>i < k. S i) \\<union> S k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S k.\n       \\<Union> (S ` {..<Suc k}) = \\<Union> (S ` {..<k}) \\<union> S k", "by (metis UN_insert lessThan_Suc sup_commute)"], ["proof (state)\nthis:\n  \\<Union> (?S ` {..<Suc ?k}) = \\<Union> (?S ` {..<?k}) \\<union> ?S ?k\n\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H' (Suc i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H' (Suc i)", "by (simp only: contract_iter_nodes_inv_def ie_H ie_H' *)"], ["proof (state)\nthis:\n  contract_iter_nodes_inv G H' (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma contract_iter_nodes_0:\n  assumes \"set (ig_arcs H) = {}\" shows \"contract_iter_nodes_inv G H 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H 0", "using assms"], ["proof (prove)\nusing this:\n  set (ig_arcs H) = {}\n\ngoal (1 subgoal):\n 1. contract_iter_nodes_inv G H 0", "unfolding contract_iter_nodes_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H) = {}\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    (\\<Union>i<0.\n        {(u, v).\n         u = ig_verts H ! i \\<and>\n         (\\<exists>p.\n             pre_digraph.gen_iapath (with_proj (mk_graph G))\n              (verts3 (with_proj (mk_graph G))) u p v)})", "by simp"], ["", "lemma contract_iter_adj_0:\n  assumes nodes: \"contract_iter_nodes_inv G H i\"\n  assumes i: \"i < ig_verts_cnt H\"\n  shows \"contract_iter_adj_inv G H H (ig_verts H ! i) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H H (ig_verts H ! i) 0", "using assms distinct_ig_verts"], ["proof (prove)\nusing this:\n  contract_iter_nodes_inv G H i\n  i < ig_verts_cnt H\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. contract_iter_adj_inv G H H (ig_verts H ! i) 0", "unfolding contract_iter_adj_inv_def contract_iter_nodes_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  (\\<Union>i<i.\n      {(u, v).\n       u = ig_verts H ! i \\<and>\n       (\\<exists>p.\n           pre_digraph.gen_iapath (with_proj (mk_graph G))\n            (verts3 (with_proj (mk_graph G))) u p v)})\n  i < ig_verts_cnt H\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) - {ig_verts H ! i} \\<times> UNIV =\n    set (ig_arcs H) \\<and>\n    ig_verts H = ig_verts H \\<and>\n    (\\<forall>v.\n        ((ig_verts H ! i, v) \\<in> set (ig_arcs H)) =\n        (\\<exists>j<0.\n            \\<exists>p.\n               pre_digraph.gen_iapath (with_proj (mk_graph G))\n                (verts3 (with_proj (mk_graph G))) (ig_verts H ! i)\n                ((ig_verts H ! i,\n                  ig_opposite G (ig_in_out_arcs G (ig_verts H ! i) ! j)\n                   (ig_verts H ! i)) #\n                 p)\n                v))", "by (auto simp: distinct_conv_nth)"], ["", "lemma snp_vertexes:\n  assumes \"select_nodes_prop G H\" \"u \\<in> set (ig_verts H)\" shows \"u \\<in> set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G)", "using assms"], ["proof (prove)\nusing this:\n  select_nodes_prop G H\n  u \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G)", "unfolding select_nodes_prop_def"], ["proof (prove)\nusing this:\n  pverts (mk_graph H) = verts3 (with_proj (mk_graph G))\n  u \\<in> set (ig_verts H)\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G)", "by (auto simp: verts3_def mkg_simps)"], ["", "lemma igraph_ig_add_eI:\n  assumes \"IGraph_inv G\"\n  assumes \"u \\<in> set (ig_verts G)\" \"v \\<in> set (ig_verts G)\"\n  shows \"IGraph_inv (ig_add_e G u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IGraph_inv (ig_add_e G u v)", "using assms"], ["proof (prove)\nusing this:\n  IGraph_inv G\n  u \\<in> set (ig_verts G)\n  v \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. IGraph_inv (ig_add_e G u v)", "unfolding IGraph_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (ig_arcs G).\n     fst e \\<in> set (ig_verts G) \\<and> snd e \\<in> set (ig_verts G)\n  u \\<in> set (ig_verts G)\n  v \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set (ig_arcs (ig_add_e G u v)).\n       fst e \\<in> set (ig_verts (ig_add_e G u v)) \\<and>\n       snd e \\<in> set (ig_verts (ig_add_e G u v))", "by auto"], ["", "lemma snp_iapath_ends_in:\n  assumes \"select_nodes_prop G H\"\n  assumes \"pre_digraph.iapath (mk_graph G) u p v\"\n  shows \"u \\<in> set (ig_verts H)\" \"v \\<in> set (ig_verts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts H) &&& v \\<in> set (ig_verts H)", "using assms"], ["proof (prove)\nusing this:\n  select_nodes_prop G H\n  pre_digraph.gen_iapath (with_proj (mk_graph G))\n   (verts3 (with_proj (mk_graph G))) u p v\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts H) &&& v \\<in> set (ig_verts H)", "unfolding pre_digraph.gen_iapath_def select_nodes_prop_def verts3_def"], ["proof (prove)\nusing this:\n  pverts (mk_graph H) =\n  {v \\<in> verts (with_proj (mk_graph G)).\n   2 < in_degree (with_proj (mk_graph G)) v}\n  u \\<in> {v \\<in> verts (with_proj (mk_graph G)).\n           2 < in_degree (with_proj (mk_graph G)) v} \\<and>\n  v \\<in> {v \\<in> verts (with_proj (mk_graph G)).\n           2 < in_degree (with_proj (mk_graph G)) v} \\<and>\n  pre_digraph.apath (with_proj (mk_graph G)) u p v \\<and>\n  set (pre_digraph.inner_verts (with_proj (mk_graph G)) p) \\<inter>\n  {v \\<in> verts (with_proj (mk_graph G)).\n   2 < in_degree (with_proj (mk_graph G)) v} =\n  {} \\<and>\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts H) &&& v \\<in> set (ig_verts H)", "by (auto simp: mkg_simps)"], ["", "lemma contract_iter_nodes_last:\n  assumes nodes: \"contract_iter_nodes_inv G H (ig_verts_cnt H)\"\n  assumes snp: \"select_nodes_prop G H\"\n  assumes igraph: \"IGraph_inv G\"\n  shows \"mk_graph' H = contr_graph (mk_graph G)\" (is ?t1)\n    and \"symmetric (mk_graph' H)\" (is ?t2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G))) &&&\n    symmetric (with_proj (mk_graph' H))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "interpret ppg_mkG: pair_pseudo_graph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "using igraph"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "by (rule IGraph_imp_ppg_mkg)"], ["proof (state)\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "fix u v p"], ["proof (state)\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "assume \"pre_digraph.iapath (mk_graph G) u p v\""], ["proof (state)\nthis:\n  ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "then"], ["proof (chain)\npicking this:\n  ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v", "have \"\\<exists>p. pre_digraph.iapath (mk_graph G) v p u\""], ["proof (prove)\nusing this:\n  ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v\n\ngoal (1 subgoal):\n 1. \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) v p u", "using ppg_mkG.gen_iapath_rev_path[where u=u and v=v, symmetric]"], ["proof (prove)\nusing this:\n  ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v\n  ppg_mkG.gen_iapath ?V u ?p v = ppg_mkG.gen_iapath ?V v (rev_path ?p) u\n\ngoal (1 subgoal):\n 1. \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) v p u", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) v p u\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "}"], ["proof (state)\nthis:\n  ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?u3 ?p3\n   ?v3 \\<Longrightarrow>\n  \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?v3 p ?u3\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "then"], ["proof (chain)\npicking this:\n  ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?u3 ?p3\n   ?v3 \\<Longrightarrow>\n  \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?v3 p ?u3", "have ie_sym: \"\\<And>u v. (\\<exists>p. pre_digraph.iapath (mk_graph G) u p v) \\<longleftrightarrow> (\\<exists>p. pre_digraph.iapath (mk_graph G) v p u)\""], ["proof (prove)\nusing this:\n  ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?u3 ?p3\n   ?v3 \\<Longrightarrow>\n  \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?v3 p ?u3\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       (\\<exists>p.\n           ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v) =\n       (\\<exists>p.\n           ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) v p u)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>p.\n      ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?u1 p ?v1) =\n  (\\<exists>p.\n      ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?v1 p ?u1)\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "from nodes"], ["proof (chain)\npicking this:\n  contract_iter_nodes_inv G H (ig_verts_cnt H)", "have \"set (ig_arcs H) = {(u, v). u \\<in> set (ig_verts H) \\<and> (\\<exists>p. pre_digraph.gen_iapath (mk_graph G) (verts3 (mk_graph G)) u p v)}\""], ["proof (prove)\nusing this:\n  contract_iter_nodes_inv G H (ig_verts_cnt H)\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    {(u, v).\n     u \\<in> set (ig_verts H) \\<and>\n     (\\<exists>p.\n         ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v)}", "unfolding contract_iter_nodes_inv_def"], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  (\\<Union>i<ig_verts_cnt H.\n      {(u, v).\n       u = ig_verts H ! i \\<and>\n       (\\<exists>p.\n           ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v)})\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    {(u, v).\n     u \\<in> set (ig_verts H) \\<and>\n     (\\<exists>p.\n         ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v)}", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  set (ig_arcs H) =\n  {(u, v).\n   u \\<in> set (ig_verts H) \\<and>\n   (\\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v)}\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "then"], ["proof (chain)\npicking this:\n  set (ig_arcs H) =\n  {(u, v).\n   u \\<in> set (ig_verts H) \\<and>\n   (\\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v)}", "have *: \"set (ig_arcs H) = {(u,v).  (\\<exists>p. pre_digraph.iapath (mk_graph G) u p v)}\""], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  {(u, v).\n   u \\<in> set (ig_verts H) \\<and>\n   (\\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v)}\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    {(u, v).\n     \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "using snp"], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  {(u, v).\n   u \\<in> set (ig_verts H) \\<and>\n   (\\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v)}\n  select_nodes_prop G H\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    {(u, v).\n     \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "by (auto simp: snp_iapath_ends_in(1))"], ["proof (state)\nthis:\n  set (ig_arcs H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "then"], ["proof (chain)\npicking this:\n  set (ig_arcs H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "have **: \"set (ig_arcs H) = (\\<lambda>(a,b). (b,a)) ` {(u,v). (\\<exists>p. pre_digraph.iapath (mk_graph G) u p v)}\""], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    (\\<lambda>(a, b). (b, a)) `\n    {(u, v).\n     \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "using ie_sym"], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n  (\\<exists>p.\n      ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?u1 p ?v1) =\n  (\\<exists>p.\n      ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) ?v1 p ?u1)\n\ngoal (1 subgoal):\n 1. set (ig_arcs H) =\n    (\\<lambda>(a, b). (b, a)) `\n    {(u, v).\n     \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "by fastforce"], ["proof (state)\nthis:\n  set (ig_arcs H) =\n  (\\<lambda>(a, b). (b, a)) `\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "have sym: \"symmetric (mk_graph' H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (with_proj (mk_graph' H))", "unfolding symmetric_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e1\\<in>arcs (with_proj (mk_graph' H)).\n       \\<exists>e2\\<in>arcs (with_proj (mk_graph' H)).\n          tail (with_proj (mk_graph' H)) e1 =\n          pre_digraph.head (with_proj (mk_graph' H)) e2 \\<and>\n          pre_digraph.head (with_proj (mk_graph' H)) e1 =\n          tail (with_proj (mk_graph' H)) e2", "by (auto simp: mkg'_simps * ie_sym)"], ["proof (state)\nthis:\n  symmetric (with_proj (mk_graph' H))\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "have \"pverts (mk_graph' H) = verts3 (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))", "using snp"], ["proof (prove)\nusing this:\n  select_nodes_prop G H\n\ngoal (1 subgoal):\n 1. pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))", "unfolding select_nodes_prop_def"], ["proof (prove)\nusing this:\n  pverts (mk_graph H) = verts3 (with_proj (mk_graph G))\n\ngoal (1 subgoal):\n 1. pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))", "by (simp add: mkg_simps mkg'_simps)"], ["proof (state)\nthis:\n  pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "moreover"], ["proof (state)\nthis:\n  pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "have \"parcs (mk_graph' H) = {(u,v). (\\<exists>p. ppg_mkG.iapath u p v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parcs (mk_graph' H) =\n    {(u, v).\n     \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "using *"], ["proof (prove)\nusing this:\n  set (ig_arcs H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (1 subgoal):\n 1. parcs (mk_graph' H) =\n    {(u, v).\n     \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "by (auto simp: mkg_simps mkg'_simps)"], ["proof (state)\nthis:\n  parcs (mk_graph' H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (2 subgoals):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G)))\n 2. symmetric (with_proj (mk_graph' H))", "ultimately"], ["proof (chain)\npicking this:\n  pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))\n  parcs (mk_graph' H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}", "show ?t1 ?t2"], ["proof (prove)\nusing this:\n  pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))\n  parcs (mk_graph' H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n\ngoal (1 subgoal):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G))) &&&\n    symmetric (with_proj (mk_graph' H))", "using snp sym"], ["proof (prove)\nusing this:\n  pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))\n  parcs (mk_graph' H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n  select_nodes_prop G H\n  symmetric (with_proj (mk_graph' H))\n\ngoal (1 subgoal):\n 1. mk_graph' H =\n    gen_contr_graph (with_proj (mk_graph G))\n     (verts3 (with_proj (mk_graph G))) &&&\n    symmetric (with_proj (mk_graph' H))", "unfolding gen_contr_graph_def select_nodes_prop_def"], ["proof (prove)\nusing this:\n  pverts (mk_graph' H) = verts3 (with_proj (mk_graph G))\n  parcs (mk_graph' H) =\n  {(u, v).\n   \\<exists>p. ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p v}\n  pverts (mk_graph H) = verts3 (with_proj (mk_graph G))\n  symmetric (with_proj (mk_graph' H))\n\ngoal (1 subgoal):\n 1. mk_graph' H =\n    \\<lparr>pverts = verts3 (with_proj (mk_graph G)),\n       parcs =\n         {(u, v).\n          \\<exists>p.\n             ppg_mkG.gen_iapath (verts3 (with_proj (mk_graph G))) u p\n              v}\\<rparr> &&&\n    symmetric (with_proj (mk_graph' H))", "by auto"], ["proof (state)\nthis:\n  mk_graph' H =\n  gen_contr_graph (with_proj (mk_graph G)) (verts3 (with_proj (mk_graph G)))\n  symmetric (with_proj (mk_graph' H))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in contract_impl) contract_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop \\<acute>G \\<acute>H \\<and> IGraph_inv \\<acute>G \\<and> loop_free (mk_graph \\<acute>G) \\<and> IGraph_inv \\<acute>H \\<and> set (ig_arcs \\<acute>H) = {}\\<rbrace>\n    \\<acute>R :== PROC contract(\\<acute>G, \\<acute>H)\n  \\<lbrace>\\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> mk_graph' \\<acute>R = contr_graph (mk_graph \\<acute>G) \\<and> symmetric (mk_graph' \\<acute>R) \\<and> IGraph_inv \\<acute>R\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            IGraph_inv \\<acute>G \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            IGraph_inv \\<acute>H \\<and>\n            set (ig_arcs \\<acute>H) = {}\\<rbrace>\n                               \\<acute>R :== PROC contract(\\<acute>G,\n                               \\<acute>H)\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  mk_graph' \\<acute>R =\n  gen_contr_graph (with_proj (mk_graph \\<acute>G))\n   (verts3 (with_proj (mk_graph \\<acute>G))) \\<and>\n  symmetric (with_proj (mk_graph' \\<acute>R)) \\<and>\n  IGraph_inv \\<acute>R\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            IGraph_inv \\<acute>G \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            IGraph_inv \\<acute>H \\<and>\n            set (ig_arcs \\<acute>H) = {}\\<rbrace>\n                               \\<acute>i :== 0;;\n                               WHILE \\<acute>i < ig_verts_cnt \\<acute>H\n                               INV named_loop ''iter_nodes'' \n                               DO \\<acute>u :==\n                                  ig_verts \\<acute>H ! \\<acute>i;;\n                                  \\<acute>io_arcs :==\n                                  ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                  \\<acute>j :== 0;;\n                                  WHILE \\<acute>j < length \\<acute>io_arcs\n                                  INV named_loop ''iter_adj'' \n                                  DO \\<acute>v :==\n                                     ig_opposite \\<acute>G\n(\\<acute>io_arcs ! \\<acute>j) \\<acute>u;;\n                                     \\<acute>vo :== CALL find_endpoint(\\<acute>G,\n                                     \\<acute>H,\\<acute>u,\\<acute>v);;\n                                     IF \\<acute>vo \\<noteq> None\n                                     THEN\n \\<acute>H :== ig_add_e \\<acute>H \\<acute>u (the \\<acute>vo)\n                                     FI;;\n                                     \\<acute>j :== \\<acute>j + 1 \n                                  OD;;\n                                  \\<acute>i :== \\<acute>i + 1 \n                               OD;;\n                               \\<acute>R :== \\<acute>H\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  mk_graph' \\<acute>R =\n  gen_contr_graph (with_proj (mk_graph \\<acute>G))\n   (verts3 (with_proj (mk_graph \\<acute>G))) \\<and>\n  symmetric (with_proj (mk_graph' \\<acute>R)) \\<and>\n  IGraph_inv \\<acute>R\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''iter_nodes'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace>contract_iter_nodes_inv \\<acute>G \\<acute>H \\<acute>i\n        \\<and> select_nodes_prop \\<acute>G \\<acute>H \\<and> \\<acute>i \\<le> ig_verts_cnt \\<acute>H \\<and> IGraph_inv \\<acute>G \\<and> loop_free (mk_graph \\<acute>G)\n        \\<and> IGraph_inv \\<acute>H  \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G\\<rbrace>\n      (MEASURE ig_verts_cnt \\<acute>H - \\<acute>i)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            IGraph_inv \\<acute>G \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            IGraph_inv \\<acute>H \\<and>\n            set (ig_arcs \\<acute>H) = {}\\<rbrace>\n                               \\<acute>i :== 0;;\n                               WHILE \\<acute>i < ig_verts_cnt \\<acute>H\n                               INV \\<lbrace>contract_iter_nodes_inv\n       \\<acute>G \\<acute>H \\<acute>i \\<and>\n      select_nodes_prop \\<acute>G \\<acute>H \\<and>\n      \\<acute>i \\<le> ig_verts_cnt \\<acute>H \\<and>\n      IGraph_inv \\<acute>G \\<and>\n      loop_free (mk_graph \\<acute>G) \\<and>\n      IGraph_inv \\<acute>H \\<and>\n      \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G\\<rbrace>\n                               VAR measure\n                                    (\\<lambda>s.\n  ig_verts_cnt\n   (lookup project_Check_Non_Planarity_Impl_IGraph H_'contract_'\n     (locals s)) -\n  lookup project_Nat_nat i_'contract_' (locals s)) \n                               DO \\<acute>u :==\n                                  ig_verts \\<acute>H ! \\<acute>i;;\n                                  \\<acute>io_arcs :==\n                                  ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                  \\<acute>j :== 0;;\n                                  WHILE \\<acute>j < length \\<acute>io_arcs\n                                  INV named_loop ''iter_adj'' \n                                  DO \\<acute>v :==\n                                     ig_opposite \\<acute>G\n(\\<acute>io_arcs ! \\<acute>j) \\<acute>u;;\n                                     \\<acute>vo :== CALL find_endpoint(\\<acute>G,\n                                     \\<acute>H,\\<acute>u,\\<acute>v);;\n                                     IF \\<acute>vo \\<noteq> None\n                                     THEN\n \\<acute>H :== ig_add_e \\<acute>H \\<acute>u (the \\<acute>vo)\n                                     FI;;\n                                     \\<acute>j :== \\<acute>j + 1 \n                                  OD;;\n                                  \\<acute>i :== \\<acute>i + 1 \n                               OD;;\n                               \\<acute>R :== \\<acute>H\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  mk_graph' \\<acute>R =\n  gen_contr_graph (with_proj (mk_graph \\<acute>G))\n   (verts3 (with_proj (mk_graph \\<acute>G))) \\<and>\n  symmetric (with_proj (mk_graph' \\<acute>R)) \\<and>\n  IGraph_inv \\<acute>R\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''iter_adj'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnnoFix _\n      (\\<lambda>(H, u, i). \\<lbrace>contract_iter_adj_inv \\<acute>G H \\<acute>H u \\<acute>j\n        \\<and> select_nodes_prop \\<acute>G \\<acute>H \\<and> \\<acute>u = u \\<and> \\<acute>j \\<le> length (ig_in_out_arcs \\<acute>G \\<acute>u) \\<and> \\<acute>io_arcs = ig_in_out_arcs \\<acute>G \\<acute>u\n        \\<and> u \\<in> set (ig_verts \\<acute>H)  \\<and>  IGraph_inv \\<acute>G  \\<and> loop_free (mk_graph \\<acute>G) \\<and> IGraph_inv \\<acute>H \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>i = i\\<rbrace>)\n      (\\<lambda>_. (MEASURE length \\<acute>io_arcs - \\<acute>j))\n      _\"\n    annotate_named_loop_var_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. select_nodes_prop\n             \\<acute>G \\<acute>H \\<and>\n            IGraph_inv \\<acute>G \\<and>\n            loop_free (mk_graph \\<acute>G) \\<and>\n            IGraph_inv \\<acute>H \\<and>\n            set (ig_arcs \\<acute>H) = {}\\<rbrace>\n                               \\<acute>i :== 0;;\n                               WHILE \\<acute>i < ig_verts_cnt \\<acute>H\n                               INV \\<lbrace>contract_iter_nodes_inv\n       \\<acute>G \\<acute>H \\<acute>i \\<and>\n      select_nodes_prop \\<acute>G \\<acute>H \\<and>\n      \\<acute>i \\<le> ig_verts_cnt \\<acute>H \\<and>\n      IGraph_inv \\<acute>G \\<and>\n      loop_free (mk_graph \\<acute>G) \\<and>\n      IGraph_inv \\<acute>H \\<and>\n      \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G\\<rbrace>\n                               VAR measure\n                                    (\\<lambda>s.\n  ig_verts_cnt\n   (lookup project_Check_Non_Planarity_Impl_IGraph H_'contract_'\n     (locals s)) -\n  lookup project_Nat_nat i_'contract_' (locals s)) \n                               DO \\<acute>u :==\n                                  ig_verts \\<acute>H ! \\<acute>i;;\n                                  \\<acute>io_arcs :==\n                                  ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                  \\<acute>j :== 0;;\n                                  WHILE \\<lbrace>\\<acute>j\n           < length \\<acute>io_arcs\\<rbrace>\n                                  FIX (H, u, i).\n                                  INV \\<lbrace>contract_iter_adj_inv\n          \\<acute>G H \\<acute>H u \\<acute>j \\<and>\n         select_nodes_prop \\<acute>G \\<acute>H \\<and>\n         \\<acute>u = u \\<and>\n         \\<acute>j \\<le> length (ig_in_out_arcs \\<acute>G \\<acute>u) \\<and>\n         \\<acute>io_arcs = ig_in_out_arcs \\<acute>G \\<acute>u \\<and>\n         u \\<in> set (ig_verts \\<acute>H) \\<and>\n         IGraph_inv \\<acute>G \\<and>\n         loop_free (mk_graph \\<acute>G) \\<and>\n         IGraph_inv \\<acute>H \\<and>\n         \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>i = i\\<rbrace>\n                                  VAR measure\n (\\<lambda>s.\n     length\n      (lookup project_Nat_nat_Nat_nat_Product_Type_prod_List_list\n        io_arcs_'contract_' (locals s)) -\n     lookup project_Nat_nat j_'contract_' (locals s)) \n                                  (\\<acute>v :==\n                                   ig_opposite \\<acute>G\n                                    (\\<acute>io_arcs ! \\<acute>j)\n                                    \\<acute>u;;\n                                   \\<acute>vo :== CALL find_endpoint(\\<acute>G,\n                                   \\<acute>H,\\<acute>u,\\<acute>v);;\n                                   IF \\<acute>vo \\<noteq> None\n                                   THEN \\<acute>H :==\n  ig_add_e \\<acute>H \\<acute>u (the \\<acute>vo)\n                                   FI;;\n                                   \\<acute>j :== \\<acute>j + 1);;\n                                  \\<acute>i :== \\<acute>i + 1 \n                               OD;;\n                               \\<acute>R :== \\<acute>H\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  mk_graph' \\<acute>R =\n  gen_contr_graph (with_proj (mk_graph \\<acute>G))\n   (verts3 (with_proj (mk_graph \\<acute>G))) \\<and>\n  symmetric (with_proj (mk_graph' \\<acute>R)) \\<and>\n  IGraph_inv \\<acute>R\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G H.\n       \\<lbrakk>select_nodes_prop G H; IGraph_inv G; loop_free (mk_graph G);\n        IGraph_inv H; set (ig_arcs H) = {}\\<rbrakk>\n       \\<Longrightarrow> contract_iter_nodes_inv G H 0 \\<and>\n                         select_nodes_prop G H \\<and>\n                         0 \\<le> ig_verts_cnt H \\<and>\n                         IGraph_inv G \\<and>\n                         loop_free (mk_graph G) \\<and>\n                         IGraph_inv H \\<and> G = G\n 2. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ha u.\n                            contract_iter_adj_inv Ga Ha H u 0 \\<and>\n                            select_nodes_prop Ga H \\<and>\n                            ig_verts H ! i = u \\<and>\n                            0 \\<le> length\n                                     (ig_in_out_arcs Ga\n (ig_verts H ! i)) \\<and>\n                            ig_in_out_arcs Ga (ig_verts H ! i) =\n                            ig_in_out_arcs Ga (ig_verts H ! i) \\<and>\n                            u \\<in> set (ig_verts H) \\<and>\n                            IGraph_inv Ga \\<and>\n                            loop_free (mk_graph Ga) \\<and>\n                            IGraph_inv H \\<and>\n                            Ga = G \\<and>\n                            (\\<forall>Ga Hb ia io_arcs j ua.\n                                contract_iter_adj_inv Ga Ha Hb u j \\<and>\n                                select_nodes_prop Ga Hb \\<and>\n                                ua = u \\<and>\n                                j \\<le> length (ig_in_out_arcs Ga ua) \\<and>\n                                io_arcs = ig_in_out_arcs Ga ua \\<and>\n                                u \\<in> set (ig_verts Hb) \\<and>\n                                IGraph_inv Ga \\<and>\n                                loop_free (mk_graph Ga) \\<and>\n                                IGraph_inv Hb \\<and>\n                                Ga = G \\<and>\n                                ia = i \\<and>\n                                \\<not> j < length io_arcs \\<longrightarrow>\n                                ig_verts_cnt Hb - (i + 1)\n                                < ig_verts_cnt H - i \\<and>\n                                contract_iter_nodes_inv G Hb (i + 1) \\<and>\n                                select_nodes_prop G Hb \\<and>\n                                i + 1 \\<le> ig_verts_cnt Hb \\<and>\n                                IGraph_inv G \\<and> loop_free (mk_graph G))\n 3. \\<And>G H Ga Ha i io_arcs j u.\n       \\<lbrakk>contract_iter_adj_inv Ga H Ha u j; select_nodes_prop Ga Ha;\n        j \\<le> length (ig_in_out_arcs Ga u); io_arcs = ig_in_out_arcs Ga u;\n        u \\<in> set (ig_verts Ha); IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv Ha; Ga = G; j < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> select_nodes_prop Ga Ha \\<and>\n                         loop_free (mk_graph Ga) \\<and>\n                         u \\<in> set (ig_verts Ha) \\<and>\n                         iadj Ga u (ig_opposite Ga (io_arcs ! j) u) \\<and>\n                         IGraph_inv Ga \\<and>\n                         (\\<forall>R.\n                             (case R of\n                              None \\<Rightarrow>\n                                \\<nexists>p.\n                                   Ex (pre_digraph.gen_iapath\n  (with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n  ((u, ig_opposite Ga (io_arcs ! j) u) # p))\n                              | Some w \\<Rightarrow>\n                                  \\<exists>p.\n                                     pre_digraph.gen_iapath\n(with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n((u, ig_opposite Ga (io_arcs ! j) u) # p) w) \\<longrightarrow>\n                             (R \\<noteq> None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H\n                               (ig_add_e Ha u (the R)) u (j + 1) \\<and>\n                              select_nodes_prop Ga\n                               (ig_add_e Ha u (the R)) \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set\n (ig_verts (ig_add_e Ha u (the R))) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv (ig_add_e Ha u (the R)) \\<and>\n                              Ga = G \\<and> i = i) \\<and>\n                             (R = None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H Ha u (j + 1) \\<and>\n                              select_nodes_prop Ga Ha \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set (ig_verts Ha) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv Ha \\<and> Ga = G \\<and> i = i))\n 4. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; \\<not> i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         mk_graph' H =\n                         gen_contr_graph (with_proj (mk_graph Ga))\n                          (verts3 (with_proj (mk_graph Ga))) \\<and>\n                         symmetric (with_proj (mk_graph' H)) \\<and>\n                         IGraph_inv H", "apply (fastforce simp: contract_iter_nodes_0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ha u.\n                            contract_iter_adj_inv Ga Ha H u 0 \\<and>\n                            select_nodes_prop Ga H \\<and>\n                            ig_verts H ! i = u \\<and>\n                            0 \\<le> length\n                                     (ig_in_out_arcs Ga\n (ig_verts H ! i)) \\<and>\n                            ig_in_out_arcs Ga (ig_verts H ! i) =\n                            ig_in_out_arcs Ga (ig_verts H ! i) \\<and>\n                            u \\<in> set (ig_verts H) \\<and>\n                            IGraph_inv Ga \\<and>\n                            loop_free (mk_graph Ga) \\<and>\n                            IGraph_inv H \\<and>\n                            Ga = G \\<and>\n                            (\\<forall>Ga Hb ia io_arcs j ua.\n                                contract_iter_adj_inv Ga Ha Hb u j \\<and>\n                                select_nodes_prop Ga Hb \\<and>\n                                ua = u \\<and>\n                                j \\<le> length (ig_in_out_arcs Ga ua) \\<and>\n                                io_arcs = ig_in_out_arcs Ga ua \\<and>\n                                u \\<in> set (ig_verts Hb) \\<and>\n                                IGraph_inv Ga \\<and>\n                                loop_free (mk_graph Ga) \\<and>\n                                IGraph_inv Hb \\<and>\n                                Ga = G \\<and>\n                                ia = i \\<and>\n                                \\<not> j < length io_arcs \\<longrightarrow>\n                                ig_verts_cnt Hb - (i + 1)\n                                < ig_verts_cnt H - i \\<and>\n                                contract_iter_nodes_inv G Hb (i + 1) \\<and>\n                                select_nodes_prop G Hb \\<and>\n                                i + 1 \\<le> ig_verts_cnt Hb \\<and>\n                                IGraph_inv G \\<and> loop_free (mk_graph G))\n 2. \\<And>G H Ga Ha i io_arcs j u.\n       \\<lbrakk>contract_iter_adj_inv Ga H Ha u j; select_nodes_prop Ga Ha;\n        j \\<le> length (ig_in_out_arcs Ga u); io_arcs = ig_in_out_arcs Ga u;\n        u \\<in> set (ig_verts Ha); IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv Ha; Ga = G; j < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> select_nodes_prop Ga Ha \\<and>\n                         loop_free (mk_graph Ga) \\<and>\n                         u \\<in> set (ig_verts Ha) \\<and>\n                         iadj Ga u (ig_opposite Ga (io_arcs ! j) u) \\<and>\n                         IGraph_inv Ga \\<and>\n                         (\\<forall>R.\n                             (case R of\n                              None \\<Rightarrow>\n                                \\<nexists>p.\n                                   Ex (pre_digraph.gen_iapath\n  (with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n  ((u, ig_opposite Ga (io_arcs ! j) u) # p))\n                              | Some w \\<Rightarrow>\n                                  \\<exists>p.\n                                     pre_digraph.gen_iapath\n(with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n((u, ig_opposite Ga (io_arcs ! j) u) # p) w) \\<longrightarrow>\n                             (R \\<noteq> None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H\n                               (ig_add_e Ha u (the R)) u (j + 1) \\<and>\n                              select_nodes_prop Ga\n                               (ig_add_e Ha u (the R)) \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set\n (ig_verts (ig_add_e Ha u (the R))) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv (ig_add_e Ha u (the R)) \\<and>\n                              Ga = G \\<and> i = i) \\<and>\n                             (R = None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H Ha u (j + 1) \\<and>\n                              select_nodes_prop Ga Ha \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set (ig_verts Ha) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv Ha \\<and> Ga = G \\<and> i = i))\n 3. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; \\<not> i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         mk_graph' H =\n                         gen_contr_graph (with_proj (mk_graph Ga))\n                          (verts3 (with_proj (mk_graph Ga))) \\<and>\n                         symmetric (with_proj (mk_graph' H)) \\<and>\n                         IGraph_inv H", "apply (match premises in \"select_nodes_prop _ H\" for H \\<Rightarrow> \\<open>rule exI[where x=H]\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u.\n                            contract_iter_adj_inv Ga H H u 0 \\<and>\n                            select_nodes_prop Ga H \\<and>\n                            ig_verts H ! i = u \\<and>\n                            0 \\<le> length\n                                     (ig_in_out_arcs Ga\n (ig_verts H ! i)) \\<and>\n                            ig_in_out_arcs Ga (ig_verts H ! i) =\n                            ig_in_out_arcs Ga (ig_verts H ! i) \\<and>\n                            u \\<in> set (ig_verts H) \\<and>\n                            IGraph_inv Ga \\<and>\n                            loop_free (mk_graph Ga) \\<and>\n                            IGraph_inv H \\<and>\n                            Ga = G \\<and>\n                            (\\<forall>Ga Ha ia io_arcs j ua.\n                                contract_iter_adj_inv Ga H Ha u j \\<and>\n                                select_nodes_prop Ga Ha \\<and>\n                                ua = u \\<and>\n                                j \\<le> length (ig_in_out_arcs Ga ua) \\<and>\n                                io_arcs = ig_in_out_arcs Ga ua \\<and>\n                                u \\<in> set (ig_verts Ha) \\<and>\n                                IGraph_inv Ga \\<and>\n                                loop_free (mk_graph Ga) \\<and>\n                                IGraph_inv Ha \\<and>\n                                Ga = G \\<and>\n                                ia = i \\<and>\n                                \\<not> j < length io_arcs \\<longrightarrow>\n                                ig_verts_cnt Ha - (i + 1)\n                                < ig_verts_cnt H - i \\<and>\n                                contract_iter_nodes_inv G Ha (i + 1) \\<and>\n                                select_nodes_prop G Ha \\<and>\n                                i + 1 \\<le> ig_verts_cnt Ha \\<and>\n                                IGraph_inv G \\<and> loop_free (mk_graph G))\n 2. \\<And>G H Ga Ha i io_arcs j u.\n       \\<lbrakk>contract_iter_adj_inv Ga H Ha u j; select_nodes_prop Ga Ha;\n        j \\<le> length (ig_in_out_arcs Ga u); io_arcs = ig_in_out_arcs Ga u;\n        u \\<in> set (ig_verts Ha); IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv Ha; Ga = G; j < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> select_nodes_prop Ga Ha \\<and>\n                         loop_free (mk_graph Ga) \\<and>\n                         u \\<in> set (ig_verts Ha) \\<and>\n                         iadj Ga u (ig_opposite Ga (io_arcs ! j) u) \\<and>\n                         IGraph_inv Ga \\<and>\n                         (\\<forall>R.\n                             (case R of\n                              None \\<Rightarrow>\n                                \\<nexists>p.\n                                   Ex (pre_digraph.gen_iapath\n  (with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n  ((u, ig_opposite Ga (io_arcs ! j) u) # p))\n                              | Some w \\<Rightarrow>\n                                  \\<exists>p.\n                                     pre_digraph.gen_iapath\n(with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n((u, ig_opposite Ga (io_arcs ! j) u) # p) w) \\<longrightarrow>\n                             (R \\<noteq> None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H\n                               (ig_add_e Ha u (the R)) u (j + 1) \\<and>\n                              select_nodes_prop Ga\n                               (ig_add_e Ha u (the R)) \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set\n (ig_verts (ig_add_e Ha u (the R))) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv (ig_add_e Ha u (the R)) \\<and>\n                              Ga = G \\<and> i = i) \\<and>\n                             (R = None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H Ha u (j + 1) \\<and>\n                              select_nodes_prop Ga Ha \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set (ig_verts Ha) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv Ha \\<and> Ga = G \\<and> i = i))\n 3. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; \\<not> i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         mk_graph' H =\n                         gen_contr_graph (with_proj (mk_graph Ga))\n                          (verts3 (with_proj (mk_graph Ga))) \\<and>\n                         symmetric (with_proj (mk_graph' H)) \\<and>\n                         IGraph_inv H", "apply (fastforce simp: contract_iter_adj_0 contract_iter_nodes_inv_step elim: contract_iter_adj_invE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G H Ga Ha i io_arcs j u.\n       \\<lbrakk>contract_iter_adj_inv Ga H Ha u j; select_nodes_prop Ga Ha;\n        j \\<le> length (ig_in_out_arcs Ga u); io_arcs = ig_in_out_arcs Ga u;\n        u \\<in> set (ig_verts Ha); IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv Ha; Ga = G; j < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> select_nodes_prop Ga Ha \\<and>\n                         loop_free (mk_graph Ga) \\<and>\n                         u \\<in> set (ig_verts Ha) \\<and>\n                         iadj Ga u (ig_opposite Ga (io_arcs ! j) u) \\<and>\n                         IGraph_inv Ga \\<and>\n                         (\\<forall>R.\n                             (case R of\n                              None \\<Rightarrow>\n                                \\<nexists>p.\n                                   Ex (pre_digraph.gen_iapath\n  (with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n  ((u, ig_opposite Ga (io_arcs ! j) u) # p))\n                              | Some w \\<Rightarrow>\n                                  \\<exists>p.\n                                     pre_digraph.gen_iapath\n(with_proj (mk_graph Ga)) (verts3 (with_proj (mk_graph Ga))) u\n((u, ig_opposite Ga (io_arcs ! j) u) # p) w) \\<longrightarrow>\n                             (R \\<noteq> None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H\n                               (ig_add_e Ha u (the R)) u (j + 1) \\<and>\n                              select_nodes_prop Ga\n                               (ig_add_e Ha u (the R)) \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set\n (ig_verts (ig_add_e Ha u (the R))) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv (ig_add_e Ha u (the R)) \\<and>\n                              Ga = G \\<and> i = i) \\<and>\n                             (R = None \\<longrightarrow>\n                              length io_arcs - (j + 1)\n                              < length io_arcs - j \\<and>\n                              contract_iter_adj_inv Ga H Ha u (j + 1) \\<and>\n                              select_nodes_prop Ga Ha \\<and>\n                              u = u \\<and>\n                              j + 1\n                              \\<le> length (ig_in_out_arcs Ga u) \\<and>\n                              io_arcs = ig_in_out_arcs Ga u \\<and>\n                              u \\<in> set (ig_verts Ha) \\<and>\n                              IGraph_inv Ga \\<and>\n                              loop_free (mk_graph Ga) \\<and>\n                              IGraph_inv Ha \\<and> Ga = G \\<and> i = i))\n 2. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; \\<not> i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         mk_graph' H =\n                         gen_contr_graph (with_proj (mk_graph Ga))\n                          (verts3 (with_proj (mk_graph Ga))) \\<and>\n                         symmetric (with_proj (mk_graph' H)) \\<and>\n                         IGraph_inv H", "apply (fastforce simp: contract_iter_adj_inv_step2 contract_iter_adj_inv_step1\n     IGraph_imp_ppg_mkg igraph_ig_add_eI snp_iapath_ends_in iadj_io_edge snp_vertexes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G Ga H i.\n       \\<lbrakk>contract_iter_nodes_inv Ga H i; select_nodes_prop Ga H;\n        i \\<le> ig_verts_cnt H; IGraph_inv Ga; loop_free (mk_graph Ga);\n        IGraph_inv H; Ga = G; \\<not> i < ig_verts_cnt H\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         mk_graph' H =\n                         gen_contr_graph (with_proj (mk_graph Ga))\n                          (verts3 (with_proj (mk_graph Ga))) \\<and>\n                         symmetric (with_proj (mk_graph' H)) \\<and>\n                         IGraph_inv H", "apply (fastforce simp: not_less intro: contract_iter_nodes_last)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Procedure @{term is_K33}\\<close>"], ["", "definition is_K33_colorize_inv :: \"IGraph \\<Rightarrow> ig_vertex \\<Rightarrow> nat \\<Rightarrow> (ig_vertex \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"is_K33_colorize_inv G u k blue \\<equiv> \\<forall>v \\<in> set (ig_verts G). blue v \\<longleftrightarrow>\n    (\\<exists>i < k. v = ig_opposite G (ig_in_out_arcs G u ! i) u)\""], ["", "definition is_K33_component_size_inv :: \"IGraph \\<Rightarrow> nat \\<Rightarrow> (ig_vertex \\<Rightarrow> bool) \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"is_K33_component_size_inv G k blue cnt \\<equiv> cnt = card {i. i < k \\<and> blue (ig_verts G ! i)}\""], ["", "definition is_K33_outer_inv :: \"IGraph \\<Rightarrow> nat \\<Rightarrow> (ig_vertex \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"is_K33_outer_inv G k blue \\<equiv> \\<forall>i < k. \\<forall>v \\<in> set (ig_verts G).\n    blue (ig_verts G ! i) = blue v \\<longleftrightarrow> (ig_verts G ! i, v) \\<notin> set (ig_arcs G)\""], ["", "definition is_K33_inner_inv :: \"IGraph \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (ig_vertex \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"is_K33_inner_inv G k l blue \\<equiv> \\<forall>j < l.\n    blue (ig_verts G ! k) = blue (ig_verts G ! j) \\<longleftrightarrow> (ig_verts G ! k, ig_verts G ! j) \\<notin> set (ig_arcs G)\""], ["", "lemma is_K33_colorize_0: \"is_K33_colorize_inv G u 0 (\\<lambda>_. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u 0 (\\<lambda>_. False)", "unfolding is_K33_colorize_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (ig_verts G).\n       False = (\\<exists>i<0. v = ig_opposite G (ig_in_out_arcs G u ! i) u)", "by auto"], ["", "lemma is_K33_component_size_0: \"is_K33_component_size_inv G 0 blue 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G 0 blue 0", "unfolding is_K33_component_size_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = card {i. i < 0 \\<and> blue (ig_verts G ! i)}", "by auto"], ["", "lemma is_K33_outer_0: \"is_K33_outer_inv G 0 blue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_outer_inv G 0 blue", "unfolding is_K33_outer_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<0.\n       \\<forall>v\\<in>set (ig_verts G).\n          (blue (ig_verts G ! i) = blue v) =\n          ((ig_verts G ! i, v) \\<notin> set (ig_arcs G))", "by auto"], ["", "lemma is_K33_inner_0: \"is_K33_inner_inv G k 0 blue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_inner_inv G k 0 blue", "unfolding is_K33_inner_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<0.\n       (blue (ig_verts G ! k) = blue (ig_verts G ! j)) =\n       ((ig_verts G ! k, ig_verts G ! j) \\<notin> set (ig_arcs G))", "by auto"], ["", "lemma is_K33_colorize_last:\n  assumes \"u \\<in> set (ig_verts G)\"\n  shows \"is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\n    = (\\<forall>v \\<in> set (ig_verts G). blue v \\<longleftrightarrow> iadj G u v)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "have \"(\\<exists>i<length (ig_in_out_arcs G u). v = ig_opposite G (ig_in_out_arcs G u ! i) u)\n        \\<longleftrightarrow> (\\<exists>e \\<in> set (ig_in_out_arcs G u). v = ig_opposite G e u)\" (is \"?A \\<longleftrightarrow> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<length (ig_in_out_arcs G u).\n        v = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n    (\\<exists>e\\<in>set (ig_in_out_arcs G u). v = ig_opposite G e u)", "by auto (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      v = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  (\\<exists>e\\<in>set (ig_in_out_arcs G u). v = ig_opposite G e u)\n\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "also"], ["proof (state)\nthis:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      v = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  (\\<exists>e\\<in>set (ig_in_out_arcs G u). v = ig_opposite G e u)\n\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "have \"\\<dots> \\<longleftrightarrow> iadj G u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>e\\<in>set (ig_in_out_arcs G u). v = ig_opposite G e u) =\n    iadj G u v", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. (\\<exists>e\\<in>set (ig_in_out_arcs G u). v = ig_opposite G e u) =\n    iadj G u v", "by (force simp: iadj_io_edge ig_opposite_simps dest: iadjD)"], ["proof (state)\nthis:\n  (\\<exists>e\\<in>set (ig_in_out_arcs G u). v = ig_opposite G e u) =\n  iadj G u v\n\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      v = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  iadj G u v", "have \"?A \\<longleftrightarrow> iadj G u v\""], ["proof (prove)\nusing this:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      v = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  iadj G u v\n\ngoal (1 subgoal):\n 1. (\\<exists>i<length (ig_in_out_arcs G u).\n        v = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n    iadj G u v", "."], ["proof (state)\nthis:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      v = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  iadj G u v\n\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "}"], ["proof (state)\nthis:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      ?v2 = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  iadj G u ?v2\n\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      ?v2 = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  iadj G u ?v2", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      ?v2 = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  iadj G u ?v2\n\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "unfolding is_K33_colorize_inv_def"], ["proof (prove)\nusing this:\n  (\\<exists>i<length (ig_in_out_arcs G u).\n      ?v2 = ig_opposite G (ig_in_out_arcs G u ! i) u) =\n  iadj G u ?v2\n\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set (ig_verts G).\n        blue v =\n        (\\<exists>i<length (ig_in_out_arcs G u).\n            v = ig_opposite G (ig_in_out_arcs G u ! i) u)) =\n    (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)", "by auto"], ["proof (state)\nthis:\n  is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue =\n  (\\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_K33_component_size_last:\n  assumes \"k = ig_verts_cnt G\"\n  shows \"is_K33_component_size_inv G k blue cnt \\<longleftrightarrow> card {u \\<in> set (ig_verts G). blue u} = cnt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G k blue cnt =\n    (card {u \\<in> set (ig_verts G). blue u} = cnt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G k blue cnt =\n    (card {u \\<in> set (ig_verts G). blue u} = cnt)", "have *: \"{u \\<in> set (ig_verts G). blue u} = (\\<lambda>n. ig_verts G ! n) ` {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {u \\<in> set (ig_verts G). blue u} =\n    (!) (ig_verts G) ` {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}", "by (auto simp: in_set_conv_nth )"], ["proof (state)\nthis:\n  {u \\<in> set (ig_verts G). blue u} =\n  (!) (ig_verts G) ` {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G k blue cnt =\n    (card {u \\<in> set (ig_verts G). blue u} = cnt)", "have \"inj_on (\\<lambda>n. ig_verts G ! n) {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((!) (ig_verts G))\n     {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}", "using distinct_ig_verts"], ["proof (prove)\nusing this:\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. inj_on ((!) (ig_verts G))\n     {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}", "by (auto simp: nth_eq_iff_index_eq intro: inj_onI)"], ["proof (state)\nthis:\n  inj_on ((!) (ig_verts G))\n   {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G k blue cnt =\n    (card {u \\<in> set (ig_verts G). blue u} = cnt)", "with assms"], ["proof (chain)\npicking this:\n  k = ig_verts_cnt G\n  inj_on ((!) (ig_verts G))\n   {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}", "show ?thesis"], ["proof (prove)\nusing this:\n  k = ig_verts_cnt G\n  inj_on ((!) (ig_verts G))\n   {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G k blue cnt =\n    (card {u \\<in> set (ig_verts G). blue u} = cnt)", "unfolding * is_K33_component_size_inv_def"], ["proof (prove)\nusing this:\n  k = ig_verts_cnt G\n  inj_on ((!) (ig_verts G))\n   {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. (cnt = card {i. i < k \\<and> blue (ig_verts G ! i)}) =\n    (card\n      ((!) (ig_verts G) `\n       {i. i < ig_verts_cnt G \\<and> blue (ig_verts G ! i)}) =\n     cnt)", "by (auto intro: card_image)"], ["proof (state)\nthis:\n  is_K33_component_size_inv G k blue cnt =\n  (card {u \\<in> set (ig_verts G). blue u} = cnt)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_K33_outer_last:\n  \"is_K33_outer_inv G (ig_verts_cnt G) blue \\<longleftrightarrow> (\\<forall>u \\<in> set (ig_verts G). \\<forall>v \\<in> set (ig_verts G).\n    blue u = blue v \\<longleftrightarrow> (u,v) \\<notin> set (ig_arcs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_outer_inv G (ig_verts_cnt G) blue =\n    (\\<forall>u\\<in>set (ig_verts G).\n        \\<forall>v\\<in>set (ig_verts G).\n           (blue u = blue v) = ((u, v) \\<notin> set (ig_arcs G)))", "unfolding is_K33_outer_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<ig_verts_cnt G.\n        \\<forall>v\\<in>set (ig_verts G).\n           (blue (ig_verts G ! i) = blue v) =\n           ((ig_verts G ! i, v) \\<notin> set (ig_arcs G))) =\n    (\\<forall>u\\<in>set (ig_verts G).\n        \\<forall>v\\<in>set (ig_verts G).\n           (blue u = blue v) = ((u, v) \\<notin> set (ig_arcs G)))", "by (simp add: All_set_ig_verts)"], ["", "lemma is_K33_inner_last:\n  \"is_K33_inner_inv G k (ig_verts_cnt G) blue \\<longleftrightarrow> (\\<forall>v \\<in> set (ig_verts G).\n    blue (ig_verts G ! k) = blue v \\<longleftrightarrow> (ig_verts G ! k, v) \\<notin> set (ig_arcs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_inner_inv G k (ig_verts_cnt G) blue =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (blue (ig_verts G ! k) = blue v) =\n        ((ig_verts G ! k, v) \\<notin> set (ig_arcs G)))", "unfolding is_K33_inner_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<ig_verts_cnt G.\n        (blue (ig_verts G ! k) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! k, ig_verts G ! j) \\<notin> set (ig_arcs G))) =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (blue (ig_verts G ! k) = blue v) =\n        ((ig_verts G ! k, v) \\<notin> set (ig_arcs G)))", "by (simp add: All_set_ig_verts)"], ["", "lemma is_K33_colorize_step:\n  fixes G u i blue\n  assumes colorize: \"is_K33_colorize_inv G u k blue\"\n  shows \" is_K33_colorize_inv G u (Suc k) (blue (ig_opposite G (ig_in_out_arcs G u ! k) u := True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (Suc k)\n     (blue(ig_opposite G (ig_in_out_arcs G u ! k) u := True))", "using assms"], ["proof (prove)\nusing this:\n  is_K33_colorize_inv G u k blue\n\ngoal (1 subgoal):\n 1. is_K33_colorize_inv G u (Suc k)\n     (blue(ig_opposite G (ig_in_out_arcs G u ! k) u := True))", "by (auto simp: is_K33_colorize_inv_def elim: less_SucE intro: less_SucI)"], ["", "lemma is_K33_component_size_step1:\n  assumes comp:\"is_K33_component_size_inv G k blue blue_cnt\"\n  assumes blue: \"blue (ig_verts G ! k)\"\n  shows \"is_K33_component_size_inv G (Suc k) blue (Suc blue_cnt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue (Suc blue_cnt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue (Suc blue_cnt)", "have \"{i. i < Suc k \\<and> blue (ig_verts G ! i)}\n      = insert k {i. i < k \\<and> blue (ig_verts G ! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n    insert k {i. i < k \\<and> blue (ig_verts G ! i)}", "using blue"], ["proof (prove)\nusing this:\n  blue (ig_verts G ! k)\n\ngoal (1 subgoal):\n 1. {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n    insert k {i. i < k \\<and> blue (ig_verts G ! i)}", "by auto"], ["proof (state)\nthis:\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  insert k {i. i < k \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue (Suc blue_cnt)", "with comp"], ["proof (chain)\npicking this:\n  is_K33_component_size_inv G k blue blue_cnt\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  insert k {i. i < k \\<and> blue (ig_verts G ! i)}", "show ?thesis"], ["proof (prove)\nusing this:\n  is_K33_component_size_inv G k blue blue_cnt\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  insert k {i. i < k \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue (Suc blue_cnt)", "unfolding is_K33_component_size_inv_def"], ["proof (prove)\nusing this:\n  blue_cnt = card {i. i < k \\<and> blue (ig_verts G ! i)}\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  insert k {i. i < k \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. Suc blue_cnt = card {i. i < Suc k \\<and> blue (ig_verts G ! i)}", "by auto"], ["proof (state)\nthis:\n  is_K33_component_size_inv G (Suc k) blue (Suc blue_cnt)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_K33_component_size_step2:\n  assumes comp:\"is_K33_component_size_inv G k blue blue_cnt\"\n  assumes blue: \"\\<not>blue (ig_verts G ! k)\"\n  shows \"is_K33_component_size_inv G (Suc k) blue blue_cnt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue blue_cnt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue blue_cnt", "have \"{i. i < Suc k \\<and> blue (ig_verts G ! i)} = {i. i < k \\<and> blue (ig_verts G ! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n    {i. i < k \\<and> blue (ig_verts G ! i)}", "using blue"], ["proof (prove)\nusing this:\n  \\<not> blue (ig_verts G ! k)\n\ngoal (1 subgoal):\n 1. {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n    {i. i < k \\<and> blue (ig_verts G ! i)}", "by (auto elim: less_SucE)"], ["proof (state)\nthis:\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  {i. i < k \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue blue_cnt", "with comp"], ["proof (chain)\npicking this:\n  is_K33_component_size_inv G k blue blue_cnt\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  {i. i < k \\<and> blue (ig_verts G ! i)}", "show ?thesis"], ["proof (prove)\nusing this:\n  is_K33_component_size_inv G k blue blue_cnt\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  {i. i < k \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (Suc k) blue blue_cnt", "unfolding is_K33_component_size_inv_def"], ["proof (prove)\nusing this:\n  blue_cnt = card {i. i < k \\<and> blue (ig_verts G ! i)}\n  {i. i < Suc k \\<and> blue (ig_verts G ! i)} =\n  {i. i < k \\<and> blue (ig_verts G ! i)}\n\ngoal (1 subgoal):\n 1. blue_cnt = card {i. i < Suc k \\<and> blue (ig_verts G ! i)}", "by auto"], ["proof (state)\nthis:\n  is_K33_component_size_inv G (Suc k) blue blue_cnt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_K33_outer_step:\n  assumes \"is_K33_outer_inv G i blue\"\n  assumes \"is_K33_inner_inv G i (ig_verts_cnt G) blue\"\n  shows \"is_K33_outer_inv G (Suc i) blue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_outer_inv G (Suc i) blue", "using assms"], ["proof (prove)\nusing this:\n  is_K33_outer_inv G i blue\n  is_K33_inner_inv G i (ig_verts_cnt G) blue\n\ngoal (1 subgoal):\n 1. is_K33_outer_inv G (Suc i) blue", "unfolding is_K33_outer_inv_def is_K33_inner_last"], ["proof (prove)\nusing this:\n  \\<forall>ia<i.\n     \\<forall>v\\<in>set (ig_verts G).\n        (blue (ig_verts G ! ia) = blue v) =\n        ((ig_verts G ! ia, v) \\<notin> set (ig_arcs G))\n  \\<forall>v\\<in>set (ig_verts G).\n     (blue (ig_verts G ! i) = blue v) =\n     ((ig_verts G ! i, v) \\<notin> set (ig_arcs G))\n\ngoal (1 subgoal):\n 1. \\<forall>ia<Suc i.\n       \\<forall>v\\<in>set (ig_verts G).\n          (blue (ig_verts G ! ia) = blue v) =\n          ((ig_verts G ! ia, v) \\<notin> set (ig_arcs G))", "by (auto intro: less_SucI elim: less_SucE)"], ["", "lemma is_K33_inner_step:\n  assumes \"is_K33_inner_inv G i j blue\"\n  assumes \"(blue (ig_verts G ! i) = blue (ig_verts G ! j)) \\<longleftrightarrow> (ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G)\"\n  shows \"is_K33_inner_inv G i (Suc j) blue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K33_inner_inv G i (Suc j) blue", "using assms"], ["proof (prove)\nusing this:\n  is_K33_inner_inv G i j blue\n  (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n  ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\n\ngoal (1 subgoal):\n 1. is_K33_inner_inv G i (Suc j) blue", "by (auto simp: is_K33_inner_inv_def elim: less_SucE)"], ["", "lemma K33_mkg'I:\n  fixes G col cnt\n  defines \"u \\<equiv> ig_verts G ! 0\"\n  assumes ig: \"IGraph_inv G\"\n  assumes iv_cnt: \"ig_verts_cnt G = 6\" and c1_cnt: \"cnt = 3\"\n  assumes colorize: \"is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\"\n  assumes comp: \"is_K33_component_size_inv G (ig_verts_cnt G) blue cnt\"\n  assumes outer: \"is_K33_outer_inv G (ig_verts_cnt G) blue\"\n  shows \"K\\<^bsub>3,3\\<^esub> (mk_graph' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "have \"u \\<in> set (ig_verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (ig_verts G)", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_verts G ! 0 \\<in> set (ig_verts G)", "using iv_cnt"], ["proof (prove)\nusing this:\n  ig_verts_cnt G = 6\n\ngoal (1 subgoal):\n 1. ig_verts G ! 0 \\<in> set (ig_verts G)", "by auto"], ["proof (state)\nthis:\n  u \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "then"], ["proof (chain)\npicking this:\n  u \\<in> set (ig_verts G)", "have \"(\\<forall>v\\<in>set (ig_verts G). blue v \\<longleftrightarrow> iadj G u v)\""], ["proof (prove)\nusing this:\n  u \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v", "using colorize"], ["proof (prove)\nusing this:\n  u \\<in> set (ig_verts G)\n  is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v", "by (rule is_K33_colorize_last[THEN iffD1])"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (ig_verts G). blue v = iadj G u v\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "define U V where \"U = {u \\<in> set (ig_verts G). \\<not>blue u}\" and \"V = {v \\<in> set (ig_verts G). blue v}\""], ["proof (state)\nthis:\n  U = {u \\<in> set (ig_verts G). \\<not> blue u}\n  V = {v \\<in> set (ig_verts G). blue v}\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "then"], ["proof (chain)\npicking this:\n  U = {u \\<in> set (ig_verts G). \\<not> blue u}\n  V = {v \\<in> set (ig_verts G). blue v}", "have UV_set: \"U \\<subseteq> set (ig_verts G)\" \"V \\<subseteq> set (ig_verts G)\" \"U \\<union> V = set (ig_verts G)\" \"U \\<inter> V = {}\"\n    and fin_UV: \"finite U\" \"finite V\""], ["proof (prove)\nusing this:\n  U = {u \\<in> set (ig_verts G). \\<not> blue u}\n  V = {v \\<in> set (ig_verts G). blue v}\n\ngoal (1 subgoal):\n 1. ((U \\<subseteq> set (ig_verts G) &&& V \\<subseteq> set (ig_verts G)) &&&\n     U \\<union> V = set (ig_verts G) &&& U \\<inter> V = {}) &&&\n    finite U &&& finite V", "by auto"], ["proof (state)\nthis:\n  U \\<subseteq> set (ig_verts G)\n  V \\<subseteq> set (ig_verts G)\n  U \\<union> V = set (ig_verts G)\n  U \\<inter> V = {}\n  finite U\n  finite V\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "have card_verts: \"card (set (ig_verts G)) = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (ig_verts G)) = 6", "using iv_cnt distinct_ig_verts"], ["proof (prove)\nusing this:\n  ig_verts_cnt G = 6\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. card (set (ig_verts G)) = 6", "by (simp add: distinct_card)"], ["proof (state)\nthis:\n  card (set (ig_verts G)) = 6\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "from ig comp c1_cnt"], ["proof (chain)\npicking this:\n  IGraph_inv G\n  is_K33_component_size_inv G (ig_verts_cnt G) blue cnt\n  cnt = 3", "have \"card V = 3\""], ["proof (prove)\nusing this:\n  IGraph_inv G\n  is_K33_component_size_inv G (ig_verts_cnt G) blue cnt\n  cnt = 3\n\ngoal (1 subgoal):\n 1. card V = 3", "by (simp add: is_K33_component_size_last V_def)"], ["proof (state)\nthis:\n  card V = 3\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "moreover"], ["proof (state)\nthis:\n  card V = 3\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "have \"card (U \\<union> V) = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (U \\<union> V) = 6", "using UV_set distinct_ig_verts iv_cnt"], ["proof (prove)\nusing this:\n  U \\<subseteq> set (ig_verts G)\n  V \\<subseteq> set (ig_verts G)\n  U \\<union> V = set (ig_verts G)\n  U \\<inter> V = {}\n  distinct (ig_verts ?G)\n  ig_verts_cnt G = 6\n\ngoal (1 subgoal):\n 1. card (U \\<union> V) = 6", "by (auto simp: distinct_card)"], ["proof (state)\nthis:\n  card (U \\<union> V) = 6\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "ultimately"], ["proof (chain)\npicking this:\n  card V = 3\n  card (U \\<union> V) = 6", "have \"card U = 3\""], ["proof (prove)\nusing this:\n  card V = 3\n  card (U \\<union> V) = 6\n\ngoal (1 subgoal):\n 1. card U = 3", "by (simp add: card_Un_disjoint[OF fin_UV UV_set(4)])"], ["proof (state)\nthis:\n  card U = 3\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "note cards = \\<open>card V = 3\\<close> \\<open>card U = 3\\<close> card_verts"], ["proof (state)\nthis:\n  card V = 3\n  card U = 3\n  card (set (ig_verts G)) = 6\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "from is_K33_outer_last[THEN iffD1, OF outer]"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>set (ig_verts G).\n     \\<forall>v\\<in>set (ig_verts G).\n        (blue u = blue v) = ((u, v) \\<notin> set (ig_arcs G))", "have \"(\\<forall>u\\<in>U. \\<forall>v\\<in>V. (u, v) \\<in> set (ig_arcs G) \\<and> (v, u) \\<in> set (ig_arcs G))\n      \\<and> (\\<forall>u\\<in>U. \\<forall>u'\\<in>U. (u, u') \\<notin> set (ig_arcs G))\n      \\<and> (\\<forall>v\\<in>V. \\<forall>v'\\<in>V. (v, v') \\<notin> set (ig_arcs G))\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>set (ig_verts G).\n     \\<forall>v\\<in>set (ig_verts G).\n        (blue u = blue v) = ((u, v) \\<notin> set (ig_arcs G))\n\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>U.\n        \\<forall>v\\<in>V.\n           (u, v) \\<in> set (ig_arcs G) \\<and>\n           (v, u) \\<in> set (ig_arcs G)) \\<and>\n    (\\<forall>u\\<in>U.\n        \\<forall>u'\\<in>U. (u, u') \\<notin> set (ig_arcs G)) \\<and>\n    (\\<forall>v\\<in>V. \\<forall>v'\\<in>V. (v, v') \\<notin> set (ig_arcs G))", "unfolding U_def V_def"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>set (ig_verts G).\n     \\<forall>v\\<in>set (ig_verts G).\n        (blue u = blue v) = ((u, v) \\<notin> set (ig_arcs G))\n\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>{u \\<in> set (ig_verts G). \\<not> blue u}.\n        \\<forall>v\\<in>{v \\<in> set (ig_verts G). blue v}.\n           (u, v) \\<in> set (ig_arcs G) \\<and>\n           (v, u) \\<in> set (ig_arcs G)) \\<and>\n    (\\<forall>u\\<in>{u \\<in> set (ig_verts G). \\<not> blue u}.\n        \\<forall>u'\\<in>{u \\<in> set (ig_verts G). \\<not> blue u}.\n           (u, u') \\<notin> set (ig_arcs G)) \\<and>\n    (\\<forall>v\\<in>{v \\<in> set (ig_verts G). blue v}.\n        \\<forall>v'\\<in>{v \\<in> set (ig_verts G). blue v}.\n           (v, v') \\<notin> set (ig_arcs G))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>u\\<in>U.\n      \\<forall>v\\<in>V.\n         (u, v) \\<in> set (ig_arcs G) \\<and>\n         (v, u) \\<in> set (ig_arcs G)) \\<and>\n  (\\<forall>u\\<in>U.\n      \\<forall>u'\\<in>U. (u, u') \\<notin> set (ig_arcs G)) \\<and>\n  (\\<forall>v\\<in>V. \\<forall>v'\\<in>V. (v, v') \\<notin> set (ig_arcs G))\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "then"], ["proof (chain)\npicking this:\n  (\\<forall>u\\<in>U.\n      \\<forall>v\\<in>V.\n         (u, v) \\<in> set (ig_arcs G) \\<and>\n         (v, u) \\<in> set (ig_arcs G)) \\<and>\n  (\\<forall>u\\<in>U.\n      \\<forall>u'\\<in>U. (u, u') \\<notin> set (ig_arcs G)) \\<and>\n  (\\<forall>v\\<in>V. \\<forall>v'\\<in>V. (v, v') \\<notin> set (ig_arcs G))", "have \"U \\<times> V \\<subseteq> set (ig_arcs G)\" \"V \\<times> U \\<subseteq> set (ig_arcs G)\"\n    \"U \\<times> U \\<inter> set (ig_arcs G) = {}\" \"V \\<times> V \\<inter> set (ig_arcs G) = {}\""], ["proof (prove)\nusing this:\n  (\\<forall>u\\<in>U.\n      \\<forall>v\\<in>V.\n         (u, v) \\<in> set (ig_arcs G) \\<and>\n         (v, u) \\<in> set (ig_arcs G)) \\<and>\n  (\\<forall>u\\<in>U.\n      \\<forall>u'\\<in>U. (u, u') \\<notin> set (ig_arcs G)) \\<and>\n  (\\<forall>v\\<in>V. \\<forall>v'\\<in>V. (v, v') \\<notin> set (ig_arcs G))\n\ngoal (1 subgoal):\n 1. (U \\<times> V \\<subseteq> set (ig_arcs G) &&&\n     V \\<times> U \\<subseteq> set (ig_arcs G)) &&&\n    U \\<times> U \\<inter> set (ig_arcs G) = {} &&&\n    V \\<times> V \\<inter> set (ig_arcs G) = {}", "by auto"], ["proof (state)\nthis:\n  U \\<times> V \\<subseteq> set (ig_arcs G)\n  V \\<times> U \\<subseteq> set (ig_arcs G)\n  U \\<times> U \\<inter> set (ig_arcs G) = {}\n  V \\<times> V \\<inter> set (ig_arcs G) = {}\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "moreover"], ["proof (state)\nthis:\n  U \\<times> V \\<subseteq> set (ig_arcs G)\n  V \\<times> U \\<subseteq> set (ig_arcs G)\n  U \\<times> U \\<inter> set (ig_arcs G) = {}\n  V \\<times> V \\<inter> set (ig_arcs G) = {}\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "have \"set (ig_arcs G) \\<subseteq> (U \\<union> V) \\<times> (U \\<union> V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ig_arcs G) \\<subseteq> (U \\<union> V) \\<times> (U \\<union> V)", "unfolding \\<open>U \\<union> V = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ig_arcs G) \\<subseteq> set (ig_verts G) \\<times> set (ig_verts G)", "by (auto simp: ig set_ig_arcs_verts)"], ["proof (state)\nthis:\n  set (ig_arcs G) \\<subseteq> (U \\<union> V) \\<times> (U \\<union> V)\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "ultimately"], ["proof (chain)\npicking this:\n  U \\<times> V \\<subseteq> set (ig_arcs G)\n  V \\<times> U \\<subseteq> set (ig_arcs G)\n  U \\<times> U \\<inter> set (ig_arcs G) = {}\n  V \\<times> V \\<inter> set (ig_arcs G) = {}\n  set (ig_arcs G) \\<subseteq> (U \\<union> V) \\<times> (U \\<union> V)", "have conn: \"set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U\""], ["proof (prove)\nusing this:\n  U \\<times> V \\<subseteq> set (ig_arcs G)\n  V \\<times> U \\<subseteq> set (ig_arcs G)\n  U \\<times> U \\<inter> set (ig_arcs G) = {}\n  V \\<times> V \\<inter> set (ig_arcs G) = {}\n  set (ig_arcs G) \\<subseteq> (U \\<union> V) \\<times> (U \\<union> V)\n\ngoal (1 subgoal):\n 1. set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U", "by blast"], ["proof (state)\nthis:\n  set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U\n\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "interpret ppg_mkg': pair_fin_digraph \"mk_graph' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "using ig"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "by (auto intro: IGraph_imp_ppd_mkg')"], ["proof (state)\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "unfolding complete_bipartite_digraph_pair_def mkg'_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (ig_verts G)) \\<and>\n    (\\<exists>U V.\n        set (ig_verts G) = U \\<union> V \\<and>\n        U \\<inter> V = {} \\<and>\n        card U = 3 \\<and>\n        card V = 3 \\<and>\n        set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U)", "using cards UV_set conn"], ["proof (prove)\nusing this:\n  card V = 3\n  card U = 3\n  card (set (ig_verts G)) = 6\n  U \\<subseteq> set (ig_verts G)\n  V \\<subseteq> set (ig_verts G)\n  U \\<union> V = set (ig_verts G)\n  U \\<inter> V = {}\n  set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U\n\ngoal (1 subgoal):\n 1. finite (set (ig_verts G)) \\<and>\n    (\\<exists>U V.\n        set (ig_verts G) = U \\<union> V \\<and>\n        U \\<inter> V = {} \\<and>\n        card U = 3 \\<and>\n        card V = 3 \\<and>\n        set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U)", "by simp metis"], ["proof (state)\nthis:\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K33_mkg'E:\n  assumes K33: \"K\\<^bsub>3,3\\<^esub> (mk_graph' G)\"\n  assumes ig: \"IGraph_inv G\"\n  assumes colorize: \"is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\"\n  and u: \"u \\<in> set (ig_verts G)\"\n  obtains \"is_K33_component_size_inv G (ig_verts_cnt G) blue 3\"\n    \"is_K33_outer_inv G (ig_verts_cnt G) blue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from K33"], ["proof (chain)\npicking this:\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "obtain U V where\n      verts_G: \"set (ig_verts G) = U \\<union> V\" and\n      arcs_G: \"set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U\" and\n      disj_UV: \"U \\<inter> V = {}\"  and\n      card: \"card U = 3\" \"card V = 3\""], ["proof (prove)\nusing this:\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))\n\ngoal (1 subgoal):\n 1. (\\<And>U V.\n        \\<lbrakk>set (ig_verts G) = U \\<union> V;\n         set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U;\n         U \\<inter> V = {}; card U = 3; card V = 3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding complete_bipartite_digraph_pair_def mkg'_simps"], ["proof (prove)\nusing this:\n  finite (set (ig_verts G)) \\<and>\n  (\\<exists>U V.\n      set (ig_verts G) = U \\<union> V \\<and>\n      U \\<inter> V = {} \\<and>\n      card U = 3 \\<and>\n      card V = 3 \\<and>\n      set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U)\n\ngoal (1 subgoal):\n 1. (\\<And>U V.\n        \\<lbrakk>set (ig_verts G) = U \\<union> V;\n         set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U;\n         U \\<inter> V = {}; card U = 3; card V = 3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set (ig_verts G) = U \\<union> V\n  set (ig_arcs G) = U \\<times> V \\<union> V \\<times> U\n  U \\<inter> V = {}\n  card U = 3\n  card V = 3\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from colorize u"], ["proof (chain)\npicking this:\n  is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\n  u \\<in> set (ig_verts G)", "have col_adj: \"\\<And>v. v \\<in> set (ig_verts G) \\<Longrightarrow> blue v \\<longleftrightarrow> iadj G u v\""], ["proof (prove)\nusing this:\n  is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\n  u \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set (ig_verts G) \\<Longrightarrow> blue v = iadj G u v", "using is_K33_colorize_last"], ["proof (prove)\nusing this:\n  is_K33_colorize_inv G u (length (ig_in_out_arcs G u)) blue\n  u \\<in> set (ig_verts G)\n  ?u \\<in> set (ig_verts ?G) \\<Longrightarrow>\n  is_K33_colorize_inv ?G ?u (length (ig_in_out_arcs ?G ?u)) ?blue =\n  (\\<forall>v\\<in>set (ig_verts ?G). ?blue v = iadj ?G ?u v)\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set (ig_verts G) \\<Longrightarrow> blue v = iadj G u v", "by auto"], ["proof (state)\nthis:\n  ?v \\<in> set (ig_verts G) \\<Longrightarrow> blue ?v = iadj G u ?v\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have iadj_conv: \"\\<And>u v. iadj G u v \\<longleftrightarrow> (u,v) \\<in> U \\<times> V \\<union> V \\<times> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       iadj G u v = ((u, v) \\<in> U \\<times> V \\<union> V \\<times> U)", "unfolding iadj_def arcs_G"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       ((u, v) \\<in> U \\<times> V \\<union> V \\<times> U \\<or>\n        (v, u) \\<in> U \\<times> V \\<union> V \\<times> U) =\n       ((u, v) \\<in> U \\<times> V \\<union> V \\<times> U)", "by auto"], ["proof (state)\nthis:\n  iadj G ?u ?v = ((?u, ?v) \\<in> U \\<times> V \\<union> V \\<times> U)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  iadj G ?u ?v = ((?u, ?v) \\<in> U \\<times> V \\<union> V \\<times> U)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"u \\<in> U\""], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  u \\<in> U", "have \"V = {v \\<in> set (ig_verts G). blue v}\""], ["proof (prove)\nusing this:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. V = {v \\<in> set (ig_verts G). blue v}", "using disj_UV"], ["proof (prove)\nusing this:\n  u \\<in> U\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. V = {v \\<in> set (ig_verts G). blue v}", "by (auto simp: iadj_conv verts_G col_adj)"], ["proof (state)\nthis:\n  V = {v \\<in> set (ig_verts G). blue v}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  V = {v \\<in> set (ig_verts G). blue v}", "have \"is_K33_component_size_inv G (ig_verts_cnt G) blue 3\""], ["proof (prove)\nusing this:\n  V = {v \\<in> set (ig_verts G). blue v}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (ig_verts_cnt G) blue 3", "using ig card"], ["proof (prove)\nusing this:\n  V = {v \\<in> set (ig_verts G). blue v}\n  IGraph_inv G\n  card U = 3\n  card V = 3\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (ig_verts_cnt G) blue 3", "by (simp add: is_K33_component_size_last)"], ["proof (state)\nthis:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<And>v. v \\<in> U \\<union> V \\<Longrightarrow> blue v \\<longleftrightarrow> v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> U \\<union> V \\<Longrightarrow> blue v = (v \\<in> V)", "using \\<open>u \\<in> U\\<close> disj_UV"], ["proof (prove)\nusing this:\n  u \\<in> U\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> U \\<union> V \\<Longrightarrow> blue v = (v \\<in> V)", "by (auto simp: verts_G col_adj iadj_conv)"], ["proof (state)\nthis:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> V)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> V)", "have \"is_K33_outer_inv G (ig_verts_cnt G) blue\""], ["proof (prove)\nusing this:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> V)\n\ngoal (1 subgoal):\n 1. is_K33_outer_inv G (ig_verts_cnt G) blue", "using \\<open>U \\<inter> V = {}\\<close>"], ["proof (prove)\nusing this:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> V)\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. is_K33_outer_inv G (ig_verts_cnt G) blue", "by (subst is_K33_outer_last) (auto simp: arcs_G verts_G )"], ["proof (state)\nthis:\n  is_K33_outer_inv G (ig_verts_cnt G) blue\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n  is_K33_outer_inv G (ig_verts_cnt G) blue", "have ?thesis"], ["proof (prove)\nusing this:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n  is_K33_outer_inv G (ig_verts_cnt G) blue\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  u \\<in> U \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  u \\<in> U \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  u \\<in> U \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume \"u \\<in> V\""], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  u \\<in> V", "have \"U = {v \\<in> set (ig_verts G). blue v}\""], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. U = {v \\<in> set (ig_verts G). blue v}", "using disj_UV"], ["proof (prove)\nusing this:\n  u \\<in> V\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. U = {v \\<in> set (ig_verts G). blue v}", "by (auto simp: iadj_conv verts_G col_adj)"], ["proof (state)\nthis:\n  U = {v \\<in> set (ig_verts G). blue v}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  U = {v \\<in> set (ig_verts G). blue v}", "have \"is_K33_component_size_inv G (ig_verts_cnt G) blue 3\""], ["proof (prove)\nusing this:\n  U = {v \\<in> set (ig_verts G). blue v}\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (ig_verts_cnt G) blue 3", "using ig card"], ["proof (prove)\nusing this:\n  U = {v \\<in> set (ig_verts G). blue v}\n  IGraph_inv G\n  card U = 3\n  card V = 3\n\ngoal (1 subgoal):\n 1. is_K33_component_size_inv G (ig_verts_cnt G) blue 3", "by (simp add: is_K33_component_size_last)"], ["proof (state)\nthis:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<And>v. v \\<in> U \\<union> V \\<Longrightarrow> blue v \\<longleftrightarrow> v \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> U \\<union> V \\<Longrightarrow> blue v = (v \\<in> U)", "using \\<open>u \\<in> V\\<close> disj_UV"], ["proof (prove)\nusing this:\n  u \\<in> V\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> U \\<union> V \\<Longrightarrow> blue v = (v \\<in> U)", "by (auto simp: verts_G col_adj iadj_conv)"], ["proof (state)\nthis:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> U)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> U)", "have \"is_K33_outer_inv G (ig_verts_cnt G) blue\""], ["proof (prove)\nusing this:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> U)\n\ngoal (1 subgoal):\n 1. is_K33_outer_inv G (ig_verts_cnt G) blue", "using \\<open>U \\<inter> V = {}\\<close>"], ["proof (prove)\nusing this:\n  ?v \\<in> U \\<union> V \\<Longrightarrow> blue ?v = (?v \\<in> U)\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. is_K33_outer_inv G (ig_verts_cnt G) blue", "by (subst is_K33_outer_last) (auto simp: arcs_G verts_G )"], ["proof (state)\nthis:\n  is_K33_outer_inv G (ig_verts_cnt G) blue\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n  is_K33_outer_inv G (ig_verts_cnt G) blue", "have ?thesis"], ["proof (prove)\nusing this:\n  is_K33_component_size_inv G (ig_verts_cnt G) blue 3\n  is_K33_outer_inv G (ig_verts_cnt G) blue\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  u \\<in> V \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>is_K33_component_size_inv G (ig_verts_cnt G) blue 3;\n      is_K33_outer_inv G (ig_verts_cnt G) blue\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> U \\<Longrightarrow> thesis\n  u \\<in> V \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> U \\<Longrightarrow> thesis\n  u \\<in> V \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "using verts_G u"], ["proof (prove)\nusing this:\n  u \\<in> U \\<Longrightarrow> thesis\n  u \\<in> V \\<Longrightarrow> thesis\n  set (ig_verts G) = U \\<union> V\n  u \\<in> set (ig_verts G)\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K33_card:\n  assumes \"K\\<^bsub>3,3\\<^esub> (mk_graph' G)\" shows \"ig_verts_cnt G = 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 6", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 6", "from assms"], ["proof (chain)\npicking this:\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))", "have \"card (verts (mk_graph' G)) = 6\""], ["proof (prove)\nusing this:\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))\n\ngoal (1 subgoal):\n 1. card (verts (with_proj (mk_graph' G))) = 6", "unfolding complete_bipartite_digraph_pair_def"], ["proof (prove)\nusing this:\n  finite (pverts (mk_graph' G)) \\<and>\n  (\\<exists>U V.\n      pverts (mk_graph' G) = U \\<union> V \\<and>\n      U \\<inter> V = {} \\<and>\n      card U = 3 \\<and>\n      card V = 3 \\<and>\n      parcs (mk_graph' G) = U \\<times> V \\<union> V \\<times> U)\n\ngoal (1 subgoal):\n 1. card (verts (with_proj (mk_graph' G))) = 6", "by (auto simp: card_Un_disjoint)"], ["proof (state)\nthis:\n  card (verts (with_proj (mk_graph' G))) = 6\n\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 6", "then"], ["proof (chain)\npicking this:\n  card (verts (with_proj (mk_graph' G))) = 6", "show ?thesis"], ["proof (prove)\nusing this:\n  card (verts (with_proj (mk_graph' G))) = 6\n\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 6", "using distinct_ig_verts"], ["proof (prove)\nusing this:\n  card (verts (with_proj (mk_graph' G))) = 6\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 6", "by (auto simp: mkg'_simps distinct_card)"], ["proof (state)\nthis:\n  ig_verts_cnt G = 6\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input) is_K33_colorize_inv_last :: \"IGraph \\<Rightarrow> (ig_vertex \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"is_K33_colorize_inv_last G blue \\<equiv> is_K33_colorize_inv G (ig_verts G ! 0) (length (ig_in_out_arcs G (ig_verts G ! 0))) blue\""], ["", "abbreviation (input) is_K33_component_size_inv_last :: \"IGraph \\<Rightarrow> (ig_vertex \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"is_K33_component_size_inv_last G blue \\<equiv> is_K33_component_size_inv G (ig_verts_cnt G) blue 3\""], ["", "lemma is_K33_outerD:\n  assumes \"is_K33_outer_inv G (ig_verts_cnt G) blue\"\n  assumes \"i < ig_verts_cnt G\" \"j < ig_verts_cnt G\"\n  shows \"(blue (ig_verts G ! i) = blue (ig_verts G ! j)) \\<longleftrightarrow> (ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n    ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))", "using assms"], ["proof (prove)\nusing this:\n  is_K33_outer_inv G (ig_verts_cnt G) blue\n  i < ig_verts_cnt G\n  j < ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n    ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))", "unfolding is_K33_outer_last"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>set (ig_verts G).\n     \\<forall>v\\<in>set (ig_verts G).\n        (blue u = blue v) = ((u, v) \\<notin> set (ig_arcs G))\n  i < ig_verts_cnt G\n  j < ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n    ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))", "by auto"], ["", "lemma (in is_K33_impl) is_K33_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G \\<and> symmetric (mk_graph' \\<acute>G)\\<rbrace>\n    \\<acute>R :== PROC is_K33(\\<acute>G)\n  \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>R = K\\<^bsub>3,3\\<^esub>(mk_graph' \\<acute>G) \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               \\<acute>R :== PROC is_K33(\\<acute>G)\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R =\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 6\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>blue :== (\\<lambda>_. False);;\n                                   \\<acute>u :== ig_verts \\<acute>G ! 0;;\n                                   \\<acute>i :== 0;;\n                                   \\<acute>io_arcs :==\n                                   ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                   WHILE \\<acute>i < length \\<acute>io_arcs\n                                   INV named_loop ''colorize'' \n                                   DO \\<acute>v :==\nig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>u;;\n\\<acute>v\\<rightarrow>\\<acute>blue :== True;; \\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>blue_cnt :== 0;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV named_loop ''component_size'' \n                                   DO IF ig_verts \\<acute>G !\n   \\<acute>i\\<rightarrow>\\<acute>blue\nTHEN \\<acute>blue_cnt :== \\<acute>blue_cnt + 1 FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   IF \\<acute>blue_cnt \\<noteq> 3\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV named_loop ''connected_outer'' \n                                   DO \\<acute>u :==\nig_verts \\<acute>G ! \\<acute>i;;\n\\<acute>j :== 0;;\nWHILE \\<acute>j < ig_verts_cnt \\<acute>G INV named_loop ''connected_inner'' \nDO \\<acute>v :== ig_verts \\<acute>G ! \\<acute>j;;\n   IF (\\<acute>u\\<rightarrow>\\<acute>blue =\n       \\<acute>v\\<rightarrow>\\<acute>blue) \\<noteq>\n      ((\\<acute>u, \\<acute>v) \\<notin> set (ig_arcs \\<acute>G))\n   THEN RAISE \\<acute>R :== False FI;;\n   \\<acute>j :== \\<acute>j + 1 \nOD;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R =\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''colorize'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace> is_K33_colorize_inv \\<acute>G \\<acute>u \\<acute>i \\<acute>blue \\<and> \\<acute>i \\<le> length \\<acute>io_arcs\n        \\<and> \\<acute>io_arcs = ig_in_out_arcs \\<acute>G \\<acute>u \\<and> \\<acute>u = ig_verts \\<acute>G ! 0 \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> IGraph_inv \\<acute>G\n        \\<and> \\<acute>u = ig_verts \\<acute>G ! 0 \\<and> ig_verts_cnt \\<acute>G = 6\\<rbrace>\n      (MEASURE length \\<acute>io_arcs - \\<acute>i)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 6\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>blue :== (\\<lambda>_. False);;\n                                   \\<acute>u :== ig_verts \\<acute>G ! 0;;\n                                   \\<acute>i :== 0;;\n                                   \\<acute>io_arcs :==\n                                   ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                   WHILE \\<acute>i < length \\<acute>io_arcs\n                                   INV \\<lbrace>is_K33_colorize_inv\n           \\<acute>G \\<acute>u \\<acute>i \\<acute>blue \\<and>\n          \\<acute>i \\<le> length \\<acute>io_arcs \\<and>\n          \\<acute>io_arcs = ig_in_out_arcs \\<acute>G \\<acute>u \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          ig_verts_cnt \\<acute>G = 6\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      length\n       (lookup project_Nat_nat_Nat_nat_Product_Type_prod_List_list\n         io_arcs_'is_K33_' (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   DO \\<acute>v :==\nig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>u;;\n\\<acute>v\\<rightarrow>\\<acute>blue :== True;; \\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>blue_cnt :== 0;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV named_loop ''component_size'' \n                                   DO IF ig_verts \\<acute>G !\n   \\<acute>i\\<rightarrow>\\<acute>blue\nTHEN \\<acute>blue_cnt :== \\<acute>blue_cnt + 1 FI;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   IF \\<acute>blue_cnt \\<noteq> 3\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV named_loop ''connected_outer'' \n                                   DO \\<acute>u :==\nig_verts \\<acute>G ! \\<acute>i;;\n\\<acute>j :== 0;;\nWHILE \\<acute>j < ig_verts_cnt \\<acute>G INV named_loop ''connected_inner'' \nDO \\<acute>v :== ig_verts \\<acute>G ! \\<acute>j;;\n   IF (\\<acute>u\\<rightarrow>\\<acute>blue =\n       \\<acute>v\\<rightarrow>\\<acute>blue) \\<noteq>\n      ((\\<acute>u, \\<acute>v) \\<notin> set (ig_arcs \\<acute>G))\n   THEN RAISE \\<acute>R :== False FI;;\n   \\<acute>j :== \\<acute>j + 1 \nOD;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R =\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''component_size'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnnoFix _\n      (\\<lambda>blue. \\<lbrace> is_K33_component_size_inv \\<acute>G \\<acute>i \\<acute>blue \\<acute>blue_cnt\n      \\<and> \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and> \\<acute>blue = blue \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> IGraph_inv \\<acute>G\n      \\<and> ig_verts_cnt \\<acute>G = 6 \\<and> is_K33_colorize_inv_last \\<acute>G \\<acute>blue \\<rbrace>)\n      (\\<lambda>_. (MEASURE ig_verts_cnt \\<acute>G - \\<acute>i))\n      _\"\n    annotate_named_loop_var_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 6\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>blue :== (\\<lambda>_. False);;\n                                   \\<acute>u :== ig_verts \\<acute>G ! 0;;\n                                   \\<acute>i :== 0;;\n                                   \\<acute>io_arcs :==\n                                   ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                   WHILE \\<acute>i < length \\<acute>io_arcs\n                                   INV \\<lbrace>is_K33_colorize_inv\n           \\<acute>G \\<acute>u \\<acute>i \\<acute>blue \\<and>\n          \\<acute>i \\<le> length \\<acute>io_arcs \\<and>\n          \\<acute>io_arcs = ig_in_out_arcs \\<acute>G \\<acute>u \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          ig_verts_cnt \\<acute>G = 6\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      length\n       (lookup project_Nat_nat_Nat_nat_Product_Type_prod_List_list\n         io_arcs_'is_K33_' (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   DO \\<acute>v :==\nig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>u;;\n\\<acute>v\\<rightarrow>\\<acute>blue :== True;; \\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>blue_cnt :== 0;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<lbrace>\\<acute>i\n            < ig_verts_cnt \\<acute>G\\<rbrace>\n                                   FIX blue.\n                                   INV \\<lbrace>is_K33_component_size_inv\n           \\<acute>G \\<acute>i \\<acute>blue \\<acute>blue_cnt \\<and>\n          \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n          \\<acute>blue = blue \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          ig_verts_cnt \\<acute>G = 6 \\<and>\n          is_K33_colorize_inv \\<acute>G (ig_verts \\<acute>G ! 0)\n           (length (ig_in_out_arcs \\<acute>G (ig_verts \\<acute>G ! 0)))\n           \\<acute>blue\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_verts_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_K33_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   (IF ig_verts \\<acute>G !\n \\<acute>i\\<rightarrow>\\<acute>blue\n                                    THEN\n\\<acute>blue_cnt :== \\<acute>blue_cnt + 1\n                                    FI;;\n                                    \\<acute>i :== \\<acute>i + 1);;\n                                   IF \\<acute>blue_cnt \\<noteq> 3\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < ig_verts_cnt \\<acute>G\n                                   INV named_loop ''connected_outer'' \n                                   DO \\<acute>u :==\nig_verts \\<acute>G ! \\<acute>i;;\n\\<acute>j :== 0;;\nWHILE \\<acute>j < ig_verts_cnt \\<acute>G INV named_loop ''connected_inner'' \nDO \\<acute>v :== ig_verts \\<acute>G ! \\<acute>j;;\n   IF (\\<acute>u\\<rightarrow>\\<acute>blue =\n       \\<acute>v\\<rightarrow>\\<acute>blue) \\<noteq>\n      ((\\<acute>u, \\<acute>v) \\<notin> set (ig_arcs \\<acute>G))\n   THEN RAISE \\<acute>R :== False FI;;\n   \\<acute>j :== \\<acute>j + 1 \nOD;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R =\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''connected_outer'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnnoFix _\n      (\\<lambda>blue. \\<lbrace> is_K33_outer_inv \\<acute>G \\<acute>i \\<acute>blue \\<and> \\<acute>i \\<le> ig_verts_cnt \\<acute>G\n        \\<and> \\<acute>blue = blue \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> IGraph_inv \\<acute>G\n        \\<and> ig_verts_cnt \\<acute>G = 6 \\<and> is_K33_colorize_inv_last \\<acute>G \\<acute>blue \\<and> is_K33_component_size_inv_last \\<acute>G \\<acute>blue \\<rbrace>)\n      (\\<lambda>_. (MEASURE ig_verts_cnt \\<acute>G - \\<acute>i))\n      _\"\n    annotate_named_loop_var_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 6\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>blue :== (\\<lambda>_. False);;\n                                   \\<acute>u :== ig_verts \\<acute>G ! 0;;\n                                   \\<acute>i :== 0;;\n                                   \\<acute>io_arcs :==\n                                   ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                   WHILE \\<acute>i < length \\<acute>io_arcs\n                                   INV \\<lbrace>is_K33_colorize_inv\n           \\<acute>G \\<acute>u \\<acute>i \\<acute>blue \\<and>\n          \\<acute>i \\<le> length \\<acute>io_arcs \\<and>\n          \\<acute>io_arcs = ig_in_out_arcs \\<acute>G \\<acute>u \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          ig_verts_cnt \\<acute>G = 6\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      length\n       (lookup project_Nat_nat_Nat_nat_Product_Type_prod_List_list\n         io_arcs_'is_K33_' (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   DO \\<acute>v :==\nig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>u;;\n\\<acute>v\\<rightarrow>\\<acute>blue :== True;; \\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>blue_cnt :== 0;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<lbrace>\\<acute>i\n            < ig_verts_cnt \\<acute>G\\<rbrace>\n                                   FIX blue.\n                                   INV \\<lbrace>is_K33_component_size_inv\n           \\<acute>G \\<acute>i \\<acute>blue \\<acute>blue_cnt \\<and>\n          \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n          \\<acute>blue = blue \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          ig_verts_cnt \\<acute>G = 6 \\<and>\n          is_K33_colorize_inv \\<acute>G (ig_verts \\<acute>G ! 0)\n           (length (ig_in_out_arcs \\<acute>G (ig_verts \\<acute>G ! 0)))\n           \\<acute>blue\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_verts_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_K33_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   (IF ig_verts \\<acute>G !\n \\<acute>i\\<rightarrow>\\<acute>blue\n                                    THEN\n\\<acute>blue_cnt :== \\<acute>blue_cnt + 1\n                                    FI;;\n                                    \\<acute>i :== \\<acute>i + 1);;\n                                   IF \\<acute>blue_cnt \\<noteq> 3\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<lbrace>\\<acute>i\n            < ig_verts_cnt \\<acute>G\\<rbrace>\n                                   FIX blue.\n                                   INV \\<lbrace>is_K33_outer_inv \\<acute>G\n           \\<acute>i \\<acute>blue \\<and>\n          \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n          \\<acute>blue = blue \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          ig_verts_cnt \\<acute>G = 6 \\<and>\n          is_K33_colorize_inv \\<acute>G (ig_verts \\<acute>G ! 0)\n           (length (ig_in_out_arcs \\<acute>G (ig_verts \\<acute>G ! 0)))\n           \\<acute>blue \\<and>\n          is_K33_component_size_inv \\<acute>G (ig_verts_cnt \\<acute>G)\n           \\<acute>blue 3\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_verts_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_K33_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   (\\<acute>u :==\n                                    ig_verts \\<acute>G ! \\<acute>i;;\n                                    \\<acute>j :== 0;;\n                                    WHILE \\<acute>j < ig_verts_cnt \\<acute>G\n                                    INV named_loop ''connected_inner'' \n                                    DO\n\\<acute>v :== ig_verts \\<acute>G ! \\<acute>j;;\nIF (\\<acute>u\\<rightarrow>\\<acute>blue =\n    \\<acute>v\\<rightarrow>\\<acute>blue) \\<noteq>\n   ((\\<acute>u, \\<acute>v) \\<notin> set (ig_arcs \\<acute>G))\nTHEN RAISE \\<acute>R :== False FI;;\n\\<acute>j :== \\<acute>j + 1 \n                                    OD;;\n                                    \\<acute>i :== \\<acute>i + 1);;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R =\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''connected_inner'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnnoFix _\n      (\\<lambda>(i,blue). \\<lbrace> is_K33_inner_inv \\<acute>G \\<acute>i \\<acute>j \\<acute>blue \\<and> \\<acute>j \\<le> ig_verts_cnt \\<acute>G\n        \\<and> \\<acute>i = i \\<and>\\<acute>i < ig_verts_cnt \\<acute>G \\<and> \\<acute>blue = blue \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> IGraph_inv \\<acute>G \\<and> \\<acute>u = ig_verts \\<acute>G ! \\<acute>i\n        \\<and> ig_verts_cnt \\<acute>G = 6 \\<and> is_K33_colorize_inv_last \\<acute>G \\<acute>blue \\<and> is_K33_component_size_inv_last \\<acute>G \\<acute>blue \\<rbrace>)\n      (\\<lambda>_. (MEASURE ig_verts_cnt \\<acute>G - \\<acute>j))\n      _\"\n    annotate_named_loop_var_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 6\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>blue :== (\\<lambda>_. False);;\n                                   \\<acute>u :== ig_verts \\<acute>G ! 0;;\n                                   \\<acute>i :== 0;;\n                                   \\<acute>io_arcs :==\n                                   ig_in_out_arcs \\<acute>G \\<acute>u;;\n                                   WHILE \\<acute>i < length \\<acute>io_arcs\n                                   INV \\<lbrace>is_K33_colorize_inv\n           \\<acute>G \\<acute>u \\<acute>i \\<acute>blue \\<and>\n          \\<acute>i \\<le> length \\<acute>io_arcs \\<and>\n          \\<acute>io_arcs = ig_in_out_arcs \\<acute>G \\<acute>u \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          \\<acute>u = ig_verts \\<acute>G ! 0 \\<and>\n          ig_verts_cnt \\<acute>G = 6\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      length\n       (lookup project_Nat_nat_Nat_nat_Product_Type_prod_List_list\n         io_arcs_'is_K33_' (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   DO \\<acute>v :==\nig_opposite \\<acute>G (\\<acute>io_arcs ! \\<acute>i) \\<acute>u;;\n\\<acute>v\\<rightarrow>\\<acute>blue :== True;; \\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>blue_cnt :== 0;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<lbrace>\\<acute>i\n            < ig_verts_cnt \\<acute>G\\<rbrace>\n                                   FIX blue.\n                                   INV \\<lbrace>is_K33_component_size_inv\n           \\<acute>G \\<acute>i \\<acute>blue \\<acute>blue_cnt \\<and>\n          \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n          \\<acute>blue = blue \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          ig_verts_cnt \\<acute>G = 6 \\<and>\n          is_K33_colorize_inv \\<acute>G (ig_verts \\<acute>G ! 0)\n           (length (ig_in_out_arcs \\<acute>G (ig_verts \\<acute>G ! 0)))\n           \\<acute>blue\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_verts_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_K33_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   (IF ig_verts \\<acute>G !\n \\<acute>i\\<rightarrow>\\<acute>blue\n                                    THEN\n\\<acute>blue_cnt :== \\<acute>blue_cnt + 1\n                                    FI;;\n                                    \\<acute>i :== \\<acute>i + 1);;\n                                   IF \\<acute>blue_cnt \\<noteq> 3\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<lbrace>\\<acute>i\n            < ig_verts_cnt \\<acute>G\\<rbrace>\n                                   FIX blue.\n                                   INV \\<lbrace>is_K33_outer_inv \\<acute>G\n           \\<acute>i \\<acute>blue \\<and>\n          \\<acute>i \\<le> ig_verts_cnt \\<acute>G \\<and>\n          \\<acute>blue = blue \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          ig_verts_cnt \\<acute>G = 6 \\<and>\n          is_K33_colorize_inv \\<acute>G (ig_verts \\<acute>G ! 0)\n           (length (ig_in_out_arcs \\<acute>G (ig_verts \\<acute>G ! 0)))\n           \\<acute>blue \\<and>\n          is_K33_component_size_inv \\<acute>G (ig_verts_cnt \\<acute>G)\n           \\<acute>blue 3\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s.\n      ig_verts_cnt\n       (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_K33_'\n         (locals s)) -\n      lookup project_Nat_nat i_'is_K33_' (locals s)) \n                                   (\\<acute>u :==\n                                    ig_verts \\<acute>G ! \\<acute>i;;\n                                    \\<acute>j :== 0;;\n                                    WHILE \\<lbrace>\\<acute>j\n             < ig_verts_cnt \\<acute>G\\<rbrace>\n                                    FIX (i, blue).\n                                    INV \\<lbrace>is_K33_inner_inv \\<acute>G\n            \\<acute>i \\<acute>j \\<acute>blue \\<and>\n           \\<acute>j \\<le> ig_verts_cnt \\<acute>G \\<and>\n           \\<acute>i = i \\<and>\n           \\<acute>i < ig_verts_cnt \\<acute>G \\<and>\n           \\<acute>blue = blue \\<and>\n           \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n           IGraph_inv \\<acute>G \\<and>\n           \\<acute>u = ig_verts \\<acute>G ! \\<acute>i \\<and>\n           ig_verts_cnt \\<acute>G = 6 \\<and>\n           is_K33_colorize_inv \\<acute>G (ig_verts \\<acute>G ! 0)\n            (length (ig_in_out_arcs \\<acute>G (ig_verts \\<acute>G ! 0)))\n            \\<acute>blue \\<and>\n           is_K33_component_size_inv \\<acute>G (ig_verts_cnt \\<acute>G)\n            \\<acute>blue 3\\<rbrace>\n                                    VAR measure\n   (\\<lambda>s.\n       ig_verts_cnt\n        (lookup project_Check_Non_Planarity_Impl_IGraph G_'is_K33_'\n          (locals s)) -\n       lookup project_Nat_nat j_'is_K33_' (locals s)) \n                                    (\\<acute>v :==\n                                     ig_verts \\<acute>G ! \\<acute>j;;\n                                     IF (\\<acute>u\\<rightarrow>\\<acute>blue =\n   \\<acute>v\\<rightarrow>\\<acute>blue) \\<noteq>\n  ((\\<acute>u, \\<acute>v) \\<notin> set (ig_arcs \\<acute>G))\n                                     THEN RAISE \\<acute>R :== False FI;;\n                                     \\<acute>j :== \\<acute>j + 1);;\n                                    \\<acute>i :== \\<acute>i + 1);;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R =\n  K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>IGraph_inv G; symmetric (with_proj (mk_graph' G))\\<rbrakk>\n       \\<Longrightarrow> (ig_verts_cnt G \\<noteq> 6 \\<longrightarrow>\n                          G = G \\<and>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' G))) \\<and>\n                         (\\<not> ig_verts_cnt G \\<noteq> 6 \\<longrightarrow>\n                          is_K33_colorize_inv G (ig_verts G ! 0) 0\n                           (\\<lambda>_. False) \\<and>\n                          0 \\<le> length\n                                   (ig_in_out_arcs G\n                                     (ig_verts G ! 0)) \\<and>\n                          ig_in_out_arcs G (ig_verts G ! 0) =\n                          ig_in_out_arcs G (ig_verts G ! 0) \\<and>\n                          ig_verts G ! 0 = ig_verts G ! 0 \\<and>\n                          G = G \\<and>\n                          IGraph_inv G \\<and>\n                          ig_verts G ! 0 = ig_verts G ! 0 \\<and>\n                          ig_verts_cnt G = 6)\n 2. \\<And>G Ga blue i io_arcs u.\n       \\<lbrakk>is_K33_colorize_inv Ga u i blue; i \\<le> length io_arcs;\n        io_arcs = ig_in_out_arcs Ga u; u = ig_verts Ga ! 0; Ga = G;\n        IGraph_inv Ga; u = ig_verts Ga ! 0; ig_verts_cnt Ga = 6;\n        i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> length io_arcs - (i + 1)\n                         < length io_arcs - i \\<and>\n                         is_K33_colorize_inv Ga u (i + 1)\n                          (blue\n                           (ig_opposite Ga (io_arcs ! i) u := True)) \\<and>\n                         i + 1 \\<le> length io_arcs \\<and>\n                         io_arcs = ig_in_out_arcs Ga u \\<and>\n                         u = ig_verts Ga ! 0 \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         u = ig_verts Ga ! 0 \\<and> ig_verts_cnt Ga = 6\n 3. \\<And>G Ga blue i io_arcs u.\n       \\<lbrakk>is_K33_colorize_inv Ga u i blue; i \\<le> length io_arcs;\n        io_arcs = ig_in_out_arcs Ga u; u = ig_verts Ga ! 0; Ga = G;\n        IGraph_inv Ga; u = ig_verts Ga ! 0; ig_verts_cnt Ga = 6;\n        \\<not> i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> is_K33_component_size_inv Ga 0 blue 0 \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         (\\<forall>Ga bluea blue_cnt i.\n                             is_K33_component_size_inv Ga i bluea\n                              blue_cnt \\<and>\n                             i \\<le> ig_verts_cnt Ga \\<and>\n                             bluea = blue \\<and>\n                             Ga = G \\<and>\n                             IGraph_inv Ga \\<and>\n                             ig_verts_cnt Ga = 6 \\<and>\n                             is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                              (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                              bluea \\<and>\n                             \\<not> i < ig_verts_cnt Ga \\<longrightarrow>\n                             (blue_cnt \\<noteq> 3 \\<longrightarrow>\n                              \\<not> K\\<^bsub>3,3\\<^esub>\n(with_proj (mk_graph' G))) \\<and>\n                             (blue_cnt = 3 \\<longrightarrow>\n                              is_K33_outer_inv G 0 blue \\<and>\n                              0 \\<le> ig_verts_cnt G \\<and>\n                              IGraph_inv G \\<and>\n                              ig_verts_cnt G = 6 \\<and>\n                              is_K33_colorize_inv G (ig_verts G ! 0)\n                               (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                               blue \\<and>\n                              is_K33_component_size_inv G (ig_verts_cnt G)\n                               blue 3 \\<and>\n                              (\\<forall>Ga bluea i.\n                                  is_K33_outer_inv Ga i bluea \\<and>\n                                  i \\<le> ig_verts_cnt Ga \\<and>\n                                  bluea = blue \\<and>\n                                  Ga = G \\<and>\n                                  IGraph_inv Ga \\<and>\n                                  ig_verts_cnt Ga = 6 \\<and>\n                                  is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                                   (length\n                                     (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                                   bluea \\<and>\n                                  is_K33_component_size_inv Ga\n                                   (ig_verts_cnt Ga) bluea 3 \\<and>\n                                  \\<not> i\n   < ig_verts_cnt Ga \\<longrightarrow>\n                                  K\\<^bsub>3,3\\<^esub>\n                                   (with_proj (mk_graph' G)))))\n 4. \\<And>G Ga blue blue_cnt i.\n       \\<lbrakk>is_K33_component_size_inv Ga i blue blue_cnt;\n        i \\<le> ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           (blue_cnt + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue) \\<and>\n                         (\\<not> blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           blue_cnt \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue)\n 5. \\<And>G Ga blue i.\n       \\<lbrakk>is_K33_outer_inv Ga i blue; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv Ga i 0 blue \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         i < ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts Ga ! i = ig_verts Ga ! i \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue\n                          3 \\<and>\n                         (\\<forall>Gb bluea ia j u.\n                             is_K33_inner_inv Gb ia j bluea \\<and>\n                             j \\<le> ig_verts_cnt Gb \\<and>\n                             ia = i \\<and>\n                             ia < ig_verts_cnt Gb \\<and>\n                             bluea = blue \\<and>\n                             Gb = G \\<and>\n                             IGraph_inv Gb \\<and>\n                             u = ig_verts Gb ! ia \\<and>\n                             ig_verts_cnt Gb = 6 \\<and>\n                             is_K33_colorize_inv Gb (ig_verts Gb ! 0)\n                              (length (ig_in_out_arcs Gb (ig_verts Gb ! 0)))\n                              bluea \\<and>\n                             is_K33_component_size_inv Gb (ig_verts_cnt Gb)\n                              bluea 3 \\<and>\n                             \\<not> j < ig_verts_cnt Gb \\<longrightarrow>\n                             ig_verts_cnt G - (i + 1)\n                             < ig_verts_cnt Ga - i \\<and>\n                             is_K33_outer_inv G (i + 1) blue \\<and>\n                             i + 1 \\<le> ig_verts_cnt G \\<and>\n                             blue = blue \\<and>\n                             IGraph_inv G \\<and>\n                             ig_verts_cnt G = 6 \\<and>\n                             is_K33_colorize_inv G (ig_verts G ! 0)\n                              (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                              blue \\<and>\n                             is_K33_component_size_inv G (ig_verts_cnt G)\n                              blue 3)\n 6. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv Ga i j blue; j \\<le> ig_verts_cnt Ga;\n        i < ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; u = ig_verts Ga ! i;\n        ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        j < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> ((blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<notin> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<notin> set\n      (ig_arcs Ga)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (j + 1)\n                          < ig_verts_cnt Ga - j \\<and>\n                          is_K33_inner_inv Ga i (j + 1) blue \\<and>\n                          j + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          i = i \\<and>\n                          i < ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          u = ig_verts Ga ! i \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue \\<and>\n                          is_K33_component_size_inv Ga (ig_verts_cnt Ga)\n                           blue 3)", "apply (fastforce simp: is_K33_colorize_0 is_K33_component_size_0 is_K33_outer_0 is_K33_component_size_last\n         elim: K33_mkg'E dest: K33_card intro: K33_mkg'I)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>G Ga blue i io_arcs u.\n       \\<lbrakk>is_K33_colorize_inv Ga u i blue; i \\<le> length io_arcs;\n        io_arcs = ig_in_out_arcs Ga u; u = ig_verts Ga ! 0; Ga = G;\n        IGraph_inv Ga; u = ig_verts Ga ! 0; ig_verts_cnt Ga = 6;\n        i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> length io_arcs - (i + 1)\n                         < length io_arcs - i \\<and>\n                         is_K33_colorize_inv Ga u (i + 1)\n                          (blue\n                           (ig_opposite Ga (io_arcs ! i) u := True)) \\<and>\n                         i + 1 \\<le> length io_arcs \\<and>\n                         io_arcs = ig_in_out_arcs Ga u \\<and>\n                         u = ig_verts Ga ! 0 \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         u = ig_verts Ga ! 0 \\<and> ig_verts_cnt Ga = 6\n 2. \\<And>G Ga blue i io_arcs u.\n       \\<lbrakk>is_K33_colorize_inv Ga u i blue; i \\<le> length io_arcs;\n        io_arcs = ig_in_out_arcs Ga u; u = ig_verts Ga ! 0; Ga = G;\n        IGraph_inv Ga; u = ig_verts Ga ! 0; ig_verts_cnt Ga = 6;\n        \\<not> i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> is_K33_component_size_inv Ga 0 blue 0 \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         (\\<forall>Ga bluea blue_cnt i.\n                             is_K33_component_size_inv Ga i bluea\n                              blue_cnt \\<and>\n                             i \\<le> ig_verts_cnt Ga \\<and>\n                             bluea = blue \\<and>\n                             Ga = G \\<and>\n                             IGraph_inv Ga \\<and>\n                             ig_verts_cnt Ga = 6 \\<and>\n                             is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                              (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                              bluea \\<and>\n                             \\<not> i < ig_verts_cnt Ga \\<longrightarrow>\n                             (blue_cnt \\<noteq> 3 \\<longrightarrow>\n                              \\<not> K\\<^bsub>3,3\\<^esub>\n(with_proj (mk_graph' G))) \\<and>\n                             (blue_cnt = 3 \\<longrightarrow>\n                              is_K33_outer_inv G 0 blue \\<and>\n                              0 \\<le> ig_verts_cnt G \\<and>\n                              IGraph_inv G \\<and>\n                              ig_verts_cnt G = 6 \\<and>\n                              is_K33_colorize_inv G (ig_verts G ! 0)\n                               (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                               blue \\<and>\n                              is_K33_component_size_inv G (ig_verts_cnt G)\n                               blue 3 \\<and>\n                              (\\<forall>Ga bluea i.\n                                  is_K33_outer_inv Ga i bluea \\<and>\n                                  i \\<le> ig_verts_cnt Ga \\<and>\n                                  bluea = blue \\<and>\n                                  Ga = G \\<and>\n                                  IGraph_inv Ga \\<and>\n                                  ig_verts_cnt Ga = 6 \\<and>\n                                  is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                                   (length\n                                     (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                                   bluea \\<and>\n                                  is_K33_component_size_inv Ga\n                                   (ig_verts_cnt Ga) bluea 3 \\<and>\n                                  \\<not> i\n   < ig_verts_cnt Ga \\<longrightarrow>\n                                  K\\<^bsub>3,3\\<^esub>\n                                   (with_proj (mk_graph' G)))))\n 3. \\<And>G Ga blue blue_cnt i.\n       \\<lbrakk>is_K33_component_size_inv Ga i blue blue_cnt;\n        i \\<le> ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           (blue_cnt + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue) \\<and>\n                         (\\<not> blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           blue_cnt \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue)\n 4. \\<And>G Ga blue i.\n       \\<lbrakk>is_K33_outer_inv Ga i blue; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv Ga i 0 blue \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         i < ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts Ga ! i = ig_verts Ga ! i \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue\n                          3 \\<and>\n                         (\\<forall>Gb bluea ia j u.\n                             is_K33_inner_inv Gb ia j bluea \\<and>\n                             j \\<le> ig_verts_cnt Gb \\<and>\n                             ia = i \\<and>\n                             ia < ig_verts_cnt Gb \\<and>\n                             bluea = blue \\<and>\n                             Gb = G \\<and>\n                             IGraph_inv Gb \\<and>\n                             u = ig_verts Gb ! ia \\<and>\n                             ig_verts_cnt Gb = 6 \\<and>\n                             is_K33_colorize_inv Gb (ig_verts Gb ! 0)\n                              (length (ig_in_out_arcs Gb (ig_verts Gb ! 0)))\n                              bluea \\<and>\n                             is_K33_component_size_inv Gb (ig_verts_cnt Gb)\n                              bluea 3 \\<and>\n                             \\<not> j < ig_verts_cnt Gb \\<longrightarrow>\n                             ig_verts_cnt G - (i + 1)\n                             < ig_verts_cnt Ga - i \\<and>\n                             is_K33_outer_inv G (i + 1) blue \\<and>\n                             i + 1 \\<le> ig_verts_cnt G \\<and>\n                             blue = blue \\<and>\n                             IGraph_inv G \\<and>\n                             ig_verts_cnt G = 6 \\<and>\n                             is_K33_colorize_inv G (ig_verts G ! 0)\n                              (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                              blue \\<and>\n                             is_K33_component_size_inv G (ig_verts_cnt G)\n                              blue 3)\n 5. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv Ga i j blue; j \\<le> ig_verts_cnt Ga;\n        i < ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; u = ig_verts Ga ! i;\n        ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        j < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> ((blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<notin> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<notin> set\n      (ig_arcs Ga)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (j + 1)\n                          < ig_verts_cnt Ga - j \\<and>\n                          is_K33_inner_inv Ga i (j + 1) blue \\<and>\n                          j + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          i = i \\<and>\n                          i < ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          u = ig_verts Ga ! i \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue \\<and>\n                          is_K33_component_size_inv Ga (ig_verts_cnt Ga)\n                           blue 3)", "apply (fastforce simp add: is_K33_colorize_step)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G Ga blue i io_arcs u.\n       \\<lbrakk>is_K33_colorize_inv Ga u i blue; i \\<le> length io_arcs;\n        io_arcs = ig_in_out_arcs Ga u; u = ig_verts Ga ! 0; Ga = G;\n        IGraph_inv Ga; u = ig_verts Ga ! 0; ig_verts_cnt Ga = 6;\n        \\<not> i < length io_arcs\\<rbrakk>\n       \\<Longrightarrow> is_K33_component_size_inv Ga 0 blue 0 \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         (\\<forall>Ga bluea blue_cnt i.\n                             is_K33_component_size_inv Ga i bluea\n                              blue_cnt \\<and>\n                             i \\<le> ig_verts_cnt Ga \\<and>\n                             bluea = blue \\<and>\n                             Ga = G \\<and>\n                             IGraph_inv Ga \\<and>\n                             ig_verts_cnt Ga = 6 \\<and>\n                             is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                              (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                              bluea \\<and>\n                             \\<not> i < ig_verts_cnt Ga \\<longrightarrow>\n                             (blue_cnt \\<noteq> 3 \\<longrightarrow>\n                              \\<not> K\\<^bsub>3,3\\<^esub>\n(with_proj (mk_graph' G))) \\<and>\n                             (blue_cnt = 3 \\<longrightarrow>\n                              is_K33_outer_inv G 0 blue \\<and>\n                              0 \\<le> ig_verts_cnt G \\<and>\n                              IGraph_inv G \\<and>\n                              ig_verts_cnt G = 6 \\<and>\n                              is_K33_colorize_inv G (ig_verts G ! 0)\n                               (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                               blue \\<and>\n                              is_K33_component_size_inv G (ig_verts_cnt G)\n                               blue 3 \\<and>\n                              (\\<forall>Ga bluea i.\n                                  is_K33_outer_inv Ga i bluea \\<and>\n                                  i \\<le> ig_verts_cnt Ga \\<and>\n                                  bluea = blue \\<and>\n                                  Ga = G \\<and>\n                                  IGraph_inv Ga \\<and>\n                                  ig_verts_cnt Ga = 6 \\<and>\n                                  is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                                   (length\n                                     (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                                   bluea \\<and>\n                                  is_K33_component_size_inv Ga\n                                   (ig_verts_cnt Ga) bluea 3 \\<and>\n                                  \\<not> i\n   < ig_verts_cnt Ga \\<longrightarrow>\n                                  K\\<^bsub>3,3\\<^esub>\n                                   (with_proj (mk_graph' G)))))\n 2. \\<And>G Ga blue blue_cnt i.\n       \\<lbrakk>is_K33_component_size_inv Ga i blue blue_cnt;\n        i \\<le> ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           (blue_cnt + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue) \\<and>\n                         (\\<not> blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           blue_cnt \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue)\n 3. \\<And>G Ga blue i.\n       \\<lbrakk>is_K33_outer_inv Ga i blue; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv Ga i 0 blue \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         i < ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts Ga ! i = ig_verts Ga ! i \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue\n                          3 \\<and>\n                         (\\<forall>Gb bluea ia j u.\n                             is_K33_inner_inv Gb ia j bluea \\<and>\n                             j \\<le> ig_verts_cnt Gb \\<and>\n                             ia = i \\<and>\n                             ia < ig_verts_cnt Gb \\<and>\n                             bluea = blue \\<and>\n                             Gb = G \\<and>\n                             IGraph_inv Gb \\<and>\n                             u = ig_verts Gb ! ia \\<and>\n                             ig_verts_cnt Gb = 6 \\<and>\n                             is_K33_colorize_inv Gb (ig_verts Gb ! 0)\n                              (length (ig_in_out_arcs Gb (ig_verts Gb ! 0)))\n                              bluea \\<and>\n                             is_K33_component_size_inv Gb (ig_verts_cnt Gb)\n                              bluea 3 \\<and>\n                             \\<not> j < ig_verts_cnt Gb \\<longrightarrow>\n                             ig_verts_cnt G - (i + 1)\n                             < ig_verts_cnt Ga - i \\<and>\n                             is_K33_outer_inv G (i + 1) blue \\<and>\n                             i + 1 \\<le> ig_verts_cnt G \\<and>\n                             blue = blue \\<and>\n                             IGraph_inv G \\<and>\n                             ig_verts_cnt G = 6 \\<and>\n                             is_K33_colorize_inv G (ig_verts G ! 0)\n                              (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                              blue \\<and>\n                             is_K33_component_size_inv G (ig_verts_cnt G)\n                              blue 3)\n 4. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv Ga i j blue; j \\<le> ig_verts_cnt Ga;\n        i < ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; u = ig_verts Ga ! i;\n        ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        j < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> ((blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<notin> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<notin> set\n      (ig_arcs Ga)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (j + 1)\n                          < ig_verts_cnt Ga - j \\<and>\n                          is_K33_inner_inv Ga i (j + 1) blue \\<and>\n                          j + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          i = i \\<and>\n                          i < ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          u = ig_verts Ga ! i \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue \\<and>\n                          is_K33_component_size_inv Ga (ig_verts_cnt Ga)\n                           blue 3)", "apply (fastforce simp: is_K33_colorize_0 is_K33_component_size_0 is_K33_outer_0 is_K33_component_size_last\n       elim: K33_mkg'E  intro: K33_mkg'I)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G Ga blue blue_cnt i.\n       \\<lbrakk>is_K33_component_size_inv Ga i blue blue_cnt;\n        i \\<le> ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> (blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           (blue_cnt + 1) \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue) \\<and>\n                         (\\<not> blue (ig_verts Ga ! i) \\<longrightarrow>\n                          ig_verts_cnt Ga - (i + 1)\n                          < ig_verts_cnt Ga - i \\<and>\n                          is_K33_component_size_inv Ga (i + 1) blue\n                           blue_cnt \\<and>\n                          i + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue)\n 2. \\<And>G Ga blue i.\n       \\<lbrakk>is_K33_outer_inv Ga i blue; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv Ga i 0 blue \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         i < ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts Ga ! i = ig_verts Ga ! i \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue\n                          3 \\<and>\n                         (\\<forall>Gb bluea ia j u.\n                             is_K33_inner_inv Gb ia j bluea \\<and>\n                             j \\<le> ig_verts_cnt Gb \\<and>\n                             ia = i \\<and>\n                             ia < ig_verts_cnt Gb \\<and>\n                             bluea = blue \\<and>\n                             Gb = G \\<and>\n                             IGraph_inv Gb \\<and>\n                             u = ig_verts Gb ! ia \\<and>\n                             ig_verts_cnt Gb = 6 \\<and>\n                             is_K33_colorize_inv Gb (ig_verts Gb ! 0)\n                              (length (ig_in_out_arcs Gb (ig_verts Gb ! 0)))\n                              bluea \\<and>\n                             is_K33_component_size_inv Gb (ig_verts_cnt Gb)\n                              bluea 3 \\<and>\n                             \\<not> j < ig_verts_cnt Gb \\<longrightarrow>\n                             ig_verts_cnt G - (i + 1)\n                             < ig_verts_cnt Ga - i \\<and>\n                             is_K33_outer_inv G (i + 1) blue \\<and>\n                             i + 1 \\<le> ig_verts_cnt G \\<and>\n                             blue = blue \\<and>\n                             IGraph_inv G \\<and>\n                             ig_verts_cnt G = 6 \\<and>\n                             is_K33_colorize_inv G (ig_verts G ! 0)\n                              (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                              blue \\<and>\n                             is_K33_component_size_inv G (ig_verts_cnt G)\n                              blue 3)\n 3. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv Ga i j blue; j \\<le> ig_verts_cnt Ga;\n        i < ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; u = ig_verts Ga ! i;\n        ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        j < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> ((blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<notin> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<notin> set\n      (ig_arcs Ga)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (j + 1)\n                          < ig_verts_cnt Ga - j \\<and>\n                          is_K33_inner_inv Ga i (j + 1) blue \\<and>\n                          j + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          i = i \\<and>\n                          i < ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          u = ig_verts Ga ! i \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue \\<and>\n                          is_K33_component_size_inv Ga (ig_verts_cnt Ga)\n                           blue 3)", "apply (fastforce simp: is_K33_component_size_step1 is_K33_component_size_step2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G Ga blue i.\n       \\<lbrakk>is_K33_outer_inv Ga i blue; i \\<le> ig_verts_cnt Ga; Ga = G;\n        IGraph_inv Ga; ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        i < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv Ga i 0 blue \\<and>\n                         0 \\<le> ig_verts_cnt Ga \\<and>\n                         i < ig_verts_cnt Ga \\<and>\n                         Ga = G \\<and>\n                         IGraph_inv Ga \\<and>\n                         ig_verts Ga ! i = ig_verts Ga ! i \\<and>\n                         ig_verts_cnt Ga = 6 \\<and>\n                         is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                          (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                          blue \\<and>\n                         is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue\n                          3 \\<and>\n                         (\\<forall>Gb bluea ia j u.\n                             is_K33_inner_inv Gb ia j bluea \\<and>\n                             j \\<le> ig_verts_cnt Gb \\<and>\n                             ia = i \\<and>\n                             ia < ig_verts_cnt Gb \\<and>\n                             bluea = blue \\<and>\n                             Gb = G \\<and>\n                             IGraph_inv Gb \\<and>\n                             u = ig_verts Gb ! ia \\<and>\n                             ig_verts_cnt Gb = 6 \\<and>\n                             is_K33_colorize_inv Gb (ig_verts Gb ! 0)\n                              (length (ig_in_out_arcs Gb (ig_verts Gb ! 0)))\n                              bluea \\<and>\n                             is_K33_component_size_inv Gb (ig_verts_cnt Gb)\n                              bluea 3 \\<and>\n                             \\<not> j < ig_verts_cnt Gb \\<longrightarrow>\n                             ig_verts_cnt G - (i + 1)\n                             < ig_verts_cnt Ga - i \\<and>\n                             is_K33_outer_inv G (i + 1) blue \\<and>\n                             i + 1 \\<le> ig_verts_cnt G \\<and>\n                             blue = blue \\<and>\n                             IGraph_inv G \\<and>\n                             ig_verts_cnt G = 6 \\<and>\n                             is_K33_colorize_inv G (ig_verts G ! 0)\n                              (length (ig_in_out_arcs G (ig_verts G ! 0)))\n                              blue \\<and>\n                             is_K33_component_size_inv G (ig_verts_cnt G)\n                              blue 3)\n 2. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv Ga i j blue; j \\<le> ig_verts_cnt Ga;\n        i < ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; u = ig_verts Ga ! i;\n        ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        j < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> ((blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<notin> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<notin> set\n      (ig_arcs Ga)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (j + 1)\n                          < ig_verts_cnt Ga - j \\<and>\n                          is_K33_inner_inv Ga i (j + 1) blue \\<and>\n                          j + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          i = i \\<and>\n                          i < ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          u = ig_verts Ga ! i \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue \\<and>\n                          is_K33_component_size_inv Ga (ig_verts_cnt Ga)\n                           blue 3)", "apply (fastforce simp: is_K33_inner_0 is_K33_outer_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv Ga i j blue; j \\<le> ig_verts_cnt Ga;\n        i < ig_verts_cnt Ga; Ga = G; IGraph_inv Ga; u = ig_verts Ga ! i;\n        ig_verts_cnt Ga = 6;\n        is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n         (length (ig_in_out_arcs Ga (ig_verts Ga ! 0))) blue;\n        is_K33_component_size_inv Ga (ig_verts_cnt Ga) blue 3;\n        j < ig_verts_cnt Ga\\<rbrakk>\n       \\<Longrightarrow> ((blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<notin> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (blue u = blue (ig_verts Ga ! j)) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<notin> set\n      (ig_arcs Ga)) \\<longrightarrow>\n                          ig_verts_cnt Ga - (j + 1)\n                          < ig_verts_cnt Ga - j \\<and>\n                          is_K33_inner_inv Ga i (j + 1) blue \\<and>\n                          j + 1 \\<le> ig_verts_cnt Ga \\<and>\n                          i = i \\<and>\n                          i < ig_verts_cnt Ga \\<and>\n                          blue = blue \\<and>\n                          Ga = G \\<and>\n                          IGraph_inv Ga \\<and>\n                          u = ig_verts Ga ! i \\<and>\n                          ig_verts_cnt Ga = 6 \\<and>\n                          is_K33_colorize_inv Ga (ig_verts Ga ! 0)\n                           (length (ig_in_out_arcs Ga (ig_verts Ga ! 0)))\n                           blue \\<and>\n                          is_K33_component_size_inv Ga (ig_verts_cnt Ga)\n                           blue 3)", "apply (simp only: simp_thms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6\\<rbrakk>\n       \\<Longrightarrow> ((blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n                          ((ig_verts G ! i, ig_verts G ! j)\n                           \\<in> set (ig_arcs G)) \\<longrightarrow>\n                          \\<not> K\\<^bsub>3,3\\<^esub>\n                                  (with_proj (mk_graph' G))) \\<and>\n                         ((blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n                          ((ig_verts G ! i, ig_verts G ! j)\n                           \\<notin> set (ig_arcs G)) \\<longrightarrow>\n                          6 - (j + 1) < 6 - j \\<and>\n                          is_K33_inner_inv G i (j + 1) blue \\<and>\n                          j + 1 \\<le> 6)", "apply (intro conjI allI impI notI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<in> set (ig_arcs G));\n        K\\<^bsub>3,3\\<^esub> (with_proj (mk_graph' G))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> 6 - (j + 1) < 6 - j\n 3. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv G i (j + 1) blue\n 4. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> j + 1 \\<le> 6", "apply (fastforce elim: K33_mkg'E dest: is_K33_outerD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> 6 - (j + 1) < 6 - j\n 2. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv G i (j + 1) blue\n 3. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> j + 1 \\<le> 6", "apply (fastforce elim: K33_mkg'E dest: is_K33_outerD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> is_K33_inner_inv G i (j + 1) blue\n 2. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> j + 1 \\<le> 6", "apply (simp add: is_K33_inner_step; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G Ga blue i j u.\n       \\<lbrakk>is_K33_inner_inv G i j blue; j \\<le> 6; i < 6; Ga = G;\n        IGraph_inv G; u = ig_verts G ! i; ig_verts_cnt G = 6;\n        is_K33_colorize_inv G (ig_verts G ! 0)\n         (length (ig_in_out_arcs G (ig_verts G ! 0))) blue;\n        is_K33_component_size_inv G 6 blue 3; j < 6;\n        (blue (ig_verts G ! i) = blue (ig_verts G ! j)) =\n        ((ig_verts G ! i, ig_verts G ! j) \\<notin> set (ig_arcs G))\\<rbrakk>\n       \\<Longrightarrow> j + 1 \\<le> 6", "apply linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Procedure @{term is_K5}\\<close>"], ["", "definition\n  \"is_K5_outer_inv G k \\<equiv> \\<forall>i<k. \\<forall>v \\<in> set (ig_verts G). ig_verts G ! i \\<noteq> v\n    \\<longleftrightarrow> (ig_verts G ! i, v) \\<in> set (ig_arcs G)\""], ["", "definition\n  \"is_K5_inner_inv G k l \\<equiv> \\<forall>j < l. ig_verts G ! k \\<noteq> ig_verts G ! j\n    \\<longleftrightarrow> (ig_verts G ! k, ig_verts G ! j) \\<in> set (ig_arcs G)\""], ["", "lemma K5_card:\n  assumes \"K\\<^bsub>5\\<^esub> (mk_graph' G)\" shows \"ig_verts_cnt G = 5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 5", "using assms distinct_ig_verts"], ["proof (prove)\nusing this:\n  K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 5", "unfolding complete_digraph_pair_def"], ["proof (prove)\nusing this:\n  finite (pverts (mk_graph' G)) \\<and>\n  card (pverts (mk_graph' G)) = 5 \\<and>\n  parcs (mk_graph' G) =\n  {(u, v).\n   (u, v) \\<in> pverts (mk_graph' G) \\<times> pverts (mk_graph' G) \\<and>\n   u \\<noteq> v}\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 5", "by (auto simp add: mkg'_simps distinct_card)"], ["", "lemma is_K5_inner_0: \"is_K5_inner_inv G k 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k 0", "unfolding is_K5_inner_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<0.\n       (ig_verts G ! k \\<noteq> ig_verts G ! j) =\n       ((ig_verts G ! k, ig_verts G ! j) \\<in> set (ig_arcs G))", "by auto"], ["", "lemma is_K5_inner_last:\n  assumes \"l = ig_verts_cnt G\"\n  shows \"is_K5_inner_inv G k l \\<longleftrightarrow> (\\<forall>v \\<in> set (ig_verts G). ig_verts G ! k \\<noteq> v\n    \\<longleftrightarrow> (ig_verts G ! k, v) \\<in> set (ig_arcs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k l =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! k \\<noteq> v) =\n        ((ig_verts G ! k, v) \\<in> set (ig_arcs G)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k l =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! k \\<noteq> v) =\n        ((ig_verts G ! k, v) \\<in> set (ig_arcs G)))", "have \"\\<And>v. v \\<in> set (ig_verts G) \\<Longrightarrow> \\<exists>j<ig_verts_cnt G. ig_verts G ! j = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set (ig_verts G) \\<Longrightarrow>\n       \\<exists>j<ig_verts_cnt G. ig_verts G ! j = v", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  ?v \\<in> set (ig_verts G) \\<Longrightarrow>\n  \\<exists>j<ig_verts_cnt G. ig_verts G ! j = ?v\n\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k l =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! k \\<noteq> v) =\n        ((ig_verts G ! k, v) \\<in> set (ig_arcs G)))", "then"], ["proof (chain)\npicking this:\n  ?v \\<in> set (ig_verts G) \\<Longrightarrow>\n  \\<exists>j<ig_verts_cnt G. ig_verts G ! j = ?v", "show ?thesis"], ["proof (prove)\nusing this:\n  ?v \\<in> set (ig_verts G) \\<Longrightarrow>\n  \\<exists>j<ig_verts_cnt G. ig_verts G ! j = ?v\n\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k l =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! k \\<noteq> v) =\n        ((ig_verts G ! k, v) \\<in> set (ig_arcs G)))", "using assms"], ["proof (prove)\nusing this:\n  ?v \\<in> set (ig_verts G) \\<Longrightarrow>\n  \\<exists>j<ig_verts_cnt G. ig_verts G ! j = ?v\n  l = ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k l =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! k \\<noteq> v) =\n        ((ig_verts G ! k, v) \\<in> set (ig_arcs G)))", "unfolding is_K5_inner_inv_def"], ["proof (prove)\nusing this:\n  ?v \\<in> set (ig_verts G) \\<Longrightarrow>\n  \\<exists>j<ig_verts_cnt G. ig_verts G ! j = ?v\n  l = ig_verts_cnt G\n\ngoal (1 subgoal):\n 1. (\\<forall>j<l.\n        (ig_verts G ! k \\<noteq> ig_verts G ! j) =\n        ((ig_verts G ! k, ig_verts G ! j) \\<in> set (ig_arcs G))) =\n    (\\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! k \\<noteq> v) =\n        ((ig_verts G ! k, v) \\<in> set (ig_arcs G)))", "by auto metis"], ["proof (state)\nthis:\n  is_K5_inner_inv G k l =\n  (\\<forall>v\\<in>set (ig_verts G).\n      (ig_verts G ! k \\<noteq> v) =\n      ((ig_verts G ! k, v) \\<in> set (ig_arcs G)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_K5_outer_step:\n  assumes \"is_K5_outer_inv G k\"\n  assumes \"is_K5_inner_inv G k (ig_verts_cnt G)\"\n  shows \"is_K5_outer_inv G (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K5_outer_inv G (Suc k)", "using assms"], ["proof (prove)\nusing this:\n  is_K5_outer_inv G k\n  is_K5_inner_inv G k (ig_verts_cnt G)\n\ngoal (1 subgoal):\n 1. is_K5_outer_inv G (Suc k)", "unfolding is_K5_outer_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>i<k.\n     \\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! i \\<noteq> v) =\n        ((ig_verts G ! i, v) \\<in> set (ig_arcs G))\n  is_K5_inner_inv G k (ig_verts_cnt G)\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc k.\n       \\<forall>v\\<in>set (ig_verts G).\n          (ig_verts G ! i \\<noteq> v) =\n          ((ig_verts G ! i, v) \\<in> set (ig_arcs G))", "by (auto simp: is_K5_inner_last elim: less_SucE)"], ["", "lemma is_K5_outer_last:\n  assumes \"is_K5_outer_inv G (ig_verts_cnt G)\"\n  assumes \"IGraph_inv G\" \"ig_verts_cnt G = 5\" \"symmetric (mk_graph' G)\"\n  shows \"K\\<^bsub>5\\<^esub> (mk_graph' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "interpret ppg_mkg': pair_fin_digraph \"mk_graph' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "using assms(2)"], ["proof (prove)\nusing this:\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_graph' G)", "by (auto intro: IGraph_imp_ppd_mkg')"], ["proof (state)\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "have \"\\<And>u v. (u, v) \\<in> set (ig_arcs G) \\<Longrightarrow> u \\<noteq> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> set (ig_arcs G) \\<Longrightarrow> u \\<noteq> v", "using assms(1,2)"], ["proof (prove)\nusing this:\n  is_K5_outer_inv G (ig_verts_cnt G)\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> set (ig_arcs G) \\<Longrightarrow> u \\<noteq> v", "unfolding is_K5_outer_inv_def ig_verts_cnt_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (ig_verts G).\n     \\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! i \\<noteq> v) =\n        ((ig_verts G ! i, v) \\<in> set (ig_arcs G))\n  IGraph_inv G\n\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> set (ig_arcs G) \\<Longrightarrow> u \\<noteq> v", "by (metis  in_set_conv_nth set_ig_arcs_verts(2))"], ["proof (state)\nthis:\n  (?u1, ?v1) \\<in> set (ig_arcs G) \\<Longrightarrow> ?u1 \\<noteq> ?v1\n\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "then"], ["proof (chain)\npicking this:\n  (?u1, ?v1) \\<in> set (ig_arcs G) \\<Longrightarrow> ?u1 \\<noteq> ?v1", "interpret ppg_mkg': pair_graph \"(mk_graph' G)\""], ["proof (prove)\nusing this:\n  (?u1, ?v1) \\<in> set (ig_arcs G) \\<Longrightarrow> ?u1 \\<noteq> ?v1\n\ngoal (1 subgoal):\n 1. pair_graph (mk_graph' G)", "using assms(4)"], ["proof (prove)\nusing this:\n  (?u1, ?v1) \\<in> set (ig_arcs G) \\<Longrightarrow> ?u1 \\<noteq> ?v1\n  symmetric (with_proj (mk_graph' G))\n\ngoal (1 subgoal):\n 1. pair_graph (mk_graph' G)", "by unfold_locales (auto simp: mkg'_simps arc_to_ends_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "have \"\\<And>a b. a \\<in> pverts (mk_graph' G) \\<Longrightarrow>\n           b \\<in> pverts (mk_graph' G) \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> (a, b) \\<in> parcs (mk_graph' G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> pverts (mk_graph' G); b \\<in> pverts (mk_graph' G);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> parcs (mk_graph' G)", "using assms(1)"], ["proof (prove)\nusing this:\n  is_K5_outer_inv G (ig_verts_cnt G)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> pverts (mk_graph' G); b \\<in> pverts (mk_graph' G);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> parcs (mk_graph' G)", "unfolding is_K5_outer_inv_def mkg'_simps"], ["proof (prove)\nusing this:\n  \\<forall>i<ig_verts_cnt G.\n     \\<forall>v\\<in>set (ig_verts G).\n        (ig_verts G ! i \\<noteq> v) =\n        ((ig_verts G ! i, v) \\<in> set (ig_arcs G))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set (ig_verts G); b \\<in> set (ig_verts G);\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> set (ig_arcs G)", "by (metis in_set_conv_nth ig_verts_cnt_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?a1 \\<in> pverts (mk_graph' G); ?b1 \\<in> pverts (mk_graph' G);\n   ?a1 \\<noteq> ?b1\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> parcs (mk_graph' G)\n\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?a1 \\<in> pverts (mk_graph' G); ?b1 \\<in> pverts (mk_graph' G);\n   ?a1 \\<noteq> ?b1\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> parcs (mk_graph' G)\n\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "have \"card (pverts (mk_graph' G)) = 5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (pverts (mk_graph' G)) = 5", "using \\<open>ig_verts_cnt G = 5\\<close> distinct_ig_verts"], ["proof (prove)\nusing this:\n  ig_verts_cnt G = 5\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. card (pverts (mk_graph' G)) = 5", "by (auto simp: mkg'_simps distinct_card)"], ["proof (state)\nthis:\n  card (pverts (mk_graph' G)) = 5\n\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a1 \\<in> pverts (mk_graph' G); ?b1 \\<in> pverts (mk_graph' G);\n   ?a1 \\<noteq> ?b1\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> parcs (mk_graph' G)\n  card (pverts (mk_graph' G)) = 5", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a1 \\<in> pverts (mk_graph' G); ?b1 \\<in> pverts (mk_graph' G);\n   ?a1 \\<noteq> ?b1\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> parcs (mk_graph' G)\n  card (pverts (mk_graph' G)) = 5\n\ngoal (1 subgoal):\n 1. K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))", "unfolding complete_digraph_pair_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a1 \\<in> pverts (mk_graph' G); ?b1 \\<in> pverts (mk_graph' G);\n   ?a1 \\<noteq> ?b1\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> parcs (mk_graph' G)\n  card (pverts (mk_graph' G)) = 5\n\ngoal (1 subgoal):\n 1. finite (pverts (mk_graph' G)) \\<and>\n    card (pverts (mk_graph' G)) = 5 \\<and>\n    parcs (mk_graph' G) =\n    {(u, v).\n     (u, v) \\<in> pverts (mk_graph' G) \\<times> pverts (mk_graph' G) \\<and>\n     u \\<noteq> v}", "by (auto dest: ppg_mkg'.in_arcsD1 ppg_mkg'.in_arcsD2 ppg_mkg'.no_loops')"], ["proof (state)\nthis:\n  K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_K5_inner_step:\n  assumes \"is_K5_inner_inv G k l\"\n  assumes \"k < ig_verts_cnt G\"\n  assumes \"k \\<noteq> l \\<longleftrightarrow> (ig_verts G ! k, ig_verts G ! l) \\<in> set (ig_arcs G)\"\n  shows \"is_K5_inner_inv G k (Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k (Suc l)", "using assms distinct_ig_verts"], ["proof (prove)\nusing this:\n  is_K5_inner_inv G k l\n  k < ig_verts_cnt G\n  (k \\<noteq> l) = ((ig_verts G ! k, ig_verts G ! l) \\<in> set (ig_arcs G))\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. is_K5_inner_inv G k (Suc l)", "unfolding is_K5_inner_inv_def"], ["proof (prove)\nusing this:\n  \\<forall>j<l.\n     (ig_verts G ! k \\<noteq> ig_verts G ! j) =\n     ((ig_verts G ! k, ig_verts G ! j) \\<in> set (ig_arcs G))\n  k < ig_verts_cnt G\n  (k \\<noteq> l) = ((ig_verts G ! k, ig_verts G ! l) \\<in> set (ig_arcs G))\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. \\<forall>j<Suc l.\n       (ig_verts G ! k \\<noteq> ig_verts G ! j) =\n       ((ig_verts G ! k, ig_verts G ! j) \\<in> set (ig_arcs G))", "apply (auto elim: less_SucE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>\\<forall>ja<l.\n                   (ig_verts G ! j \\<noteq> ig_verts G ! ja) =\n                   ((ig_verts G ! j, ig_verts G ! ja)\n                    \\<in> set (ig_arcs G));\n        k < length (ig_verts G); \\<And>G. distinct (ig_verts G); j < Suc l;\n        k \\<noteq> l;\n        (ig_verts G ! j, ig_verts G ! l) \\<in> set (ig_arcs G);\n        (ig_verts G ! j, ig_verts G ! j) \\<in> set (ig_arcs G);\n        ig_verts G ! k = ig_verts G ! j\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis (hide_lams, no_types) Suc_lessD less_SucE less_trans_Suc linorder_neqE_nat nth_eq_iff_index_eq)"], ["", "lemma iK5E:\n  assumes \"K\\<^bsub>5\\<^esub> (mk_graph' G)\"\n  obtains \"ig_verts_cnt G = 5\" \"\\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk> \\<Longrightarrow> i \\<noteq> j \\<longleftrightarrow> (ig_verts G ! i, ig_verts G ! j) \\<in> set (ig_arcs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>ig_verts_cnt G = 5;\n      \\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk>\n      \\<Longrightarrow> (i \\<noteq> j) =\n                        ((ig_verts G ! i, ig_verts G ! j)\n                         \\<in> set (ig_arcs G))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lbrakk>ig_verts_cnt G = 5;\n      \\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk>\n      \\<Longrightarrow> (i \\<noteq> j) =\n                        ((ig_verts G ! i, ig_verts G ! j)\n                         \\<in> set (ig_arcs G))\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ig_verts_cnt G = 5\n 2. \\<lbrakk>\\<lbrakk>ig_verts_cnt G = 5;\n              \\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk>\n              \\<Longrightarrow> (i \\<noteq> j) =\n                                ((ig_verts G ! i, ig_verts G ! j)\n                                 \\<in> set (ig_arcs G))\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk>\n    \\<Longrightarrow> (i \\<noteq> j) =\n                      ((ig_verts G ! i, ig_verts G ! j)\n                       \\<in> set (ig_arcs G))", "show \"ig_verts_cnt G = 5\"\n      \"i < ig_verts_cnt G \\<Longrightarrow> j < ig_verts_cnt G \\<Longrightarrow>\n        (i \\<noteq> j) = ((ig_verts G ! i, ig_verts G ! j) \\<in> set (ig_arcs G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 5 &&&\n    (\\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk>\n     \\<Longrightarrow> (i \\<noteq> j) =\n                       ((ig_verts G ! i, ig_verts G ! j)\n                        \\<in> set (ig_arcs G)))", "using assms distinct_ig_verts"], ["proof (prove)\nusing this:\n  K\\<^bsub>5\\<^esub> (with_proj (mk_graph' G))\n  distinct (ig_verts ?G)\n\ngoal (1 subgoal):\n 1. ig_verts_cnt G = 5 &&&\n    (\\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk>\n     \\<Longrightarrow> (i \\<noteq> j) =\n                       ((ig_verts G ! i, ig_verts G ! j)\n                        \\<in> set (ig_arcs G)))", "by (auto simp: complete_digraph_pair_def mkg'_simps distinct_card nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  ig_verts_cnt G = 5\n  \\<lbrakk>i < ig_verts_cnt G; j < ig_verts_cnt G\\<rbrakk>\n  \\<Longrightarrow> (i \\<noteq> j) =\n                    ((ig_verts G ! i, ig_verts G ! j) \\<in> set (ig_arcs G))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in is_K5_impl) is_K5_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv \\<acute>G \\<and> symmetric (mk_graph' \\<acute>G)\\<rbrace>\n    \\<acute>R :== PROC is_K5(\\<acute>G)\n  \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>R = K\\<^bsub>5\\<^esub>(mk_graph' \\<acute>G) \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               \\<acute>R :== PROC is_K5(\\<acute>G)\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R = K\\<^bsub>5\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 5\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < 5\n                                   INV named_loop ''outer_loop'' \n                                   DO \\<acute>u :==\nig_verts \\<acute>G ! \\<acute>i;;\n\\<acute>j :== 0;;\nWHILE \\<acute>j < 5 INV named_loop ''inner_loop'' \nDO IF (\\<acute>i \\<noteq> \\<acute>j) \\<noteq>\n      ((\\<acute>u, ig_verts \\<acute>G ! \\<acute>j)\n       \\<in> set (ig_arcs \\<acute>G))\n   THEN RAISE \\<acute>R :== False FI;;\n   \\<acute>j :== \\<acute>j + 1 \nOD;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R = K\\<^bsub>5\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''outer_loop'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnno _\n      \\<lbrace> is_K5_outer_inv \\<acute>G \\<acute>i \\<and>\\<acute>i \\<le> 5 \\<and> IGraph_inv \\<acute>G \\<and> symmetric (mk_graph' \\<acute>G) \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> ig_verts_cnt \\<acute>G = 5 \\<rbrace>\n      (MEASURE 5 - \\<acute>i)\n      _\"\n    annotate_named_loop_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 5\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < 5\n                                   INV \\<lbrace>is_K5_outer_inv \\<acute>G\n           \\<acute>i \\<and>\n          \\<acute>i \\<le> 5 \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          symmetric (with_proj (mk_graph' \\<acute>G)) \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          ig_verts_cnt \\<acute>G = 5\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s. 5 - lookup project_Nat_nat i_'is_K5_' (locals s)) \n                                   DO \\<acute>u :==\nig_verts \\<acute>G ! \\<acute>i;;\n\\<acute>j :== 0;;\nWHILE \\<acute>j < 5 INV named_loop ''inner_loop'' \nDO IF (\\<acute>i \\<noteq> \\<acute>j) \\<noteq>\n      ((\\<acute>u, ig_verts \\<acute>G ! \\<acute>j)\n       \\<in> set (ig_arcs \\<acute>G))\n   THEN RAISE \\<acute>R :== False FI;;\n   \\<acute>j :== \\<acute>j + 1 \nOD;;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R = K\\<^bsub>5\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply (rewrite\n    at \"whileAnno _ (named_loop ''inner_loop'') _ _\"\n    in for (\\<sigma>)\n    to \"whileAnnoFix _\n      (\\<lambda>i. \\<lbrace> is_K5_inner_inv \\<acute>G \\<acute>i \\<acute>j\n        \\<and> \\<acute>j \\<le> 5 \\<and> \\<acute>i < 5 \\<and> IGraph_inv \\<acute>G \\<and> symmetric (mk_graph' \\<acute>G) \\<and> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>i = i\n        \\<and> ig_verts_cnt \\<acute>G = 5 \\<and> \\<acute>u = ig_verts \\<acute>G ! \\<acute>i\\<rbrace>)\n      (\\<lambda>_. (MEASURE 5 - \\<acute>j))\n      _\"\n    annotate_named_loop_var_fix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. IGraph_inv\n             \\<acute>G \\<and>\n            symmetric (with_proj (mk_graph' \\<acute>G))\\<rbrace>\n                               TRY IF ig_verts_cnt \\<acute>G \\<noteq> 5\n                                   THEN RAISE \\<acute>R :== False FI;;\n                                   \\<acute>i :== 0;;\n                                   WHILE \\<acute>i < 5\n                                   INV \\<lbrace>is_K5_outer_inv \\<acute>G\n           \\<acute>i \\<and>\n          \\<acute>i \\<le> 5 \\<and>\n          IGraph_inv \\<acute>G \\<and>\n          symmetric (with_proj (mk_graph' \\<acute>G)) \\<and>\n          \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n          ig_verts_cnt \\<acute>G = 5\\<rbrace>\n                                   VAR measure\n  (\\<lambda>s. 5 - lookup project_Nat_nat i_'is_K5_' (locals s)) \n                                   DO \\<acute>u :==\nig_verts \\<acute>G ! \\<acute>i;;\n\\<acute>j :== 0;;\nWHILE \\<lbrace>\\<acute>j < 5\\<rbrace> FIX i.\nINV \\<lbrace>is_K5_inner_inv \\<acute>G \\<acute>i \\<acute>j \\<and>\n             \\<acute>j \\<le> 5 \\<and>\n             \\<acute>i < 5 \\<and>\n             IGraph_inv \\<acute>G \\<and>\n             symmetric (with_proj (mk_graph' \\<acute>G)) \\<and>\n             \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n             \\<acute>i = i \\<and>\n             ig_verts_cnt \\<acute>G = 5 \\<and>\n             \\<acute>u = ig_verts \\<acute>G ! \\<acute>i\\<rbrace>\nVAR measure (\\<lambda>s. 5 - lookup project_Nat_nat j_'is_K5_' (locals s)) \n(IF (\\<acute>i \\<noteq> \\<acute>j) \\<noteq>\n    ((\\<acute>u, ig_verts \\<acute>G ! \\<acute>j)\n     \\<in> set (ig_arcs \\<acute>G))\n THEN RAISE \\<acute>R :== False FI;;\n \\<acute>j :== \\<acute>j + 1);;\n\\<acute>i :== \\<acute>i + 1 \n                                   OD;;\n                                   \\<acute>R :== True\n                               CATCH SKIP END\n                               \\<lbrace>\\<acute>G =\n  \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n  \\<acute>R = K\\<^bsub>5\\<^esub> (with_proj (mk_graph' \\<acute>G))\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G.\n       \\<lbrakk>IGraph_inv G; symmetric (with_proj (mk_graph' G))\\<rbrakk>\n       \\<Longrightarrow> (ig_verts_cnt G \\<noteq> 5 \\<longrightarrow>\n                          G = G \\<and>\n                          \\<not> K\\<^bsub>5\\<^esub>\n                                  (with_proj (mk_graph' G))) \\<and>\n                         (\\<not> ig_verts_cnt G \\<noteq> 5 \\<longrightarrow>\n                          is_K5_outer_inv G 0 \\<and>\n                          0 \\<le> 5 \\<and>\n                          IGraph_inv G \\<and>\n                          symmetric (with_proj (mk_graph' G)) \\<and>\n                          G = G \\<and> ig_verts_cnt G = 5)\n 2. \\<And>G Ga i.\n       \\<lbrakk>is_K5_outer_inv Ga i; i \\<le> 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        i < 5\\<rbrakk>\n       \\<Longrightarrow> is_K5_inner_inv Ga i 0 \\<and>\n                         0 \\<le> 5 \\<and>\n                         i < 5 \\<and>\n                         IGraph_inv Ga \\<and>\n                         symmetric (with_proj (mk_graph' Ga)) \\<and>\n                         Ga = G \\<and>\n                         ig_verts_cnt Ga = 5 \\<and>\n                         ig_verts Ga ! i = ig_verts Ga ! i \\<and>\n                         (\\<forall>Ga ia j u.\n                             is_K5_inner_inv Ga ia j \\<and>\n                             j \\<le> 5 \\<and>\n                             ia < 5 \\<and>\n                             IGraph_inv Ga \\<and>\n                             symmetric (with_proj (mk_graph' Ga)) \\<and>\n                             Ga = G \\<and>\n                             ia = i \\<and>\n                             ig_verts_cnt Ga = 5 \\<and>\n                             u = ig_verts Ga ! ia \\<and>\n                             \\<not> j < 5 \\<longrightarrow>\n                             5 - (i + 1) < 5 - i \\<and>\n                             is_K5_outer_inv G (i + 1) \\<and>\n                             i + 1 \\<le> 5 \\<and>\n                             IGraph_inv G \\<and>\n                             symmetric (with_proj (mk_graph' G)) \\<and>\n                             ig_verts_cnt G = 5)\n 3. \\<And>G Ga i j u.\n       \\<lbrakk>is_K5_inner_inv Ga i j; j \\<le> 5; i < 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        u = ig_verts Ga ! i; j < 5\\<rbrakk>\n       \\<Longrightarrow> ((i \\<noteq> j) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<in> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>5\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (i \\<noteq> j) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<in> set (ig_arcs Ga)) \\<longrightarrow>\n                          5 - (j + 1) < 5 - j \\<and>\n                          is_K5_inner_inv Ga i (j + 1) \\<and>\n                          j + 1 \\<le> 5 \\<and>\n                          i < 5 \\<and>\n                          IGraph_inv Ga \\<and>\n                          symmetric (with_proj (mk_graph' Ga)) \\<and>\n                          Ga = G \\<and>\n                          i = i \\<and>\n                          ig_verts_cnt Ga = 5 \\<and> u = ig_verts Ga ! i)\n 4. \\<And>G Ga i.\n       \\<lbrakk>is_K5_outer_inv Ga i; i \\<le> 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        \\<not> i < 5\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         True =\n                         K\\<^bsub>5\\<^esub> (with_proj (mk_graph' Ga))", "apply (fastforce simp: is_K5_outer_inv_def intro: K5_card)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G Ga i.\n       \\<lbrakk>is_K5_outer_inv Ga i; i \\<le> 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        i < 5\\<rbrakk>\n       \\<Longrightarrow> is_K5_inner_inv Ga i 0 \\<and>\n                         0 \\<le> 5 \\<and>\n                         i < 5 \\<and>\n                         IGraph_inv Ga \\<and>\n                         symmetric (with_proj (mk_graph' Ga)) \\<and>\n                         Ga = G \\<and>\n                         ig_verts_cnt Ga = 5 \\<and>\n                         ig_verts Ga ! i = ig_verts Ga ! i \\<and>\n                         (\\<forall>Ga ia j u.\n                             is_K5_inner_inv Ga ia j \\<and>\n                             j \\<le> 5 \\<and>\n                             ia < 5 \\<and>\n                             IGraph_inv Ga \\<and>\n                             symmetric (with_proj (mk_graph' Ga)) \\<and>\n                             Ga = G \\<and>\n                             ia = i \\<and>\n                             ig_verts_cnt Ga = 5 \\<and>\n                             u = ig_verts Ga ! ia \\<and>\n                             \\<not> j < 5 \\<longrightarrow>\n                             5 - (i + 1) < 5 - i \\<and>\n                             is_K5_outer_inv G (i + 1) \\<and>\n                             i + 1 \\<le> 5 \\<and>\n                             IGraph_inv G \\<and>\n                             symmetric (with_proj (mk_graph' G)) \\<and>\n                             ig_verts_cnt G = 5)\n 2. \\<And>G Ga i j u.\n       \\<lbrakk>is_K5_inner_inv Ga i j; j \\<le> 5; i < 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        u = ig_verts Ga ! i; j < 5\\<rbrakk>\n       \\<Longrightarrow> ((i \\<noteq> j) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<in> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>5\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (i \\<noteq> j) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<in> set (ig_arcs Ga)) \\<longrightarrow>\n                          5 - (j + 1) < 5 - j \\<and>\n                          is_K5_inner_inv Ga i (j + 1) \\<and>\n                          j + 1 \\<le> 5 \\<and>\n                          i < 5 \\<and>\n                          IGraph_inv Ga \\<and>\n                          symmetric (with_proj (mk_graph' Ga)) \\<and>\n                          Ga = G \\<and>\n                          i = i \\<and>\n                          ig_verts_cnt Ga = 5 \\<and> u = ig_verts Ga ! i)\n 3. \\<And>G Ga i.\n       \\<lbrakk>is_K5_outer_inv Ga i; i \\<le> 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        \\<not> i < 5\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         True =\n                         K\\<^bsub>5\\<^esub> (with_proj (mk_graph' Ga))", "apply (fastforce simp add: is_K5_inner_0 is_K5_outer_step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G Ga i j u.\n       \\<lbrakk>is_K5_inner_inv Ga i j; j \\<le> 5; i < 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        u = ig_verts Ga ! i; j < 5\\<rbrakk>\n       \\<Longrightarrow> ((i \\<noteq> j) \\<noteq>\n                          ((u, ig_verts Ga ! j)\n                           \\<in> set (ig_arcs Ga)) \\<longrightarrow>\n                          Ga = G \\<and>\n                          \\<not> K\\<^bsub>5\\<^esub>\n                                  (with_proj (mk_graph' Ga))) \\<and>\n                         (\\<not> (i \\<noteq> j) \\<noteq>\n                                 ((u, ig_verts Ga ! j)\n                                  \\<in> set (ig_arcs Ga)) \\<longrightarrow>\n                          5 - (j + 1) < 5 - j \\<and>\n                          is_K5_inner_inv Ga i (j + 1) \\<and>\n                          j + 1 \\<le> 5 \\<and>\n                          i < 5 \\<and>\n                          IGraph_inv Ga \\<and>\n                          symmetric (with_proj (mk_graph' Ga)) \\<and>\n                          Ga = G \\<and>\n                          i = i \\<and>\n                          ig_verts_cnt Ga = 5 \\<and> u = ig_verts Ga ! i)\n 2. \\<And>G Ga i.\n       \\<lbrakk>is_K5_outer_inv Ga i; i \\<le> 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        \\<not> i < 5\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         True =\n                         K\\<^bsub>5\\<^esub> (with_proj (mk_graph' Ga))", "apply (fastforce simp: is_K5_inner_step elim: iK5E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G Ga i.\n       \\<lbrakk>is_K5_outer_inv Ga i; i \\<le> 5; IGraph_inv Ga;\n        symmetric (with_proj (mk_graph' Ga)); Ga = G; ig_verts_cnt Ga = 5;\n        \\<not> i < 5\\<rbrakk>\n       \\<Longrightarrow> Ga = G \\<and>\n                         True =\n                         K\\<^bsub>5\\<^esub> (with_proj (mk_graph' Ga))", "apply (fastforce simp: is_K5_outer_last)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Soundness of the Checker\\<close>"], ["", "lemma planar_theorem:\n  assumes \"pair_pseudo_graph G\" \"pair_pseudo_graph K\"\n  and \"subgraph K G\"\n  and \"K\\<^bsub>3,3\\<^esub> (contr_graph K) \\<or> K\\<^bsub>5\\<^esub> (contr_graph K)\"\n  shows \"\\<not>kuratowski_planar G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> kuratowski_planar (with_proj G)", "using assms"], ["proof (prove)\nusing this:\n  pair_pseudo_graph G\n  pair_pseudo_graph K\n  subgraph (with_proj K) (with_proj G)\n  K\\<^bsub>3,3\\<^esub>\n   (with_proj (gen_contr_graph (with_proj K) (verts3 (with_proj K)))) \\<or>\n  K\\<^bsub>5\\<^esub>\n   (with_proj (gen_contr_graph (with_proj K) (verts3 (with_proj K))))\n\ngoal (1 subgoal):\n 1. \\<not> kuratowski_planar (with_proj G)", "by (auto dest: pair_pseudo_graph.kuratowski_contr)"], ["", "definition witness :: \"'a pair_pre_digraph \\<Rightarrow> 'a pair_pre_digraph \\<Rightarrow> bool\" where\n  \"witness G K \\<equiv> loop_free K \\<and> pair_pseudo_graph K \\<and> subgraph K G\n    \\<and> (K\\<^bsub>3,3\\<^esub> (contr_graph K) \\<or> K\\<^bsub>5\\<^esub> (contr_graph K))\""], ["", "lemma \"witness (mk_graph G) (mk_graph K) \\<longleftrightarrow> pair_pre_digraph.certify (mk_graph G) (mk_graph K) \\<and> loop_free (mk_graph K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. witness (mk_graph G) (mk_graph K) =\n    (pair_pre_digraph.certify (mk_graph G) (mk_graph K) \\<and>\n     loop_free (mk_graph K))", "by (auto simp: witness_def pair_pre_digraph.certify_def Let_def wf_digraph_wp_iff wellformed_pseudo_graph_mkg)"], ["", "lemma pwd_imp_ppg_mkg:\n  assumes \"pair_wf_digraph (mk_graph G)\"\n  shows \"pair_pseudo_graph (mk_graph G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "interpret pair_wf_digraph \"mk_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_graph G)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (mk_graph G)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (pverts (mk_graph G))\n 2. finite (parcs (mk_graph G))\n 3. symmetric (with_proj (mk_graph G))", "apply (auto simp: mkg_simps finite_symcl_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (with_proj (mk_graph G))", "apply (auto simp: mk_graph_def symmetric_mk_symmetric)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pair_pseudo_graph (mk_graph G)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in check_kuratowski_impl) check_kuratowski_spec:\n  \"\\<forall>\\<sigma>. \\<Gamma> \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. pair_wf_digraph (mk_graph \\<acute>G)\\<rbrace>\n    \\<acute>R :== PROC check_kuratowski(\\<acute>G, \\<acute>K)\n  \\<lbrace> \\<acute>G = \\<^bsup>\\<sigma>\\<^esup>G \\<and> \\<acute>K = \\<^bsup>\\<sigma>\\<^esup>K \\<and> \\<acute>R \\<longleftrightarrow> witness (mk_graph \\<acute>G) (mk_graph \\<acute>K)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. pair_wf_digraph\n             (mk_graph \\<acute>G)\\<rbrace>\n                               \\<acute>R :== PROC check_kuratowski(\\<acute>G,\n                               \\<acute>K)\n                               \\<lbrace>(\\<acute>G =\n   \\<^bsup>\\<sigma>\\<^esup>G \\<and>\n   \\<acute>K = \\<^bsup>\\<sigma>\\<^esup>K \\<and> \\<acute>R) =\n  witness (mk_graph \\<acute>G) (mk_graph \\<acute>K)\\<rbrace>", "by vcg (auto simp: witness_def IGraph_inv_conv' pwd_imp_ppg_mkg)"], ["", "lemma check_kuratowski_correct:\n  assumes \"pair_pseudo_graph G\"\n  assumes \"witness G K\"\n  shows \"\\<not>kuratowski_planar G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> kuratowski_planar (with_proj G)", "using assms"], ["proof (prove)\nusing this:\n  pair_pseudo_graph G\n  witness G K\n\ngoal (1 subgoal):\n 1. \\<not> kuratowski_planar (with_proj G)", "by (intro planar_theorem[where K=K]) (auto simp: witness_def)"], ["", "lemma check_kuratowski_correct_comb:\n  assumes \"pair_pseudo_graph G\"\n  assumes \"witness G K\"\n  shows \"\\<not>comb_planar G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> comb_planar (with_proj G)", "using assms"], ["proof (prove)\nusing this:\n  pair_pseudo_graph G\n  witness G K\n\ngoal (1 subgoal):\n 1. \\<not> comb_planar (with_proj G)", "by (metis check_kuratowski_correct comb_planar_compat)"], ["", "lemma check_kuratowski_complete:\n  assumes \"pair_pseudo_graph G\" \"pair_pseudo_graph K\" \"loop_free K\"\n  assumes \"subgraph K G\"\n  assumes \"subdivision_pair H K\" \"K\\<^bsub>3,3\\<^esub> H \\<or> K\\<^bsub>5\\<^esub> H\"\n  shows \"witness G K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. witness G K", "using assms"], ["proof (prove)\nusing this:\n  pair_pseudo_graph G\n  pair_pseudo_graph K\n  loop_free K\n  subgraph (with_proj K) (with_proj G)\n  subdivision_pair H K\n  K\\<^bsub>3,3\\<^esub> (with_proj H) \\<or> K\\<^bsub>5\\<^esub> (with_proj H)\n\ngoal (1 subgoal):\n 1. witness G K", "by (auto simp: witness_def intro: K33_contractedI K5_contractedI)"], ["", "end"]]}