{"file_name": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates/Planarity/Planar_Subdivision.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates", "problem_names": ["lemma edge_rev_GM:  \"edge_rev GM = rev_G\"", "lemma edge_succ_GM: \"edge_succ GM = perm_swap uw uv (perm_swap vw (rev_G uv) (fold perm_rem [wu, wv] (edge_succ HM)))\"", "lemma rev_H_eq_rev_G:\n    assumes \"x \\<in> arcs G - {uv,vu}\" shows \"rev_H x = rev_G x\"", "lemma edge_succ_permutes: \"edge_succ GM permutes arcs G\"", "lemma out_arcs_empty:\n    assumes \"x \\<in> verts G\"\n    shows \"out_arcs G x = {} \\<longleftrightarrow> out_arcs H x = {}\"", "lemma cyclic_on_edge_succ:\n    assumes \"x \\<in> verts G\" \"out_arcs G x \\<noteq> {}\"\n    shows \"cyclic_on (edge_succ GM) (out_arcs G x)\"", "lemma digraph_map_GM:\n    shows \"digraph_map G GM\"", "lemma reachableGD:\n    assumes \"x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y\" shows \"x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\"", "lemma proj_verts_H_in_G: \"x \\<in> verts H \\<Longrightarrow> proj_verts_H x \\<in> verts G\"", "lemma dominatesHD:\n    assumes \"x \\<rightarrow>\\<^bsub>H\\<^esub> y\" shows \"proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y\"", "lemma reachableHD:\n    assumes reach:\"x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\" shows \"proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y\"", "lemma H_reach_conv: \"\\<And>x y. x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y \\<longleftrightarrow> proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y\"", "lemma sccs_eq: \"G.sccs_verts = (`) proj_verts_H ` H.sccs_verts\" (is \"?L = ?R\")", "lemma inj_on_proj_verts_H: \"inj_on ((`) proj_verts_H) (pre_digraph.sccs_verts H)\"", "lemma card_sccs_verts: \"card G.sccs_verts = card H.sccs_verts\"", "lemma card_sccs_eq: \"card G.sccs = card H.sccs\"", "lemma isolated_verts_eq: \"G.isolated_verts = H.isolated_verts\"", "lemma card_verts: \"card (verts H) = card (verts G) + 1\"", "lemma card_arcs: \"card (arcs H) = card (arcs G) + 2\"", "lemma edge_succ_wu: \"edge_succ HM wu = wv\"", "lemma edge_succ_wv: \"edge_succ HM wv = wu\"", "lemmas edge_succ_w = edge_succ_wu edge_succ_wv", "lemma H_face_cycle_succ:\n      \"H.face_cycle_succ uw = wv\"\n      \"H.face_cycle_succ vw = wu\"", "lemma H_edge_succ_tail_eqD:\n    assumes \"edge_succ HM a = b\" shows \"tail H a = tail H b\"", "lemma YYY:\n    \"(wu \\<rightleftharpoons>\\<^sub>F wv) (edge_succ HM vw) = (edge_succ HM vw)\"\n    \"(wu \\<rightleftharpoons>\\<^sub>F wv) (edge_succ HM uw) = (edge_succ HM uw)\"", "lemma proj_arcs_H_simps[simp]:\n      \"proj_arcs_H uw = uv\"\n      \"proj_arcs_H wv = uv\"\n      \"proj_arcs_H vw = vu\"\n      \"proj_arcs_H wu = vu\"\n      \"x \\<notin> {uw,vw,wu,wv} \\<Longrightarrow> proj_arcs_H x = x\"\n      \"a \\<in> arcs G \\<Longrightarrow> proj_arcs_H a = a\"", "lemma proj_arcs_H_in_arcs_G: \"a \\<in> arcs H \\<Longrightarrow> proj_arcs_H a \\<in> arcs G\"", "lemma proj_arcs_eq_swap:\n    assumes \"a \\<notin> {uv,vu,wu,wv}\"\n    shows \"proj_arcs_H a = (uw \\<rightleftharpoons>\\<^sub>F uv o vw \\<rightleftharpoons>\\<^sub>F vu) a\"", "lemma proj_arcs_G_simps:\n      \"proj_arcs_G uv = uw\"\n      \"proj_arcs_G vu = vw\"\n      \"a \\<notin> {uv,vu} \\<Longrightarrow> proj_arcs_G a = a\"", "lemma proj_arcs_G_in_arcs_H:\n    assumes \"a \\<in> arcs G\" shows \"proj_arcs_G a \\<in> arcs H\"", "lemma proj_arcs_HG: \"a \\<in> arcs G \\<Longrightarrow> proj_arcs_H (proj_arcs_G a) = a\"", "lemma fcs_proj_arcs_GH:\n    assumes \"a \\<in> arcs H\" shows \"H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a\"", "lemma H_face_cycle_succ_neq_uv:\n    \"a \\<notin> {uv,vu} \\<Longrightarrow> H.face_cycle_succ a \\<notin> {uv,vu}\"", "lemma face_cycle_succ_choose_inter:\n    \"{H.face_cycle_succ uw, H.face_cycle_succ vw, H.face_cycle_succ wu, H.face_cycle_succ wv} \\<inter> {uv,vu} = {}\"", "lemma face_cycle_succ_choose_neq:\n      \"H.face_cycle_succ wu \\<notin> {wu,wv}\"\n      \"H.face_cycle_succ wv \\<notin> {wu,wv}\"", "lemma H_face_cycle_succ_G_not_in:\n    assumes \"a \\<in> arcs G\" shows \"H.face_cycle_succ a \\<notin> {wu,wv}\"", "lemma\n    face_cycle_succ_uv: \"GM.face_cycle_succ uv = proj_arcs_H (H.face_cycle_succ wv)\" and\n    face_cycle_succ_vu: \"GM.face_cycle_succ vu = proj_arcs_H (H.face_cycle_succ wu)\"", "lemma face_cycle_succ_not_uv:\n    assumes \"a \\<in> arcs G\" \"a \\<notin> {uv,vu}\"\n    shows \"GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)\"", "lemmas G_face_cycle_succ = face_cycle_succ_uv face_cycle_succ_vu face_cycle_succ_not_uv", "lemma in_G_fcs_in_H_fcs:\n    assumes \"a \\<in> arcs G\"\n    assumes \"x \\<in> GM.face_cycle_set a\"\n    shows \"x \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\"", "lemma in_H_fcs_in_G_fcs:\n    assumes \"a \\<in> arcs H\"\n    assumes \"x \\<in> H.face_cycle_set a\"\n    shows \"x \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\"", "lemma G_fcs_eq:\n    assumes \"a \\<in> arcs G\"\n    shows \"GM.face_cycle_set a = proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\" (is \"?L = ?R\")", "lemma H_fcs_eq:\n    assumes \"a \\<in> arcs H\"\n    shows \"proj_arcs_H ` H.face_cycle_set a = GM.face_cycle_set (proj_arcs_H a)\"", "lemma face_cycle_sets:\n    shows \"GM.face_cycle_sets = (`) proj_arcs_H ` H.face_cycle_sets\" (is \"?L = ?R\")", "lemma inj_on_proj_arcs_H: \"inj_on ((`) proj_arcs_H) H.face_cycle_sets\"", "lemma card_face_cycle_sets: \"card GM.face_cycle_sets = card H.face_cycle_sets\"", "lemma euler_char_eq: \"GM.euler_char = H.euler_char\"", "lemma euler_genus_eq: \"GM.euler_genus = H.euler_genus\"", "lemma subdivision_genus_same_rev:\n  assumes \"subdivision (G, rev_G) (H, edge_rev HM)\" \"digraph_map H HM\" \"pre_digraph_map.euler_genus H HM = m\"\n  shows \"\\<exists>GM. digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G\"", "lemma subdivision_genus:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"digraph_map H HM\" \"pre_digraph_map.euler_genus H HM = m\"\n  shows \"\\<exists>GM. digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m\"", "lemma subdivision_comb_planar:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"comb_planar H\" shows \"comb_planar G\""], "translations": [["", "lemma edge_rev_GM:  \"edge_rev GM = rev_G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_rev GM = rev_G", "by (simp add: GM_def)"], ["", "lemma edge_succ_GM: \"edge_succ GM = perm_swap uw uv (perm_swap vw (rev_G uv) (fold perm_rem [wu, wv] (edge_succ HM)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ GM =\n    perm_swap uw uv\n     (perm_swap vw (rev_G uv)\n       (fold perm_rem [rev_H uw, rev_H vw] (edge_succ HM)))", "by (simp add: GM_def)"], ["", "lemma rev_H_eq_rev_G:\n    assumes \"x \\<in> arcs G - {uv,vu}\" shows \"rev_H x = rev_G x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_H x = rev_G x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rev_H x = rev_G x", "have \"perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H)", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H)", "by (auto simp: subdivision_step_def)"], ["proof (state)\nthis:\n  perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H)\n\ngoal (1 subgoal):\n 1. rev_H x = rev_G x", "with assms"], ["proof (chain)\npicking this:\n  x \\<in> arcs G - {uv, rev_G uv}\n  perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> arcs G - {uv, rev_G uv}\n  perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H)\n\ngoal (1 subgoal):\n 1. rev_H x = rev_G x", "unfolding arcs_H"], ["proof (prove)\nusing this:\n  x \\<in> arcs G - {uv, rev_G uv}\n  perm_restrict rev_H (arcs G) =\n  perm_restrict rev_G\n   ({uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv})\n\ngoal (1 subgoal):\n 1. rev_H x = rev_G x", "by (auto simp: perm_restrict_def fun_eq_iff split: if_splits)"], ["proof (state)\nthis:\n  rev_H x = rev_G x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma edge_succ_permutes: \"edge_succ GM permutes arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ GM permutes arcs G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. edge_succ GM permutes arcs G", "have \"arcs H \\<subseteq> (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ` (uw \\<rightleftharpoons>\\<^sub>F uv) ` arcs G \\<union> {wv} \\<union> {wu}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arcs H\n    \\<subseteq> (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n                (uw \\<rightleftharpoons>\\<^sub>F uv) ` arcs G \\<union>\n                {rev_H vw} \\<union>\n                {rev_H uw}", "using subdiv_distinct_arcs in_arcs_G"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uv, rev_G uv} \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. arcs H\n    \\<subseteq> (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n                (uw \\<rightleftharpoons>\\<^sub>F uv) ` arcs G \\<union>\n                {rev_H vw} \\<union>\n                {rev_H uw}", "by (auto simp: arcs_H in_funswapid_image_iff swap_id_eq split: if_splits)"], ["proof (state)\nthis:\n  arcs H\n  \\<subseteq> (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n              (uw \\<rightleftharpoons>\\<^sub>F uv) ` arcs G \\<union>\n              {rev_H vw} \\<union>\n              {rev_H uw}\n\ngoal (1 subgoal):\n 1. edge_succ GM permutes arcs G", "then"], ["proof (chain)\npicking this:\n  arcs H\n  \\<subseteq> (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n              (uw \\<rightleftharpoons>\\<^sub>F uv) ` arcs G \\<union>\n              {rev_H vw} \\<union>\n              {rev_H uw}", "have \"perm_swap uw uv (perm_swap vw (rev_G uv) (perm_rem (wv) (perm_rem (wu) (edge_succ HM)))) permutes arcs G\""], ["proof (prove)\nusing this:\n  arcs H\n  \\<subseteq> (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n              (uw \\<rightleftharpoons>\\<^sub>F uv) ` arcs G \\<union>\n              {rev_H vw} \\<union>\n              {rev_H uw}\n\ngoal (1 subgoal):\n 1. perm_swap uw uv\n     (perm_swap vw (rev_G uv)\n       (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))) permutes\n    arcs G", "by (blast intro: perm_rem_permutes perm_swap_permutes2 permutes_subset H.edge_succ_permutes)"], ["proof (state)\nthis:\n  perm_swap uw uv\n   (perm_swap vw (rev_G uv)\n     (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))) permutes\n  arcs G\n\ngoal (1 subgoal):\n 1. edge_succ GM permutes arcs G", "then"], ["proof (chain)\npicking this:\n  perm_swap uw uv\n   (perm_swap vw (rev_G uv)\n     (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))) permutes\n  arcs G", "show ?thesis"], ["proof (prove)\nusing this:\n  perm_swap uw uv\n   (perm_swap vw (rev_G uv)\n     (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))) permutes\n  arcs G\n\ngoal (1 subgoal):\n 1. edge_succ GM permutes arcs G", "by (auto simp: edge_succ_GM)"], ["proof (state)\nthis:\n  edge_succ GM permutes arcs G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma out_arcs_empty:\n    assumes \"x \\<in> verts G\"\n    shows \"out_arcs G x = {} \\<longleftrightarrow> out_arcs H x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (out_arcs G x = {}) = (out_arcs H x = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "assume A: \"out_arcs H x = {}\""], ["proof (state)\nthis:\n  out_arcs H x = {}\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "have tail_eqI: \"\\<And>a. tail H a = tail G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. tail H a = tail G a", "by (simp only: tail_eq)"], ["proof (state)\nthis:\n  tail H ?a1 = tail G ?a1\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "{"], ["proof (state)\nthis:\n  tail H ?a1 = tail G ?a1\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "assume \"a \\<in> out_arcs G x\""], ["proof (state)\nthis:\n  a \\<in> out_arcs G x\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "moreover"], ["proof (state)\nthis:\n  a \\<in> out_arcs G x\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "have \"a \\<in> arcs H \\<Longrightarrow> a \\<noteq> uv\" \"a \\<in> arcs H \\<Longrightarrow> a \\<noteq> vu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> arcs H \\<Longrightarrow> a \\<noteq> uv) &&&\n    (a \\<in> arcs H \\<Longrightarrow> a \\<noteq> rev_G uv)", "using not_in_arcs_H"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. (a \\<in> arcs H \\<Longrightarrow> a \\<noteq> uv) &&&\n    (a \\<in> arcs H \\<Longrightarrow> a \\<noteq> rev_G uv)", "by auto"], ["proof (state)\nthis:\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> uv\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> rev_G uv\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> out_arcs G x\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> uv\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> rev_G uv", "have \"(uw \\<rightleftharpoons>\\<^sub>F uv) ((vw \\<rightleftharpoons>\\<^sub>F vu) a) \\<in> out_arcs H x\""], ["proof (prove)\nusing this:\n  a \\<in> out_arcs G x\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> uv\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> rev_G uv\n\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) a)\n    \\<in> out_arcs H x", "using subdiv_distinct_arcs in_arcs_H not_in_arcs_H"], ["proof (prove)\nusing this:\n  a \\<in> out_arcs G x\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> uv\n  a \\<in> arcs H \\<Longrightarrow> a \\<noteq> rev_G uv\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n  {uv, rev_G uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) a)\n    \\<in> out_arcs H x", "by (auto simp: arcs_G intro: tail_eqI)"], ["proof (state)\nthis:\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) a)\n  \\<in> out_arcs H x\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "}"], ["proof (state)\nthis:\n  ?a3 \\<in> out_arcs G x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs H x\n\ngoal (2 subgoals):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}\n 2. out_arcs H x = {} \\<Longrightarrow> out_arcs G x = {}", "then"], ["proof (chain)\npicking this:\n  ?a3 \\<in> out_arcs G x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs H x", "show \"out_arcs G x = {}\""], ["proof (prove)\nusing this:\n  ?a3 \\<in> out_arcs G x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs H x\n\ngoal (1 subgoal):\n 1. out_arcs G x = {}", "using A"], ["proof (prove)\nusing this:\n  ?a3 \\<in> out_arcs G x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs H x\n  out_arcs H x = {}\n\ngoal (1 subgoal):\n 1. out_arcs G x = {}", "by (auto simp del: in_out_arcs_conv)"], ["proof (state)\nthis:\n  out_arcs G x = {}\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "assume A: \"out_arcs G x = {}\""], ["proof (state)\nthis:\n  out_arcs G x = {}\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "have tail_eqI: \"\\<And>a. tail H a = tail G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. tail H a = tail G a", "by (simp only: tail_eq)"], ["proof (state)\nthis:\n  tail H ?a1 = tail G ?a1\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "{"], ["proof (state)\nthis:\n  tail H ?a1 = tail G ?a1\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "assume \"a \\<in> out_arcs H x\""], ["proof (state)\nthis:\n  a \\<in> out_arcs H x\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "moreover"], ["proof (state)\nthis:\n  a \\<in> out_arcs H x\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "have \"x \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> w", "using assms not_in_verts_G"], ["proof (prove)\nusing this:\n  x \\<in> verts G\n  w \\<notin> verts G\n\ngoal (1 subgoal):\n 1. x \\<noteq> w", "by blast"], ["proof (state)\nthis:\n  x \\<noteq> w\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> out_arcs H x\n  x \\<noteq> w", "have \"(uw \\<rightleftharpoons>\\<^sub>F uv) ((vw \\<rightleftharpoons>\\<^sub>F vu) a) \\<in> out_arcs G x\""], ["proof (prove)\nusing this:\n  a \\<in> out_arcs H x\n  x \\<noteq> w\n\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) a)\n    \\<in> out_arcs G x", "using subdiv_distinct_arcs in_arcs_G not_in_arcs_G"], ["proof (prove)\nusing this:\n  a \\<in> out_arcs H x\n  x \\<noteq> w\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uv, rev_G uv} \\<subseteq> arcs G\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) a)\n    \\<in> out_arcs G x", "by (auto simp: arcs_H ) (auto simp: swap_id_eq intro: tail_eqI[symmetric])"], ["proof (state)\nthis:\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) a)\n  \\<in> out_arcs G x\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "}"], ["proof (state)\nthis:\n  ?a3 \\<in> out_arcs H x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs G x\n\ngoal (1 subgoal):\n 1. out_arcs G x = {} \\<Longrightarrow> out_arcs H x = {}", "then"], ["proof (chain)\npicking this:\n  ?a3 \\<in> out_arcs H x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs G x", "show \"out_arcs H x = {}\""], ["proof (prove)\nusing this:\n  ?a3 \\<in> out_arcs H x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs G x\n\ngoal (1 subgoal):\n 1. out_arcs H x = {}", "using A"], ["proof (prove)\nusing this:\n  ?a3 \\<in> out_arcs H x \\<Longrightarrow>\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) ?a3)\n  \\<in> out_arcs G x\n  out_arcs G x = {}\n\ngoal (1 subgoal):\n 1. out_arcs H x = {}", "by (auto simp del: in_out_arcs_conv)"], ["proof (state)\nthis:\n  out_arcs H x = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyclic_on_edge_succ:\n    assumes \"x \\<in> verts G\" \"out_arcs G x \\<noteq> {}\"\n    shows \"cyclic_on (edge_succ GM) (out_arcs G x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ GM) (out_arcs G x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ GM) (out_arcs G x)", "have oa_Gx: \"out_arcs G x = (uw \\<rightleftharpoons>\\<^sub>F uv) ` (vw \\<rightleftharpoons>\\<^sub>F vu) ` (out_arcs H x - {wu} - {wv})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_arcs G x =\n    (uw \\<rightleftharpoons>\\<^sub>F uv) `\n    (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n    (out_arcs H x - {rev_H uw} - {rev_H vw})", "using subdiv_distinct_arcs not_in_arcs_G in_arcs_G"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n  {uv, rev_G uv} \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. out_arcs G x =\n    (uw \\<rightleftharpoons>\\<^sub>F uv) `\n    (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n    (out_arcs H x - {rev_H uw} - {rev_H vw})", "by (auto simp: in_funswapid_image_iff arcs_H swap_id_eq tail_eq[symmetric] split: if_splits)"], ["proof (state)\nthis:\n  out_arcs G x =\n  (uw \\<rightleftharpoons>\\<^sub>F uv) `\n  (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n  (out_arcs H x - {rev_H uw} - {rev_H vw})\n\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ GM) (out_arcs G x)", "have \"cyclic_on (perm_swap uw uv (perm_swap vw (rev_G uv) (perm_rem (wv) (perm_rem (wu) (edge_succ HM))))) (out_arcs G x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_on\n     (perm_swap uw uv\n       (perm_swap vw (rev_G uv)\n         (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))))\n     (out_arcs G x)", "unfolding oa_Gx"], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_on\n     (perm_swap uw uv\n       (perm_swap vw (rev_G uv)\n         (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))))\n     ((uw \\<rightleftharpoons>\\<^sub>F uv) `\n      (vw \\<rightleftharpoons>\\<^sub>F rev_G uv) `\n      (out_arcs H x - {rev_H uw} - {rev_H vw}))", "proof (intro cyclic_on_perm_swap cyclic_on_perm_rem)"], ["proof (state)\ngoal (5 subgoals):\n 1. cyclic_on (edge_succ HM) (out_arcs H x)\n 2. bij (edge_succ HM)\n 3. out_arcs H x \\<noteq> {rev_H uw}\n 4. bij (perm_rem (rev_H uw) (edge_succ HM))\n 5. out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw}", "show \"cyclic_on (edge_succ HM) (out_arcs H x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ HM) (out_arcs H x)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> verts G\n  out_arcs G x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ HM) (out_arcs H x)", "by (auto simp: out_arcs_empty verts_H intro: H.edge_succ_cyclic)"], ["proof (state)\nthis:\n  cyclic_on (edge_succ HM) (out_arcs H x)\n\ngoal (4 subgoals):\n 1. bij (edge_succ HM)\n 2. out_arcs H x \\<noteq> {rev_H uw}\n 3. bij (perm_rem (rev_H uw) (edge_succ HM))\n 4. out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw}", "show \"bij (edge_succ HM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (edge_succ HM)", "by (simp add: H.bij_edge_succ)"], ["proof (state)\nthis:\n  bij (edge_succ HM)\n\ngoal (3 subgoals):\n 1. out_arcs H x \\<noteq> {rev_H uw}\n 2. bij (perm_rem (rev_H uw) (edge_succ HM))\n 3. out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw}", "show \"bij (perm_rem (wu) (edge_succ HM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (perm_rem (rev_H uw) (edge_succ HM))", "by (simp add: H.bij_edge_succ)"], ["proof (state)\nthis:\n  bij (perm_rem (rev_H uw) (edge_succ HM))\n\ngoal (2 subgoals):\n 1. out_arcs H x \\<noteq> {rev_H uw}\n 2. out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw}", "have \"x \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> w", "using assms not_in_verts_G"], ["proof (prove)\nusing this:\n  x \\<in> verts G\n  out_arcs G x \\<noteq> {}\n  w \\<notin> verts G\n\ngoal (1 subgoal):\n 1. x \\<noteq> w", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> w\n\ngoal (2 subgoals):\n 1. out_arcs H x \\<noteq> {rev_H uw}\n 2. out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw}", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> w", "have \"wu \\<notin> out_arcs H x\" \"wv \\<notin> out_arcs H x\""], ["proof (prove)\nusing this:\n  x \\<noteq> w\n\ngoal (1 subgoal):\n 1. rev_H uw \\<notin> out_arcs H x &&& rev_H vw \\<notin> out_arcs H x", "by (auto simp: arc_to_ends_def)"], ["proof (state)\nthis:\n  rev_H uw \\<notin> out_arcs H x\n  rev_H vw \\<notin> out_arcs H x\n\ngoal (2 subgoals):\n 1. out_arcs H x \\<noteq> {rev_H uw}\n 2. out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw}", "then"], ["proof (chain)\npicking this:\n  rev_H uw \\<notin> out_arcs H x\n  rev_H vw \\<notin> out_arcs H x", "show \"out_arcs H x - {wu} \\<noteq> {wv}\" \"out_arcs H x \\<noteq> {wu}\""], ["proof (prove)\nusing this:\n  rev_H uw \\<notin> out_arcs H x\n  rev_H vw \\<notin> out_arcs H x\n\ngoal (1 subgoal):\n 1. out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw} &&&\n    out_arcs H x \\<noteq> {rev_H uw}", "by blast+"], ["proof (state)\nthis:\n  out_arcs H x - {rev_H uw} \\<noteq> {rev_H vw}\n  out_arcs H x \\<noteq> {rev_H uw}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cyclic_on\n   (perm_swap uw uv\n     (perm_swap vw (rev_G uv)\n       (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))))\n   (out_arcs G x)\n\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ GM) (out_arcs G x)", "then"], ["proof (chain)\npicking this:\n  cyclic_on\n   (perm_swap uw uv\n     (perm_swap vw (rev_G uv)\n       (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))))\n   (out_arcs G x)", "show ?thesis"], ["proof (prove)\nusing this:\n  cyclic_on\n   (perm_swap uw uv\n     (perm_swap vw (rev_G uv)\n       (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)))))\n   (out_arcs G x)\n\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ GM) (out_arcs G x)", "by (simp add: edge_succ_GM)"], ["proof (state)\nthis:\n  cyclic_on (edge_succ GM) (out_arcs G x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma digraph_map_GM:\n    shows \"digraph_map G GM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map G GM", "by unfold_locales (auto simp: edge_rev_GM G.arev_dom edge_succ_permutes cyclic_on_edge_succ verts_G)"], ["", "end"], ["", "sublocale subdiv1_contr \\<subseteq> GM: digraph_map G GM"], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map G GM", "by (rule digraph_map_GM)"], ["", "context subdiv1_contr begin"], ["", "lemma reachableGD:\n    assumes \"x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y\" shows \"x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "using assms"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> verts G \\<Longrightarrow>\n    y \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n 2. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "case base"], ["proof (state)\nthis:\n  y \\<in> verts G\n\ngoal (2 subgoals):\n 1. y \\<in> verts G \\<Longrightarrow>\n    y \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n 2. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "then"], ["proof (chain)\npicking this:\n  y \\<in> verts G", "show ?case"], ["proof (prove)\nusing this:\n  y \\<in> verts G\n\ngoal (1 subgoal):\n 1. y \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "by (auto simp: verts_H)"], ["proof (state)\nthis:\n  y \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "case (step x z)"], ["proof (state)\nthis:\n  x \\<rightarrow>\\<^bsub>G\\<^esub> z\n  z \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y\n  z \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "moreover"], ["proof (state)\nthis:\n  x \\<rightarrow>\\<^bsub>G\\<^esub> z\n  z \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y\n  z \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "have \"u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\" \"v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v &&&\n    v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u", "using adj_with_w"], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^bsub>H\\<^esub> w\n  w \\<rightarrow>\\<^bsub>H\\<^esub> u\n  v \\<rightarrow>\\<^bsub>H\\<^esub> w\n  w \\<rightarrow>\\<^bsub>H\\<^esub> v\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v &&&\n    v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u", "by auto"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\n  v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "moreover"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\n  v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "{"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\n  v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "assume A: \"(x,z) \\<noteq> (u,v)\" \"(x,z) \\<noteq> (v,u)\""], ["proof (state)\nthis:\n  (x, z) \\<noteq> (u, v)\n  (x, z) \\<noteq> (v, u)\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "from \\<open>x \\<rightarrow>\\<^bsub>G\\<^esub> z\\<close>"], ["proof (chain)\npicking this:\n  x \\<rightarrow>\\<^bsub>G\\<^esub> z", "obtain a where \"a \\<in> arcs G\" \"tail G a = x\" \"head G a = z\""], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^bsub>G\\<^esub> z\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> arcs G; tail G a = x; head G a = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> arcs G\n  tail G a = x\n  head G a = z\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "with A"], ["proof (chain)\npicking this:\n  (x, z) \\<noteq> (u, v)\n  (x, z) \\<noteq> (v, u)\n  a \\<in> arcs G\n  tail G a = x\n  head G a = z", "have \"a \\<in> arcs H\" \"arc_to_ends H a = (x,z)\" \"tail H a = x\" \"head G a = z\""], ["proof (prove)\nusing this:\n  (x, z) \\<noteq> (u, v)\n  (x, z) \\<noteq> (v, u)\n  a \\<in> arcs G\n  tail G a = x\n  head G a = z\n\ngoal (1 subgoal):\n 1. (a \\<in> arcs H &&& arc_to_ends H a = (x, z)) &&&\n    tail H a = x &&& head G a = z", "by (auto simp: arcs_H tail_eq head_eq arc_to_ends_def fun_eq_iff)"], ["proof (state)\nthis:\n  a \\<in> arcs H\n  arc_to_ends H a = (x, z)\n  tail H a = x\n  head G a = z\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "then"], ["proof (chain)\npicking this:\n  a \\<in> arcs H\n  arc_to_ends H a = (x, z)\n  tail H a = x\n  head G a = z", "have \"x \\<rightarrow>\\<^bsub>H\\<^esub> z\""], ["proof (prove)\nusing this:\n  a \\<in> arcs H\n  arc_to_ends H a = (x, z)\n  tail H a = x\n  head G a = z\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^bsub>H\\<^esub> z", "by (auto simp: arcs_ends_def intro: rev_image_eqI)"], ["proof (state)\nthis:\n  x \\<rightarrow>\\<^bsub>H\\<^esub> z\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(x, z) \\<noteq> (u, v); (x, z) \\<noteq> (v, u)\\<rbrakk>\n  \\<Longrightarrow> x \\<rightarrow>\\<^bsub>H\\<^esub> z\n\ngoal (1 subgoal):\n 1. \\<And>x ya.\n       \\<lbrakk>x \\<rightarrow>\\<^bsub>G\\<^esub> ya;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y;\n        ya \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\\<rbrakk>\n       \\<Longrightarrow> x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<rightarrow>\\<^bsub>G\\<^esub> z\n  z \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y\n  z \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n  u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\n  v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\n  \\<lbrakk>(x, z) \\<noteq> (u, v); (x, z) \\<noteq> (v, u)\\<rbrakk>\n  \\<Longrightarrow> x \\<rightarrow>\\<^bsub>H\\<^esub> z", "show ?case"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^bsub>G\\<^esub> z\n  z \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> y\n  z \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n  u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\n  v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\n  \\<lbrakk>(x, z) \\<noteq> (u, v); (x, z) \\<noteq> (v, u)\\<rbrakk>\n  \\<Longrightarrow> x \\<rightarrow>\\<^bsub>H\\<^esub> z\n\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y", "by (auto intro: H.reachable_trans)"], ["proof (state)\nthis:\n  x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition proj_verts_H :: \"'a \\<Rightarrow> 'a\" where\n    \"proj_verts_H x \\<equiv> if x = w then u else x\""], ["", "lemma proj_verts_H_in_G: \"x \\<in> verts H \\<Longrightarrow> proj_verts_H x \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> verts H \\<Longrightarrow> proj_verts_H x \\<in> verts G", "using in_verts_G"], ["proof (prove)\nusing this:\n  {u, v} \\<subseteq> verts G\n\ngoal (1 subgoal):\n 1. x \\<in> verts H \\<Longrightarrow> proj_verts_H x \\<in> verts G", "by (auto simp: proj_verts_H_def verts_H)"], ["", "lemma dominatesHD:\n    assumes \"x \\<rightarrow>\\<^bsub>H\\<^esub> y\" shows \"proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "have X1: \"\\<And>a. (w, y) = arc_to_ends G a \\<Longrightarrow> a \\<notin> arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (w, y) = arc_to_ends G a \\<Longrightarrow> a \\<notin> arcs G", "by (metis G.adj_in_verts(1) G.dominatesI not_in_verts_G)"], ["proof (state)\nthis:\n  (w, y) = arc_to_ends G ?a1 \\<Longrightarrow> ?a1 \\<notin> arcs G\n\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "have X2: \"\\<And>a. (x, w) = arc_to_ends G a \\<Longrightarrow> a \\<notin> arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (x, w) = arc_to_ends G a \\<Longrightarrow> a \\<notin> arcs G", "by (metis G.adj_in_verts(2) G.dominatesI not_in_verts_G)"], ["proof (state)\nthis:\n  (x, w) = arc_to_ends G ?a1 \\<Longrightarrow> ?a1 \\<notin> arcs G\n\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "using assms subdiv_ate_H_rev subdiv_ate in_verts_G"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^bsub>H\\<^esub> y\n  arc_to_ends H (rev_H uw) = (w, u)\n  arc_to_ends H (rev_H vw) = (w, v)\n  arc_to_ends G uv = (u, v)\n  arc_to_ends H uv = (u, v)\n  arc_to_ends H uw = (u, w)\n  arc_to_ends H vw = (v, w)\n  {u, v} \\<subseteq> verts G\n\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "by (auto simp: arcs_ends_def arcs_H arc_to_ends_eq proj_verts_H_def G_reach dest: X1 X2)"], ["proof (state)\nthis:\n  proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachableHD:\n    assumes reach:\"x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\" shows \"proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "using assms"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y\n\ngoal (1 subgoal):\n 1. proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y", "by induct (blast intro: proj_verts_H_in_G G.reachable_trans dominatesHD)+"], ["", "lemma H_reach_conv: \"\\<And>x y. x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y \\<longleftrightarrow> proj_verts_H x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y) =\n       (proj_verts_H\n         x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y)", "using w_reach"], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w\n  w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\n  v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w\n  w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> y) =\n       (proj_verts_H\n         x \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> proj_verts_H y)", "by (auto simp: reachableHD)\n      (auto simp: proj_verts_H_def verts_H split: if_splits dest: reachableGD intro: H.reachable_trans)"], ["", "lemma sccs_eq: \"G.sccs_verts = (`) proj_verts_H ` H.sccs_verts\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. G.sccs_verts = (`) proj_verts_H ` H.sccs_verts", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "fix S"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "assume \"S \\<in> ?L\""], ["proof (state)\nthis:\n  S \\<in> G.sccs_verts\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "then"], ["proof (chain)\npicking this:\n  S \\<in> G.sccs_verts", "have \"w \\<notin> S\""], ["proof (prove)\nusing this:\n  S \\<in> G.sccs_verts\n\ngoal (1 subgoal):\n 1. w \\<notin> S", "using G.sccs_verts_subsets not_in_verts_G"], ["proof (prove)\nusing this:\n  S \\<in> G.sccs_verts\n  ?S \\<in> G.sccs_verts \\<Longrightarrow> ?S \\<subseteq> verts G\n  w \\<notin> verts G\n\ngoal (1 subgoal):\n 1. w \\<notin> S", "by blast"], ["proof (state)\nthis:\n  w \\<notin> S\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "then"], ["proof (chain)\npicking this:\n  w \\<notin> S", "have S_eq: \"proj_verts_H ` proj_verts_H -` S = S\""], ["proof (prove)\nusing this:\n  w \\<notin> S\n\ngoal (1 subgoal):\n 1. proj_verts_H ` proj_verts_H -` S = S", "by (auto simp: proj_verts_H_def intro: range_eqI)"], ["proof (state)\nthis:\n  proj_verts_H ` proj_verts_H -` S = S\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "then"], ["proof (chain)\npicking this:\n  proj_verts_H ` proj_verts_H -` S = S", "have \"proj_verts_H -` S \\<noteq> {}\""], ["proof (prove)\nusing this:\n  proj_verts_H ` proj_verts_H -` S = S\n\ngoal (1 subgoal):\n 1. proj_verts_H -` S \\<noteq> {}", "using \\<open>S \\<in> ?L\\<close>"], ["proof (prove)\nusing this:\n  proj_verts_H ` proj_verts_H -` S = S\n  S \\<in> G.sccs_verts\n\ngoal (1 subgoal):\n 1. proj_verts_H -` S \\<noteq> {}", "by safe (auto simp: G.sccs_verts_def)"], ["proof (state)\nthis:\n  proj_verts_H -` S \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "with \\<open>S \\<in> ?L\\<close>"], ["proof (chain)\npicking this:\n  S \\<in> G.sccs_verts\n  proj_verts_H -` S \\<noteq> {}", "have \"proj_verts_H -` S \\<in> H.sccs_verts\""], ["proof (prove)\nusing this:\n  S \\<in> G.sccs_verts\n  proj_verts_H -` S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. proj_verts_H -` S \\<in> H.sccs_verts", "by (auto simp: G.in_sccs_verts_conv_reachable H.in_sccs_verts_conv_reachable H_reach_conv)"], ["proof (state)\nthis:\n  proj_verts_H -` S \\<in> H.sccs_verts\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "then"], ["proof (chain)\npicking this:\n  proj_verts_H -` S \\<in> H.sccs_verts", "have \"proj_verts_H ` proj_verts_H -` S \\<in> (`) proj_verts_H ` H.sccs_verts\""], ["proof (prove)\nusing this:\n  proj_verts_H -` S \\<in> H.sccs_verts\n\ngoal (1 subgoal):\n 1. proj_verts_H ` proj_verts_H -` S \\<in> (`) proj_verts_H ` H.sccs_verts", "by (rule imageI)"], ["proof (state)\nthis:\n  proj_verts_H ` proj_verts_H -` S \\<in> (`) proj_verts_H ` H.sccs_verts\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> G.sccs_verts \\<Longrightarrow>\n       x \\<in> (`) proj_verts_H ` H.sccs_verts\n 2. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "then"], ["proof (chain)\npicking this:\n  proj_verts_H ` proj_verts_H -` S \\<in> (`) proj_verts_H ` H.sccs_verts", "show \"S \\<in> ?R\""], ["proof (prove)\nusing this:\n  proj_verts_H ` proj_verts_H -` S \\<in> (`) proj_verts_H ` H.sccs_verts\n\ngoal (1 subgoal):\n 1. S \\<in> (`) proj_verts_H ` H.sccs_verts", "by (simp only: S_eq)"], ["proof (state)\nthis:\n  S \\<in> (`) proj_verts_H ` H.sccs_verts\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "assume \"S \\<in> ?R\""], ["proof (state)\nthis:\n  S \\<in> (`) proj_verts_H ` H.sccs_verts\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "have X: \"\\<And>v x. v \\<notin> proj_verts_H ` x \\<Longrightarrow> v = w \\<or> (\\<exists>y. v = proj_verts_H y \\<and> y \\<notin> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v x.\n       v \\<notin> proj_verts_H ` x \\<Longrightarrow>\n       v = w \\<or> (\\<exists>y. v = proj_verts_H y \\<and> y \\<notin> x)", "by (auto simp: proj_verts_H_def split: if_splits)"], ["proof (state)\nthis:\n  ?v1 \\<notin> proj_verts_H ` ?x1 \\<Longrightarrow>\n  ?v1 = w \\<or> (\\<exists>y. ?v1 = proj_verts_H y \\<and> y \\<notin> ?x1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (`) proj_verts_H ` H.sccs_verts \\<Longrightarrow>\n       x \\<in> G.sccs_verts", "from \\<open>S \\<in> ?R\\<close>"], ["proof (chain)\npicking this:\n  S \\<in> (`) proj_verts_H ` H.sccs_verts", "show \"S \\<in> ?L\""], ["proof (prove)\nusing this:\n  S \\<in> (`) proj_verts_H ` H.sccs_verts\n\ngoal (1 subgoal):\n 1. S \\<in> G.sccs_verts", "using not_in_verts_G"], ["proof (prove)\nusing this:\n  S \\<in> (`) proj_verts_H ` H.sccs_verts\n  w \\<notin> verts G\n\ngoal (1 subgoal):\n 1. S \\<in> G.sccs_verts", "by (fastforce simp: G.reachable_in_verts G.in_sccs_verts_conv_reachable\n        H.in_sccs_verts_conv_reachable H_reach_conv dest: X)"], ["proof (state)\nthis:\n  S \\<in> G.sccs_verts\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_proj_verts_H: \"inj_on ((`) proj_verts_H) (pre_digraph.sccs_verts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((`) proj_verts_H) H.sccs_verts", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.sccs_verts; y \\<in> H.sccs_verts;\n        proj_verts_H ` x = proj_verts_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix S T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.sccs_verts; y \\<in> H.sccs_verts;\n        proj_verts_H ` x = proj_verts_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume A: \"S \\<in> H.sccs_verts\" \"T \\<in> H.sccs_verts\" \"proj_verts_H ` S = proj_verts_H ` T\""], ["proof (state)\nthis:\n  S \\<in> H.sccs_verts\n  T \\<in> H.sccs_verts\n  proj_verts_H ` S = proj_verts_H ` T\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.sccs_verts; y \\<in> H.sccs_verts;\n        proj_verts_H ` x = proj_verts_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"\\<And>x. w \\<notin> x \\<Longrightarrow> proj_verts_H ` x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. w \\<notin> x \\<Longrightarrow> proj_verts_H ` x = x", "by (auto simp: proj_verts_H_def)"], ["proof (state)\nthis:\n  w \\<notin> ?x1 \\<Longrightarrow> proj_verts_H ` ?x1 = ?x1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.sccs_verts; y \\<in> H.sccs_verts;\n        proj_verts_H ` x = proj_verts_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with A"], ["proof (chain)\npicking this:\n  S \\<in> H.sccs_verts\n  T \\<in> H.sccs_verts\n  proj_verts_H ` S = proj_verts_H ` T\n  w \\<notin> ?x1 \\<Longrightarrow> proj_verts_H ` ?x1 = ?x1", "have \"S \\<noteq> T \\<Longrightarrow> S \\<inter> T \\<noteq> {}\""], ["proof (prove)\nusing this:\n  S \\<in> H.sccs_verts\n  T \\<in> H.sccs_verts\n  proj_verts_H ` S = proj_verts_H ` T\n  w \\<notin> ?x1 \\<Longrightarrow> proj_verts_H ` ?x1 = ?x1\n\ngoal (1 subgoal):\n 1. S \\<noteq> T \\<Longrightarrow> S \\<inter> T \\<noteq> {}", "by (metis H.in_sccs_verts_conv_reachable Int_iff empty_iff image_eqI proj_verts_H_def w_reach(1,2))"], ["proof (state)\nthis:\n  S \\<noteq> T \\<Longrightarrow> S \\<inter> T \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.sccs_verts; y \\<in> H.sccs_verts;\n        proj_verts_H ` x = proj_verts_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  S \\<noteq> T \\<Longrightarrow> S \\<inter> T \\<noteq> {}", "show \"S = T\""], ["proof (prove)\nusing this:\n  S \\<noteq> T \\<Longrightarrow> S \\<inter> T \\<noteq> {}\n\ngoal (1 subgoal):\n 1. S = T", "using H.sccs_verts_disjoint[OF A(1,2)]"], ["proof (prove)\nusing this:\n  S \\<noteq> T \\<Longrightarrow> S \\<inter> T \\<noteq> {}\n  S \\<noteq> T \\<Longrightarrow> S \\<inter> T = {}\n\ngoal (1 subgoal):\n 1. S = T", "by metis"], ["proof (state)\nthis:\n  S = T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_sccs_verts: \"card G.sccs_verts = card H.sccs_verts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card G.sccs_verts = card H.sccs_verts", "unfolding sccs_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((`) proj_verts_H ` H.sccs_verts) = card H.sccs_verts", "by (intro card_image inj_on_proj_verts_H)"], ["", "lemma card_sccs_eq: \"card G.sccs = card H.sccs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card G.sccs = card H.sccs", "using card_sccs_verts G.inj_on_verts_sccs H.inj_on_verts_sccs"], ["proof (prove)\nusing this:\n  card G.sccs_verts = card H.sccs_verts\n  inj_on verts G.sccs\n  inj_on verts H.sccs\n\ngoal (1 subgoal):\n 1. card G.sccs = card H.sccs", "by (auto simp: G.sccs_verts_conv H.sccs_verts_conv card_image)"], ["", "lemma isolated_verts_eq: \"G.isolated_verts = H.isolated_verts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G.isolated_verts = H.isolated_verts", "by (auto simp: G.isolated_verts_def H.isolated_verts_def verts_H out_arcs_w dest: out_arcs_empty)"], ["", "lemma card_verts: \"card (verts H) = card (verts G) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (verts H) = card (verts G) + 1", "unfolding verts_H"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (verts G \\<union> {w}) = card (verts G) + 1", "using not_in_verts_G"], ["proof (prove)\nusing this:\n  w \\<notin> verts G\n\ngoal (1 subgoal):\n 1. card (verts G \\<union> {w}) = card (verts G) + 1", "by auto"], ["", "lemma card_arcs: \"card (arcs H) = card (arcs G) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (arcs H) = card (arcs G) + 2", "unfolding arcs_H"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv}) =\n    card (arcs G) + 2", "using not_in_arcs_G subdiv_distinct_arcs in_arcs_G"], ["proof (prove)\nusing this:\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uv, rev_G uv} \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. card ({uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv}) =\n    card (arcs G) + 2", "by (auto simp: card_insert_if)"], ["", "lemma edge_succ_wu: \"edge_succ HM wu = wv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ HM (rev_H uw) = rev_H vw", "using out_arcs_w out_degree_w edge_succ_permutes H.edge_succ_cyclic[of w]"], ["proof (prove)\nusing this:\n  out_arcs H w = {rev_H uw, rev_H vw}\n  out_degree H w = 2\n  edge_succ GM permutes arcs G\n  \\<lbrakk>w \\<in> verts H; out_arcs H w \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (edge_succ HM) (out_arcs H w)\n\ngoal (1 subgoal):\n 1. edge_succ HM (rev_H uw) = rev_H vw", "by (auto elim: eq_on_cyclic_on_iff1[where x=\"wu\"] simp: verts_H out_degree_def)"], ["", "lemma edge_succ_wv: \"edge_succ HM wv = wu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ HM (rev_H vw) = rev_H uw", "using out_arcs_w out_degree_w edge_succ_permutes H.edge_succ_cyclic[of w]"], ["proof (prove)\nusing this:\n  out_arcs H w = {rev_H uw, rev_H vw}\n  out_degree H w = 2\n  edge_succ GM permutes arcs G\n  \\<lbrakk>w \\<in> verts H; out_arcs H w \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (edge_succ HM) (out_arcs H w)\n\ngoal (1 subgoal):\n 1. edge_succ HM (rev_H vw) = rev_H uw", "by (auto elim: eq_on_cyclic_on_iff1[where x=\"wv\"] simp: verts_H out_degree_def)"], ["", "lemmas edge_succ_w = edge_succ_wu edge_succ_wv"], ["", "lemma H_face_cycle_succ:\n      \"H.face_cycle_succ uw = wv\"\n      \"H.face_cycle_succ vw = wu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.face_cycle_succ uw = rev_H vw &&& H.face_cycle_succ vw = rev_H uw", "unfolding H.face_cycle_succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (edge_succ HM \\<circ> rev_H) uw = rev_H vw &&&\n    (edge_succ HM \\<circ> rev_H) vw = rev_H uw", "by (auto simp: edge_succ_w)"], ["", "lemma H_edge_succ_tail_eqD:\n    assumes \"edge_succ HM a = b\" shows \"tail H a = tail H b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail H a = tail H b", "using assms H.tail_edge_succ[of a]"], ["proof (prove)\nusing this:\n  edge_succ HM a = b\n  tail H (edge_succ HM a) = tail H a\n\ngoal (1 subgoal):\n 1. tail H a = tail H b", "by auto"], ["", "lemma YYY:\n    \"(wu \\<rightleftharpoons>\\<^sub>F wv) (edge_succ HM vw) = (edge_succ HM vw)\"\n    \"(wu \\<rightleftharpoons>\\<^sub>F wv) (edge_succ HM uw) = (edge_succ HM uw)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw) (edge_succ HM vw) =\n    edge_succ HM vw &&&\n    (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw) (edge_succ HM uw) =\n    edge_succ HM uw", "using H.edge_succ_cyclic[of w] subdiv_distinct_verts0"], ["proof (prove)\nusing this:\n  \\<lbrakk>w \\<in> verts H; out_arcs H w \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (edge_succ HM) (out_arcs H w)\n  u \\<noteq> w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw) (edge_succ HM vw) =\n    edge_succ HM vw &&&\n    (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw) (edge_succ HM uw) =\n    edge_succ HM uw", "by (auto simp: swap_id_eq dest: H_edge_succ_tail_eqD)"], ["", "text \\<open>Project arcs of @{term H} to corresponding arcs of @{term G}\\<close>"], ["", "definition proj_arcs_H :: \"'b \\<Rightarrow> 'b\" where\n    \"proj_arcs_H x \\<equiv>\n      if x = uw \\<or> x = wv then uv\n      else if x = vw \\<or> x = wu then vu\n      else x\""], ["", "text \\<open>Project arcs of @{term G} to corresponding arcs of @{term H}\\<close>"], ["", "definition proj_arcs_G :: \"'b \\<Rightarrow> 'b\" where\n    \"proj_arcs_G x \\<equiv>\n      if x = uv then uw\n      else if x = vu then vw\n      else x\""], ["", "lemma proj_arcs_H_simps[simp]:\n      \"proj_arcs_H uw = uv\"\n      \"proj_arcs_H wv = uv\"\n      \"proj_arcs_H vw = vu\"\n      \"proj_arcs_H wu = vu\"\n      \"x \\<notin> {uw,vw,wu,wv} \\<Longrightarrow> proj_arcs_H x = x\"\n      \"a \\<in> arcs G \\<Longrightarrow> proj_arcs_H a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (proj_arcs_H uw = uv &&&\n     proj_arcs_H (rev_H vw) = uv &&& proj_arcs_H vw = rev_G uv) &&&\n    proj_arcs_H (rev_H uw) = rev_G uv &&&\n    (x \\<notin> {uw, vw, rev_H uw, rev_H vw} \\<Longrightarrow>\n     proj_arcs_H x = x) &&&\n    (a \\<in> arcs G \\<Longrightarrow> proj_arcs_H a = a)", "using subdiv_distinct_arcs not_in_arcs_G"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n\ngoal (1 subgoal):\n 1. (proj_arcs_H uw = uv &&&\n     proj_arcs_H (rev_H vw) = uv &&& proj_arcs_H vw = rev_G uv) &&&\n    proj_arcs_H (rev_H uw) = rev_G uv &&&\n    (x \\<notin> {uw, vw, rev_H uw, rev_H vw} \\<Longrightarrow>\n     proj_arcs_H x = x) &&&\n    (a \\<in> arcs G \\<Longrightarrow> proj_arcs_H a = a)", "by (auto simp: proj_arcs_H_def)"], ["", "lemma proj_arcs_H_in_arcs_G: \"a \\<in> arcs H \\<Longrightarrow> proj_arcs_H a \\<in> arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> arcs H \\<Longrightarrow> proj_arcs_H a \\<in> arcs G", "using subdiv_distinct_arcs in_arcs_G"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uv, rev_G uv} \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. a \\<in> arcs H \\<Longrightarrow> proj_arcs_H a \\<in> arcs G", "by (auto simp: proj_arcs_H_def arcs_H)"], ["", "lemma proj_arcs_eq_swap:\n    assumes \"a \\<notin> {uv,vu,wu,wv}\"\n    shows \"proj_arcs_H a = (uw \\<rightleftharpoons>\\<^sub>F uv o vw \\<rightleftharpoons>\\<^sub>F vu) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_arcs_H a =\n    (uw \\<rightleftharpoons>\\<^sub>F uv \\<circ>\n     vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n     a", "using assms subdiv_distinct_arcs"], ["proof (prove)\nusing this:\n  a \\<notin> {uv, rev_G uv, rev_H uw, rev_H vw}\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n\ngoal (1 subgoal):\n 1. proj_arcs_H a =\n    (uw \\<rightleftharpoons>\\<^sub>F uv \\<circ>\n     vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n     a", "by (cases \"a \\<in> {uw,vw}\") auto"], ["", "lemma proj_arcs_G_simps:\n      \"proj_arcs_G uv = uw\"\n      \"proj_arcs_G vu = vw\"\n      \"a \\<notin> {uv,vu} \\<Longrightarrow> proj_arcs_G a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_arcs_G uv = uw &&&\n    proj_arcs_G (rev_G uv) = vw &&&\n    (a \\<notin> {uv, rev_G uv} \\<Longrightarrow> proj_arcs_G a = a)", "using subdiv_distinct_arcs not_in_arcs_G"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n\ngoal (1 subgoal):\n 1. proj_arcs_G uv = uw &&&\n    proj_arcs_G (rev_G uv) = vw &&&\n    (a \\<notin> {uv, rev_G uv} \\<Longrightarrow> proj_arcs_G a = a)", "by (auto simp: swap_id_eq proj_arcs_G_def)"], ["", "lemma proj_arcs_G_in_arcs_H:\n    assumes \"a \\<in> arcs G\" shows \"proj_arcs_G a \\<in> arcs H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_arcs_G a \\<in> arcs H", "using assms subdiv_distinct_arcs"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n\ngoal (1 subgoal):\n 1. proj_arcs_G a \\<in> arcs H", "by (auto simp: proj_arcs_G_def arcs_H)"], ["", "lemma proj_arcs_HG: \"a \\<in> arcs G \\<Longrightarrow> proj_arcs_H (proj_arcs_G a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> arcs G \\<Longrightarrow> proj_arcs_H (proj_arcs_G a) = a", "by (auto simp: proj_arcs_G_def)"], ["", "lemma fcs_proj_arcs_GH:\n    assumes \"a \\<in> arcs H\" shows \"H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a", "have \"H.face_cycle_set vw = H.face_cycle_set wu\" \"H.face_cycle_set uw = H.face_cycle_set wv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.face_cycle_set vw = H.face_cycle_set (rev_H uw) &&&\n    H.face_cycle_set uw = H.face_cycle_set (rev_H vw)", "unfolding H.face_cycle_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. orbit H.face_cycle_succ vw = orbit H.face_cycle_succ (rev_H uw) &&&\n    orbit H.face_cycle_succ uw = orbit H.face_cycle_succ (rev_H vw)", "by (auto simp add: H_face_cycle_succ[symmetric]\n        self_in_orbit_step H.permutation_face_cycle_succ permutation_self_in_orbit)"], ["proof (state)\nthis:\n  H.face_cycle_set vw = H.face_cycle_set (rev_H uw)\n  H.face_cycle_set uw = H.face_cycle_set (rev_H vw)\n\ngoal (1 subgoal):\n 1. H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a", "then"], ["proof (chain)\npicking this:\n  H.face_cycle_set vw = H.face_cycle_set (rev_H uw)\n  H.face_cycle_set uw = H.face_cycle_set (rev_H vw)", "show ?thesis"], ["proof (prove)\nusing this:\n  H.face_cycle_set vw = H.face_cycle_set (rev_H uw)\n  H.face_cycle_set uw = H.face_cycle_set (rev_H vw)\n\ngoal (1 subgoal):\n 1. H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a", "using assms not_in_arcs_H"], ["proof (prove)\nusing this:\n  H.face_cycle_set vw = H.face_cycle_set (rev_H uw)\n  H.face_cycle_set uw = H.face_cycle_set (rev_H vw)\n  a \\<in> arcs H\n  {uv, rev_G uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a", "by (cases \"a \\<in> {uv,vu,uw,wu,vw,wv}\") (auto simp: proj_arcs_G_simps)"], ["proof (state)\nthis:\n  H.face_cycle_set (proj_arcs_G (proj_arcs_H a)) = H.face_cycle_set a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma H_face_cycle_succ_neq_uv:\n    \"a \\<notin> {uv,vu} \\<Longrightarrow> H.face_cycle_succ a \\<notin> {uv,vu}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {uv, rev_G uv}", "using not_in_arcs_H"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {uv, rev_G uv}", "by (cases \"a \\<in> arcs H\") (auto dest: H.face_cycle_succ_in_arcsI)"], ["", "lemma face_cycle_succ_choose_inter:\n    \"{H.face_cycle_succ uw, H.face_cycle_succ vw, H.face_cycle_succ wu, H.face_cycle_succ wv} \\<inter> {uv,vu} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {H.face_cycle_succ uw, H.face_cycle_succ vw,\n     H.face_cycle_succ (rev_H uw), H.face_cycle_succ (rev_H vw)} \\<inter>\n    {uv, rev_G uv} =\n    {}", "using subdiv_distinct_arcs H_face_cycle_succ_neq_uv"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  ?a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n  H.face_cycle_succ ?a \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. {H.face_cycle_succ uw, H.face_cycle_succ vw,\n     H.face_cycle_succ (rev_H uw), H.face_cycle_succ (rev_H vw)} \\<inter>\n    {uv, rev_G uv} =\n    {}", "by safe (simp_all, metis+)"], ["", "lemma face_cycle_succ_choose_neq:\n      \"H.face_cycle_succ wu \\<notin> {wu,wv}\"\n      \"H.face_cycle_succ wv \\<notin> {wu,wv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.face_cycle_succ (rev_H uw) \\<notin> {rev_H uw, rev_H vw} &&&\n    H.face_cycle_succ (rev_H vw) \\<notin> {rev_H uw, rev_H vw}", "using subdiv_distinct_verts0 in_arcs_H"], ["proof (prove)\nusing this:\n  u \\<noteq> w\n  v \\<noteq> w\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ (rev_H uw) \\<notin> {rev_H uw, rev_H vw} &&&\n    H.face_cycle_succ (rev_H vw) \\<notin> {rev_H uw, rev_H vw}", "by (auto simp del: H.edge_rev_in_arcs dest: H.tail_face_cycle_succ)"], ["", "lemma H_face_cycle_succ_G_not_in:\n    assumes \"a \\<in> arcs G\" shows \"H.face_cycle_succ a \\<notin> {wu,wv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "proof (cases \"a \\<in> {uv,vu}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}\n 2. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "case True"], ["proof (state)\nthis:\n  a \\<in> {uv, rev_G uv}\n\ngoal (2 subgoals):\n 1. a \\<in> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}\n 2. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> arcs G\n  a \\<in> {uv, rev_G uv}", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<in> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "using subdiv_distinct_arcs"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<in> {uv, rev_G uv}\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "by (auto simp: arcs_H)"], ["proof (state)\nthis:\n  H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}\n\ngoal (1 subgoal):\n 1. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "case False"], ["proof (state)\nthis:\n  a \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}", "have \"a \\<in> arcs H\""], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. a \\<in> arcs H", "by (auto simp: arcs_H)"], ["proof (state)\nthis:\n  a \\<in> arcs H\n\ngoal (1 subgoal):\n 1. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "from assms"], ["proof (chain)\npicking this:\n  a \\<in> arcs G", "have \"head H a \\<noteq> w\""], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n\ngoal (1 subgoal):\n 1. head H a \\<noteq> w", "by (auto simp: head_eq verts_G arcs_H dest: G.head_in_verts)"], ["proof (state)\nthis:\n  head H a \\<noteq> w\n\ngoal (1 subgoal):\n 1. a \\<notin> {uv, rev_G uv} \\<Longrightarrow>\n    H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "then"], ["proof (chain)\npicking this:\n  head H a \\<noteq> w", "show ?thesis"], ["proof (prove)\nusing this:\n  head H a \\<noteq> w\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "using H.tail_face_cycle_succ[OF \\<open>a \\<in> arcs H\\<close>]"], ["proof (prove)\nusing this:\n  head H a \\<noteq> w\n  tail H (H.face_cycle_succ a) = head H a\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}", "by auto"], ["proof (state)\nthis:\n  H.face_cycle_succ a \\<notin> {rev_H uw, rev_H vw}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n    face_cycle_succ_uv: \"GM.face_cycle_succ uv = proj_arcs_H (H.face_cycle_succ wv)\" and\n    face_cycle_succ_vu: \"GM.face_cycle_succ vu = proj_arcs_H (H.face_cycle_succ wu)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.face_cycle_succ uv = proj_arcs_H (H.face_cycle_succ (rev_H vw)) &&&\n    GM.face_cycle_succ (rev_G uv) =\n    proj_arcs_H (H.face_cycle_succ (rev_H uw))", "unfolding GM.face_cycle_succ_def edge_rev_GM edge_succ_GM"], ["proof (prove)\ngoal (1 subgoal):\n 1. (perm_swap uw uv\n      (perm_swap vw (rev_G uv)\n        (fold perm_rem [rev_H uw, rev_H vw] (edge_succ HM))) \\<circ>\n     rev_G)\n     uv =\n    proj_arcs_H (H.face_cycle_succ (rev_H vw)) &&&\n    (perm_swap uw uv\n      (perm_swap vw (rev_G uv)\n        (fold perm_rem [rev_H uw, rev_H vw] (edge_succ HM))) \\<circ>\n     rev_G)\n     (rev_G uv) =\n    proj_arcs_H (H.face_cycle_succ (rev_H uw))", "using face_cycle_succ_choose_neq face_cycle_succ_choose_inter subdiv_distinct_arcs"], ["proof (prove)\nusing this:\n  H.face_cycle_succ (rev_H uw) \\<notin> {rev_H uw, rev_H vw}\n  H.face_cycle_succ (rev_H vw) \\<notin> {rev_H uw, rev_H vw}\n  {H.face_cycle_succ uw, H.face_cycle_succ vw, H.face_cycle_succ (rev_H uw),\n   H.face_cycle_succ (rev_H vw)} \\<inter>\n  {uv, rev_G uv} =\n  {}\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n\ngoal (1 subgoal):\n 1. (perm_swap uw uv\n      (perm_swap vw (rev_G uv)\n        (fold perm_rem [rev_H uw, rev_H vw] (edge_succ HM))) \\<circ>\n     rev_G)\n     uv =\n    proj_arcs_H (H.face_cycle_succ (rev_H vw)) &&&\n    (perm_swap uw uv\n      (perm_swap vw (rev_G uv)\n        (fold perm_rem [rev_H uw, rev_H vw] (edge_succ HM))) \\<circ>\n     rev_G)\n     (rev_G uv) =\n    proj_arcs_H (H.face_cycle_succ (rev_H uw))", "apply (auto simp: fun_eq_iff perm_swap_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>H.face_cycle_succ (rev_H uw) \\<noteq> rev_H uw;\n     H.face_cycle_succ (rev_H uw) \\<noteq> rev_H vw;\n     H.face_cycle_succ (rev_H vw) \\<noteq> rev_H uw;\n     H.face_cycle_succ (rev_H vw) \\<noteq> rev_H vw;\n     uv \\<noteq> H.face_cycle_succ uw; uv \\<noteq> rev_G uv;\n     uv \\<noteq> H.face_cycle_succ vw; uv \\<noteq> uw;\n     uv \\<noteq> H.face_cycle_succ (rev_H uw); uv \\<noteq> rev_H uw;\n     uv \\<noteq> H.face_cycle_succ (rev_H vw); uv \\<noteq> vw;\n     rev_G uv \\<noteq> H.face_cycle_succ uw; uv \\<noteq> rev_H vw;\n     rev_G uv \\<noteq> H.face_cycle_succ vw; rev_G uv \\<noteq> uw;\n     rev_G uv \\<noteq> H.face_cycle_succ (rev_H uw);\n     rev_G uv \\<noteq> H.face_cycle_succ (rev_H vw);\n     rev_G uv \\<noteq> rev_H uw; rev_G uv \\<noteq> vw;\n     rev_G uv \\<noteq> rev_H vw; uw \\<noteq> rev_H uw; uw \\<noteq> vw;\n     uw \\<noteq> rev_H vw; rev_H uw \\<noteq> vw; rev_H uw \\<noteq> rev_H vw;\n     vw \\<noteq> rev_H vw\\<rbrakk>\n    \\<Longrightarrow> (uw \\<rightleftharpoons>\\<^sub>F uv)\n                       ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n                         (perm_rem (rev_H vw)\n                           (perm_rem (rev_H uw) (edge_succ HM)) vw)) =\n                      proj_arcs_H (H.face_cycle_succ (rev_H vw))\n 2. \\<lbrakk>H.face_cycle_succ (rev_H uw) \\<noteq> rev_H uw;\n     H.face_cycle_succ (rev_H uw) \\<noteq> rev_H vw;\n     H.face_cycle_succ (rev_H vw) \\<noteq> rev_H uw;\n     H.face_cycle_succ (rev_H vw) \\<noteq> rev_H vw;\n     uv \\<noteq> H.face_cycle_succ uw; uv \\<noteq> rev_G uv;\n     uv \\<noteq> H.face_cycle_succ vw; uv \\<noteq> uw;\n     uv \\<noteq> H.face_cycle_succ (rev_H uw); uv \\<noteq> rev_H uw;\n     uv \\<noteq> H.face_cycle_succ (rev_H vw); uv \\<noteq> vw;\n     rev_G uv \\<noteq> H.face_cycle_succ uw; uv \\<noteq> rev_H vw;\n     rev_G uv \\<noteq> H.face_cycle_succ vw; rev_G uv \\<noteq> uw;\n     rev_G uv \\<noteq> H.face_cycle_succ (rev_H uw);\n     rev_G uv \\<noteq> H.face_cycle_succ (rev_H vw);\n     rev_G uv \\<noteq> rev_H uw; rev_G uv \\<noteq> vw;\n     rev_G uv \\<noteq> rev_H vw; uw \\<noteq> rev_H uw; uw \\<noteq> vw;\n     uw \\<noteq> rev_H vw; rev_H uw \\<noteq> vw; rev_H uw \\<noteq> rev_H vw;\n     vw \\<noteq> rev_H vw\\<rbrakk>\n    \\<Longrightarrow> (uw \\<rightleftharpoons>\\<^sub>F uv)\n                       ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n                         (perm_rem (rev_H vw)\n                           (perm_rem (rev_H uw) (edge_succ HM)) uw)) =\n                      proj_arcs_H (H.face_cycle_succ (rev_H uw))", "apply (auto simp: perm_rem_def edge_succ_w H.face_cycle_succ_def YYY proj_arcs_H_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma face_cycle_succ_not_uv:\n    assumes \"a \\<in> arcs G\" \"a \\<notin> {uv,vu}\"\n    shows \"GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "have \"GM.face_cycle_succ a = (uw \\<rightleftharpoons>\\<^sub>F uv) ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (perm_rem (wv) (perm_rem (wu) (edge_succ HM)) (((vw \\<rightleftharpoons>\\<^sub>F vu) ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a =\n    (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n       (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM))\n         ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n           ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)))))", "by (simp add: GM.face_cycle_succ_def perm_swap_def edge_succ_GM edge_rev_GM)"], ["proof (state)\nthis:\n  GM.face_cycle_succ a =\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n     (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM))\n       ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n         ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)))))\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "also"], ["proof (state)\nthis:\n  GM.face_cycle_succ a =\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n     (perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM))\n       ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n         ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)))))\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "have \"(vw \\<rightleftharpoons>\\<^sub>F vu) ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)) = rev_G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n     ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)) =\n    rev_G a", "using assms not_in_arcs_G"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n\ngoal (1 subgoal):\n 1. (vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n     ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)) =\n    rev_G a", "by (auto simp: swap_id_eq G.arev_eq_iff)"], ["proof (state)\nthis:\n  (vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n   ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)) =\n  rev_G a\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "also"], ["proof (state)\nthis:\n  (vw \\<rightleftharpoons>\\<^sub>F rev_G uv)\n   ((uw \\<rightleftharpoons>\\<^sub>F uv) (rev_G a)) =\n  rev_G a\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "have \"perm_rem (wv) (perm_rem (wu) (edge_succ HM)) (rev_G a) = edge_succ HM (rev_G a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n    edge_succ HM (rev_G a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n    edge_succ HM (rev_G a)", "have *: \"\\<And>a. tail H a \\<noteq> w \\<Longrightarrow> (wu \\<rightleftharpoons>\\<^sub>F wv) a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       tail H a \\<noteq> w \\<Longrightarrow>\n       (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw) a = a", "by (auto simp: swap_id_eq)"], ["proof (state)\nthis:\n  tail H ?a1 \\<noteq> w \\<Longrightarrow>\n  (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw) ?a1 = ?a1\n\ngoal (1 subgoal):\n 1. perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n    edge_succ HM (rev_G a)", "from assms"], ["proof (chain)\npicking this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}", "have \"head H a \\<noteq> w\" \"tail H (rev_G a) = head H a\""], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. head H a \\<noteq> w &&& tail H (rev_G a) = head H a", "by (auto simp: tail_eq head_eq verts_G dest: G.head_in_verts)"], ["proof (state)\nthis:\n  head H a \\<noteq> w\n  tail H (rev_G a) = head H a\n\ngoal (1 subgoal):\n 1. perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n    edge_succ HM (rev_G a)", "then"], ["proof (chain)\npicking this:\n  head H a \\<noteq> w\n  tail H (rev_G a) = head H a", "have \"((wu \\<rightleftharpoons>\\<^sub>F wv) (edge_succ HM (rev_G a))) = edge_succ HM (rev_G a)\""], ["proof (prove)\nusing this:\n  head H a \\<noteq> w\n  tail H (rev_G a) = head H a\n\ngoal (1 subgoal):\n 1. (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw)\n     (edge_succ HM (rev_G a)) =\n    edge_succ HM (rev_G a)", "by (intro *) auto"], ["proof (state)\nthis:\n  (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw)\n   (edge_succ HM (rev_G a)) =\n  edge_succ HM (rev_G a)\n\ngoal (1 subgoal):\n 1. perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n    edge_succ HM (rev_G a)", "then"], ["proof (chain)\npicking this:\n  (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw)\n   (edge_succ HM (rev_G a)) =\n  edge_succ HM (rev_G a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (rev_H uw \\<rightleftharpoons>\\<^sub>F rev_H vw)\n   (edge_succ HM (rev_G a)) =\n  edge_succ HM (rev_G a)\n\ngoal (1 subgoal):\n 1. perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n    edge_succ HM (rev_G a)", "by (auto simp: perm_rem_def edge_succ_w)"], ["proof (state)\nthis:\n  perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n  edge_succ HM (rev_G a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n  edge_succ HM (rev_G a)\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "also"], ["proof (state)\nthis:\n  perm_rem (rev_H vw) (perm_rem (rev_H uw) (edge_succ HM)) (rev_G a) =\n  edge_succ HM (rev_G a)\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "have \"edge_succ HM (rev_G a) = H.face_cycle_succ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ HM (rev_G a) = H.face_cycle_succ a", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. edge_succ HM (rev_G a) = H.face_cycle_succ a", "unfolding H.face_cycle_succ_def"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. edge_succ HM (rev_G a) = (edge_succ HM \\<circ> rev_H) a", "by (simp add: rev_H_eq_rev_G)"], ["proof (state)\nthis:\n  edge_succ HM (rev_G a) = H.face_cycle_succ a\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "also"], ["proof (state)\nthis:\n  edge_succ HM (rev_G a) = H.face_cycle_succ a\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "have \"(uw \\<rightleftharpoons>\\<^sub>F uv) ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) = proj_arcs_H (H.face_cycle_succ a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) =\n    proj_arcs_H (H.face_cycle_succ a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) =\n    proj_arcs_H (H.face_cycle_succ a)", "from assms"], ["proof (chain)\npicking this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}", "have \"a \\<in> arcs H\""], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. a \\<in> arcs H", "by (auto simp: arcs_H)"], ["proof (state)\nthis:\n  a \\<in> arcs H\n\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) =\n    proj_arcs_H (H.face_cycle_succ a)", "then"], ["proof (chain)\npicking this:\n  a \\<in> arcs H", "have fcs_not_in: \"H.face_cycle_succ a \\<notin> {uv, vu, wu, wv}\""], ["proof (prove)\nusing this:\n  a \\<in> arcs H\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ a \\<notin> {uv, rev_G uv, rev_H uw, rev_H vw}", "using assms H_face_cycle_succ_G_not_in in_arcs_G not_in_arcs_H"], ["proof (prove)\nusing this:\n  a \\<in> arcs H\n  a \\<in> arcs G\n  a \\<notin> {uv, rev_G uv}\n  ?a \\<in> arcs G \\<Longrightarrow>\n  H.face_cycle_succ ?a \\<notin> {rev_H uw, rev_H vw}\n  {uv, rev_G uv} \\<subseteq> arcs G\n  {uv, rev_G uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ a \\<notin> {uv, rev_G uv, rev_H uw, rev_H vw}", "by (auto simp del: G.arev_in_arcs dest: H.face_cycle_succ_closed[THEN iffD2])"], ["proof (state)\nthis:\n  H.face_cycle_succ a \\<notin> {uv, rev_G uv, rev_H uw, rev_H vw}\n\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) =\n    proj_arcs_H (H.face_cycle_succ a)", "then"], ["proof (chain)\npicking this:\n  H.face_cycle_succ a \\<notin> {uv, rev_G uv, rev_H uw, rev_H vw}", "show ?thesis"], ["proof (prove)\nusing this:\n  H.face_cycle_succ a \\<notin> {uv, rev_G uv, rev_H uw, rev_H vw}\n\ngoal (1 subgoal):\n 1. (uw \\<rightleftharpoons>\\<^sub>F uv)\n     ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) =\n    proj_arcs_H (H.face_cycle_succ a)", "by (auto simp add: proj_arcs_eq_swap)"], ["proof (state)\nthis:\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) =\n  proj_arcs_H (H.face_cycle_succ a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (uw \\<rightleftharpoons>\\<^sub>F uv)\n   ((vw \\<rightleftharpoons>\\<^sub>F rev_G uv) (H.face_cycle_succ a)) =\n  proj_arcs_H (H.face_cycle_succ a)\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "finally"], ["proof (chain)\npicking this:\n  GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "show ?thesis"], ["proof (prove)\nusing this:\n  GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)", "."], ["proof (state)\nthis:\n  GM.face_cycle_succ a = proj_arcs_H (H.face_cycle_succ a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas G_face_cycle_succ = face_cycle_succ_uv face_cycle_succ_vu face_cycle_succ_not_uv"], ["", "lemma in_G_fcs_in_H_fcs:\n    assumes \"a \\<in> arcs G\"\n    assumes \"x \\<in> GM.face_cycle_set a\"\n    shows \"x \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)", "using \\<open>x \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> GM.face_cycle_set a\n\ngoal (1 subgoal):\n 1. x \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\n 2. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. a \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\n 2. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)", "by (rule rev_image_eqI[where x=\"proj_arcs_G a\"]) (auto simp: \\<open>a \\<in> arcs G\\<close> proj_arcs_G_def)"], ["proof (state)\nthis:\n  a \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "case (step b)"], ["proof (state)\nthis:\n  b \\<in> GM.face_cycle_set a\n  b \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "{"], ["proof (state)\nthis:\n  b \\<in> GM.face_cycle_set a\n  b \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "assume \"x \\<in> H.face_cycle_set (proj_arcs_G a)\""], ["proof (state)\nthis:\n  x \\<in> H.face_cycle_set (proj_arcs_G a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H.face_cycle_set (proj_arcs_G a)", "have \"x \\<in> arcs H\""], ["proof (prove)\nusing this:\n  x \\<in> H.face_cycle_set (proj_arcs_G a)\n\ngoal (1 subgoal):\n 1. x \\<in> arcs H", "using \\<open>a \\<in> arcs G\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H.face_cycle_set (proj_arcs_G a)\n  a \\<in> arcs G\n\ngoal (1 subgoal):\n 1. x \\<in> arcs H", "by (auto dest: H.in_face_cycle_setD simp: proj_arcs_G_in_arcs_H)"], ["proof (state)\nthis:\n  x \\<in> arcs H\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "moreover"], ["proof (state)\nthis:\n  x \\<in> arcs H\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> arcs H", "have \"x \\<notin> {uv,vu}\" \"x \\<notin> {uw,wu,vw,wv} \\<Longrightarrow> x \\<in> arcs G\""], ["proof (prove)\nusing this:\n  x \\<in> arcs H\n\ngoal (1 subgoal):\n 1. x \\<notin> {uv, rev_G uv} &&&\n    (x \\<notin> {uw, rev_H uw, vw, rev_H vw} \\<Longrightarrow>\n     x \\<in> arcs G)", "using \\<open>a \\<in> arcs G\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> arcs H\n  a \\<in> arcs G\n\ngoal (1 subgoal):\n 1. x \\<notin> {uv, rev_G uv} &&&\n    (x \\<notin> {uw, rev_H uw, vw, rev_H vw} \\<Longrightarrow>\n     x \\<in> arcs G)", "by (auto simp: arcs_H dest: H.in_face_cycle_setD)"], ["proof (state)\nthis:\n  x \\<notin> {uv, rev_G uv}\n  x \\<notin> {uw, rev_H uw, vw, rev_H vw} \\<Longrightarrow> x \\<in> arcs G\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> arcs H\n  x \\<notin> {uv, rev_G uv}\n  x \\<notin> {uw, rev_H uw, vw, rev_H vw} \\<Longrightarrow> x \\<in> arcs G", "have \"GM.face_cycle_succ (proj_arcs_H x) \\<in> {proj_arcs_H (H.face_cycle_succ x),\n          proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ x))}\""], ["proof (prove)\nusing this:\n  x \\<in> arcs H\n  x \\<notin> {uv, rev_G uv}\n  x \\<notin> {uw, rev_H uw, vw, rev_H vw} \\<Longrightarrow> x \\<in> arcs G\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ (proj_arcs_H x)\n    \\<in> {proj_arcs_H (H.face_cycle_succ x),\n           proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ x))}", "by (cases \"x \\<in> {uw,vw,wu,wv}\") (auto simp: G_face_cycle_succ H_face_cycle_succ)"], ["proof (state)\nthis:\n  GM.face_cycle_succ (proj_arcs_H x)\n  \\<in> {proj_arcs_H (H.face_cycle_succ x),\n         proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ x))}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "}"], ["proof (state)\nthis:\n  ?xa3 \\<in> H.face_cycle_set (proj_arcs_G a) \\<Longrightarrow>\n  GM.face_cycle_succ (proj_arcs_H ?xa3)\n  \\<in> {proj_arcs_H (H.face_cycle_succ ?xa3),\n         proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ ?xa3))}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "moreover"], ["proof (state)\nthis:\n  ?xa3 \\<in> H.face_cycle_set (proj_arcs_G a) \\<Longrightarrow>\n  GM.face_cycle_succ (proj_arcs_H ?xa3)\n  \\<in> {proj_arcs_H (H.face_cycle_succ ?xa3),\n         proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ ?xa3))}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "have \"b \\<in> arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> arcs G", "using step(1) \\<open>a \\<in> arcs G\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> GM.face_cycle_set a\n  a \\<in> arcs G\n\ngoal (1 subgoal):\n 1. b \\<in> arcs G", "by (simp add: GM.in_face_cycle_setD GM.face_cycle_set_def)"], ["proof (state)\nthis:\n  b \\<in> arcs G\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> GM.face_cycle_set a;\n        y \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\\<rbrakk>\n       \\<Longrightarrow> GM.face_cycle_succ y\n                         \\<in> proj_arcs_H `\n                               H.face_cycle_set (proj_arcs_G a)", "ultimately"], ["proof (chain)\npicking this:\n  ?xa3 \\<in> H.face_cycle_set (proj_arcs_G a) \\<Longrightarrow>\n  GM.face_cycle_succ (proj_arcs_H ?xa3)\n  \\<in> {proj_arcs_H (H.face_cycle_succ ?xa3),\n         proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ ?xa3))}\n  b \\<in> arcs G", "show ?case"], ["proof (prove)\nusing this:\n  ?xa3 \\<in> H.face_cycle_set (proj_arcs_G a) \\<Longrightarrow>\n  GM.face_cycle_succ (proj_arcs_H ?xa3)\n  \\<in> {proj_arcs_H (H.face_cycle_succ ?xa3),\n         proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ ?xa3))}\n  b \\<in> arcs G\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ b\n    \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)", "using \\<open>b \\<in> arcs G\\<close> step(2)"], ["proof (prove)\nusing this:\n  ?xa3 \\<in> H.face_cycle_set (proj_arcs_G a) \\<Longrightarrow>\n  GM.face_cycle_succ (proj_arcs_H ?xa3)\n  \\<in> {proj_arcs_H (H.face_cycle_succ ?xa3),\n         proj_arcs_H (H.face_cycle_succ (H.face_cycle_succ ?xa3))}\n  b \\<in> arcs G\n  b \\<in> arcs G\n  b \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\n\ngoal (1 subgoal):\n 1. GM.face_cycle_succ b\n    \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)", "by (auto intro: H.face_cycle_succ_inI)"], ["proof (state)\nthis:\n  GM.face_cycle_succ b \\<in> proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_H_fcs_in_G_fcs:\n    assumes \"a \\<in> arcs H\"\n    assumes \"x \\<in> H.face_cycle_set a\"\n    shows \"x \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)", "using \\<open>x \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H.face_cycle_set a\n\ngoal (1 subgoal):\n 1. x \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n 2. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. a \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n 2. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)", "by auto"], ["proof (state)\nthis:\n  a \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "case (step y)"], ["proof (state)\nthis:\n  y \\<in> H.face_cycle_set a\n  y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "then"], ["proof (chain)\npicking this:\n  y \\<in> H.face_cycle_set a\n  y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)", "have \"y \\<in> arcs H\""], ["proof (prove)\nusing this:\n  y \\<in> H.face_cycle_set a\n  y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n\ngoal (1 subgoal):\n 1. y \\<in> arcs H", "using \\<open>a \\<in> arcs H\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> H.face_cycle_set a\n  y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n  a \\<in> arcs H\n\ngoal (1 subgoal):\n 1. y \\<in> arcs H", "by (auto dest: H.in_face_cycle_setD)"], ["proof (state)\nthis:\n  y \\<in> arcs H\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "moreover"], ["proof (state)\nthis:\n  y \\<in> arcs H\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "then"], ["proof (chain)\npicking this:\n  y \\<in> arcs H", "have \"y \\<notin> {uv,vu}\""], ["proof (prove)\nusing this:\n  y \\<in> arcs H\n\ngoal (1 subgoal):\n 1. y \\<notin> {uv, rev_G uv}", "by (fastforce simp: arcs_H)"], ["proof (state)\nthis:\n  y \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> arcs H\n  y \\<notin> {uv, rev_G uv}", "have \"proj_arcs_H (H.face_cycle_succ y) = GM.face_cycle_succ (proj_arcs_H y)\n        \\<or> proj_arcs_H (H.face_cycle_succ y) = proj_arcs_H y\""], ["proof (prove)\nusing this:\n  y \\<in> arcs H\n  y \\<notin> {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. proj_arcs_H (H.face_cycle_succ y) =\n    GM.face_cycle_succ (proj_arcs_H y) \\<or>\n    proj_arcs_H (H.face_cycle_succ y) = proj_arcs_H y", "by (cases \"y \\<in> {uw,vw,wv,wu}\") (auto simp: H_face_cycle_succ G_face_cycle_succ arcs_G)"], ["proof (state)\nthis:\n  proj_arcs_H (H.face_cycle_succ y) =\n  GM.face_cycle_succ (proj_arcs_H y) \\<or>\n  proj_arcs_H (H.face_cycle_succ y) = proj_arcs_H y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> H.face_cycle_set a;\n        y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\\<rbrakk>\n       \\<Longrightarrow> H.face_cycle_succ y\n                         \\<in> proj_arcs_H -`\n                               GM.face_cycle_set (proj_arcs_H a)", "with step"], ["proof (chain)\npicking this:\n  y \\<in> H.face_cycle_set a\n  y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n  proj_arcs_H (H.face_cycle_succ y) =\n  GM.face_cycle_succ (proj_arcs_H y) \\<or>\n  proj_arcs_H (H.face_cycle_succ y) = proj_arcs_H y", "show ?case"], ["proof (prove)\nusing this:\n  y \\<in> H.face_cycle_set a\n  y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n  proj_arcs_H (H.face_cycle_succ y) =\n  GM.face_cycle_succ (proj_arcs_H y) \\<or>\n  proj_arcs_H (H.face_cycle_succ y) = proj_arcs_H y\n\ngoal (1 subgoal):\n 1. H.face_cycle_succ y\n    \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)", "by (auto intro: GM.face_cycle_succ_inI)"], ["proof (state)\nthis:\n  H.face_cycle_succ y \\<in> proj_arcs_H -` GM.face_cycle_set (proj_arcs_H a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma G_fcs_eq:\n    assumes \"a \\<in> arcs G\"\n    shows \"GM.face_cycle_set a = proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.face_cycle_set a = proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n\ngoal (1 subgoal):\n 1. GM.face_cycle_set a = proj_arcs_H ` H.face_cycle_set (proj_arcs_G a)", "by (auto dest: in_H_fcs_in_G_fcs[rotated] in_G_fcs_in_H_fcs[rotated]\n      simp: proj_arcs_G_in_arcs_H proj_arcs_HG)"], ["", "lemma H_fcs_eq:\n    assumes \"a \\<in> arcs H\"\n    shows \"proj_arcs_H ` H.face_cycle_set a = GM.face_cycle_set (proj_arcs_H a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_arcs_H ` H.face_cycle_set a = GM.face_cycle_set (proj_arcs_H a)", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> arcs H\n\ngoal (1 subgoal):\n 1. proj_arcs_H ` H.face_cycle_set a = GM.face_cycle_set (proj_arcs_H a)", "by (auto dest: in_H_fcs_in_G_fcs[rotated] in_G_fcs_in_H_fcs[rotated]\n      simp: proj_arcs_H_in_arcs_G fcs_proj_arcs_GH)"], ["", "lemma face_cycle_sets:\n    shows \"GM.face_cycle_sets = (`) proj_arcs_H ` H.face_cycle_sets\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.face_cycle_sets = (`) proj_arcs_H ` H.face_cycle_sets", "unfolding GM.face_cycle_sets_def H.face_cycle_sets_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.face_cycle_set ` arcs G = (`) proj_arcs_H ` H.face_cycle_set ` arcs H", "by (blast intro!: H_fcs_eq G_fcs_eq proj_arcs_G_in_arcs_H proj_arcs_H_in_arcs_G)"], ["", "lemma inj_on_proj_arcs_H: \"inj_on ((`) proj_arcs_H) H.face_cycle_sets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((`) proj_arcs_H) H.face_cycle_sets", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume fcs: \"A \\<in> H.face_cycle_sets\" \"B \\<in> H.face_cycle_sets\"\n      and pa_eq: \"proj_arcs_H ` A = proj_arcs_H ` B\""], ["proof (state)\nthis:\n  A \\<in> H.face_cycle_sets\n  B \\<in> H.face_cycle_sets\n  proj_arcs_H ` A = proj_arcs_H ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have xw_iff_wy:\n      \"\\<And>X. X \\<in> H.face_cycle_sets \\<Longrightarrow> uw \\<in> X \\<longleftrightarrow> wv \\<in> X\"\n      \"\\<And>X. X \\<in> H.face_cycle_sets \\<Longrightarrow> vw \\<in> X \\<longleftrightarrow> wu \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        X \\<in> H.face_cycle_sets \\<Longrightarrow>\n        (uw \\<in> X) = (rev_H vw \\<in> X)) &&&\n    (\\<And>X.\n        X \\<in> H.face_cycle_sets \\<Longrightarrow>\n        (vw \\<in> X) = (rev_H uw \\<in> X))", "using H_face_cycle_succ"], ["proof (prove)\nusing this:\n  H.face_cycle_succ uw = rev_H vw\n  H.face_cycle_succ vw = rev_H uw\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        X \\<in> H.face_cycle_sets \\<Longrightarrow>\n        (uw \\<in> X) = (rev_H vw \\<in> X)) &&&\n    (\\<And>X.\n        X \\<in> H.face_cycle_sets \\<Longrightarrow>\n        (vw \\<in> X) = (rev_H uw \\<in> X))", "by (auto simp: H.face_cycle_sets_def dest: H.face_cycle_succ_inI intro: H.face_cycle_succ_inD)"], ["proof (state)\nthis:\n  ?X1 \\<in> H.face_cycle_sets \\<Longrightarrow>\n  (uw \\<in> ?X1) = (rev_H vw \\<in> ?X1)\n  ?X1 \\<in> H.face_cycle_sets \\<Longrightarrow>\n  (vw \\<in> ?X1) = (rev_H uw \\<in> ?X1)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have not_in_A: \"uv \\<notin> A\" \"vu \\<notin> A\" and not_in_B: \"vu \\<notin> B\" \"uv \\<notin> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uv \\<notin> A &&& rev_G uv \\<notin> A) &&&\n    rev_G uv \\<notin> B &&& uv \\<notin> B", "using fcs not_in_arcs_H"], ["proof (prove)\nusing this:\n  A \\<in> H.face_cycle_sets\n  B \\<in> H.face_cycle_sets\n  {uv, rev_G uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. (uv \\<notin> A &&& rev_G uv \\<notin> A) &&&\n    rev_G uv \\<notin> B &&& uv \\<notin> B", "by (auto dest: H.in_face_cycle_setsD)"], ["proof (state)\nthis:\n  uv \\<notin> A\n  rev_G uv \\<notin> A\n  rev_G uv \\<notin> B\n  uv \\<notin> B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"A = proj_arcs_H -` (proj_arcs_H ` A) - {uv,vu}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = proj_arcs_H -` proj_arcs_H ` A - {uv, rev_G uv}", "using subdiv_distinct_arcs not_in_A"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  uv \\<notin> A\n  rev_G uv \\<notin> A\n\ngoal (1 subgoal):\n 1. A = proj_arcs_H -` proj_arcs_H ` A - {uv, rev_G uv}", "by (auto simp: proj_arcs_H_def xw_iff_wy[OF fcs(1)] split: if_splits)"], ["proof (state)\nthis:\n  A = proj_arcs_H -` proj_arcs_H ` A - {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  A = proj_arcs_H -` proj_arcs_H ` A - {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"\\<dots> = proj_arcs_H -` (proj_arcs_H ` B) - {uv,vu}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_arcs_H -` proj_arcs_H ` A - {uv, rev_G uv} =\n    proj_arcs_H -` proj_arcs_H ` B - {uv, rev_G uv}", "by (simp add: pa_eq)"], ["proof (state)\nthis:\n  proj_arcs_H -` proj_arcs_H ` A - {uv, rev_G uv} =\n  proj_arcs_H -` proj_arcs_H ` B - {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  proj_arcs_H -` proj_arcs_H ` A - {uv, rev_G uv} =\n  proj_arcs_H -` proj_arcs_H ` B - {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"\\<dots> = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_arcs_H -` proj_arcs_H ` B - {uv, rev_G uv} = B", "using subdiv_distinct_arcs not_in_B"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n  rev_G uv \\<notin> B\n  uv \\<notin> B\n\ngoal (1 subgoal):\n 1. proj_arcs_H -` proj_arcs_H ` B - {uv, rev_G uv} = B", "by (auto simp: proj_arcs_H_def xw_iff_wy[OF fcs(2)] split: if_splits)"], ["proof (state)\nthis:\n  proj_arcs_H -` proj_arcs_H ` B - {uv, rev_G uv} = B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> H.face_cycle_sets; y \\<in> H.face_cycle_sets;\n        proj_arcs_H ` x = proj_arcs_H ` y\\<rbrakk>\n       \\<Longrightarrow> x = y", "finally"], ["proof (chain)\npicking this:\n  A = B", "show \"A = B\""], ["proof (prove)\nusing this:\n  A = B\n\ngoal (1 subgoal):\n 1. A = B", "."], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_face_cycle_sets: \"card GM.face_cycle_sets = card H.face_cycle_sets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card GM.face_cycle_sets = card H.face_cycle_sets", "unfolding face_cycle_sets"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((`) proj_arcs_H ` H.face_cycle_sets) = card H.face_cycle_sets", "using inj_on_proj_arcs_H"], ["proof (prove)\nusing this:\n  inj_on ((`) proj_arcs_H) H.face_cycle_sets\n\ngoal (1 subgoal):\n 1. card ((`) proj_arcs_H ` H.face_cycle_sets) = card H.face_cycle_sets", "by (rule card_image)"], ["", "lemma euler_char_eq: \"GM.euler_char = H.euler_char\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.euler_char = H.euler_char", "by (auto simp: GM.euler_char_def H.euler_char_def card_verts card_arcs card_face_cycle_sets)"], ["", "lemma euler_genus_eq: \"GM.euler_genus = H.euler_genus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GM.euler_genus = H.euler_genus", "by (auto simp: GM.euler_genus_def H.euler_genus_def euler_char_eq card_sccs_eq isolated_verts_eq)"], ["", "end"], ["", "lemma subdivision_genus_same_rev:\n  assumes \"subdivision (G, rev_G) (H, edge_rev HM)\" \"digraph_map H HM\" \"pre_digraph_map.euler_genus H HM = m\"\n  shows \"\\<exists>GM. digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and>\n       pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and>\n       pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G", "from assms"], ["proof (chain)\npicking this:\n  subdivision (G, rev_G) (H, edge_rev HM)\n  digraph_map H HM\n  pre_digraph_map.euler_genus H HM = m", "show ?thesis"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, edge_rev HM)\n  digraph_map H HM\n  pre_digraph_map.euler_genus H HM = m\n\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and>\n       pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G", "proof (induction rev_H\\<equiv>\"edge_rev HM\" arbitrary: HM)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>HM.\n       \\<lbrakk>bidirected_digraph G rev_G; rev_G = edge_rev HM;\n        digraph_map G HM; pre_digraph_map.euler_genus G HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G\n 2. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "case base"], ["proof (state)\nthis:\n  bidirected_digraph G rev_G\n  rev_G = edge_rev HM\n  digraph_map G HM\n  pre_digraph_map.euler_genus G HM = m\n\ngoal (2 subgoals):\n 1. \\<And>HM.\n       \\<lbrakk>bidirected_digraph G rev_G; rev_G = edge_rev HM;\n        digraph_map G HM; pre_digraph_map.euler_genus G HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G\n 2. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "then"], ["proof (chain)\npicking this:\n  bidirected_digraph G rev_G\n  rev_G = edge_rev HM\n  digraph_map G HM\n  pre_digraph_map.euler_genus G HM = m", "show ?case"], ["proof (prove)\nusing this:\n  bidirected_digraph G rev_G\n  rev_G = edge_rev HM\n  digraph_map G HM\n  pre_digraph_map.euler_genus G HM = m\n\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and>\n       pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G", "by auto"], ["proof (state)\nthis:\n  \\<exists>GM.\n     digraph_map G GM \\<and>\n     pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "case (divide I rev_I H u v w uv uw vw)"], ["proof (state)\nthis:\n  subdivision (G, rev_G) (I, rev_I)\n  \\<lbrakk>rev_I = edge_rev ?HM; digraph_map I ?HM;\n   pre_digraph_map.euler_genus I ?HM = m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>GM.\n                       digraph_map G GM \\<and>\n                       pre_digraph_map.euler_genus G GM = m \\<and>\n                       edge_rev GM = rev_G\n  subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw)\n  digraph_map H HM\n  pre_digraph_map.euler_genus H HM = m\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "then"], ["proof (chain)\npicking this:\n  subdivision (G, rev_G) (I, rev_I)\n  \\<lbrakk>rev_I = edge_rev ?HM; digraph_map I ?HM;\n   pre_digraph_map.euler_genus I ?HM = m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>GM.\n                       digraph_map G GM \\<and>\n                       pre_digraph_map.euler_genus G GM = m \\<and>\n                       edge_rev GM = rev_G\n  subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw)\n  digraph_map H HM\n  pre_digraph_map.euler_genus H HM = m", "interpret subdiv_step I rev_I H \"edge_rev HM\" u v w uv uw vw"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (I, rev_I)\n  \\<lbrakk>rev_I = edge_rev ?HM; digraph_map I ?HM;\n   pre_digraph_map.euler_genus I ?HM = m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>GM.\n                       digraph_map G GM \\<and>\n                       pre_digraph_map.euler_genus G GM = m \\<and>\n                       edge_rev GM = rev_G\n  subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw)\n  digraph_map H HM\n  pre_digraph_map.euler_genus H HM = m\n\ngoal (1 subgoal):\n 1. subdiv_step I rev_I H (edge_rev HM) u v w uv uw vw", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "interpret H: digraph_map H HM"], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map H HM", "using \\<open>digraph_map H HM\\<close>"], ["proof (prove)\nusing this:\n  digraph_map H HM\n\ngoal (1 subgoal):\n 1. digraph_map H HM", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "interpret IH: subdiv1_contr I rev_I H \"edge_rev HM\" u v w uv uw vw HM"], ["proof (prove)\ngoal (1 subgoal):\n 1. subdiv1_contr I rev_I H (edge_rev HM) u v w uv uw vw HM", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "have eulerI: \"IH.GM.euler_genus = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IH.GM.euler_genus = m", "by (auto simp: IH.euler_genus_eq divide)"], ["proof (state)\nthis:\n  IH.GM.euler_genus = m\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H u v w uv uw vw HM.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>HM.\n           \\<lbrakk>rev_I = edge_rev HM; digraph_map I HM;\n            pre_digraph_map.euler_genus I HM = m\\<rbrakk>\n           \\<Longrightarrow> \\<exists>GM.\n                                digraph_map G GM \\<and>\n                                pre_digraph_map.euler_genus G GM = m \\<and>\n                                edge_rev GM = rev_G;\n        subdivision_step I rev_I H (edge_rev HM) (u, v, w) (uv, uw, vw);\n        digraph_map H HM; pre_digraph_map.euler_genus H HM = m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>GM.\n                            digraph_map G GM \\<and>\n                            pre_digraph_map.euler_genus G GM = m \\<and>\n                            edge_rev GM = rev_G", "with _ IH.digraph_map_GM"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  digraph_map I IH.GM\n  IH.GM.euler_genus = m", "show ?case"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  digraph_map I IH.GM\n  IH.GM.euler_genus = m\n\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and>\n       pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G", "by (rule divide) (simp add: IH.edge_rev_GM)"], ["proof (state)\nthis:\n  \\<exists>GM.\n     digraph_map G GM \\<and>\n     pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>GM.\n     digraph_map G GM \\<and>\n     pre_digraph_map.euler_genus G GM = m \\<and> edge_rev GM = rev_G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subdivision_genus:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"digraph_map H HM\" \"pre_digraph_map.euler_genus H HM = m\"\n  shows \"\\<exists>GM. digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m", "interpret H: digraph_map H HM"], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map H HM", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m", "using subdivision_genus_same_rev subdivision_choose_rev assms H.bidirected_digraph"], ["proof (prove)\nusing this:\n  \\<lbrakk>subdivision (?G, ?rev_G) (?H, edge_rev ?HM); digraph_map ?H ?HM;\n   pre_digraph_map.euler_genus ?H ?HM = ?m\\<rbrakk>\n  \\<Longrightarrow> \\<exists>GM.\n                       digraph_map ?G GM \\<and>\n                       pre_digraph_map.euler_genus ?G GM = ?m \\<and>\n                       edge_rev GM = ?rev_G\n  \\<lbrakk>subdivision (?G, ?rev_G) (?H, ?rev_H);\n   bidirected_digraph ?H ?rev_H'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>rev_G'. subdivision (?G, rev_G') (?H, ?rev_H')\n  subdivision (G, rev_G) (H, rev_H)\n  digraph_map H HM\n  H.euler_genus = m\n  bidirected_digraph H (edge_rev HM)\n\ngoal (1 subgoal):\n 1. \\<exists>GM.\n       digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m", "by metis"], ["proof (state)\nthis:\n  \\<exists>GM. digraph_map G GM \\<and> pre_digraph_map.euler_genus G GM = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subdivision_comb_planar:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"comb_planar H\" shows \"comb_planar G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comb_planar G", "using assms"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n  comb_planar H\n\ngoal (1 subgoal):\n 1. comb_planar G", "unfolding comb_planar_def"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n  \\<exists>M. digraph_map H M \\<and> pre_digraph_map.euler_genus H M = 0\n\ngoal (1 subgoal):\n 1. \\<exists>M. digraph_map G M \\<and> pre_digraph_map.euler_genus G M = 0", "by (metis subdivision_genus)"], ["", "end"]]}