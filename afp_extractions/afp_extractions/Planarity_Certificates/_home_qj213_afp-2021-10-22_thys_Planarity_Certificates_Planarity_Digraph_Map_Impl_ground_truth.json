{"file_name": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates/Planarity/Digraph_Map_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates", "problem_names": ["lemma list_digraph_simps:\n  \"pverts (list_digraph G_list) = set (fst G_list)\"\n  \"parcs (list_digraph G_list) = set (snd G_list)\"", "lemma union_grouped_by_fst:\n  \"(\\<Union>xs \\<in> set (grouped_by_fst ys). set xs) = set ys\"", "lemma union_grouped_out_arcs:\n  \"(\\<Union>xs \\<in> set (grouped_out_arcs G_list). set xs) = set (snd G_list)\"", "lemma nil_not_in_grouped_out_arcs: \"[] \\<notin> set (grouped_out_arcs G_list)\"", "lemma set_grouped_out_arcs:\n  assumes \"pair_wf_digraph (list_digraph G_list)\"\n  shows \"set ` set (grouped_out_arcs G_list) = {out_arcs (list_digraph G_list) v | v. v \\<in> pverts (list_digraph G_list) \\<and> out_arcs (list_digraph G_list) v \\<noteq> {} }\"\n    (is \"?L = ?R\")", "lemma distincts_grouped_by_fst:\n  assumes \"distinct xs\" shows \"distincts (grouped_by_fst xs)\"", "lemma distincts_grouped_arcs:\n  assumes \"distinct (snd G_list)\" shows \"distincts (grouped_out_arcs G_list)\"", "lemma distincts_in_all_maps_list:\n  \"distinct (snd X) \\<Longrightarrow> xss \\<in> set (all_maps_list X) \\<Longrightarrow> distincts xss\"", "lemma (in pair_graph) all_maps_correct:\n  shows \"all_maps G = {M. digraph_map G M}\"", "lemma set_maps_all_maps_list:\n  assumes \"pair_wf_digraph (list_digraph G_list)\" \"distinct (snd G_list)\"\n  shows \"all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)\"", "lemma edge_rev_simps:\n  assumes \"(u,v) \\<in> parcs G\" shows \"edge_rev M (u,v) = (v,u)\"", "lemma M_simps:\n  \"edge_succ M = lists_succ xss\"", "lemma lists_fc_succ_permutes: \"lists_fc_succ xss permutes (\\<Union>(sset xss))\"", "lemma permutation_lists_fc_succ[intro, simp]: \"permutation (lists_fc_succ xss)\"", "lemma face_cycle_succ_conv: \"face_cycle_succ = lists_fc_succ xss\"", "lemma sset_lists_fcs:\n  \"sset (lists_fcs as) = {face_cycle_set a | a. a \\<in> set as}\"", "lemma distincts_lists_fcs: \"distinct as \\<Longrightarrow>distincts (lists_fcs as)\"", "lemma face_cycle_set_ss: \"a \\<in> parcs G \\<Longrightarrow> face_cycle_set a \\<subseteq> parcs G\"", "lemma face_cycle_succ_neq:\n  assumes \"a \\<in> parcs G\" shows \"face_cycle_succ a \\<noteq> a\"", "lemma card_face_cycle_sets_conv:\n  shows \"card (pre_digraph_map.face_cycle_sets G M) = length (lists_fcs (remdups (snd G_list)))\"", "lemma sccs_verts_impl_correct:\n  assumes \"pair_pseudo_graph (list_digraph G)\"\n  shows \"pre_digraph.sccs_verts (list_digraph G) = sccs_verts_impl G\"", "lemma isolated_verts_impl_correct:\n  \"pre_digraph.isolated_verts (list_digraph G) = set (isolated_verts_impl G)\"", "lemma pair_graph_impl_correct[code]:\n  \"pair_graph (list_digraph G) = pair_graph_impl G\" (is \"?L = ?R\")", "lemma genus_impl_correct:\n  assumes dist_V: \"distinct (fst G)\" and dist_A: \"distinct (snd G)\"\n  assumes \"lists_digraph_map G M\"\n  shows \"pre_digraph_map.euler_genus (list_digraph G) (to_map' (snd G) M) = genus_impl G M\"", "lemma elems_all_maps_list:\n  assumes \"M \\<in> set (all_maps_list G)\" \"distinct (snd G)\"\n  shows \"\\<Union>(sset M) = set (snd G)\"", "lemma comb_planar_impl_altdef: \"comb_planar_impl G = (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)\"", "lemma comb_planar_impl_correct:\n  assumes \"pair_graph (list_digraph G)\"\n  assumes dist_V: \"distinct (fst G)\" and dist_A: \"distinct (snd G)\"\n  shows \"comb_planar (list_digraph G) = comb_planar_impl G\" (is \"?L = ?R\")"], "translations": [["", "lemma list_digraph_simps:\n  \"pverts (list_digraph G_list) = set (fst G_list)\"\n  \"parcs (list_digraph G_list) = set (snd G_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pverts (list_digraph G_list) = set (fst G_list) &&&\n    parcs (list_digraph G_list) = set (snd G_list)", "by (auto simp: list_digraph_ext_def)"], ["", "lemma union_grouped_by_fst:\n  \"(\\<Union>xs \\<in> set (grouped_by_fst ys). set xs) = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (sset (grouped_by_fst ys)) = set ys", "by (auto simp: grouped_by_fst_def)"], ["", "lemma union_grouped_out_arcs:\n  \"(\\<Union>xs \\<in> set (grouped_out_arcs G_list). set xs) = set (snd G_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (sset (grouped_out_arcs G_list)) = set (snd G_list)", "by (cases G_list) (simp add: union_grouped_by_fst)"], ["", "lemma nil_not_in_grouped_out_arcs: \"[] \\<notin> set (grouped_out_arcs G_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<notin> set (grouped_out_arcs G_list)", "apply (cases G_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       G_list = (a, b) \\<Longrightarrow>\n       [] \\<notin> set (grouped_out_arcs G_list)", "apply (auto simp: grouped_by_fst_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>G_list = (a, b); [] = filter (\\<lambda>x. fst x = aa) b;\n        (aa, ba) \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis (mono_tags) filter_empty_conv fst_conv)"], ["", "lemma set_grouped_out_arcs:\n  assumes \"pair_wf_digraph (list_digraph G_list)\"\n  shows \"set ` set (grouped_out_arcs G_list) = {out_arcs (list_digraph G_list) v | v. v \\<in> pverts (list_digraph G_list) \\<and> out_arcs (list_digraph G_list) v \\<noteq> {} }\"\n    (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "interpret pair_wf_digraph \"list_digraph G_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_wf_digraph (list_digraph G_list)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "define vs where \"vs = remdups (map fst (snd G_list))\""], ["proof (state)\nthis:\n  vs = remdups (map fst (snd G_list))\n\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "have \"set vs = {v. out_arcs (list_digraph G_list) v \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set vs = {v. out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "by (auto simp: out_arcs_def list_digraph_ext_def vs_def intro: rev_image_eqI )"], ["proof (state)\nthis:\n  set vs = {v. out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "then"], ["proof (chain)\npicking this:\n  set vs = {v. out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "have vs: \"set vs = {v \\<in> pverts (list_digraph G_list). out_arcs (list_digraph G_list) v \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  set vs = {v. out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. set vs =\n    {v \\<in> pverts (list_digraph G_list).\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "by (auto dest: in_arcsD1)"], ["proof (state)\nthis:\n  set vs =\n  {v \\<in> pverts (list_digraph G_list).\n   out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "have goa: \"grouped_out_arcs G_list = map (\\<lambda>u. filter (\\<lambda>x. fst x = u) (snd G_list)) vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grouped_out_arcs G_list =\n    map (\\<lambda>u. filter (\\<lambda>x. fst x = u) (snd G_list)) vs", "by (cases G_list) (auto simp: grouped_by_fst_def vs_def)"], ["proof (state)\nthis:\n  grouped_out_arcs G_list =\n  map (\\<lambda>u. filter (\\<lambda>x. fst x = u) (snd G_list)) vs\n\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "have filter: \"set \\<circ> (\\<lambda>u. filter (\\<lambda>x. fst x = u) (snd G_list)) = out_arcs (list_digraph G_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<circ> (\\<lambda>u. filter (\\<lambda>x. fst x = u) (snd G_list)) =\n    out_arcs (with_proj (list_digraph G_list))", "by (rule ext) (auto simp: list_digraph_ext_def)"], ["proof (state)\nthis:\n  set \\<circ> (\\<lambda>u. filter (\\<lambda>x. fst x = u) (snd G_list)) =\n  out_arcs (with_proj (list_digraph G_list))\n\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "have \"set (map set (grouped_out_arcs G_list)) = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map set (grouped_out_arcs G_list)) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "by (auto simp add: goa filter vs)"], ["proof (state)\nthis:\n  set (map set (grouped_out_arcs G_list)) =\n  {out_arcs (with_proj (list_digraph G_list)) v |v.\n   v \\<in> pverts (list_digraph G_list) \\<and>\n   out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "then"], ["proof (chain)\npicking this:\n  set (map set (grouped_out_arcs G_list)) =\n  {out_arcs (with_proj (list_digraph G_list)) v |v.\n   v \\<in> pverts (list_digraph G_list) \\<and>\n   out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (map set (grouped_out_arcs G_list)) =\n  {out_arcs (with_proj (list_digraph G_list)) v |v.\n   v \\<in> pverts (list_digraph G_list) \\<and>\n   out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. sset (grouped_out_arcs G_list) =\n    {out_arcs (with_proj (list_digraph G_list)) v |v.\n     v \\<in> pverts (list_digraph G_list) \\<and>\n     out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}", "by simp"], ["proof (state)\nthis:\n  sset (grouped_out_arcs G_list) =\n  {out_arcs (with_proj (list_digraph G_list)) v |v.\n   v \\<in> pverts (list_digraph G_list) \\<and>\n   out_arcs (with_proj (list_digraph G_list)) v \\<noteq> {}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distincts_grouped_by_fst:\n  assumes \"distinct xs\" shows \"distincts (grouped_by_fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (grouped_by_fst xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distincts (grouped_by_fst xs)", "have list_eq_setD: \"\\<And>xs ys. xs = ys \\<Longrightarrow> set xs = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys. xs = ys \\<Longrightarrow> set xs = set ys", "by auto"], ["proof (state)\nthis:\n  ?xs = ?ys \\<Longrightarrow> set ?xs = set ?ys\n\ngoal (1 subgoal):\n 1. distincts (grouped_by_fst xs)", "have inj: \"inj_on (\\<lambda>u. filter (\\<lambda>x. fst x = u) xs) (fst ` set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>u. filter (\\<lambda>x. fst x = u) xs) (fst ` set xs)", "by (rule inj_onI) (drule list_eq_setD, auto)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>u. filter (\\<lambda>x. fst x = u) xs) (fst ` set xs)\n\ngoal (1 subgoal):\n 1. distincts (grouped_by_fst xs)", "with assms"], ["proof (chain)\npicking this:\n  distinct xs\n  inj_on (\\<lambda>u. filter (\\<lambda>x. fst x = u) xs) (fst ` set xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n  inj_on (\\<lambda>u. filter (\\<lambda>x. fst x = u) xs) (fst ` set xs)\n\ngoal (1 subgoal):\n 1. distincts (grouped_by_fst xs)", "by (auto simp: grouped_by_fst_def distincts_def distinct_map filter_empty_conv)"], ["proof (state)\nthis:\n  distincts (grouped_by_fst xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distincts_grouped_arcs:\n  assumes \"distinct (snd G_list)\" shows \"distincts (grouped_out_arcs G_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts (grouped_out_arcs G_list)", "using assms"], ["proof (prove)\nusing this:\n  distinct (snd G_list)\n\ngoal (1 subgoal):\n 1. distincts (grouped_out_arcs G_list)", "by (cases G_list) (simp add: distincts_grouped_by_fst)"], ["", "lemma distincts_in_all_maps_list:\n  \"distinct (snd X) \\<Longrightarrow> xss \\<in> set (all_maps_list X) \\<Longrightarrow> distincts xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (snd X); xss \\<in> set (all_maps_list X)\\<rbrakk>\n    \\<Longrightarrow> distincts xss", "by (simp add: all_maps_list_def distincts_grouped_arcs in_set_cyc_permutationss)"], ["", "definition to_map :: \"('a \\<times> 'a) set \\<Rightarrow> ('a \\<times> 'a \\<Rightarrow> 'a \\<times> 'a) \\<Rightarrow> ('a \\<times> 'a) pre_map\" where\n  \"to_map A f = \\<lparr> edge_rev = swap_in A, edge_succ = f \\<rparr>\""], ["", "abbreviation \"to_map' as xss \\<equiv> to_map (set as) (lists_succ xss)\""], ["", "definition all_maps :: \"'a pair_pre_digraph \\<Rightarrow> ('a \\<times> 'a) pre_map set\" where\n  \"all_maps G \\<equiv> to_map (arcs G) ` {f. f permutes arcs G \\<and> (\\<forall>v \\<in> verts G. out_arcs G v \\<noteq> {} \\<longrightarrow> cyclic_on f (out_arcs G v))}\""], ["", "definition maps_all_maps_list :: \"('a list \\<times> ('a \\<times> 'a) list) \\<Rightarrow> ('a \\<times> 'a) pre_map list\" where\n  \"maps_all_maps_list G_list = map (to_map (set (snd G_list)) o lists_succ) (all_maps_list G_list)\""], ["", "lemma (in pair_graph) all_maps_correct:\n  shows \"all_maps G = {M. digraph_map G M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_maps G = {M. digraph_map (with_proj G) M}", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> all_maps G \\<Longrightarrow>\n       x \\<in> {M. digraph_map (with_proj G) M}\n 2. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "fix M"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> all_maps G \\<Longrightarrow>\n       x \\<in> {M. digraph_map (with_proj G) M}\n 2. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "assume A:\"M \\<in> all_maps G\""], ["proof (state)\nthis:\n  M \\<in> all_maps G\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> all_maps G \\<Longrightarrow>\n       x \\<in> {M. digraph_map (with_proj G) M}\n 2. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "then"], ["proof (chain)\npicking this:\n  M \\<in> all_maps G", "have [simp]: \"edge_rev M = swap_in (arcs G)\" \"edge_succ M permutes parcs G\""], ["proof (prove)\nusing this:\n  M \\<in> all_maps G\n\ngoal (1 subgoal):\n 1. edge_rev M = swap_in (arcs (with_proj G)) &&&\n    edge_succ M permutes parcs G", "by (auto simp: all_maps_def to_map_def)"], ["proof (state)\nthis:\n  edge_rev M = swap_in (arcs (with_proj G))\n  edge_succ M permutes parcs G\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> all_maps G \\<Longrightarrow>\n       x \\<in> {M. digraph_map (with_proj G) M}\n 2. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "have \"digraph_map G M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map (with_proj G) M", "proof (rule digraph_mapI)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a. a \\<notin> parcs G \\<Longrightarrow> edge_rev M a = a\n 2. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M a \\<noteq> a\n 3. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M (edge_rev M a) = a\n 4. \\<And>a. a \\<in> parcs G \\<Longrightarrow> fst (edge_rev M a) = snd a\n 5. edge_succ M permutes parcs G\n 6. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "fix a"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a. a \\<notin> parcs G \\<Longrightarrow> edge_rev M a = a\n 2. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M a \\<noteq> a\n 3. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M (edge_rev M a) = a\n 4. \\<And>a. a \\<in> parcs G \\<Longrightarrow> fst (edge_rev M a) = snd a\n 5. edge_succ M permutes parcs G\n 6. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "assume \"a \\<notin> parcs G\""], ["proof (state)\nthis:\n  a \\<notin> parcs G\n\ngoal (6 subgoals):\n 1. \\<And>a. a \\<notin> parcs G \\<Longrightarrow> edge_rev M a = a\n 2. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M a \\<noteq> a\n 3. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M (edge_rev M a) = a\n 4. \\<And>a. a \\<in> parcs G \\<Longrightarrow> fst (edge_rev M a) = snd a\n 5. edge_succ M permutes parcs G\n 6. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "then"], ["proof (chain)\npicking this:\n  a \\<notin> parcs G", "show \"edge_rev M a = a\""], ["proof (prove)\nusing this:\n  a \\<notin> parcs G\n\ngoal (1 subgoal):\n 1. edge_rev M a = a", "by (auto simp: swap_in_def)"], ["proof (state)\nthis:\n  edge_rev M a = a\n\ngoal (5 subgoals):\n 1. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M a \\<noteq> a\n 2. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M (edge_rev M a) = a\n 3. \\<And>a. a \\<in> parcs G \\<Longrightarrow> fst (edge_rev M a) = snd a\n 4. edge_succ M permutes parcs G\n 5. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M a \\<noteq> a\n 2. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M (edge_rev M a) = a\n 3. \\<And>a. a \\<in> parcs G \\<Longrightarrow> fst (edge_rev M a) = snd a\n 4. edge_succ M permutes parcs G\n 5. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "fix a"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M a \\<noteq> a\n 2. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M (edge_rev M a) = a\n 3. \\<And>a. a \\<in> parcs G \\<Longrightarrow> fst (edge_rev M a) = snd a\n 4. edge_succ M permutes parcs G\n 5. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "assume \"a \\<in> parcs G\""], ["proof (state)\nthis:\n  a \\<in> parcs G\n\ngoal (5 subgoals):\n 1. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M a \\<noteq> a\n 2. \\<And>a. a \\<in> parcs G \\<Longrightarrow> edge_rev M (edge_rev M a) = a\n 3. \\<And>a. a \\<in> parcs G \\<Longrightarrow> fst (edge_rev M a) = snd a\n 4. edge_succ M permutes parcs G\n 5. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "then"], ["proof (chain)\npicking this:\n  a \\<in> parcs G", "show \"edge_rev M (edge_rev M a) = a\" \"fst (edge_rev M a) = snd a\" \"edge_rev M a \\<noteq> a\""], ["proof (prove)\nusing this:\n  a \\<in> parcs G\n\ngoal (1 subgoal):\n 1. edge_rev M (edge_rev M a) = a &&&\n    fst (edge_rev M a) = snd a &&& edge_rev M a \\<noteq> a", "by (case_tac [!] \"a\") (auto intro: arcs_symmetric simp: swap_in_def dest: no_loops)"], ["proof (state)\nthis:\n  edge_rev M (edge_rev M a) = a\n  fst (edge_rev M a) = snd a\n  edge_rev M a \\<noteq> a\n\ngoal (2 subgoals):\n 1. edge_succ M permutes parcs G\n 2. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. edge_succ M permutes parcs G\n 2. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "show \"edge_succ M permutes parcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ M permutes parcs G", "by simp"], ["proof (state)\nthis:\n  edge_succ M permutes parcs G\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "assume \"v \\<in> pverts G\" \"out_arcs (with_proj G) v \\<noteq> {}\""], ["proof (state)\nthis:\n  v \\<in> pverts G\n  out_arcs (with_proj G) v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>v \\<in> pverts G;\n        out_arcs (with_proj G) v \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "then"], ["proof (chain)\npicking this:\n  v \\<in> pverts G\n  out_arcs (with_proj G) v \\<noteq> {}", "show \"cyclic_on (edge_succ M) (out_arcs (with_proj G) v)\""], ["proof (prove)\nusing this:\n  v \\<in> pverts G\n  out_arcs (with_proj G) v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "using A"], ["proof (prove)\nusing this:\n  v \\<in> pverts G\n  out_arcs (with_proj G) v \\<noteq> {}\n  M \\<in> all_maps G\n\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "unfolding all_maps_def"], ["proof (prove)\nusing this:\n  v \\<in> pverts G\n  out_arcs (with_proj G) v \\<noteq> {}\n  M \\<in> to_map (arcs (with_proj G)) `\n          {f. f permutes arcs (with_proj G) \\<and>\n              (\\<forall>v\\<in>verts (with_proj G).\n                  out_arcs (with_proj G) v \\<noteq> {} \\<longrightarrow>\n                  cyclic_on f (out_arcs (with_proj G) v))}\n\ngoal (1 subgoal):\n 1. cyclic_on (edge_succ M) (out_arcs (with_proj G) v)", "by (auto simp: to_map_def)"], ["proof (state)\nthis:\n  cyclic_on (edge_succ M) (out_arcs (with_proj G) v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  digraph_map (with_proj G) M\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> all_maps G \\<Longrightarrow>\n       x \\<in> {M. digraph_map (with_proj G) M}\n 2. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "then"], ["proof (chain)\npicking this:\n  digraph_map (with_proj G) M", "show \"M \\<in> {M. digraph_map G M}\""], ["proof (prove)\nusing this:\n  digraph_map (with_proj G) M\n\ngoal (1 subgoal):\n 1. M \\<in> {M. digraph_map (with_proj G) M}", "by simp"], ["proof (state)\nthis:\n  M \\<in> {M. digraph_map (with_proj G) M}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "fix M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "assume A: \"M \\<in> {M. digraph_map G M}\""], ["proof (state)\nthis:\n  M \\<in> {M. digraph_map (with_proj G) M}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "then"], ["proof (chain)\npicking this:\n  M \\<in> {M. digraph_map (with_proj G) M}", "interpret M: digraph_map G M"], ["proof (prove)\nusing this:\n  M \\<in> {M. digraph_map (with_proj G) M}\n\ngoal (1 subgoal):\n 1. digraph_map (with_proj G) M", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "from A"], ["proof (chain)\npicking this:\n  M \\<in> {M. digraph_map (with_proj G) M}", "have \"\\<And>x. fst (edge_rev M x) = fst (swap_in (arcs G) x)\"\n      \"\\<And>x. snd (edge_rev M x) = snd (swap_in (arcs G) x)\""], ["proof (prove)\nusing this:\n  M \\<in> {M. digraph_map (with_proj G) M}\n\ngoal (1 subgoal):\n 1. (\\<And>x. fst (edge_rev M x) = fst (swap_in (arcs (with_proj G)) x)) &&&\n    (\\<And>x. snd (edge_rev M x) = snd (swap_in (arcs (with_proj G)) x))", "using M.tail_arev M.head_arev"], ["proof (prove)\nusing this:\n  M \\<in> {M. digraph_map (with_proj G) M}\n  ?a \\<in> arcs (with_proj G) \\<Longrightarrow>\n  tail (with_proj G) (edge_rev M ?a) = head (with_proj G) ?a\n  ?a \\<in> arcs (with_proj G) \\<Longrightarrow>\n  head (with_proj G) (edge_rev M ?a) = tail (with_proj G) ?a\n\ngoal (1 subgoal):\n 1. (\\<And>x. fst (edge_rev M x) = fst (swap_in (arcs (with_proj G)) x)) &&&\n    (\\<And>x. snd (edge_rev M x) = snd (swap_in (arcs (with_proj G)) x))", "by (auto simp: fun_eq_iff swap_in_def M.arev_eq)"], ["proof (state)\nthis:\n  fst (edge_rev M ?x1) = fst (swap_in (arcs (with_proj G)) ?x1)\n  snd (edge_rev M ?x1) = snd (swap_in (arcs (with_proj G)) ?x1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "then"], ["proof (chain)\npicking this:\n  fst (edge_rev M ?x1) = fst (swap_in (arcs (with_proj G)) ?x1)\n  snd (edge_rev M ?x1) = snd (swap_in (arcs (with_proj G)) ?x1)", "have \"edge_rev M = swap_in (arcs G)\""], ["proof (prove)\nusing this:\n  fst (edge_rev M ?x1) = fst (swap_in (arcs (with_proj G)) ?x1)\n  snd (edge_rev M ?x1) = snd (swap_in (arcs (with_proj G)) ?x1)\n\ngoal (1 subgoal):\n 1. edge_rev M = swap_in (arcs (with_proj G))", "by (metis prod.collapse fun_eq_iff)"], ["proof (state)\nthis:\n  edge_rev M = swap_in (arcs (with_proj G))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {M. digraph_map (with_proj G) M} \\<Longrightarrow>\n       x \\<in> all_maps G", "then"], ["proof (chain)\npicking this:\n  edge_rev M = swap_in (arcs (with_proj G))", "show \"M \\<in> all_maps G\""], ["proof (prove)\nusing this:\n  edge_rev M = swap_in (arcs (with_proj G))\n\ngoal (1 subgoal):\n 1. M \\<in> all_maps G", "using M.edge_succ_permutes M.edge_succ_cyclic"], ["proof (prove)\nusing this:\n  edge_rev M = swap_in (arcs (with_proj G))\n  edge_succ M permutes arcs (with_proj G)\n  \\<lbrakk>?v \\<in> verts (with_proj G);\n   out_arcs (with_proj G) ?v \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) ?v)\n\ngoal (1 subgoal):\n 1. M \\<in> all_maps G", "unfolding all_maps_def"], ["proof (prove)\nusing this:\n  edge_rev M = swap_in (arcs (with_proj G))\n  edge_succ M permutes arcs (with_proj G)\n  \\<lbrakk>?v \\<in> verts (with_proj G);\n   out_arcs (with_proj G) ?v \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cyclic_on (edge_succ M) (out_arcs (with_proj G) ?v)\n\ngoal (1 subgoal):\n 1. M \\<in> to_map (arcs (with_proj G)) `\n            {f. f permutes arcs (with_proj G) \\<and>\n                (\\<forall>v\\<in>verts (with_proj G).\n                    out_arcs (with_proj G) v \\<noteq> {} \\<longrightarrow>\n                    cyclic_on f (out_arcs (with_proj G) v))}", "by (auto simp: to_map_def intro!: image_eqI[where x=\"edge_succ M\"])"], ["proof (state)\nthis:\n  M \\<in> all_maps G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_maps_all_maps_list:\n  assumes \"pair_wf_digraph (list_digraph G_list)\" \"distinct (snd G_list)\"\n  shows \"all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "let ?G = \"list_digraph G_list\""], ["proof (state)\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "have \"(\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x))\n        \\<longleftrightarrow> (\\<forall>x\\<in>set ` set (grouped_out_arcs G_list). cyclic_on f x)\" (is \"?all1 = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x)) =\n    (\\<forall>x\\<in>sset (grouped_out_arcs G_list). cyclic_on f x)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x)) =\n  (\\<forall>x\\<in>sset (grouped_out_arcs G_list). cyclic_on f x)\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "also"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x)) =\n  (\\<forall>x\\<in>sset (grouped_out_arcs G_list). cyclic_on f x)\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "have \"\\<dots> \\<longleftrightarrow> (\\<forall>v\\<in>pverts ?G. out_arcs ?G v \\<noteq> {} \\<longrightarrow> cyclic_on f (out_arcs ?G v))\" (is \"_ = ?all2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>sset (grouped_out_arcs G_list). cyclic_on f x) =\n    (\\<forall>v\\<in>pverts (list_digraph G_list).\n        out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n        {} \\<longrightarrow>\n        cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))", "using assms"], ["proof (prove)\nusing this:\n  pair_wf_digraph (list_digraph G_list)\n  distinct (snd G_list)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>sset (grouped_out_arcs G_list). cyclic_on f x) =\n    (\\<forall>v\\<in>pverts (list_digraph G_list).\n        out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n        {} \\<longrightarrow>\n        cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))", "by (auto simp: set_grouped_out_arcs)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>sset (grouped_out_arcs G_list). cyclic_on f x) =\n  (\\<forall>v\\<in>pverts (list_digraph G_list).\n      out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n      {} \\<longrightarrow>\n      cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x)) =\n  (\\<forall>v\\<in>pverts (list_digraph G_list).\n      out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n      {} \\<longrightarrow>\n      cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))", "have \"?all1 = ?all2\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x)) =\n  (\\<forall>v\\<in>pverts (list_digraph G_list).\n      out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n      {} \\<longrightarrow>\n      cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x)) =\n    (\\<forall>v\\<in>pverts (list_digraph G_list).\n        out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n        {} \\<longrightarrow>\n        cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))", "."], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on f (set x)) =\n  (\\<forall>v\\<in>pverts (list_digraph G_list).\n      out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n      {} \\<longrightarrow>\n      cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "}"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on ?f2 (set x)) =\n  (\\<forall>v\\<in>pverts (list_digraph G_list).\n      out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n      {} \\<longrightarrow>\n      cyclic_on ?f2 (out_arcs (with_proj (list_digraph G_list)) v))\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "note all_eq = this"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on ?f2 (set x)) =\n  (\\<forall>v\\<in>pverts (list_digraph G_list).\n      out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n      {} \\<longrightarrow>\n      cyclic_on ?f2 (out_arcs (with_proj (list_digraph G_list)) v))\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "have \"lists_succ ` set (all_maps_list G_list)\n      = {f. f permutes arcs ?G \\<and> (\\<forall>v \\<in> pverts ?G. out_arcs ?G v \\<noteq> {} \\<longrightarrow> cyclic_on f (out_arcs ?G v))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ ` set (all_maps_list G_list) =\n    {f. f permutes arcs (with_proj (list_digraph G_list)) \\<and>\n        (\\<forall>v\\<in>pverts (list_digraph G_list).\n            out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n            {} \\<longrightarrow>\n            cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))}", "unfolding all_maps_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ ` set ((cyc_permutationss \\<circ> grouped_out_arcs) G_list) =\n    {f. f permutes arcs (with_proj (list_digraph G_list)) \\<and>\n        (\\<forall>v\\<in>pverts (list_digraph G_list).\n            out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n            {} \\<longrightarrow>\n            cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))}", "using assms all_eq"], ["proof (prove)\nusing this:\n  pair_wf_digraph (list_digraph G_list)\n  distinct (snd G_list)\n  (\\<forall>x\\<in>set (grouped_out_arcs G_list). cyclic_on ?f2 (set x)) =\n  (\\<forall>v\\<in>pverts (list_digraph G_list).\n      out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n      {} \\<longrightarrow>\n      cyclic_on ?f2 (out_arcs (with_proj (list_digraph G_list)) v))\n\ngoal (1 subgoal):\n 1. lists_succ ` set ((cyc_permutationss \\<circ> grouped_out_arcs) G_list) =\n    {f. f permutes arcs (with_proj (list_digraph G_list)) \\<and>\n        (\\<forall>v\\<in>pverts (list_digraph G_list).\n            out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n            {} \\<longrightarrow>\n            cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))}", "by (simp add: lists_succ_set_cyc_permutationss distincts_grouped_arcs union_grouped_out_arcs list_digraph_simps)"], ["proof (state)\nthis:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes arcs (with_proj (list_digraph G_list)) \\<and>\n      (\\<forall>v\\<in>pverts (list_digraph G_list).\n          out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))}\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "then"], ["proof (chain)\npicking this:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes arcs (with_proj (list_digraph G_list)) \\<and>\n      (\\<forall>v\\<in>pverts (list_digraph G_list).\n          out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))}", "have *: \"lists_succ ` set (all_maps_list G_list) = {f. f permutes set (snd G_list) \\<and> (\\<forall>v\\<in>set (fst G_list). out_arcs (with_proj \\<lparr>pverts = set (fst G_list), parcs = set (snd G_list)\\<rparr>) v \\<noteq> {} \\<longrightarrow> cyclic_on f (out_arcs (with_proj \\<lparr>pverts = set (fst G_list), parcs = set (snd G_list)\\<rparr>) v))}\""], ["proof (prove)\nusing this:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes arcs (with_proj (list_digraph G_list)) \\<and>\n      (\\<forall>v\\<in>pverts (list_digraph G_list).\n          out_arcs (with_proj (list_digraph G_list)) v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f (out_arcs (with_proj (list_digraph G_list)) v))}\n\ngoal (1 subgoal):\n 1. lists_succ ` set (all_maps_list G_list) =\n    {f. f permutes set (snd G_list) \\<and>\n        (\\<forall>v\\<in>set (fst G_list).\n            out_arcs\n             (with_proj\n               \\<lparr>pverts = set (fst G_list),\n                  parcs = set (snd G_list)\\<rparr>)\n             v \\<noteq>\n            {} \\<longrightarrow>\n            cyclic_on f\n             (out_arcs\n               (with_proj\n                 \\<lparr>pverts = set (fst G_list),\n                    parcs = set (snd G_list)\\<rparr>)\n               v))}", "by (auto simp add: maps_all_maps_list_def all_maps_def list_digraph_simps list_digraph_ext_def)"], ["proof (state)\nthis:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes set (snd G_list) \\<and>\n      (\\<forall>v\\<in>set (fst G_list).\n          out_arcs\n           (with_proj\n             \\<lparr>pverts = set (fst G_list),\n                parcs = set (snd G_list)\\<rparr>)\n           v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f\n           (out_arcs\n             (with_proj\n               \\<lparr>pverts = set (fst G_list),\n                  parcs = set (snd G_list)\\<rparr>)\n             v))}\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "then"], ["proof (chain)\npicking this:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes set (snd G_list) \\<and>\n      (\\<forall>v\\<in>set (fst G_list).\n          out_arcs\n           (with_proj\n             \\<lparr>pverts = set (fst G_list),\n                parcs = set (snd G_list)\\<rparr>)\n           v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f\n           (out_arcs\n             (with_proj\n               \\<lparr>pverts = set (fst G_list),\n                  parcs = set (snd G_list)\\<rparr>)\n             v))}", "have **: \"\\<And>f. \\<not> (f permutes set (snd G_list) \\<and> (\\<forall>a. a \\<in> set (fst G_list) \\<longrightarrow> out_arcs (with_proj \\<lparr>pverts = set (fst G_list), parcs = set (snd G_list)\\<rparr>) a \\<noteq> {} \\<longrightarrow> cyclic_on f (out_arcs (with_proj \\<lparr>pverts = set (fst G_list), parcs = set (snd G_list)\\<rparr>) a))) \\<or> f \\<in> lists_succ ` set (all_maps_list G_list)\""], ["proof (prove)\nusing this:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes set (snd G_list) \\<and>\n      (\\<forall>v\\<in>set (fst G_list).\n          out_arcs\n           (with_proj\n             \\<lparr>pverts = set (fst G_list),\n                parcs = set (snd G_list)\\<rparr>)\n           v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f\n           (out_arcs\n             (with_proj\n               \\<lparr>pverts = set (fst G_list),\n                  parcs = set (snd G_list)\\<rparr>)\n             v))}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<not> (f permutes set (snd G_list) \\<and>\n               (\\<forall>a.\n                   a \\<in> set (fst G_list) \\<longrightarrow>\n                   out_arcs\n                    (with_proj\n                      \\<lparr>pverts = set (fst G_list),\n                         parcs = set (snd G_list)\\<rparr>)\n                    a \\<noteq>\n                   {} \\<longrightarrow>\n                   cyclic_on f\n                    (out_arcs\n                      (with_proj\n                        \\<lparr>pverts = set (fst G_list),\n                           parcs = set (snd G_list)\\<rparr>)\n                      a))) \\<or>\n       f \\<in> lists_succ ` set (all_maps_list G_list)", "by force"], ["proof (state)\nthis:\n  \\<not> (?f permutes set (snd G_list) \\<and>\n          (\\<forall>a.\n              a \\<in> set (fst G_list) \\<longrightarrow>\n              out_arcs\n               (with_proj\n                 \\<lparr>pverts = set (fst G_list),\n                    parcs = set (snd G_list)\\<rparr>)\n               a \\<noteq>\n              {} \\<longrightarrow>\n              cyclic_on ?f\n               (out_arcs\n                 (with_proj\n                   \\<lparr>pverts = set (fst G_list),\n                      parcs = set (snd G_list)\\<rparr>)\n                 a))) \\<or>\n  ?f \\<in> lists_succ ` set (all_maps_list G_list)\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "from *"], ["proof (chain)\npicking this:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes set (snd G_list) \\<and>\n      (\\<forall>v\\<in>set (fst G_list).\n          out_arcs\n           (with_proj\n             \\<lparr>pverts = set (fst G_list),\n                parcs = set (snd G_list)\\<rparr>)\n           v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f\n           (out_arcs\n             (with_proj\n               \\<lparr>pverts = set (fst G_list),\n                  parcs = set (snd G_list)\\<rparr>)\n             v))}", "show ?thesis"], ["proof (prove)\nusing this:\n  lists_succ ` set (all_maps_list G_list) =\n  {f. f permutes set (snd G_list) \\<and>\n      (\\<forall>v\\<in>set (fst G_list).\n          out_arcs\n           (with_proj\n             \\<lparr>pverts = set (fst G_list),\n                parcs = set (snd G_list)\\<rparr>)\n           v \\<noteq>\n          {} \\<longrightarrow>\n          cyclic_on f\n           (out_arcs\n             (with_proj\n               \\<lparr>pverts = set (fst G_list),\n                  parcs = set (snd G_list)\\<rparr>)\n             v))}\n\ngoal (1 subgoal):\n 1. all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)", "by (auto simp add: maps_all_maps_list_def all_maps_def list_digraph_simps list_digraph_ext_def) (use ** in blast)"], ["proof (state)\nthis:\n  all_maps (list_digraph G_list) = set (maps_all_maps_list G_list)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Compute Face Cycles\\<close>"], ["", "definition lists_fc_succ :: \"('a \\<times> 'a) list list \\<Rightarrow> ('a \\<times> 'a) \\<Rightarrow> ('a \\<times> 'a)\" where\n  \"lists_fc_succ xss = (let sxss = \\<Union>(sset xss) in (\\<lambda>x. lists_succ xss (swap_in sxss x)))\""], ["", "locale lists_digraph_map =\n  fixes G_list :: \"'b list \\<times> ('b \\<times> 'b) list\"\n    and xss :: \"('b \\<times> 'b) list list\"\n  assumes digraph_map: \"digraph_map (list_digraph G_list) (to_map' (snd G_list) xss)\"\n  assumes no_loops: \"\\<And>a. a \\<in> parcs (list_digraph G_list) \\<Longrightarrow> fst a \\<noteq> snd a\"\n  assumes distincts_xss: \"distincts xss\"\n  assumes parcs_xss: \"parcs (list_digraph G_list) = \\<Union>(sset xss)\"\nbegin"], ["", "abbreviation (input) \"G \\<equiv> list_digraph G_list\""], ["", "abbreviation (input) \"M \\<equiv> to_map' (snd G_list) xss\""], ["", "lemma edge_rev_simps:\n  assumes \"(u,v) \\<in> parcs G\" shows \"edge_rev M (u,v) = (v,u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_rev (to_map' (snd G_list) xss) (u, v) = (v, u)", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. edge_rev (to_map' (snd G_list) xss) (u, v) = (v, u)", "unfolding to_map_def list_digraph_ext_def"], ["proof (prove)\nusing this:\n  (u, v)\n  \\<in> parcs\n         \\<lparr>pverts = set (fst G_list), parcs = set (snd G_list)\\<rparr>\n\ngoal (1 subgoal):\n 1. edge_rev\n     \\<lparr>edge_rev = swap_in (set (snd G_list)),\n        edge_succ = lists_succ xss\\<rparr>\n     (u, v) =\n    (v, u)", "by (auto simp: swap_in_def to_map_def)"], ["", "end"], ["", "sublocale lists_digraph_map \\<subseteq> digraph_map G M"], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map (with_proj (list_digraph G_list)) (to_map' (snd G_list) xss)", "by (rule local.digraph_map)"], ["", "sublocale lists_digraph_map \\<subseteq> pair_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_graph (list_digraph G_list)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<in> pverts (list_digraph G_list)\n 2. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       snd e \\<in> pverts (list_digraph G_list)\n 3. finite (pverts (list_digraph G_list))\n 4. finite (parcs (list_digraph G_list))\n 5. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 6. symmetric (with_proj (list_digraph G_list))", "fix e"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<in> pverts (list_digraph G_list)\n 2. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       snd e \\<in> pverts (list_digraph G_list)\n 3. finite (pverts (list_digraph G_list))\n 4. finite (parcs (list_digraph G_list))\n 5. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 6. symmetric (with_proj (list_digraph G_list))", "assume \"e \\<in> parcs G\""], ["proof (state)\nthis:\n  e \\<in> parcs (list_digraph G_list)\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<in> pverts (list_digraph G_list)\n 2. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       snd e \\<in> pverts (list_digraph G_list)\n 3. finite (pverts (list_digraph G_list))\n 4. finite (parcs (list_digraph G_list))\n 5. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 6. symmetric (with_proj (list_digraph G_list))", "then"], ["proof (chain)\npicking this:\n  e \\<in> parcs (list_digraph G_list)", "have \"e \\<in> arcs G\""], ["proof (prove)\nusing this:\n  e \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. e \\<in> arcs (with_proj (list_digraph G_list))", "by simp"], ["proof (state)\nthis:\n  e \\<in> arcs (with_proj (list_digraph G_list))\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<in> pverts (list_digraph G_list)\n 2. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       snd e \\<in> pverts (list_digraph G_list)\n 3. finite (pverts (list_digraph G_list))\n 4. finite (parcs (list_digraph G_list))\n 5. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 6. symmetric (with_proj (list_digraph G_list))", "then"], ["proof (chain)\npicking this:\n  e \\<in> arcs (with_proj (list_digraph G_list))", "have \"head G e \\<in> verts G\" \"tail G e \\<in> verts G\""], ["proof (prove)\nusing this:\n  e \\<in> arcs (with_proj (list_digraph G_list))\n\ngoal (1 subgoal):\n 1. head (with_proj (list_digraph G_list)) e\n    \\<in> verts (with_proj (list_digraph G_list)) &&&\n    tail (with_proj (list_digraph G_list)) e\n    \\<in> verts (with_proj (list_digraph G_list))", "by (blast dest: wellformed)+"], ["proof (state)\nthis:\n  head (with_proj (list_digraph G_list)) e\n  \\<in> verts (with_proj (list_digraph G_list))\n  tail (with_proj (list_digraph G_list)) e\n  \\<in> verts (with_proj (list_digraph G_list))\n\ngoal (6 subgoals):\n 1. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<in> pverts (list_digraph G_list)\n 2. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       snd e \\<in> pverts (list_digraph G_list)\n 3. finite (pverts (list_digraph G_list))\n 4. finite (parcs (list_digraph G_list))\n 5. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 6. symmetric (with_proj (list_digraph G_list))", "then"], ["proof (chain)\npicking this:\n  head (with_proj (list_digraph G_list)) e\n  \\<in> verts (with_proj (list_digraph G_list))\n  tail (with_proj (list_digraph G_list)) e\n  \\<in> verts (with_proj (list_digraph G_list))", "show \"fst e \\<in> pverts G\" \"snd e \\<in> pverts G\""], ["proof (prove)\nusing this:\n  head (with_proj (list_digraph G_list)) e\n  \\<in> verts (with_proj (list_digraph G_list))\n  tail (with_proj (list_digraph G_list)) e\n  \\<in> verts (with_proj (list_digraph G_list))\n\ngoal (1 subgoal):\n 1. fst e \\<in> pverts (list_digraph G_list) &&&\n    snd e \\<in> pverts (list_digraph G_list)", "by auto"], ["proof (state)\nthis:\n  fst e \\<in> pverts (list_digraph G_list)\n  snd e \\<in> pverts (list_digraph G_list)\n\ngoal (4 subgoals):\n 1. finite (pverts (list_digraph G_list))\n 2. finite (parcs (list_digraph G_list))\n 3. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 4. symmetric (with_proj (list_digraph G_list))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (pverts (list_digraph G_list))\n 2. finite (parcs (list_digraph G_list))\n 3. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 4. symmetric (with_proj (list_digraph G_list))", "fix e"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (pverts (list_digraph G_list))\n 2. finite (parcs (list_digraph G_list))\n 3. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 4. symmetric (with_proj (list_digraph G_list))", "assume \"e \\<in> parcs G\""], ["proof (state)\nthis:\n  e \\<in> parcs (list_digraph G_list)\n\ngoal (4 subgoals):\n 1. finite (pverts (list_digraph G_list))\n 2. finite (parcs (list_digraph G_list))\n 3. \\<And>e.\n       e \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n       fst e \\<noteq> snd e\n 4. symmetric (with_proj (list_digraph G_list))", "then"], ["proof (chain)\npicking this:\n  e \\<in> parcs (list_digraph G_list)", "show \"fst e \\<noteq> snd e\""], ["proof (prove)\nusing this:\n  e \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. fst e \\<noteq> snd e", "using no_loops"], ["proof (prove)\nusing this:\n  e \\<in> parcs (list_digraph G_list)\n  ?a \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n  fst ?a \\<noteq> snd ?a\n\ngoal (1 subgoal):\n 1. fst e \\<noteq> snd e", "by simp"], ["proof (state)\nthis:\n  fst e \\<noteq> snd e\n\ngoal (3 subgoals):\n 1. finite (pverts (list_digraph G_list))\n 2. finite (parcs (list_digraph G_list))\n 3. symmetric (with_proj (list_digraph G_list))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (pverts (list_digraph G_list))\n 2. finite (parcs (list_digraph G_list))\n 3. symmetric (with_proj (list_digraph G_list))", "show \"finite (pverts G)\" \"finite (parcs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pverts (list_digraph G_list)) &&&\n    finite (parcs (list_digraph G_list))", "unfolding list_digraph_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (pverts\n       \\<lparr>pverts = set (fst G_list),\n          parcs = set (snd G_list)\\<rparr>) &&&\n    finite\n     (parcs\n       \\<lparr>pverts = set (fst G_list), parcs = set (snd G_list)\\<rparr>)", "by simp_all"], ["proof (state)\nthis:\n  finite (pverts (list_digraph G_list))\n  finite (parcs (list_digraph G_list))\n\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "assume \"(u,v) \\<in> parcs G\""], ["proof (state)\nthis:\n  (u, v) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> parcs (list_digraph G_list)", "have \"edge_rev M (u,v) \\<in> parcs G\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. edge_rev (to_map' (snd G_list) xss) (u, v)\n    \\<in> parcs (list_digraph G_list)", "using edge_rev_in_arcs"], ["proof (prove)\nusing this:\n  (u, v) \\<in> parcs (list_digraph G_list)\n  (edge_rev (to_map' (snd G_list) xss) ?a\n   \\<in> arcs (with_proj (list_digraph G_list))) =\n  (?a \\<in> arcs (with_proj (list_digraph G_list)))\n\ngoal (1 subgoal):\n 1. edge_rev (to_map' (snd G_list) xss) (u, v)\n    \\<in> parcs (list_digraph G_list)", "by simp"], ["proof (state)\nthis:\n  edge_rev (to_map' (snd G_list) xss) (u, v)\n  \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "then"], ["proof (chain)\npicking this:\n  edge_rev (to_map' (snd G_list) xss) (u, v)\n  \\<in> parcs (list_digraph G_list)", "have \"(v,u) \\<in> parcs G\""], ["proof (prove)\nusing this:\n  edge_rev (to_map' (snd G_list) xss) (u, v)\n  \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> parcs (list_digraph G_list)", "using \\<open>(u,v) \\<in> _ \\<close>"], ["proof (prove)\nusing this:\n  edge_rev (to_map' (snd G_list) xss) (u, v)\n  \\<in> parcs (list_digraph G_list)\n  (u, v) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> parcs (list_digraph G_list)", "by (simp add: edge_rev_simps)"], ["proof (state)\nthis:\n  (v, u) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "}"], ["proof (state)\nthis:\n  (?u3, ?v3) \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n  (?v3, ?u3) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "then"], ["proof (chain)\npicking this:\n  (?u3, ?v3) \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n  (?v3, ?u3) \\<in> parcs (list_digraph G_list)", "show \"symmetric G\""], ["proof (prove)\nusing this:\n  (?u3, ?v3) \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n  (?v3, ?u3) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. symmetric (with_proj (list_digraph G_list))", "unfolding symmetric_def"], ["proof (prove)\nusing this:\n  (?u3, ?v3) \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n  (?v3, ?u3) \\<in> parcs (list_digraph G_list)\n\ngoal (1 subgoal):\n 1. sym (arcs_ends (with_proj (list_digraph G_list)))", "by (auto intro: symI)"], ["proof (state)\nthis:\n  symmetric (with_proj (list_digraph G_list))\n\ngoal:\nNo subgoals!", "qed"], ["", "context lists_digraph_map begin"], ["", "definition \"lists_fcs \\<equiv> orbits_list (lists_fc_succ xss)\""], ["", "lemma M_simps:\n  \"edge_succ M = lists_succ xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ (to_map' (snd G_list) xss) = lists_succ xss", "unfolding to_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_succ\n     \\<lparr>edge_rev = swap_in (set (snd G_list)),\n        edge_succ = lists_succ xss\\<rparr> =\n    lists_succ xss", "by (cases G_list) auto"], ["", "lemma lists_fc_succ_permutes: \"lists_fc_succ xss permutes (\\<Union>(sset xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "have \"\\<forall>(u,v) \\<in> \\<Union>(sset xss). (v,u) \\<in> \\<Union>(sset xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>\\<Union> (sset xss).\n       (v, u) \\<in> \\<Union> (sset xss)", "using sym_arcs"], ["proof (prove)\nusing this:\n  symmetric (with_proj (list_digraph G_list))\n\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>\\<Union> (sset xss).\n       (v, u) \\<in> \\<Union> (sset xss)", "unfolding parcs_xss[symmetric] symmetric_def"], ["proof (prove)\nusing this:\n  sym (arcs_ends (with_proj (list_digraph G_list)))\n\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>parcs (list_digraph G_list).\n       (v, u) \\<in> parcs (list_digraph G_list)", "by (auto elim: symE)"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>\\<Union> (sset xss). (v, u) \\<in> \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "then"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>\\<Union> (sset xss). (v, u) \\<in> \\<Union> (sset xss)", "have \"swap_in (\\<Union>(sset xss)) permutes \\<Union>(sset xss)\""], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>\\<Union> (sset xss). (v, u) \\<in> \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. swap_in (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "using distincts_xss"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>\\<Union> (sset xss). (v, u) \\<in> \\<Union> (sset xss)\n  distincts xss\n\ngoal (1 subgoal):\n 1. swap_in (\\<Union> (sset xss)) permutes \\<Union> (sset xss)", "apply (auto simp: permutes_def split: if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss;\n        \\<forall>x\\<in>set xss. (a, b) \\<notin> set x\\<rbrakk>\n       \\<Longrightarrow> swap_in (\\<Union> (sset xss)) (a, b) = (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            swap_in (\\<Union> (sset xss)) (aa, ba) = (a, b)\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss; swap_in (\\<Union> (sset xss)) (aa, ba) = (a, b);\n        swap_in (\\<Union> (sset xss)) (ab, bb) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> aa = ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss; swap_in (\\<Union> (sset xss)) (aa, ba) = (a, b);\n        swap_in (\\<Union> (sset xss)) (ab, bb) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ba = bb", "unfolding swap_in_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss;\n        \\<forall>x\\<in>set xss. (a, b) \\<notin> set x\\<rbrakk>\n       \\<Longrightarrow> (if (a, b) \\<in> \\<Union> (sset xss)\n                          then prod.swap (a, b) else (a, b)) =\n                         (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            (if (aa, ba) \\<in> \\<Union> (sset xss)\n                             then prod.swap (aa, ba) else (aa, ba)) =\n                            (a, b)\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss;\n        (if (aa, ba) \\<in> \\<Union> (sset xss) then prod.swap (aa, ba)\n         else (aa, ba)) =\n        (a, b);\n        (if (ab, bb) \\<in> \\<Union> (sset xss) then prod.swap (ab, bb)\n         else (ab, bb)) =\n        (a, b)\\<rbrakk>\n       \\<Longrightarrow> aa = ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      case x of\n                      (u, v) \\<Rightarrow>\n                        \\<exists>x\\<in>set xss. (v, u) \\<in> set x;\n        distincts xss;\n        (if (aa, ba) \\<in> \\<Union> (sset xss) then prod.swap (aa, ba)\n         else (aa, ba)) =\n        (a, b);\n        (if (ab, bb) \\<in> \\<Union> (sset xss) then prod.swap (ab, bb)\n         else (ab, bb)) =\n        (a, b)\\<rbrakk>\n       \\<Longrightarrow> ba = bb", "apply (simp_all split: if_splits prod.splits)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      \\<forall>x1 x2.\n                         x = (x1, x2) \\<longrightarrow>\n                         (\\<exists>x\\<in>set xss. (x2, x1) \\<in> set x);\n        distincts xss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba.\n                            ((\\<exists>x\\<in>set xss.\n                                 (aa, ba) \\<in> set x) \\<longrightarrow>\n                             ba = a \\<and> aa = b) \\<and>\n                            ((\\<forall>x\\<in>set xss.\n                                 (aa, ba) \\<notin> set x) \\<longrightarrow>\n                             aa = a \\<and> ba = b)\n 2. \\<And>a b aa ab.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      \\<forall>x1 x2.\n                         x = (x1, x2) \\<longrightarrow>\n                         (\\<exists>x\\<in>set xss. (x2, x1) \\<in> set x);\n        distincts xss; \\<exists>x\\<in>set xss. (b, a) \\<in> set x; aa = b;\n        \\<forall>x\\<in>set xss. (a, b) \\<notin> set x; ab = a\\<rbrakk>\n       \\<Longrightarrow> b = a\n 3. \\<And>a b aa ab.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      \\<forall>x1 x2.\n                         x = (x1, x2) \\<longrightarrow>\n                         (\\<exists>x\\<in>set xss. (x2, x1) \\<in> set x);\n        distincts xss; \\<forall>x\\<in>set xss. (a, b) \\<notin> set x;\n        aa = a; \\<exists>x\\<in>set xss. (b, a) \\<in> set x; ab = b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>a b aa ab.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      \\<forall>x1 x2.\n                         x = (x1, x2) \\<longrightarrow>\n                         (\\<exists>x\\<in>set xss. (x2, x1) \\<in> set x);\n        distincts xss; \\<exists>x\\<in>set xss. (b, a) \\<in> set x; aa = b;\n        \\<forall>x\\<in>set xss. (a, b) \\<notin> set x; ab = a\\<rbrakk>\n       \\<Longrightarrow> a = b\n 5. \\<And>a b aa ab.\n       \\<lbrakk>\\<forall>y\\<in>set xss.\n                   \\<forall>x\\<in>set y.\n                      \\<forall>x1 x2.\n                         x = (x1, x2) \\<longrightarrow>\n                         (\\<exists>x\\<in>set xss. (x2, x1) \\<in> set x);\n        distincts xss; \\<forall>x\\<in>set xss. (a, b) \\<notin> set x;\n        aa = a; \\<exists>x\\<in>set xss. (b, a) \\<in> set x; ab = b\\<rbrakk>\n       \\<Longrightarrow> b = a", "apply metis+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  swap_in (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "moreover"], ["proof (state)\nthis:\n  swap_in (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "have \"lists_succ xss permutes (\\<Union>(sset xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_succ xss permutes \\<Union> (sset xss)", "using lists_succ_permutes[OF distincts_xss]"], ["proof (prove)\nusing this:\n  lists_succ xss permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. lists_succ xss permutes \\<Union> (sset xss)", "by simp"], ["proof (state)\nthis:\n  lists_succ xss permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "moreover"], ["proof (state)\nthis:\n  lists_succ xss permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "have \"lists_fc_succ xss = lists_succ xss o swap_in (\\<Union>(sset xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_fc_succ xss = lists_succ xss \\<circ> swap_in (\\<Union> (sset xss))", "by (simp add: fun_eq_iff lists_fc_succ_def)"], ["proof (state)\nthis:\n  lists_fc_succ xss = lists_succ xss \\<circ> swap_in (\\<Union> (sset xss))\n\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "ultimately"], ["proof (chain)\npicking this:\n  swap_in (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n  lists_succ xss permutes \\<Union> (sset xss)\n  lists_fc_succ xss = lists_succ xss \\<circ> swap_in (\\<Union> (sset xss))", "show ?thesis"], ["proof (prove)\nusing this:\n  swap_in (\\<Union> (sset xss)) permutes \\<Union> (sset xss)\n  lists_succ xss permutes \\<Union> (sset xss)\n  lists_fc_succ xss = lists_succ xss \\<circ> swap_in (\\<Union> (sset xss))\n\ngoal (1 subgoal):\n 1. lists_fc_succ xss permutes \\<Union> (sset xss)", "by (metis permutes_compose)"], ["proof (state)\nthis:\n  lists_fc_succ xss permutes \\<Union> (sset xss)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutation_lists_fc_succ[intro, simp]: \"permutation (lists_fc_succ xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation (lists_fc_succ xss)", "using lists_fc_succ_permutes"], ["proof (prove)\nusing this:\n  lists_fc_succ xss permutes \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. permutation (lists_fc_succ xss)", "by (auto simp: permutation_permutes)"], ["", "lemma face_cycle_succ_conv: \"face_cycle_succ = lists_fc_succ xss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. face_cycle_succ = lists_fc_succ xss", "using parcs_xss"], ["proof (prove)\nusing this:\n  parcs (list_digraph G_list) = \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. face_cycle_succ = lists_fc_succ xss", "unfolding face_cycle_succ_def"], ["proof (prove)\nusing this:\n  parcs (list_digraph G_list) = \\<Union> (sset xss)\n\ngoal (1 subgoal):\n 1. edge_succ (to_map' (snd G_list) xss) \\<circ>\n    edge_rev (to_map' (snd G_list) xss) =\n    lists_fc_succ xss", "by (simp add: fun_eq_iff to_map_def lists_fc_succ_def swap_in_def list_digraph_ext_def)"], ["", "lemma sset_lists_fcs:\n  \"sset (lists_fcs as) = {face_cycle_set a | a. a \\<in> set as}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (lists_fcs as) = {face_cycle_set a |a. a \\<in> set as}", "by (auto simp: lists_fcs_def sset_orbits_list face_cycle_set_def face_cycle_succ_conv)"], ["", "lemma distincts_lists_fcs: \"distinct as \\<Longrightarrow>distincts (lists_fcs as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct as \\<Longrightarrow> distincts (lists_fcs as)", "by (simp add: lists_fcs_def distincts_orbits_list)"], ["", "lemma face_cycle_set_ss: \"a \\<in> parcs G \\<Longrightarrow> face_cycle_set a \\<subseteq> parcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n    face_cycle_set a \\<subseteq> parcs (list_digraph G_list)", "using in_face_cycle_setD with_proj_simps(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> face_cycle_set ?x;\n   ?x \\<in> arcs (with_proj (list_digraph G_list))\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> arcs (with_proj (list_digraph G_list))\n  arcs (with_proj ?G) = parcs ?G\n\ngoal (1 subgoal):\n 1. a \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n    face_cycle_set a \\<subseteq> parcs (list_digraph G_list)", "by blast"], ["", "lemma face_cycle_succ_neq:\n  assumes \"a \\<in> parcs G\" shows \"face_cycle_succ a \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. face_cycle_succ a \\<noteq> a", "using assms no_loops"], ["proof (prove)\nusing this:\n  a \\<in> parcs (list_digraph G_list)\n  ?a \\<in> parcs (list_digraph G_list) \\<Longrightarrow>\n  fst ?a \\<noteq> snd ?a\n\ngoal (1 subgoal):\n 1. face_cycle_succ a \\<noteq> a", "by (intro face_cycle_succ_neq) auto"], ["", "lemma card_face_cycle_sets_conv:\n  shows \"card (pre_digraph_map.face_cycle_sets G M) = length (lists_fcs (remdups (snd G_list)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "interpret digraph_map G M"], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map (with_proj (list_digraph G_list)) (to_map' (snd G_list) xss)", "by (rule digraph_map)"], ["proof (state)\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "have \"face_cycle_sets = {face_cycle_set a | a. a \\<in> parcs G}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. face_cycle_sets =\n    {face_cycle_set a |a. a \\<in> parcs (list_digraph G_list)}", "by (auto simp: face_cycle_sets_def)"], ["proof (state)\nthis:\n  face_cycle_sets =\n  {face_cycle_set a |a. a \\<in> parcs (list_digraph G_list)}\n\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "also"], ["proof (state)\nthis:\n  face_cycle_sets =\n  {face_cycle_set a |a. a \\<in> parcs (list_digraph G_list)}\n\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "have \"\\<dots> = sset (lists_fcs (remdups (snd G_list)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {face_cycle_set a |a. a \\<in> parcs (list_digraph G_list)} =\n    sset (lists_fcs (remdups (snd G_list)))", "unfolding sset_lists_fcs"], ["proof (prove)\ngoal (1 subgoal):\n 1. {face_cycle_set a |a. a \\<in> parcs (list_digraph G_list)} =\n    {face_cycle_set a |a. a \\<in> set (remdups (snd G_list))}", "by (simp add: list_digraph_simps)"], ["proof (state)\nthis:\n  {face_cycle_set a |a. a \\<in> parcs (list_digraph G_list)} =\n  sset (lists_fcs (remdups (snd G_list)))\n\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "also"], ["proof (state)\nthis:\n  {face_cycle_set a |a. a \\<in> parcs (list_digraph G_list)} =\n  sset (lists_fcs (remdups (snd G_list)))\n\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "have \"card \\<dots> = length (lists_fcs (remdups (snd G_list)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (sset (lists_fcs (remdups (snd G_list)))) =\n    length (lists_fcs (remdups (snd G_list)))", "by (simp add: card_image distincts_inj_on_set distinct_card distincts_distinct distincts_lists_fcs)"], ["proof (state)\nthis:\n  card (sset (lists_fcs (remdups (snd G_list)))) =\n  length (lists_fcs (remdups (snd G_list)))\n\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "finally"], ["proof (chain)\npicking this:\n  card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "show ?thesis"], ["proof (prove)\nusing this:\n  card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))\n\ngoal (1 subgoal):\n 1. card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))", "."], ["proof (state)\nthis:\n  card face_cycle_sets = length (lists_fcs (remdups (snd G_list)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition \"gen_succ \\<equiv> \\<lambda>as xs. [b. (a,b) <- as, a \\<in> set xs]\""], ["", "interpretation RTLI: set_access_gen set \"\\<lambda>x xs. x \\<in> set xs\" \"[]\" \"\\<lambda>xs ys. remdups (xs @ ys)\" \"gen_succ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_access_gen set (\\<lambda>x xs. x \\<in> set xs) []\n     (\\<lambda>xs ys. remdups (xs @ ys)) gen_succ", "by standard (auto simp: gen_succ_def)"], ["", "hide_const (open) gen_succ"], ["", "text \\<open>\n  It would suffice to check that @{term \"set (RTLI.rtrancl_i A [u]) = set V\"}. We don't do\n  this here, since it makes the proof more complicated (and is not necessary for the graphs\n  we care about\n\\<close>"], ["", "definition sccs_verts_impl :: \"'a list \\<times> ('a \\<times> 'a) list \\<Rightarrow> 'a set set\" where\n  \"sccs_verts_impl G \\<equiv> set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)\""], ["", "definition isolated_verts_impl :: \"'a list \\<times> ('a \\<times> 'a) list \\<Rightarrow> 'a list\" where\n  \"isolated_verts_impl G = [v \\<leftarrow> (fst G). \\<not>(\\<exists>e \\<in> set (snd G). fst e = v)]\""], ["", "definition pair_graph_impl :: \"'a list \\<times> ('a \\<times> 'a) list \\<Rightarrow> bool\" where\n  \"pair_graph_impl G \\<equiv> case G of (V,A) \\<Rightarrow> (\\<forall>(u,v) \\<in> set A. u \\<noteq> v \\<and> u \\<in> set V \\<and> v \\<in> set V \\<and> (v,u) \\<in> set A)\""], ["", "definition genus_impl :: \"'a list \\<times> ('a \\<times> 'a) list \\<Rightarrow> ('a \\<times> 'a) list list \\<Rightarrow> int\" where\n  \"genus_impl G M \\<equiv> case G of (V,A) \\<Rightarrow>\n    (int (2*card (sccs_verts_impl G)) - int (length (isolated_verts_impl G))\n      - (int (length V) - int (length A) div 2\n      + int (length (orbits_list_impl (lists_fc_succ M) A)))) div 2\""], ["", "definition comb_planar_impl :: \"'a list \\<times> ('a \\<times> 'a) list \\<Rightarrow> bool\" where\n  \"comb_planar_impl G \\<equiv> case G of (V,A) \\<Rightarrow>\n    let i = int (2*card (sccs_verts_impl G)) - int (length (isolated_verts_impl G))\n      - int (length V) + int (length A) div 2\n    in (\\<exists>M\\<in>set (all_maps_list G). (i - int (length (orbits_list_impl (lists_fc_succ M) A))) div 2 = 0)\""], ["", "(*\ndefinition comb_planar_impl :: \"'a list \\<times> ('a \\<times> 'a) list \\<Rightarrow> bool\" where\n  \"comb_planar_impl G \\<equiv> \\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0\"\n*)"], ["", "lemma sccs_verts_impl_correct:\n  assumes \"pair_pseudo_graph (list_digraph G)\"\n  shows \"pre_digraph.sccs_verts (list_digraph G) = sccs_verts_impl G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_digraph.sccs_verts (with_proj (list_digraph G)) = sccs_verts_impl G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pre_digraph.sccs_verts (with_proj (list_digraph G)) = sccs_verts_impl G", "interpret pair_pseudo_graph \"list_digraph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pseudo_graph (list_digraph G)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "assume \"u \\<in> set (fst G)\""], ["proof (state)\nthis:\n  u \\<in> set (fst G)\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "then"], ["proof (chain)\npicking this:\n  u \\<in> set (fst G)", "have \"\\<And>x. (u, x) \\<in> (set (snd G))\\<^sup>* \\<Longrightarrow> x \\<in> set (fst G)\""], ["proof (prove)\nusing this:\n  u \\<in> set (fst G)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (u, x) \\<in> (set (snd G))\\<^sup>* \\<Longrightarrow>\n       x \\<in> set (fst G)", "by (metis in_arcsD2 list_digraph_simps rtrancl.cases)"], ["proof (state)\nthis:\n  (u, ?x1) \\<in> (set (snd G))\\<^sup>* \\<Longrightarrow>\n  ?x1 \\<in> set (fst G)\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "then"], ["proof (chain)\npicking this:\n  (u, ?x1) \\<in> (set (snd G))\\<^sup>* \\<Longrightarrow>\n  ?x1 \\<in> set (fst G)", "have \"set (RTLI.rtrancl_i (snd G) [u]) = {v. u \\<rightarrow>\\<^sup>*\\<^bsub>list_digraph G\\<^esub> v }\""], ["proof (prove)\nusing this:\n  (u, ?x1) \\<in> (set (snd G))\\<^sup>* \\<Longrightarrow>\n  ?x1 \\<in> set (fst G)\n\ngoal (1 subgoal):\n 1. set (RTLI.rtrancl_i (snd G) [u]) =\n    {v. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> v}", "unfolding RTLI.rtrancl_impl reachable_conv"], ["proof (prove)\nusing this:\n  (u, ?x1) \\<in> (set (snd G))\\<^sup>* \\<Longrightarrow>\n  ?x1 \\<in> set (fst G)\n\ngoal (1 subgoal):\n 1. {b. \\<exists>a\\<in>set [u]. (a, b) \\<in> (set (snd G))\\<^sup>*} =\n    {v. (u, v)\n        \\<in> Restr ((parcs (list_digraph G))\\<^sup>*)\n               (pverts (list_digraph G))}", "by (auto simp: list_digraph_simps \\<open>u \\<in> _\\<close>)"], ["proof (state)\nthis:\n  set (RTLI.rtrancl_i (snd G) [u]) =\n  {v. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> v}\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "also"], ["proof (state)\nthis:\n  set (RTLI.rtrancl_i (snd G) [u]) =\n  {v. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> v}\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "have \"\\<dots> = scc_of u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> v} =\n    scc_of u", "unfolding scc_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> v} =\n    {v. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> v \\<and>\n        v \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> u}", "by (auto intro: symmetric_reachable')"], ["proof (state)\nthis:\n  {v. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (list_digraph G)\\<^esub> v} =\n  scc_of u\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "finally"], ["proof (chain)\npicking this:\n  set (RTLI.rtrancl_i (snd G) [u]) = scc_of u", "have \"scc_of u = set (RTLI.rtrancl_i (snd G) [u])\""], ["proof (prove)\nusing this:\n  set (RTLI.rtrancl_i (snd G) [u]) = scc_of u\n\ngoal (1 subgoal):\n 1. scc_of u = set (RTLI.rtrancl_i (snd G) [u])", "by simp"], ["proof (state)\nthis:\n  scc_of u = set (RTLI.rtrancl_i (snd G) [u])\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> set (fst G) \\<Longrightarrow>\n  scc_of ?u3 = set (RTLI.rtrancl_i (snd G) [?u3])\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "then"], ["proof (chain)\npicking this:\n  ?u3 \\<in> set (fst G) \\<Longrightarrow>\n  scc_of ?u3 = set (RTLI.rtrancl_i (snd G) [?u3])", "have \"pre_digraph.sccs_verts (list_digraph G) = set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)\""], ["proof (prove)\nusing this:\n  ?u3 \\<in> set (fst G) \\<Longrightarrow>\n  scc_of ?u3 = set (RTLI.rtrancl_i (snd G) [?u3])\n\ngoal (1 subgoal):\n 1. sccs_verts =\n    set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)", "unfolding sccs_verts_conv_scc_of list_digraph_simps"], ["proof (prove)\nusing this:\n  ?u3 \\<in> set (fst G) \\<Longrightarrow>\n  scc_of ?u3 = set (RTLI.rtrancl_i (snd G) [?u3])\n\ngoal (1 subgoal):\n 1. scc_of ` set (fst G) =\n    set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)", "by (force intro: rev_image_eqI)"], ["proof (state)\nthis:\n  sccs_verts = set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "then"], ["proof (chain)\npicking this:\n  sccs_verts = set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)", "show ?thesis"], ["proof (prove)\nusing this:\n  sccs_verts = set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)\n\ngoal (1 subgoal):\n 1. sccs_verts = sccs_verts_impl G", "unfolding sccs_verts_impl_def"], ["proof (prove)\nusing this:\n  sccs_verts = set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)\n\ngoal (1 subgoal):\n 1. sccs_verts =\n    set ` (\\<lambda>x. RTLI.rtrancl_i (snd G) [x]) ` set (fst G)", "by simp"], ["proof (state)\nthis:\n  sccs_verts = sccs_verts_impl G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isolated_verts_impl_correct:\n  \"pre_digraph.isolated_verts (list_digraph G) = set (isolated_verts_impl G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_digraph.isolated_verts (with_proj (list_digraph G)) =\n    set (isolated_verts_impl G)", "by (auto simp: pre_digraph.isolated_verts_def isolated_verts_impl_def list_digraph_simps out_arcs_def)"], ["", "lemma pair_graph_impl_correct[code]:\n  \"pair_graph (list_digraph G) = pair_graph_impl G\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_graph (list_digraph G) = pair_graph_impl G", "unfolding pair_graph_def pair_digraph_def pair_fin_digraph_def pair_wf_digraph_def\n    pair_fin_digraph_axioms_def pair_loopfree_digraph_def pair_loopfree_digraph_axioms_def\n    pair_sym_digraph_def pair_sym_digraph_axioms_def pair_pseudo_graph_def\n    pair_graph_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((((\\<forall>e.\n            e \\<in> parcs (list_digraph G) \\<longrightarrow>\n            fst e \\<in> pverts (list_digraph G)) \\<and>\n        (\\<forall>e.\n            e \\<in> parcs (list_digraph G) \\<longrightarrow>\n            snd e \\<in> pverts (list_digraph G))) \\<and>\n       finite (pverts (list_digraph G)) \\<and>\n       finite (parcs (list_digraph G))) \\<and>\n      ((\\<forall>e.\n           e \\<in> parcs (list_digraph G) \\<longrightarrow>\n           fst e \\<in> pverts (list_digraph G)) \\<and>\n       (\\<forall>e.\n           e \\<in> parcs (list_digraph G) \\<longrightarrow>\n           snd e \\<in> pverts (list_digraph G))) \\<and>\n      (\\<forall>e.\n          e \\<in> parcs (list_digraph G) \\<longrightarrow>\n          fst e \\<noteq> snd e)) \\<and>\n     (((\\<forall>e.\n           e \\<in> parcs (list_digraph G) \\<longrightarrow>\n           fst e \\<in> pverts (list_digraph G)) \\<and>\n       (\\<forall>e.\n           e \\<in> parcs (list_digraph G) \\<longrightarrow>\n           snd e \\<in> pverts (list_digraph G))) \\<and>\n      finite (pverts (list_digraph G)) \\<and>\n      finite (parcs (list_digraph G))) \\<and>\n     ((\\<forall>e.\n          e \\<in> parcs (list_digraph G) \\<longrightarrow>\n          fst e \\<in> pverts (list_digraph G)) \\<and>\n      (\\<forall>e.\n          e \\<in> parcs (list_digraph G) \\<longrightarrow>\n          snd e \\<in> pverts (list_digraph G))) \\<and>\n     symmetric (with_proj (list_digraph G))) =\n    (case G of\n     (V, A) \\<Rightarrow>\n       \\<forall>(u, v)\\<in>set A.\n          u \\<noteq> v \\<and>\n          u \\<in> set V \\<and> v \\<in> set V \\<and> (v, u) \\<in> set A)", "by (auto simp: pair_graph_impl_def list_digraph_simps symmetric_def intro: symI dest: symD split: prod.splits)"], ["", "lemma genus_impl_correct:\n  assumes dist_V: \"distinct (fst G)\" and dist_A: \"distinct (snd G)\"\n  assumes \"lists_digraph_map G M\"\n  shows \"pre_digraph_map.euler_genus (list_digraph G) (to_map' (snd G) M) = genus_impl G M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_digraph_map.euler_genus (with_proj (list_digraph G))\n     (to_map' (snd G) M) =\n    genus_impl G M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pre_digraph_map.euler_genus (with_proj (list_digraph G))\n     (to_map' (snd G) M) =\n    genus_impl G M", "interpret lists_digraph_map G M"], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_digraph_map G M", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "obtain V A where G_eq: \"G = (V,A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V A. G = (V, A) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases G)"], ["proof (state)\nthis:\n  G = (V, A)\n\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "moreover"], ["proof (state)\nthis:\n  G = (V, A)\n\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "have \"distinct (isolated_verts_impl G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (isolated_verts_impl G)", "using dist_V"], ["proof (prove)\nusing this:\n  distinct (fst G)\n\ngoal (1 subgoal):\n 1. distinct (isolated_verts_impl G)", "by (auto simp: isolated_verts_impl_def )"], ["proof (state)\nthis:\n  distinct (isolated_verts_impl G)\n\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "moreover"], ["proof (state)\nthis:\n  distinct (isolated_verts_impl G)\n\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "have faces: \"card face_cycle_sets = length (orbits_list_impl (lists_fc_succ M) (snd G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card face_cycle_sets =\n    length (orbits_list_impl (lists_fc_succ M) (snd G))", "using dist_A"], ["proof (prove)\nusing this:\n  distinct (snd G)\n\ngoal (1 subgoal):\n 1. card face_cycle_sets =\n    length (orbits_list_impl (lists_fc_succ M) (snd G))", "by (simp add: card_face_cycle_sets_conv lists_fcs_def orbits_list_conv_impl distinct_remdups_id)"], ["proof (state)\nthis:\n  card face_cycle_sets = length (orbits_list_impl (lists_fc_succ M) (snd G))\n\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "ultimately"], ["proof (chain)\npicking this:\n  G = (V, A)\n  distinct (isolated_verts_impl G)\n  card face_cycle_sets = length (orbits_list_impl (lists_fc_succ M) (snd G))", "show ?thesis"], ["proof (prove)\nusing this:\n  G = (V, A)\n  distinct (isolated_verts_impl G)\n  card face_cycle_sets = length (orbits_list_impl (lists_fc_succ M) (snd G))\n\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "using pair_pseudo_graph dist_V dist_A"], ["proof (prove)\nusing this:\n  G = (V, A)\n  distinct (isolated_verts_impl G)\n  card face_cycle_sets = length (orbits_list_impl (lists_fc_succ M) (snd G))\n  pair_pseudo_graph (list_digraph G)\n  distinct (fst G)\n  distinct (snd G)\n\ngoal (1 subgoal):\n 1. euler_genus = genus_impl G M", "unfolding euler_genus_def euler_char_def genus_impl_def card_sccs_verts[symmetric]"], ["proof (prove)\nusing this:\n  G = (V, A)\n  distinct (isolated_verts_impl G)\n  card face_cycle_sets = length (orbits_list_impl (lists_fc_succ M) (snd G))\n  pair_pseudo_graph (list_digraph G)\n  distinct (fst G)\n  distinct (snd G)\n\ngoal (1 subgoal):\n 1. (int (2 * card sccs_verts) - int (card isolated_verts) -\n     (int (card (verts (with_proj (list_digraph G)))) -\n      int (card (arcs (with_proj (list_digraph G))) div 2) +\n      int (card face_cycle_sets))) div\n    2 =\n    (case G of\n     (V, A) \\<Rightarrow>\n       (int (2 * card (sccs_verts_impl G)) -\n        int (length (isolated_verts_impl G)) -\n        (int (length V) - int (length A) div 2 +\n         int (length (orbits_list_impl (lists_fc_succ M) A)))) div\n       2)", "by (simp add: sccs_verts_impl_correct isolated_verts_impl_correct\n      distinct_card list_digraph_simps zdiv_int)"], ["proof (state)\nthis:\n  euler_genus = genus_impl G M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elems_all_maps_list:\n  assumes \"M \\<in> set (all_maps_list G)\" \"distinct (snd G)\"\n  shows \"\\<Union>(sset M) = set (snd G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (sset M) = set (snd G)", "using assms"], ["proof (prove)\nusing this:\n  M \\<in> set (all_maps_list G)\n  distinct (snd G)\n\ngoal (1 subgoal):\n 1. \\<Union> (sset M) = set (snd G)", "by (simp add: all_maps_list_def in_set_cyc_permutationss distincts_grouped_arcs union_grouped_out_arcs[symmetric])\n       (metis set_map)"], ["", "lemma comb_planar_impl_altdef: \"comb_planar_impl G = (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comb_planar_impl G =\n    (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)", "unfolding comb_planar_impl_def Let_def genus_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case G of\n     (V, A) \\<Rightarrow>\n       \\<exists>M\\<in>set (all_maps_list G).\n          (int (2 * card (sccs_verts_impl G)) -\n           int (length (isolated_verts_impl G)) -\n           int (length V) +\n           int (length A) div 2 -\n           int (length (orbits_list_impl (lists_fc_succ M) A))) div\n          2 =\n          0) =\n    (\\<exists>M\\<in>set (all_maps_list G).\n        (case G of\n         (V, A) \\<Rightarrow>\n           (int (2 * card (sccs_verts_impl G)) -\n            int (length (isolated_verts_impl G)) -\n            (int (length V) - int (length A) div 2 +\n             int (length (orbits_list_impl (lists_fc_succ M) A)))) div\n           2) =\n        0)", "by (cases G) (simp add: algebra_simps)"], ["", "lemma comb_planar_impl_correct:\n  assumes \"pair_graph (list_digraph G)\"\n  assumes dist_V: \"distinct (fst G)\" and dist_A: \"distinct (snd G)\"\n  shows \"comb_planar (list_digraph G) = comb_planar_impl G\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "interpret G: pair_graph \"list_digraph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_graph (list_digraph G)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "let ?G = \"list_digraph G\""], ["proof (state)\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have *: \"all_maps (list_digraph G) = set (maps_all_maps_list G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_maps (list_digraph G) = set (maps_all_maps_list G)", "by (rule set_maps_all_maps_list) (unfold_locales, simp add: dist_A)"], ["proof (state)\nthis:\n  all_maps (list_digraph G) = set (maps_all_maps_list G)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "obtain V A where \"G = (V,A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V A. G = (V, A) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases G)"], ["proof (state)\nthis:\n  G = (V, A)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "{"], ["proof (state)\nthis:\n  G = (V, A)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "fix M"], ["proof (state)\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "assume \"M \\<in> set (all_maps_list G)\""], ["proof (state)\nthis:\n  M \\<in> set (all_maps_list G)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have \"digraph_map (list_digraph G) (to_map' (snd G) M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_map (with_proj (list_digraph G)) (to_map' (snd G) M)", "using \\<open>M \\<in> _\\<close> G.all_maps_correct"], ["proof (prove)\nusing this:\n  M \\<in> set (all_maps_list G)\n  all_maps (list_digraph G) =\n  {M. digraph_map (with_proj (list_digraph G)) M}\n\ngoal (1 subgoal):\n 1. digraph_map (with_proj (list_digraph G)) (to_map' (snd G) M)", "by (auto simp: * maps_all_maps_list_def)"], ["proof (state)\nthis:\n  digraph_map (with_proj (list_digraph G)) (to_map' (snd G) M)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "then"], ["proof (chain)\npicking this:\n  digraph_map (with_proj (list_digraph G)) (to_map' (snd G) M)", "interpret G: digraph_map \"list_digraph G\" \"to_map' (snd G) M\""], ["proof (prove)\nusing this:\n  digraph_map (with_proj (list_digraph G)) (to_map' (snd G) M)\n\ngoal (1 subgoal):\n 1. digraph_map (with_proj (list_digraph G)) (to_map' (snd G) M)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have \"distincts M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distincts M", "using \\<open>M \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  M \\<in> set (all_maps_list G)\n\ngoal (1 subgoal):\n 1. distincts M", "using dist_A distincts_in_all_maps_list"], ["proof (prove)\nusing this:\n  M \\<in> set (all_maps_list G)\n  distinct (snd G)\n  \\<lbrakk>distinct (snd ?X); ?xss \\<in> set (all_maps_list ?X)\\<rbrakk>\n  \\<Longrightarrow> distincts ?xss\n\ngoal (1 subgoal):\n 1. distincts M", "by blast"], ["proof (state)\nthis:\n  distincts M\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have \"lists_digraph_map G M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists_digraph_map G M", "using elems_all_maps_list[OF \\<open>M \\<in> _\\<close> \\<open>distinct (snd G)\\<close>]"], ["proof (prove)\nusing this:\n  \\<Union> (sset M) = set (snd G)\n\ngoal (1 subgoal):\n 1. lists_digraph_map G M", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<Union> (sset M) = set (snd G);\n        a \\<in> parcs (list_digraph G)\\<rbrakk>\n       \\<Longrightarrow> fst a \\<noteq> snd a\n 2. \\<Union> (sset M) = set (snd G) \\<Longrightarrow> distincts M\n 3. \\<Union> (sset M) = set (snd G) \\<Longrightarrow>\n    parcs (list_digraph G) = \\<Union> (sset M)", "by (auto intro: \\<open>distincts M\\<close> dest: G.adj_not_same) (auto simp: list_digraph_simps)"], ["proof (state)\nthis:\n  lists_digraph_map G M\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "}"], ["proof (state)\nthis:\n  ?M3 \\<in> set (all_maps_list G) \\<Longrightarrow> lists_digraph_map G ?M3\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "note ldm = this"], ["proof (state)\nthis:\n  ?M3 \\<in> set (all_maps_list G) \\<Longrightarrow> lists_digraph_map G ?M3\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have \"comb_planar ?G = (\\<exists>M \\<in> {M. digraph_map ?G M}. pre_digraph_map.euler_genus ?G M = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) =\n    (\\<exists>M\\<in>{M. digraph_map (with_proj (list_digraph G)) M}.\n        pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0)", "unfolding comb_planar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>M.\n        digraph_map (with_proj (list_digraph G)) M \\<and>\n        pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0) =\n    (\\<exists>M\\<in>{M. digraph_map (with_proj (list_digraph G)) M}.\n        pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0)", "by simp"], ["proof (state)\nthis:\n  comb_planar (with_proj (list_digraph G)) =\n  (\\<exists>M\\<in>{M. digraph_map (with_proj (list_digraph G)) M}.\n      pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "also"], ["proof (state)\nthis:\n  comb_planar (with_proj (list_digraph G)) =\n  (\\<exists>M\\<in>{M. digraph_map (with_proj (list_digraph G)) M}.\n      pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have \"\\<dots> = (\\<exists>M\\<in>set (all_maps_list G). pre_digraph_map.euler_genus (list_digraph G)\n      (to_map (set (snd G)) (lists_succ M)) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>M\\<in>{M. digraph_map (with_proj (list_digraph G)) M}.\n        pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0) =\n    (\\<exists>M\\<in>set (all_maps_list G).\n        pre_digraph_map.euler_genus (with_proj (list_digraph G))\n         (to_map' (snd G) M) =\n        0)", "unfolding comb_planar_def comb_planar_impl_def Let_def G.all_maps_correct[symmetric]\n      set_maps_all_maps_list[OF G.pair_wf_digraph dist_A] maps_all_maps_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>M\\<in>set (map (to_map (set (snd G)) \\<circ> lists_succ)\n                          (all_maps_list G)).\n        pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0) =\n    (\\<exists>M\\<in>set (all_maps_list G).\n        pre_digraph_map.euler_genus (with_proj (list_digraph G))\n         (to_map' (snd G) M) =\n        0)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>M\\<in>{M. digraph_map (with_proj (list_digraph G)) M}.\n      pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0) =\n  (\\<exists>M\\<in>set (all_maps_list G).\n      pre_digraph_map.euler_genus (with_proj (list_digraph G))\n       (to_map' (snd G) M) =\n      0)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "also"], ["proof (state)\nthis:\n  (\\<exists>M\\<in>{M. digraph_map (with_proj (list_digraph G)) M}.\n      pre_digraph_map.euler_genus (with_proj (list_digraph G)) M = 0) =\n  (\\<exists>M\\<in>set (all_maps_list G).\n      pre_digraph_map.euler_genus (with_proj (list_digraph G))\n       (to_map' (snd G) M) =\n      0)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have \"\\<dots> = (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>M\\<in>set (all_maps_list G).\n        pre_digraph_map.euler_genus (with_proj (list_digraph G))\n         (to_map' (snd G) M) =\n        0) =\n    (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)", "using ldm assms"], ["proof (prove)\nusing this:\n  ?M3 \\<in> set (all_maps_list G) \\<Longrightarrow> lists_digraph_map G ?M3\n  pair_graph (list_digraph G)\n  distinct (fst G)\n  distinct (snd G)\n\ngoal (1 subgoal):\n 1. (\\<exists>M\\<in>set (all_maps_list G).\n        pre_digraph_map.euler_genus (with_proj (list_digraph G))\n         (to_map' (snd G) M) =\n        0) =\n    (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)", "by (simp add: genus_impl_correct)"], ["proof (state)\nthis:\n  (\\<exists>M\\<in>set (all_maps_list G).\n      pre_digraph_map.euler_genus (with_proj (list_digraph G))\n       (to_map' (snd G) M) =\n      0) =\n  (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "also"], ["proof (state)\nthis:\n  (\\<exists>M\\<in>set (all_maps_list G).\n      pre_digraph_map.euler_genus (with_proj (list_digraph G))\n       (to_map' (snd G) M) =\n      0) =\n  (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0)\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "have \"\\<dots> = comb_planar_impl G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0) =\n    comb_planar_impl G", "unfolding comb_planar_impl_def genus_impl_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>M\\<in>set (all_maps_list G).\n        (case G of\n         (V, A) \\<Rightarrow>\n           (int (2 * card (sccs_verts_impl G)) -\n            int (length (isolated_verts_impl G)) -\n            (int (length V) - int (length A) div 2 +\n             int (length (orbits_list_impl (lists_fc_succ M) A)))) div\n           2) =\n        0) =\n    (case G of\n     (V, A) \\<Rightarrow>\n       \\<exists>M\\<in>set (all_maps_list G).\n          (int (2 * card (sccs_verts_impl G)) -\n           int (length (isolated_verts_impl G)) -\n           int (length V) +\n           int (length A) div 2 -\n           int (length (orbits_list_impl (lists_fc_succ M) A))) div\n          2 =\n          0)", "by (simp add: \\<open>G = (V,A)\\<close> algebra_simps)"], ["proof (state)\nthis:\n  (\\<exists>M\\<in>set (all_maps_list G). genus_impl G M = 0) =\n  comb_planar_impl G\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "finally"], ["proof (chain)\npicking this:\n  comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "show ?thesis"], ["proof (prove)\nusing this:\n  comb_planar (with_proj (list_digraph G)) = comb_planar_impl G\n\ngoal (1 subgoal):\n 1. comb_planar (with_proj (list_digraph G)) = comb_planar_impl G", "."], ["proof (state)\nthis:\n  comb_planar (with_proj (list_digraph G)) = comb_planar_impl G\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}