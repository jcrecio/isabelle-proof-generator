{"file_name": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates/Planarity/List_Aux.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates", "problem_names": ["lemma nth_rotate_conv_nth1_conv_nth:\n  assumes \"m < length xs\"\n  shows \"rotate1 xs ! m = xs ! (Suc m mod length xs)\"", "lemma nth_rotate_conv_nth:\n  assumes \"m < length xs\"\n  shows \"rotate n xs ! m = xs ! ((m + n) mod length xs)\"", "lemma not_nil_if_in_set:\n  assumes \"x \\<in> set xs\" shows \"xs \\<noteq> []\"", "lemma length_fold_remove1_le:\n \"length (fold remove1 ys xs) \\<le> length xs\"", "lemma set_fold_remove1':\n  assumes \"x \\<in> set xs - set ys\" shows \"x \\<in> set (fold remove1 ys xs)\"", "lemma set_fold_remove1:\n  \"set (fold remove1 xs ys) \\<subseteq> set ys\"", "lemma set_fold_remove1_distinct:\n  assumes \"distinct xs\" shows \"set (fold remove1 ys xs) = set xs - set ys\"", "lemma distinct_fold_remove1:\n  assumes \"distinct xs\"\n  shows \"distinct (fold remove1 ys xs)\""], "translations": [["", "lemma nth_rotate_conv_nth1_conv_nth:\n  assumes \"m < length xs\"\n  shows \"rotate1 xs ! m = xs ! (Suc m mod length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate1 xs ! m = xs ! (Suc m mod length xs)", "using assms"], ["proof (prove)\nusing this:\n  m < length xs\n\ngoal (1 subgoal):\n 1. rotate1 xs ! m = xs ! (Suc m mod length xs)", "proof (induction xs arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m < length [] \\<Longrightarrow>\n       rotate1 [] ! m = [] ! (Suc m mod length [])\n 2. \\<And>a xs m.\n       \\<lbrakk>\\<And>m.\n                   m < length xs \\<Longrightarrow>\n                   rotate1 xs ! m = xs ! (Suc m mod length xs);\n        m < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rotate1 (a # xs) ! m =\n                         (a # xs) ! (Suc m mod length (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?m < length xs \\<Longrightarrow>\n  rotate1 xs ! ?m = xs ! (Suc ?m mod length xs)\n  m < length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m < length [] \\<Longrightarrow>\n       rotate1 [] ! m = [] ! (Suc m mod length [])\n 2. \\<And>a xs m.\n       \\<lbrakk>\\<And>m.\n                   m < length xs \\<Longrightarrow>\n                   rotate1 xs ! m = xs ! (Suc m mod length xs);\n        m < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> rotate1 (a # xs) ! m =\n                         (a # xs) ! (Suc m mod length (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))", "proof (cases \"m < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m < length xs \\<Longrightarrow>\n    rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))\n 2. \\<not> m < length xs \\<Longrightarrow>\n    rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))", "case False"], ["proof (state)\nthis:\n  \\<not> m < length xs\n\ngoal (2 subgoals):\n 1. m < length xs \\<Longrightarrow>\n    rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))\n 2. \\<not> m < length xs \\<Longrightarrow>\n    rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))", "with Cons.prems"], ["proof (chain)\npicking this:\n  m < length (x # xs)\n  \\<not> m < length xs", "have \"m = length xs\""], ["proof (prove)\nusing this:\n  m < length (x # xs)\n  \\<not> m < length xs\n\ngoal (1 subgoal):\n 1. m = length xs", "by force"], ["proof (state)\nthis:\n  m = length xs\n\ngoal (2 subgoals):\n 1. m < length xs \\<Longrightarrow>\n    rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))\n 2. \\<not> m < length xs \\<Longrightarrow>\n    rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))", "then"], ["proof (chain)\npicking this:\n  m = length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  m = length xs\n\ngoal (1 subgoal):\n 1. rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))\n\ngoal (1 subgoal):\n 1. m < length xs \\<Longrightarrow>\n    rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))", "qed (auto simp: nth_append)"], ["proof (state)\nthis:\n  rotate1 (x # xs) ! m = (x # xs) ! (Suc m mod length (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m < length [] \\<Longrightarrow>\n       rotate1 [] ! m = [] ! (Suc m mod length [])", "qed simp"], ["", "lemma nth_rotate_conv_nth:\n  assumes \"m < length xs\"\n  shows \"rotate n xs ! m = xs ! ((m + n) mod length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate n xs ! m = xs ! ((m + n) mod length xs)", "using assms"], ["proof (prove)\nusing this:\n  m < length xs\n\ngoal (1 subgoal):\n 1. rotate n xs ! m = xs ! ((m + n) mod length xs)", "proof (induction n arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m < length xs \\<Longrightarrow>\n       rotate 0 xs ! m = xs ! ((m + 0) mod length xs)\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < length xs \\<Longrightarrow>\n                   rotate n xs ! m = xs ! ((m + n) mod length xs);\n        m < length xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc n) xs ! m =\n                         xs ! ((m + Suc n) mod length xs)", "case 0"], ["proof (state)\nthis:\n  m < length xs\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m < length xs \\<Longrightarrow>\n       rotate 0 xs ! m = xs ! ((m + 0) mod length xs)\n 2. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < length xs \\<Longrightarrow>\n                   rotate n xs ! m = xs ! ((m + n) mod length xs);\n        m < length xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc n) xs ! m =\n                         xs ! ((m + Suc n) mod length xs)", "then"], ["proof (chain)\npicking this:\n  m < length xs", "show ?case"], ["proof (prove)\nusing this:\n  m < length xs\n\ngoal (1 subgoal):\n 1. rotate 0 xs ! m = xs ! ((m + 0) mod length xs)", "by simp"], ["proof (state)\nthis:\n  rotate 0 xs ! m = xs ! ((m + 0) mod length xs)\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < length xs \\<Longrightarrow>\n                   rotate n xs ! m = xs ! ((m + n) mod length xs);\n        m < length xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc n) xs ! m =\n                         xs ! ((m + Suc n) mod length xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < length xs \\<Longrightarrow>\n                   rotate n xs ! m = xs ! ((m + n) mod length xs);\n        m < length xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc n) xs ! m =\n                         xs ! ((m + Suc n) mod length xs)", "case (Suc n)"], ["proof (state)\nthis:\n  ?m < length xs \\<Longrightarrow>\n  rotate n xs ! ?m = xs ! ((?m + n) mod length xs)\n  m < length xs\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>\\<And>m.\n                   m < length xs \\<Longrightarrow>\n                   rotate n xs ! m = xs ! ((m + n) mod length xs);\n        m < length xs\\<rbrakk>\n       \\<Longrightarrow> rotate (Suc n) xs ! m =\n                         xs ! ((m + Suc n) mod length xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)\n 2. \\<not> ?P \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "assume \"m + 1 < length xs\""], ["proof (state)\nthis:\n  m + 1 < length xs\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)\n 2. \\<not> ?P \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "with Suc"], ["proof (chain)\npicking this:\n  ?m < length xs \\<Longrightarrow>\n  rotate n xs ! ?m = xs ! ((?m + n) mod length xs)\n  m < length xs\n  m + 1 < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ?m < length xs \\<Longrightarrow>\n  rotate n xs ! ?m = xs ! ((?m + n) mod length xs)\n  m < length xs\n  m + 1 < length xs\n\ngoal (1 subgoal):\n 1. rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "using Suc"], ["proof (prove)\nusing this:\n  ?m < length xs \\<Longrightarrow>\n  rotate n xs ! ?m = xs ! ((?m + n) mod length xs)\n  m < length xs\n  m + 1 < length xs\n  ?m < length xs \\<Longrightarrow>\n  rotate n xs ! ?m = xs ! ((?m + n) mod length xs)\n  m < length xs\n\ngoal (1 subgoal):\n 1. rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "by (auto simp: nth_rotate_conv_nth1_conv_nth)"], ["proof (state)\nthis:\n  rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "assume \"\\<not>(m + 1 < length xs)\""], ["proof (state)\nthis:\n  \\<not> m + 1 < length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "with Suc"], ["proof (chain)\npicking this:\n  ?m < length xs \\<Longrightarrow>\n  rotate n xs ! ?m = xs ! ((?m + n) mod length xs)\n  m < length xs\n  \\<not> m + 1 < length xs", "have \"m + 1 = length xs\" \"0 < length xs\""], ["proof (prove)\nusing this:\n  ?m < length xs \\<Longrightarrow>\n  rotate n xs ! ?m = xs ! ((?m + n) mod length xs)\n  m < length xs\n  \\<not> m + 1 < length xs\n\ngoal (1 subgoal):\n 1. m + 1 = length xs &&& 0 < length xs", "by auto"], ["proof (state)\nthis:\n  m + 1 = length xs\n  0 < length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "moreover"], ["proof (state)\nthis:\n  m + 1 = length xs\n  0 < length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "{"], ["proof (state)\nthis:\n  m + 1 = length xs\n  0 < length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "have \"Suc (m + n) mod length xs = (Suc m + n) mod length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (m + n) mod length xs = (Suc m + n) mod length xs", "by auto"], ["proof (state)\nthis:\n  Suc (m + n) mod length xs = (Suc m + n) mod length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "also"], ["proof (state)\nthis:\n  Suc (m + n) mod length xs = (Suc m + n) mod length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "have \"\\<dots> = n mod length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc m + n) mod length xs = n mod length xs", "using \\<open>m + 1 = _\\<close>"], ["proof (prove)\nusing this:\n  m + 1 = length xs\n\ngoal (1 subgoal):\n 1. (Suc m + n) mod length xs = n mod length xs", "by simp"], ["proof (state)\nthis:\n  (Suc m + n) mod length xs = n mod length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "finally"], ["proof (chain)\npicking this:\n  Suc (m + n) mod length xs = n mod length xs", "have \"Suc (m + n) mod length xs = n mod length xs\""], ["proof (prove)\nusing this:\n  Suc (m + n) mod length xs = n mod length xs\n\ngoal (1 subgoal):\n 1. Suc (m + n) mod length xs = n mod length xs", "."], ["proof (state)\nthis:\n  Suc (m + n) mod length xs = n mod length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "}"], ["proof (state)\nthis:\n  Suc (m + n) mod length xs = n mod length xs\n\ngoal (1 subgoal):\n 1. \\<not> m + 1 < length xs \\<Longrightarrow>\n    rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "ultimately"], ["proof (chain)\npicking this:\n  m + 1 = length xs\n  0 < length xs\n  Suc (m + n) mod length xs = n mod length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  m + 1 = length xs\n  0 < length xs\n  Suc (m + n) mod length xs = n mod length xs\n\ngoal (1 subgoal):\n 1. rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)", "by (auto simp: nth_rotate_conv_nth1_conv_nth Suc.IH)"], ["proof (state)\nthis:\n  rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rotate (Suc n) xs ! m = xs ! ((m + Suc n) mod length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_nil_if_in_set:\n  assumes \"x \\<in> set xs\" shows \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["", "lemma length_fold_remove1_le:\n \"length (fold remove1 ys xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fold remove1 ys xs) \\<le> length xs", "proof (induct ys arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. length (fold remove1 [] xs) \\<le> length xs\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           length (fold remove1 ys xs) \\<le> length xs) \\<Longrightarrow>\n       length (fold remove1 (a # ys) xs) \\<le> length xs", "case (Cons y ys)"], ["proof (state)\nthis:\n  length (fold remove1 ys ?xs) \\<le> length ?xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. length (fold remove1 [] xs) \\<le> length xs\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           length (fold remove1 ys xs) \\<le> length xs) \\<Longrightarrow>\n       length (fold remove1 (a # ys) xs) \\<le> length xs", "then"], ["proof (chain)\npicking this:\n  length (fold remove1 ys ?xs) \\<le> length ?xs", "have \"length (fold remove1 ys (remove1 y xs)) \\<le> length (remove1 y xs)\""], ["proof (prove)\nusing this:\n  length (fold remove1 ys ?xs) \\<le> length ?xs\n\ngoal (1 subgoal):\n 1. length (fold remove1 ys (remove1 y xs)) \\<le> length (remove1 y xs)", "by auto"], ["proof (state)\nthis:\n  length (fold remove1 ys (remove1 y xs)) \\<le> length (remove1 y xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs. length (fold remove1 [] xs) \\<le> length xs\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           length (fold remove1 ys xs) \\<le> length xs) \\<Longrightarrow>\n       length (fold remove1 (a # ys) xs) \\<le> length xs", "also"], ["proof (state)\nthis:\n  length (fold remove1 ys (remove1 y xs)) \\<le> length (remove1 y xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs. length (fold remove1 [] xs) \\<le> length xs\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           length (fold remove1 ys xs) \\<le> length xs) \\<Longrightarrow>\n       length (fold remove1 (a # ys) xs) \\<le> length xs", "have \"\\<dots> \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remove1 y xs) \\<le> length xs", "by (auto simp: length_remove1)"], ["proof (state)\nthis:\n  length (remove1 y xs) \\<le> length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs. length (fold remove1 [] xs) \\<le> length xs\n 2. \\<And>a ys xs.\n       (\\<And>xs.\n           length (fold remove1 ys xs) \\<le> length xs) \\<Longrightarrow>\n       length (fold remove1 (a # ys) xs) \\<le> length xs", "finally"], ["proof (chain)\npicking this:\n  length (fold remove1 ys (remove1 y xs)) \\<le> length xs", "show ?case"], ["proof (prove)\nusing this:\n  length (fold remove1 ys (remove1 y xs)) \\<le> length xs\n\ngoal (1 subgoal):\n 1. length (fold remove1 (y # ys) xs) \\<le> length xs", "by simp"], ["proof (state)\nthis:\n  length (fold remove1 (y # ys) xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. length (fold remove1 [] xs) \\<le> length xs", "qed simp"], ["", "lemma set_fold_remove1':\n  assumes \"x \\<in> set xs - set ys\" shows \"x \\<in> set (fold remove1 ys xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (fold remove1 ys xs)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set xs - set ys\n\ngoal (1 subgoal):\n 1. x \\<in> set (fold remove1 ys xs)", "by (induct ys arbitrary: xs) auto"], ["", "lemma set_fold_remove1:\n  \"set (fold remove1 xs ys) \\<subseteq> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold remove1 xs ys) \\<subseteq> set ys", "by (induct xs arbitrary: ys) (auto, metis notin_set_remove1 subsetCE)"], ["", "lemma set_fold_remove1_distinct:\n  assumes \"distinct xs\" shows \"set (fold remove1 ys xs) = set xs - set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold remove1 ys xs) = set xs - set ys", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. set (fold remove1 ys xs) = set xs - set ys", "by (induct ys arbitrary: xs) auto"], ["", "lemma distinct_fold_remove1:\n  assumes \"distinct xs\"\n  shows \"distinct (fold remove1 ys xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fold remove1 ys xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (fold remove1 ys xs)", "by (induct ys arbitrary: xs) auto"], ["", "end"]]}