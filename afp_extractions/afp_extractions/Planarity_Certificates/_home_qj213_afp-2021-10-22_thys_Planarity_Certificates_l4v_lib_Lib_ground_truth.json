{"file_name": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates/l4v/lib/Lib.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Planarity_Certificates", "problem_names": ["lemma hd_map_simp:\n  \"b \\<noteq> [] \\<Longrightarrow> hd (map a b) = a (hd b)\"", "lemma tl_map_simp:\n  \"tl (map a b) = map a (tl b)\"", "lemma Collect_eq:\n  \"{x. P x} = {x. Q x} \\<longleftrightarrow> (\\<forall>x. P x = Q x)\"", "lemma iff_impI: \"\\<lbrakk>P \\<Longrightarrow> Q = R\\<rbrakk> \\<Longrightarrow> (P \\<longrightarrow> Q) = (P \\<longrightarrow> R)\"", "lemma fun_app_cong[fundef_cong]:\n  \"\\<lbrakk> f x = f' x' \\<rbrakk> \\<Longrightarrow> (f $ x) = (f' $ x')\"", "lemma fun_app_apply_cong[fundef_cong]:\n  \"f x y = f' x' y' \\<Longrightarrow> (f $ x) y = (f' $ x') y'\"", "lemma if_apply_cong[fundef_cong]:\n  \"\\<lbrakk> P = P'; x = x'; P' \\<Longrightarrow> f x' = f' x'; \\<not> P' \\<Longrightarrow> g x' = g' x' \\<rbrakk>\n     \\<Longrightarrow> (if P then f else g) x = (if P' then f' else g') x'\"", "lemma case_prod_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f (fst p) (snd p) s = f' (fst p') (snd p') s' \\<rbrakk> \\<Longrightarrow> case_prod f p s = case_prod f' p' s'\"", "lemma tranclD2:\n  \"(x, y) \\<in> R\\<^sup>+ \\<Longrightarrow> \\<exists>z. (x, z) \\<in> R\\<^sup>* \\<and> (z, y) \\<in> R\"", "lemma linorder_min_same1 [simp]:\n  \"(min y x = y) = (y \\<le> (x::'a::linorder))\"", "lemma linorder_min_same2 [simp]:\n  \"(min x y = y) = (y \\<le> (x::'a::linorder))\"", "lemma wf_sum_wf:\n  \"\\<lbrakk> wf r; wf r' \\<rbrakk> \\<Longrightarrow> wf (wf_sum divisor r r')\"", "lemmas option_map_def = map_option_case", "lemma False_implies_equals [simp]:\n  \"((False \\<Longrightarrow> P) \\<Longrightarrow> PROP Q) \\<equiv> PROP Q\"", "lemma split_paired_Ball:\n  \"(\\<forall>x \\<in> A. P x) = (\\<forall>x y. (x,y) \\<in> A \\<longrightarrow> P (x,y))\"", "lemma split_paired_Bex:\n  \"(\\<exists>x \\<in> A. P x) = (\\<exists>x y. (x,y) \\<in> A \\<and> P (x,y))\""], "translations": [["", "lemma hd_map_simp:\n  \"b \\<noteq> [] \\<Longrightarrow> hd (map a b) = a (hd b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> [] \\<Longrightarrow> hd (map a b) = a (hd b)", "by (rule hd_map)"], ["", "lemma tl_map_simp:\n  \"tl (map a b) = map a (tl b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (map a b) = map a (tl b)", "by (induct b,auto)"], ["", "(* FIXME: could be added to Set.thy *)"], ["", "lemma Collect_eq:\n  \"{x. P x} = {x. Q x} \\<longleftrightarrow> (\\<forall>x. P x = Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x. P x} = {x. Q x}) = (\\<forall>x. P x = Q x)", "by (rule iffI) auto"], ["", "(* FIXME: move next to HOL.iff_allI *)"], ["", "lemma iff_impI: \"\\<lbrakk>P \\<Longrightarrow> Q = R\\<rbrakk> \\<Longrightarrow> (P \\<longrightarrow> Q) = (P \\<longrightarrow> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow> Q = R) \\<Longrightarrow>\n    (P \\<longrightarrow> Q) = (P \\<longrightarrow> R)", "by blast"], ["", "definition\n  fun_app :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" (infixr \"$\" 10) where\n  \"f $ x \\<equiv> f x\""], ["", "declare fun_app_def [iff]"], ["", "lemma fun_app_cong[fundef_cong]:\n  \"\\<lbrakk> f x = f' x' \\<rbrakk> \\<Longrightarrow> (f $ x) = (f' $ x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = f' x' \\<Longrightarrow> (f $ x) = (f' $ x')", "by simp"], ["", "lemma fun_app_apply_cong[fundef_cong]:\n  \"f x y = f' x' y' \\<Longrightarrow> (f $ x) y = (f' $ x') y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y = f' x' y' \\<Longrightarrow> (f $ x) y = (f' $ x') y'", "by simp"], ["", "lemma if_apply_cong[fundef_cong]:\n  \"\\<lbrakk> P = P'; x = x'; P' \\<Longrightarrow> f x' = f' x'; \\<not> P' \\<Longrightarrow> g x' = g' x' \\<rbrakk>\n     \\<Longrightarrow> (if P then f else g) x = (if P' then f' else g') x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P = P'; x = x'; P' \\<Longrightarrow> f x' = f' x';\n     \\<not> P' \\<Longrightarrow> g x' = g' x'\\<rbrakk>\n    \\<Longrightarrow> (if P then f else g) x = (if P' then f' else g') x'", "by simp"], ["", "lemma case_prod_apply_cong[fundef_cong]:\n  \"\\<lbrakk> f (fst p) (snd p) s = f' (fst p') (snd p') s' \\<rbrakk> \\<Longrightarrow> case_prod f p s = case_prod f' p' s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (fst p) (snd p) s = f' (fst p') (snd p') s' \\<Longrightarrow>\n    (case p of (x, xa) \\<Rightarrow> f x xa) s =\n    (case p' of (x, xa) \\<Rightarrow> f' x xa) s'", "by (simp add: split_def)"], ["", "definition\n  pred_conj :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool)\" (infixl \"and\" 35)\nwhere\n  \"pred_conj P Q \\<equiv> \\<lambda>x. P x \\<and> Q x\""], ["", "definition\n  pred_disj :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool)\" (infixl \"or\" 30)\nwhere\n  \"pred_disj P Q \\<equiv> \\<lambda>x. P x \\<or> Q x\""], ["", "definition\n  pred_neg :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool)\" (\"not _\" [40] 40)\nwhere\n  \"pred_neg P \\<equiv> \\<lambda>x. \\<not> P x\""], ["", "definition \"K \\<equiv> \\<lambda>x y. x\""], ["", "definition\n  zipWith :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> 'c list\" where\n  \"zipWith f xs ys \\<equiv> map (case_prod f) (zip xs ys)\""], ["", "primrec\n  delete :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"delete y [] = []\"\n| \"delete y (x#xs) = (if y=x then xs else x # delete y xs)\""], ["", "primrec\n  find :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a option\"\nwhere\n  \"find f [] = None\"\n| \"find f (x # xs) = (if f x then Some x else find f xs)\""], ["", "definition\n \"swp f \\<equiv> \\<lambda>x y. f y x\""], ["", "primrec (nonexhaustive)\n  theRight :: \"'a + 'b \\<Rightarrow> 'b\" where\n  \"theRight (Inr x) = x\""], ["", "primrec (nonexhaustive)\n  theLeft :: \"'a + 'b \\<Rightarrow> 'a\" where\n  \"theLeft (Inl x) = x\""], ["", "definition\n \"isLeft x \\<equiv> (\\<exists>y. x = Inl y)\""], ["", "definition\n \"isRight x \\<equiv> (\\<exists>y. x = Inr y)\""], ["", "definition\n \"const x \\<equiv> \\<lambda>y. x\""], ["", "lemma tranclD2:\n  \"(x, y) \\<in> R\\<^sup>+ \\<Longrightarrow> \\<exists>z. (x, z) \\<in> R\\<^sup>* \\<and> (z, y) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> R\\<^sup>+ \\<Longrightarrow>\n    \\<exists>z. (x, z) \\<in> R\\<^sup>* \\<and> (z, y) \\<in> R", "by (erule tranclE) auto"], ["", "lemma linorder_min_same1 [simp]:\n  \"(min y x = y) = (y \\<le> (x::'a::linorder))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min y x = y) = (y \\<le> x)", "by (auto simp: min_def linorder_not_less)"], ["", "lemma linorder_min_same2 [simp]:\n  \"(min x y = y) = (y \\<le> (x::'a::linorder))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (min x y = y) = (y \\<le> x)", "by (auto simp: min_def linorder_not_le)"], ["", "text \\<open>A combinator for pairing up well-formed relations.\n        The divisor function splits the population in halves,\n        with the True half greater than the False half, and\n        the supplied relations control the order within the halves.\\<close>"], ["", "definition\n  wf_sum :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<times> 'a) set \\<Rightarrow> ('a \\<times> 'a) set \\<Rightarrow> ('a \\<times> 'a) set\"\nwhere\n  \"wf_sum divisor r r' \\<equiv>\n     ({(x, y). \\<not> divisor x \\<and> \\<not> divisor y} \\<inter> r')\n   \\<union>  {(x, y). \\<not> divisor x \\<and> divisor y}\n   \\<union> ({(x, y). divisor x \\<and> divisor y} \\<inter> r)\""], ["", "lemma wf_sum_wf:\n  \"\\<lbrakk> wf r; wf r' \\<rbrakk> \\<Longrightarrow> wf (wf_sum divisor r r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk> \\<Longrightarrow> wf (wf_sum divisor r r')", "apply (simp add: wf_sum_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. \\<not> divisor x} \\<times>\n                          {y. \\<not> divisor y} \\<inter>\n                          r' \\<union>\n                          {x. \\<not> divisor x} \\<times>\n                          {y. divisor y} \\<union>\n                          {x. divisor x} \\<times> {y. divisor y} \\<inter> r)", "apply (rule wf_Un)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. \\<not> divisor x} \\<times>\n                          {y. \\<not> divisor y} \\<inter>\n                          r')\n 2. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. \\<not> divisor x} \\<times> {y. divisor y})\n 3. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r') \\<inter>\n                      Range\n                       ({x. \\<not> divisor x} \\<times> {y. divisor y}) =\n                      {}\n 4. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. divisor x} \\<times> {y. divisor y} \\<inter> r)\n 5. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r' \\<union>\n                        {x. \\<not> divisor x} \\<times>\n                        {y. divisor y}) \\<inter>\n                      Range\n                       ({x. divisor x} \\<times> {y. divisor y} \\<inter> r) =\n                      {}", "apply (erule wf_Int2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. \\<not> divisor x} \\<times> {y. divisor y})\n 2. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r') \\<inter>\n                      Range\n                       ({x. \\<not> divisor x} \\<times> {y. divisor y}) =\n                      {}\n 3. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. divisor x} \\<times> {y. divisor y} \\<inter> r)\n 4. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r' \\<union>\n                        {x. \\<not> divisor x} \\<times>\n                        {y. divisor y}) \\<inter>\n                      Range\n                       ({x. divisor x} \\<times> {y. divisor y} \\<inter> r) =\n                      {}", "apply (rule wf_subset\n             [where r=\"measure (\\<lambda>x. If (divisor x) 1 0)\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf (measure (\\<lambda>x. if divisor x then 1 else 0))\n 2. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> {x. \\<not> divisor x} \\<times> {y. divisor y}\n                      \\<subseteq> measure\n                                   (\\<lambda>x. if divisor x then 1 else 0)\n 3. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r') \\<inter>\n                      Range\n                       ({x. \\<not> divisor x} \\<times> {y. divisor y}) =\n                      {}\n 4. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. divisor x} \\<times> {y. divisor y} \\<inter> r)\n 5. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r' \\<union>\n                        {x. \\<not> divisor x} \\<times>\n                        {y. divisor y}) \\<inter>\n                      Range\n                       ({x. divisor x} \\<times> {y. divisor y} \\<inter> r) =\n                      {}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> {x. \\<not> divisor x} \\<times> {y. divisor y}\n                      \\<subseteq> measure\n                                   (\\<lambda>x. if divisor x then 1 else 0)\n 2. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r') \\<inter>\n                      Range\n                       ({x. \\<not> divisor x} \\<times> {y. divisor y}) =\n                      {}\n 3. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. divisor x} \\<times> {y. divisor y} \\<inter> r)\n 4. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r' \\<union>\n                        {x. \\<not> divisor x} \\<times>\n                        {y. divisor y}) \\<inter>\n                      Range\n                       ({x. divisor x} \\<times> {y. divisor y} \\<inter> r) =\n                      {}", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r') \\<inter>\n                      Range\n                       ({x. \\<not> divisor x} \\<times> {y. divisor y}) =\n                      {}\n 2. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. divisor x} \\<times> {y. divisor y} \\<inter> r)\n 3. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r' \\<union>\n                        {x. \\<not> divisor x} \\<times>\n                        {y. divisor y}) \\<inter>\n                      Range\n                       ({x. divisor x} \\<times> {y. divisor y} \\<inter> r) =\n                      {}", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> wf ({x. divisor x} \\<times> {y. divisor y} \\<inter> r)\n 2. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r' \\<union>\n                        {x. \\<not> divisor x} \\<times>\n                        {y. divisor y}) \\<inter>\n                      Range\n                       ({x. divisor x} \\<times> {y. divisor y} \\<inter> r) =\n                      {}", "apply (erule wf_Int2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf r; wf r'\\<rbrakk>\n    \\<Longrightarrow> Domain\n                       ({x. \\<not> divisor x} \\<times>\n                        {y. \\<not> divisor y} \\<inter>\n                        r' \\<union>\n                        {x. \\<not> divisor x} \\<times>\n                        {y. divisor y}) \\<inter>\n                      Range\n                       ({x. divisor x} \\<times> {y. divisor y} \\<inter> r) =\n                      {}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation(input)\n \"option_map == map_option\""], ["", "lemmas option_map_def = map_option_case"], ["", "lemma False_implies_equals [simp]:\n  \"((False \\<Longrightarrow> P) \\<Longrightarrow> PROP Q) \\<equiv> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((False \\<Longrightarrow> P) \\<Longrightarrow> PROP Q) \\<equiv> PROP Q", "apply (rule equal_intr_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((False \\<Longrightarrow> P) \\<Longrightarrow> PROP Q) \\<Longrightarrow>\n    PROP Q\n 2. \\<lbrakk>PROP Q; False \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "apply (erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. False \\<Longrightarrow> P\n 2. \\<lbrakk>PROP Q; False \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q; False \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma split_paired_Ball:\n  \"(\\<forall>x \\<in> A. P x) = (\\<forall>x y. (x,y) \\<in> A \\<longrightarrow> P (x,y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>A. P x) =\n    (\\<forall>x y. (x, y) \\<in> A \\<longrightarrow> P (x, y))", "by auto"], ["", "lemma split_paired_Bex:\n  \"(\\<exists>x \\<in> A. P x) = (\\<exists>x y. (x,y) \\<in> A \\<and> P (x,y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>A. P x) = (\\<exists>x y. (x, y) \\<in> A \\<and> P (x, y))", "by auto"], ["", "end"]]}