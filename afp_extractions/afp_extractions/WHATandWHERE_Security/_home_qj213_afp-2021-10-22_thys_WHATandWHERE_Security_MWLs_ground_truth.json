{"file_name": "/home/qj213/afp-2021-10-22/thys/WHATandWHERE_Security/MWLs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/WHATandWHERE_Security", "problem_names": ["lemma PPc_nonempt: \"PPc c \\<noteq> []\"", "lemma unique_c_uneq: \"set (PPc c) \\<inter> set (PPc c') = {} \\<Longrightarrow> c \\<noteq> c'\"", "lemma V_nonempt_PPV_nonempt: \"V \\<noteq> [] \\<Longrightarrow> PPV V \\<noteq> []\"", "lemma unique_V_uneq:\n\"\\<lbrakk>V \\<noteq> []; V' \\<noteq> []; set (PPV V) \\<inter> set (PPV V') = {}\\<rbrakk> \\<Longrightarrow> V \\<noteq> V'\"", "lemma PPc_in_PPV: \"c \\<in> set V \\<Longrightarrow> set (PPc c) \\<subseteq> set (PPV V)\"", "lemma listindices_aux: \"i < length V \\<Longrightarrow> (V!i) \\<in> set V\"", "lemma PPc_in_PPV_version:\n  \"i < length V \\<Longrightarrow> set (PPc (V!i)) \\<subseteq> set (PPV V)\"", "lemma uniPPV_uniPPc: \"unique_PPV V \\<Longrightarrow> (\\<forall>i < length V. unique_PPc (V!i))\"", "lemma nextmem_exists_and_unique:\n\"\\<exists>m' p \\<alpha>. \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\n  \\<and> (\\<forall>m''. (\\<exists>p \\<alpha>. \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m''\\<rangle>) \\<longrightarrow> m'' = m')\"", "lemma PPsc_of_step:\n\"\\<lbrakk> \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>; \\<exists>c'. p = Some c' \\<rbrakk>\n  \\<Longrightarrow> set (PPc (the p)) \\<subseteq> set (PPc c)\"", "lemma PPs\\<alpha>_of_step:\n\"\\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\n  \\<Longrightarrow> set (PPV \\<alpha>) \\<subseteq> set (PPc c)\""], "translations": [["", "lemma PPc_nonempt: \"PPc c \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PPc c \\<noteq> []", "by (induct c) auto"], ["", "lemma unique_c_uneq: \"set (PPc c) \\<inter> set (PPc c') = {} \\<Longrightarrow> c \\<noteq> c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (PPc c) \\<inter> set (PPc c') = {} \\<Longrightarrow> c \\<noteq> c'", "by (insert PPc_nonempt, force)"], ["", "lemma V_nonempt_PPV_nonempt: \"V \\<noteq> [] \\<Longrightarrow> PPV V \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<noteq> [] \\<Longrightarrow> PPV V \\<noteq> []", "by (auto, induct V, simp_all, insert PPc_nonempt, force)"], ["", "lemma unique_V_uneq:\n\"\\<lbrakk>V \\<noteq> []; V' \\<noteq> []; set (PPV V) \\<inter> set (PPV V') = {}\\<rbrakk> \\<Longrightarrow> V \\<noteq> V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<noteq> []; V' \\<noteq> [];\n     set (PPV V) \\<inter> set (PPV V') = {}\\<rbrakk>\n    \\<Longrightarrow> V \\<noteq> V'", "by (auto, induct V, simp_all, insert V_nonempt_PPV_nonempt, auto)"], ["", "lemma PPc_in_PPV: \"c \\<in> set V \\<Longrightarrow> set (PPc c) \\<subseteq> set (PPV V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> set V \\<Longrightarrow> set (PPc c) \\<subseteq> set (PPV V)", "by (induct V, auto)"], ["", "lemma listindices_aux: \"i < length V \\<Longrightarrow> (V!i) \\<in> set V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length V \\<Longrightarrow> V ! i \\<in> set V", "by (metis nth_mem)"], ["", "lemma PPc_in_PPV_version:\n  \"i < length V \\<Longrightarrow> set (PPc (V!i)) \\<subseteq> set (PPV V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length V \\<Longrightarrow> set (PPc (V ! i)) \\<subseteq> set (PPV V)", "by (rule PPc_in_PPV, erule listindices_aux)"], ["", "lemma uniPPV_uniPPc: \"unique_PPV V \\<Longrightarrow> (\\<forall>i < length V. unique_PPc (V!i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unique_PPV V \\<Longrightarrow> \\<forall>i<length V. unique_PPc (V ! i)", "by (auto, simp add: unique_PPV_def, induct V,\n    auto simp add: unique_PPc_def,\n    metis in_set_conv_nth length_Suc_conv set_ConsD)\n\n\\<comment> \\<open>SEMANTICS\\<close>"], ["", "locale MWLs_semantics =\nfixes E :: \"('exp, 'id, 'val) Evalfunction\"\nand BMap :: \"'val \\<Rightarrow> bool\"\nbegin\n\n\\<comment> \\<open>steps semantics, set of deterministic steps from commands to program states\\<close>"], ["", "inductive_set\nMWLsSteps_det ::\n  \"('exp, 'id, 'val, ('exp, 'id) MWLsCom) TLSteps\"\nand MWLslocSteps_det' ::\n  \"('exp, 'id, 'val, ('exp, 'id) MWLsCom) TLSteps_curry\"\n(\"(1\\<langle>_,/_\\<rangle>) \\<rightarrow>\\<lhd>_\\<rhd>/ (1\\<langle>_,/_\\<rangle>)\" [0,0,0,0,0] 81)\nwhere\n\"\\<langle>c1,m1\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>c2,m2\\<rangle> \\<equiv> ((c1,m1),\\<alpha>,(c2,m2)) \\<in> MWLsSteps_det\" |\nskip: \"\\<langle>skip\\<^bsub>\\<iota>\\<^esub>,m\\<rangle> \\<rightarrow>\\<lhd>[]\\<rhd> \\<langle>None,m\\<rangle>\" |\nassign: \"(E e m) = v \\<Longrightarrow>\n  \\<langle>x :=\\<^bsub>\\<iota>\\<^esub> e,m\\<rangle> \\<rightarrow>\\<lhd>[]\\<rhd> \\<langle>None,m(x := v)\\<rangle>\" |\nseq1: \"\\<langle>c1,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>None,m'\\<rangle> \\<Longrightarrow>\n  \\<langle>c1;c2,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>Some c2,m'\\<rangle>\" |\nseq2: \"\\<langle>c1,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>Some c1',m'\\<rangle> \\<Longrightarrow>\n  \\<langle>c1;c2,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>Some (c1';c2),m'\\<rangle>\" |\niftrue: \"BMap (E b m) = True \\<Longrightarrow>\n  \\<langle>if\\<^bsub>\\<iota>\\<^esub> b then c1 else c2 fi,m\\<rangle> \\<rightarrow>\\<lhd>[]\\<rhd> \\<langle>Some c1,m\\<rangle>\" |\niffalse: \"BMap (E b m) = False \\<Longrightarrow>\n  \\<langle>if\\<^bsub>\\<iota>\\<^esub> b then c1 else c2 fi,m\\<rangle> \\<rightarrow>\\<lhd>[]\\<rhd> \\<langle>Some c2,m\\<rangle>\" |\nwhiletrue: \"BMap (E b m) = True \\<Longrightarrow>\n  \\<langle>while\\<^bsub>\\<iota>\\<^esub> b do c od,m\\<rangle> \\<rightarrow>\\<lhd>[]\\<rhd> \\<langle>Some (c;(while\\<^bsub>\\<iota>\\<^esub> b do c od)),m\\<rangle>\" |\nwhilefalse: \"BMap (E b m) = False \\<Longrightarrow>\n  \\<langle>while\\<^bsub>\\<iota>\\<^esub> b do c od,m\\<rangle> \\<rightarrow>\\<lhd>[]\\<rhd> \\<langle>None,m\\<rangle>\" |\nspawn: \"\\<langle>spawn\\<^bsub>\\<iota>\\<^esub> V,m\\<rangle> \\<rightarrow>\\<lhd>V\\<rhd> \\<langle>None,m\\<rangle>\""], ["", "inductive_cases MWLsSteps_det_cases:\n\"\\<langle>skip\\<^bsub>\\<iota>\\<^esub>,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\"\n\"\\<langle>x :=\\<^bsub>\\<iota>\\<^esub> e,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\"\n\"\\<langle>c1;c2,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\"\n\"\\<langle>if\\<^bsub>\\<iota>\\<^esub> b then c1 else c2 fi,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\"\n\"\\<langle>while\\<^bsub>\\<iota>\\<^esub> b do c od,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\"\n\"\\<langle>spawn\\<^bsub>\\<iota>\\<^esub> V,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\"\n\n\\<comment> \\<open>non-deterministic, possibilistic system step (added for intuition, not used in the proofs)\\<close>"], ["", "inductive_set\nMWLsSteps_ndet ::\n  \"('exp, 'id, 'val, ('exp, 'id) MWLsCom) TPSteps\"\nand MWLsSteps_ndet' ::\n  \"('exp, 'id, 'val, ('exp, 'id) MWLsCom) TPSteps_curry\"\n(\"(1\\<langle>_,/_\\<rangle>) \\<Rightarrow>/ (1\\<langle>_,/_\\<rangle>)\" [0,0,0,0] 81)\nwhere\n\"\\<langle>V,m\\<rangle> \\<Rightarrow> \\<langle>V',m'\\<rangle> \\<equiv> ((V,m),(V',m')) \\<in> MWLsSteps_ndet\" |\nstepthreadi1: \"\\<langle>ci,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>None,m'\\<rangle> \\<Longrightarrow>\n  \\<langle>cf @ [ci] @ ca,m\\<rangle> \\<Rightarrow> \\<langle>cf @ \\<alpha> @ ca,m'\\<rangle>\" |\nstepthreadi2: \"\\<langle>ci,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>Some c',m'\\<rangle> \\<Longrightarrow>\n  \\<langle>cf @ [ci] @ ca,m\\<rangle> \\<Rightarrow> \\<langle>cf @ [c'] @ \\<alpha> @ ca,m\\<rangle>\"\n\n\n\\<comment> \\<open>lemma about existence and uniqueness of next memory of a step\\<close>"], ["", "lemma nextmem_exists_and_unique:\n\"\\<exists>m' p \\<alpha>. \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\n  \\<and> (\\<forall>m''. (\\<exists>p \\<alpha>. \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m''\\<rangle>) \\<longrightarrow> m'' = m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m' p \\<alpha>.\n       \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd>\n       \\<langle>p,m'\\<rangle> \\<and>\n       (\\<forall>m''.\n           (\\<exists>p \\<alpha>.\n               \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd>\n               \\<langle>p,m''\\<rangle>) \\<longrightarrow>\n           m'' = m')", "by (induct c, auto, metis MWLsSteps_det.skip MWLsSteps_det_cases(1),\n    metis MWLsSteps_det_cases(2) MWLsSteps_det.assign,\n    metis (no_types) MWLsSteps_det.seq1 MWLsSteps_det.seq2\n    MWLsSteps_det_cases(3) not_Some_eq,\n    metis MWLsSteps_det.iffalse MWLsSteps_det.iftrue\n    MWLsSteps_det_cases(4),\n    metis MWLsSteps_det.whilefalse MWLsSteps_det.whiletrue\n    MWLsSteps_det_cases(5),\n    metis MWLsSteps_det.spawn MWLsSteps_det_cases(6))"], ["", "lemma PPsc_of_step:\n\"\\<lbrakk> \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>; \\<exists>c'. p = Some c' \\<rbrakk>\n  \\<Longrightarrow> set (PPc (the p)) \\<subseteq> set (PPc c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd>\n             \\<langle>p,m'\\<rangle>;\n     \\<exists>c'. p = Some c'\\<rbrakk>\n    \\<Longrightarrow> set (PPc (the p)) \\<subseteq> set (PPc c)", "by (induct rule: MWLsSteps_det.induct, auto)"], ["", "lemma PPs\\<alpha>_of_step:\n\"\\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd> \\<langle>p,m'\\<rangle>\n  \\<Longrightarrow> set (PPV \\<alpha>) \\<subseteq> set (PPc c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c,m\\<rangle> \\<rightarrow>\\<lhd>\\<alpha>\\<rhd>\n    \\<langle>p,m'\\<rangle> \\<Longrightarrow>\n    set (PPV \\<alpha>) \\<subseteq> set (PPc c)", "by (induct rule: MWLsSteps_det.induct, auto)"], ["", "end"], ["", "end"]]}